{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/Snip20160714_1.png","path":"images/Snip20160714_1.png","modified":1,"renderable":0},{"_id":"source/images/Ojihao.png","path":"images/Ojihao.png","modified":1,"renderable":0},{"_id":"source/images/jishu2.png","path":"images/jishu2.png","modified":1,"renderable":0},{"_id":"source/images/jishu1.png","path":"images/jishu1.png","modified":1,"renderable":0},{"_id":"source/images/fenerzhizhi.png","path":"images/fenerzhizhi.png","modified":1,"renderable":0},{"_id":"source/images/jishu3.png","path":"images/jishu3.png","modified":1,"renderable":0},{"_id":"source/images/jishu.png","path":"images/jishu.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"b76f7f8970b06f9a86aa3f95bfa8cf3aac57c5a2","modified":1507716823000},{"_id":"source/_posts/Mach-O文件解析.md","hash":"511c960fed05fba22d7e99c8e30b038028fd6a48","modified":1507716823000},{"_id":"source/_posts/Python多进程通信和调用.md","hash":"465a33a3dcb03b2ce9c327877732f8f178bf9aeb","modified":1507716823000},{"_id":"source/_posts/c-string用法.md","hash":"caac3e1af78774167253f130af54936152733bf1","modified":1507716823000},{"_id":"source/_posts/clang插件开发.md","hash":"561031f7192820262c5a0847511a7748afebdf6a","modified":1507716823000},{"_id":"source/_posts/find命令.md","hash":"40129c11aca74dfbd6b5f967c2e333ae8a481c36","modified":1507716823000},{"_id":"source/_posts/hexo多端同步错误解决方案.md","hash":"5c42b580068eddc93b521d598c00a08b3e43a80c","modified":1507771323000},{"_id":"source/_posts/itchat使用总结.md","hash":"0d1d8e90e46a1b90e6ba087bb90e1945cfa5baf1","modified":1507716823000},{"_id":"source/_posts/otool作用以及使用.md","hash":"000dc3e9731c2a749089547a9856fa46a91f7934","modified":1507716823000},{"_id":"source/_posts/python发送邮件代码记录.md","hash":"f878e9fe9f24da6b6f8a881dcfe1e3ca31df9efb","modified":1507716823000},{"_id":"source/_posts/python学习环境搭建-jupyter-notebook.md","hash":"56a0246224bf4ce0d8d0d3c5a21583c7eaa6048e","modified":1507716823000},{"_id":"source/_posts/xcode多版本自动化打包记录.md","hash":"a8363525342e3c55e1b3ac5af398f422291ba7c9","modified":1507716823000},{"_id":"source/_posts/xcode工程加密思路.md","hash":"e8ab9cdbba884e00752aa22f3836a165e54e318b","modified":1507716823000},{"_id":"source/_posts/数据结构算法-概论.md","hash":"77f617ea16ba8e7f01c62b9d417cd84dd86691e3","modified":1507716823000},{"_id":"source/_posts/利用hexo搭建团队博客系统.md","hash":"45ba6238a2f12c75b45f13092dd61e249fe43f5f","modified":1507716823000},{"_id":"source/_posts/深度学习概论.md","hash":"b223bf2962acd4c8b32c95cfd80afac0cdb50705","modified":1507716823000},{"_id":"source/_posts/算法题汇总.md","hash":"2dbe83d9dcc0aba35f315986812a5f2aa8d42629","modified":1507716823000},{"_id":"source/_posts/自然语言处理概念基础.md","hash":"db4f1cf3ba58e568f945ce69ca17c124a1b230e8","modified":1507716823000},{"_id":"source/about/index.md","hash":"0c210f6e5e64cfee0bbeeeb2f9f9a0aa58bef5b8","modified":1507716823000},{"_id":"source/categories/index.md","hash":"851c8796c0da202fb2d105536ef9a01c335f1666","modified":1507716823000},{"_id":"source/tags/index.md","hash":"e0226545cd55a30ee4c24841b74118b0e21783e9","modified":1507716823000},{"_id":"source/待发/性能优化总结.md","hash":"387e081b54aaa075193bfa2898b755cbe97142a2","modified":1507716823000},{"_id":"source/待发/React-Native概述.md","hash":"9cca2190fec7caaaae0edb5b286677cfdd35b190","modified":1507716823000},{"_id":"source/_posts/2014/Foundation系列-NSString.md","hash":"42a7fbb2a0634aac8c773719a51d78a927581b24","modified":1507716823000},{"_id":"source/_posts/2014/UIKit系列-UIButton.md","hash":"bcb88ac28a7a1bf8cabfaa60ffff42e2be1e8cd8","modified":1507716823000},{"_id":"source/_posts/2014/UIKit系列-UICollectionView.md","hash":"ed8d948f8016960cec2f21b277382b6f32f74ff0","modified":1507716823000},{"_id":"source/_posts/2014/UIKit系列-UILable.md","hash":"b0d70f1adbcdb4f1dc6c4413fa688db41738430c","modified":1507716823000},{"_id":"source/_posts/2014/UIKit系列-UIPikerView-日期选择器.md","hash":"09e04921d688d104ce9965bae263f1dc5b2e031d","modified":1507716823000},{"_id":"source/_posts/2014/UIKit系列-UITextField.md","hash":"e8fbd8e953c9fb9fac7832a599b96424b6c8665e","modified":1507716823000},{"_id":"source/_posts/2014/iOS设计模式.md","hash":"3cf68e877e7d14b29013d14ef036e8a07bedf77a","modified":1507716823000},{"_id":"source/_posts/2014/事件与响应者链.md","hash":"ff5b6d51365520c4929e2364fcb3afb9b5ebeb90","modified":1507716823000},{"_id":"source/_posts/2014/计算机网络概述.md","hash":"82051c5447f133016d226857c22d4b69759cea4d","modified":1507716823000},{"_id":"source/_posts/2015/Block使用总结.md","hash":"295ef61490b4999f7ffa9a89e614bbaabcec3d3a","modified":1507716823000},{"_id":"source/_posts/2015/Git使用总结.md","hash":"0ce45c9cf5d5ee7124d2cfc319a37f99658ca783","modified":1507716823000},{"_id":"source/_posts/2015/Hexo-配置教程.md","hash":"21135d8890fee27fe6b539742c309de42003c842","modified":1507716823000},{"_id":"source/_posts/2015/OC中的各种变量.md","hash":"c450b533e8df0bb381999b13a23d52ef0bf673b7","modified":1507716823000},{"_id":"source/_posts/2015/Runloop概述.md","hash":"01ed0f9bbfac4c448297d4c757ed3195a7879d2f","modified":1507716823000},{"_id":"source/_posts/2015/category内部实现原理.md","hash":"34093969c8f53d017c53a9646661c524dc3a5d68","modified":1507716823000},{"_id":"source/_posts/2015/iOS中的定时和延时.md","hash":"a1bda56c2360cdd7c95416e01293eba1ba786d33","modified":1507716823000},{"_id":"source/_posts/2015/iOS中的屏幕旋转.md","hash":"601d99a3a0d6c1bea2c9eb05ba1d0301980bbd71","modified":1507716823000},{"_id":"source/_posts/2015/iOS中的空值.md","hash":"c5c0e3e3584c8bb24f4ca59b826c9be875aa2d7e","modified":1507716823000},{"_id":"source/_posts/2015/runtime概述.md","hash":"d1fef7d4c57c2b6ae149712ccdf78bba113a821a","modified":1507716823000},{"_id":"source/_posts/2015/流媒体技术概述.md","hash":"25e76a0766fae097dd90564407cacb2f791e62b2","modified":1507716823000},{"_id":"source/_posts/2015/转-视音频编解码技术零基础学习方法.md","hash":"8fac6dd81dac92f709d51223e7b593f258975ea9","modified":1507716823000},{"_id":"source/_posts/2017/2017年死磕几件事.md","hash":"7f77d72cb3cdf50d170ac04c548dce248070e657","modified":1507716823000},{"_id":"source/_posts/2017/Andorid自动打包gradle安装笔记.md","hash":"bc8eb7017a2ad6089535a565e11b998e4fb5eb03","modified":1507716823000},{"_id":"source/_posts/2017/Lunix云服务器折腾小记.md","hash":"ec27307cfb0d30c7784481da0cab59dc7df67bd0","modified":1507716823000},{"_id":"source/_posts/2015/转-音视频基础概念汇总.md","hash":"a32b18320ff85c658bc68bab51ec9bce53b52724","modified":1507716823000},{"_id":"source/_posts/2017/Python基础知识-列表-元组-字符串.md","hash":"69df477769c5d880b311a428f1832c9aeac29543","modified":1507716823000},{"_id":"source/_posts/2017/Python基础知识-字典.md","hash":"aac7b6dc09eb6bdaa63042b9ae9e383ef8decc6d","modified":1507716823000},{"_id":"source/_posts/2017/Python基础知识-文件操作.md","hash":"48d767a30f162d03a9a89a9e59f8e9a59e365dc5","modified":1507716823000},{"_id":"source/_posts/2017/UIImage.md","hash":"615885a13cdead9398c1e857aee2e6753df9c661","modified":1507716823000},{"_id":"source/_posts/2017/UIKit-UITableView.md","hash":"4db9026542683f367d122614edc1e4fc001b425a","modified":1507716823000},{"_id":"source/_posts/2017/iOS工程小知识.md","hash":"2b0dd77a2173b71c31530db352a122e860e0c3ed","modified":1507716823000},{"_id":"source/_posts/2017/mac下使用virtualbox安装win7以及设置共享文件.md","hash":"479dd12c4ded9fe45fc4ab8073cc35909dd17fa9","modified":1507716823000},{"_id":"source/_posts/2017/基于Django的平台构建笔记(2).md","hash":"a7ea2c216632028b4315ac169ba5f53daec1c0d5","modified":1507716823000},{"_id":"source/_posts/2017/mongodb使用小结.md","hash":"0dfbb5ee089c13f44561599e34e01bab5d4267a7","modified":1507716823000},{"_id":"source/_posts/2017/基于Django的自动化平台构建笔记(1).md","hash":"adb1e8ecfc0c2cc3819c520494ce3b8b8315be9d","modified":1507716823000},{"_id":"source/_posts/2017/定时检查网页更新并发送微信消息.md","hash":"e6d4fa568415859bd10565fb25928a3131bfcf1b","modified":1507716823000},{"_id":"source/_posts/2017/指数自动获取.md","hash":"ce2170f9332d7752a3ec3a1f72fa0a6cd399e654","modified":1507716823000},{"_id":"source/_posts/2017/移动开发流程.md","hash":"2669e10d2185458b10b6109eb747b5a60e6c14aa","modified":1507716823000},{"_id":"source/_posts/2017/爬虫系列.md","hash":"ef0d2ce8172daeb10c707b21795e8457bab8b058","modified":1507716823000},{"_id":"source/_posts/2016/Django部署-apache-mod-wsgi.md","hash":"722cba40b02871e029ddbc6ff5b28b3394d278d4","modified":1507716823000},{"_id":"source/_posts/2016/FLV格式解析.md","hash":"33d2f451f436f92bdf41a0f57716b6254aab0751","modified":1507716823000},{"_id":"source/_posts/2016/iOS中的屏幕旋转.md","hash":"10ceda1b88b822779e03eac225c28f7bc6ced52f","modified":1507716823000},{"_id":"source/_posts/2016/iOS技能总结.md","hash":"c960c58930650320f503966d9d070d953bd23747","modified":1507716823000},{"_id":"source/_posts/2016/iOS性能优化概述.md","hash":"aab8a5f3197962e880a6379f96c22c6f0e32b654","modified":1507716823000},{"_id":"source/_posts/2016/iOS知识小集.md","hash":"809737d2a36d946a716c21be1be5d6e8ba0bcb95","modified":1507716823000},{"_id":"source/_posts/2016/多线程技术-GCD.md","hash":"f1e91ee55875532219465a730173018a06a9d452","modified":1507716823000},{"_id":"source/_posts/2016/热修复技术在移动端的应用.md","hash":"1ce3eeec00d995f965dbbd9e21d49eeeff8627e6","modified":1507716823000},{"_id":"source/_posts/2016/转-block进阶1-block实现.md","hash":"cc4382a4ff6bdfaaf7d6192000cd95d11df22c1e","modified":1507716823000},{"_id":"source/_posts/2016/转-block进阶2-block和变量内存管理.md","hash":"7a4e8794e6ea7183055957c25d8e62daec8b39c6","modified":1507716823000},{"_id":"source/_posts/2016/转-block进阶3-block和对象的内存管理.md","hash":"7d604a4a3f3ad7642c2ae6fb3b9a806f8de46e10","modified":1507716823000},{"_id":"source/_posts/2016/转-block进阶4-block的逻辑理解.md","hash":"8f109fe4c66d0d8fc51cc55e9b33d98537556180","modified":1507716823000},{"_id":"source/_posts/2016/转-delegate-KVO-Notification选择.md","hash":"0e69eb7ea1e9f9e526f5736bd566c85d552606e8","modified":1507716823000},{"_id":"source/_posts/2016/转-项目优化-安装包体积控制.md","hash":"e5be3762ff0c206f21b03fcf0ec96d6e4f71f2e9","modified":1507716823000},{"_id":"source/images/Snip20160714_1.png","hash":"1ffcdce3ba82d76ece90d140b3582101e0b06e48","modified":1507716823000},{"_id":"source/images/Ojihao.png","hash":"6a8230aa7d2b9a4b93af4d1a2e0d36d9d449c02c","modified":1507716823000},{"_id":"source/images/jishu2.png","hash":"40a35e900aa427d81f2ebb287bf23961bc848947","modified":1507716823000},{"_id":"source/images/jishu1.png","hash":"d1f06db079afc059744c9ab79aa4e482be75d04b","modified":1507716823000},{"_id":"source/images/fenerzhizhi.png","hash":"27ac68ee0a262fb110ef0d3246cb79fb90b38538","modified":1507716823000},{"_id":"source/images/jishu3.png","hash":"0d624823dec0fea6b8aae320e4d9901df639f2b4","modified":1507716823000},{"_id":"source/images/jishu.png","hash":"53c7feed41b080b14bacffdf03813f6d88b1e133","modified":1507716823000},{"_id":"public/search.xml","hash":"28b632817154608cb4a72637fae17b251e54ea39","modified":1507771348488},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348499},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348499},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348500},{"_id":"public/待发/性能优化总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348500},{"_id":"public/待发/React-Native概述.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348500},{"_id":"public/2017/10/11/hexo多端同步错误解决方案/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348500},{"_id":"public/2017/10/11/python学习环境搭建-jupyter-notebook/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348500},{"_id":"public/2017/10/10/python发送邮件代码记录/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/10/10/xcode工程加密思路/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/10/10/xcode多版本自动化打包记录/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/10/09/Mach-O文件解析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/09/28/otool作用以及使用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/09/06/c-string用法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/09/22/find命令/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/09/05/clang插件开发/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/07/18/算法题汇总/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/07/17/数据结构算法-概论/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/06/27/自然语言处理概念基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/06/16/深度学习概论/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/06/14/itchat使用总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/06/12/利用hexo搭建团队博客系统/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/06/12/Python多进程通信和调用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/05/25/2017/mac下使用virtualbox安装win7以及设置共享文件/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/05/18/2017/基于Django的平台构建笔记(2)/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/05/17/2017/mongodb使用小结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/02/26/2017/iOS工程小知识/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/02/16/2017/定时检查网页更新并发送微信消息/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/02/16/2017/指数自动获取/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/02/10/2017/爬虫系列/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/01/17/2017/Lunix云服务器折腾小记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2017/01/06/2017/2017年死磕几件事/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/12/16/2017/Andorid自动打包gradle安装笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/12/15/2017/基于Django的自动化平台构建笔记(1)/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/12/01/2017/移动开发流程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/11/30/2017/UIKit-UITableView/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/11/15/2014/Foundation系列-NSString/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/11/15/2014/UIKit系列-UICollectionView/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/11/15/2016/iOS知识小集/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348501},{"_id":"public/2016/11/09/2016/Django部署-apache-mod-wsgi/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/07/30/2016/FLV格式解析/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/07/21/2016/iOS性能优化概述/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/07/19/2016/多线程技术-GCD/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/06/29/2016/转-block进阶4-block的逻辑理解/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/06/25/2016/转-block进阶3-block和对象的内存管理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/06/25/2016/转-block进阶2-block和变量内存管理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/04/16/2017/Python基础知识-文件操作/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/04/10/2017/Python基础知识-字典/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/04/09/2017/Python基础知识-列表-元组-字符串/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/03/18/2016/转-delegate-KVO-Notification选择/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/02/19/2016/iOS技能总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/02/12/2016/iOS中的屏幕旋转/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/01/18/2016/转-项目优化-安装包体积控制/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2016/01/12/2016/热修复技术在移动端的应用/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/12/15/2015/category内部实现原理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/08/10/2015/runtime概述/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/07/21/2015/Runloop概述/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/07/17/2015/转-视音频编解码技术零基础学习方法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/07/17/2015/转-音视频基础概念汇总/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/06/10/2015/OC中的各种变量/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/05/02/2015/Block使用总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/04/12/2015/iOS中的屏幕旋转/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/04/10/2015/Git使用总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/03/09/2015/Hexo-配置教程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/02/15/2015/iOS中的空值/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/01/23/2015/iOS中的定时和延时/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2015/01/17/2015/流媒体技术概述/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/12/15/2014/UIKit系列-UIPikerView-日期选择器/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/12/12/2014/UIKit系列-UITextField/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/12/03/2014/UIKit系列-UIButton/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/11/18/2014/iOS设计模式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/11/16/2014/UIKit系列-UILable/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348502},{"_id":"public/2014/10/16/2017/UIImage/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/2014/07/21/2014/事件与响应者链/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/2014/07/18/2014/计算机网络概述/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2014/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2014/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2014/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2014/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2014/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348503},{"_id":"public/archives/2015/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2015/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2015/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2015/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2015/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2015/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348504},{"_id":"public/archives/2016/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2016/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2016/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/archives/2017/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348505},{"_id":"public/categories/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/categories/iOS/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/categories/基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/categories/Python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/iOS进阶/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/iOS进阶/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/c/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/Python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/clang插件/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/命令行/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348506},{"_id":"public/tags/hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/python/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/xcode/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/git/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/数据结构算法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/深度学习/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/iOS基础知识/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/IOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/计算机基础/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/流媒体/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/自动化/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/Lunix/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/mac/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/Django/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/JS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/mongo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/tags/爬虫/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348507},{"_id":"public/2017/10/11/2016/转-block进阶1-block实现/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507771348512},{"_id":"public/CNAME","hash":"b76f7f8970b06f9a86aa3f95bfa8cf3aac57c5a2","modified":1507771348517},{"_id":"public/images/Snip20160714_1.png","hash":"1ffcdce3ba82d76ece90d140b3582101e0b06e48","modified":1507771348533},{"_id":"public/images/Ojihao.png","hash":"6a8230aa7d2b9a4b93af4d1a2e0d36d9d449c02c","modified":1507771348538},{"_id":"public/images/jishu2.png","hash":"40a35e900aa427d81f2ebb287bf23961bc848947","modified":1507771348538},{"_id":"public/images/jishu1.png","hash":"d1f06db079afc059744c9ab79aa4e482be75d04b","modified":1507771348538},{"_id":"public/images/fenerzhizhi.png","hash":"27ac68ee0a262fb110ef0d3246cb79fb90b38538","modified":1507771348538},{"_id":"public/images/jishu3.png","hash":"0d624823dec0fea6b8aae320e4d9901df639f2b4","modified":1507771348538},{"_id":"public/images/jishu.png","hash":"53c7feed41b080b14bacffdf03813f6d88b1e133","modified":1507771348539}],"Category":[{"name":"iOS","_id":"cj8ns4pm2001qsauairvnfmah"},{"name":"基础","_id":"cj8ns4pmh0028sauamq5c9ub2"},{"name":"Python","_id":"cj8ns4pn5003msaua1099k26v"}],"Data":[],"Page":[{"title":"about","date":"2016-07-11T09:39:41.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-07-11 17:39:41\n---\n","updated":"2017-10-11T10:13:43.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj8ns4pk20001sauausdtkbu0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2016-11-09T06:29:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-09 14:29:36\ntype: \"categories\"\n---\n","updated":"2017-10-11T10:13:43.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj8ns4pk50003saua0zx3v37n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-11-09T04:12:42.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-09 12:12:42\ntype: \"tags\"\n---\n","updated":"2017-10-11T10:13:43.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj8ns4pkb0006sauao80ho8o3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"性能优化总结","date":"2016-07-24T08:25:07.000Z","tags":["iOS进阶"],"categories":"iOS","_content":"性能优化总的来讲可以分为下面几个方面\n<!--more-->\n- 性能优化\n  - 启动页优化\n  - 页面浏览速度\n  - 操作流畅度\n  - 服务端和客户端交互优化\n  - 内存\n- 性能监测\n  - 生产环境\n  \t- APM性能监测上报\n  \t- 线上卡顿监测\n  - 开发环境\n    - instrument\n    - 浮窗+内存泄漏监测 \t\n- 编码层面预防\n  - checklist\n  - 插件\n  - gitlab扫描\n  - 代码规范\n\n\n## 性能优化\n### 启动页优化\n\n\niOSAPP启动过程：\n- 链接并加载Framework和static lib\n- UIKit初始化\n- 应用程序callback\n- 第一个Core Animation transaction(事务)\n\n#### 链接并加载Framework和static lib\n- 每个framework都会占用启动时间和内存\n- 不必要的framework不要链接\n- 必要的framwork不要标为optinal\n- 避免创建全局C++对象\n\n#### UIKit初始化\n- 字体、状态栏、userdefualt、mainnib会被初始化\n- 保持main nib尽量下\n- user defealt是一个plist文件，不要再里面保存图片等大数据\n\n#### 应用程序callback\n\n#### 第一个Core Animation transaction(事务)\n\n#### 启动时间测量\n```\nCFAbsoluteTime startTime;\nint main(int argc, char * argv[]) {\n    startTime = CFAbsoluteTimeGetCurrent();\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n\nextern CFAbsoluteTime startTime;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSLog(@\"const of time %f\", CFAbsoluteTimeGetCurrent()- startTime);\n    });//该方法会在下一个runloop执行，此时动画事务已经提交，启动已经完成\n\n}\n```\n\n### 页面浏览速度\n\n\n### 操作流畅度\n- 控制器跳转优化\n- tableview优化\n### 服务端与客户端交互\n- 接口合并\n\n### 内存\n内存泄漏\n\n## 性能监测\n### 生产环境\n### 开发环境\n\n## 编码层面预防\n### checklist\n### 插件提示\n### gitlab扫描\n### 代码规范\n","source":"待发/性能优化总结.md","raw":"---\ntitle: 性能优化总结\ndate: 2016-07-24 16:25:07\ntags:\n- iOS进阶\ncategories: iOS\n---\n性能优化总的来讲可以分为下面几个方面\n<!--more-->\n- 性能优化\n  - 启动页优化\n  - 页面浏览速度\n  - 操作流畅度\n  - 服务端和客户端交互优化\n  - 内存\n- 性能监测\n  - 生产环境\n  \t- APM性能监测上报\n  \t- 线上卡顿监测\n  - 开发环境\n    - instrument\n    - 浮窗+内存泄漏监测 \t\n- 编码层面预防\n  - checklist\n  - 插件\n  - gitlab扫描\n  - 代码规范\n\n\n## 性能优化\n### 启动页优化\n\n\niOSAPP启动过程：\n- 链接并加载Framework和static lib\n- UIKit初始化\n- 应用程序callback\n- 第一个Core Animation transaction(事务)\n\n#### 链接并加载Framework和static lib\n- 每个framework都会占用启动时间和内存\n- 不必要的framework不要链接\n- 必要的framwork不要标为optinal\n- 避免创建全局C++对象\n\n#### UIKit初始化\n- 字体、状态栏、userdefualt、mainnib会被初始化\n- 保持main nib尽量下\n- user defealt是一个plist文件，不要再里面保存图片等大数据\n\n#### 应用程序callback\n\n#### 第一个Core Animation transaction(事务)\n\n#### 启动时间测量\n```\nCFAbsoluteTime startTime;\nint main(int argc, char * argv[]) {\n    startTime = CFAbsoluteTimeGetCurrent();\n    @autoreleasepool {\n        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));\n    }\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n\nextern CFAbsoluteTime startTime;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        NSLog(@\"const of time %f\", CFAbsoluteTimeGetCurrent()- startTime);\n    });//该方法会在下一个runloop执行，此时动画事务已经提交，启动已经完成\n\n}\n```\n\n### 页面浏览速度\n\n\n### 操作流畅度\n- 控制器跳转优化\n- tableview优化\n### 服务端与客户端交互\n- 接口合并\n\n### 内存\n内存泄漏\n\n## 性能监测\n### 生产环境\n### 开发环境\n\n## 编码层面预防\n### checklist\n### 插件提示\n### gitlab扫描\n### 代码规范\n","updated":"2017-10-11T10:13:43.000Z","path":"待发/性能优化总结.html","comments":1,"layout":"page","_id":"cj8ns4plc001ksauaah1lrp9a","content":"<p>性能优化总的来讲可以分为下面几个方面<br><a id=\"more\"></a></p>\n<ul>\n<li>性能优化<ul>\n<li>启动页优化</li>\n<li>页面浏览速度</li>\n<li>操作流畅度</li>\n<li>服务端和客户端交互优化</li>\n<li>内存</li>\n</ul>\n</li>\n<li>性能监测<ul>\n<li>生产环境<ul>\n<li>APM性能监测上报</li>\n<li>线上卡顿监测</li>\n</ul>\n</li>\n<li>开发环境<ul>\n<li>instrument</li>\n<li>浮窗+内存泄漏监测     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码层面预防<ul>\n<li>checklist</li>\n<li>插件</li>\n<li>gitlab扫描</li>\n<li>代码规范</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"启动页优化\"><a href=\"#启动页优化\" class=\"headerlink\" title=\"启动页优化\"></a>启动页优化</h3><p>iOSAPP启动过程：</p>\n<ul>\n<li>链接并加载Framework和static lib</li>\n<li>UIKit初始化</li>\n<li>应用程序callback</li>\n<li>第一个Core Animation transaction(事务)</li>\n</ul>\n<h4 id=\"链接并加载Framework和static-lib\"><a href=\"#链接并加载Framework和static-lib\" class=\"headerlink\" title=\"链接并加载Framework和static lib\"></a>链接并加载Framework和static lib</h4><ul>\n<li>每个framework都会占用启动时间和内存</li>\n<li>不必要的framework不要链接</li>\n<li>必要的framwork不要标为optinal</li>\n<li>避免创建全局C++对象</li>\n</ul>\n<h4 id=\"UIKit初始化\"><a href=\"#UIKit初始化\" class=\"headerlink\" title=\"UIKit初始化\"></a>UIKit初始化</h4><ul>\n<li>字体、状态栏、userdefualt、mainnib会被初始化</li>\n<li>保持main nib尽量下</li>\n<li>user defealt是一个plist文件，不要再里面保存图片等大数据</li>\n</ul>\n<h4 id=\"应用程序callback\"><a href=\"#应用程序callback\" class=\"headerlink\" title=\"应用程序callback\"></a>应用程序callback</h4><h4 id=\"第一个Core-Animation-transaction-事务\"><a href=\"#第一个Core-Animation-transaction-事务\" class=\"headerlink\" title=\"第一个Core Animation transaction(事务)\"></a>第一个Core Animation transaction(事务)</h4><h4 id=\"启动时间测量\"><a href=\"#启动时间测量\" class=\"headerlink\" title=\"启动时间测量\"></a>启动时间测量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFAbsoluteTime startTime;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    startTime = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class=\"line\"></div><div class=\"line\">extern CFAbsoluteTime startTime;</div><div class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        NSLog(@&quot;const of time %f&quot;, CFAbsoluteTimeGetCurrent()- startTime);</div><div class=\"line\">    &#125;);//该方法会在下一个runloop执行，此时动画事务已经提交，启动已经完成</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"页面浏览速度\"><a href=\"#页面浏览速度\" class=\"headerlink\" title=\"页面浏览速度\"></a>页面浏览速度</h3><h3 id=\"操作流畅度\"><a href=\"#操作流畅度\" class=\"headerlink\" title=\"操作流畅度\"></a>操作流畅度</h3><ul>\n<li>控制器跳转优化</li>\n<li>tableview优化<h3 id=\"服务端与客户端交互\"><a href=\"#服务端与客户端交互\" class=\"headerlink\" title=\"服务端与客户端交互\"></a>服务端与客户端交互</h3></li>\n<li>接口合并</li>\n</ul>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p>内存泄漏</p>\n<h2 id=\"性能监测\"><a href=\"#性能监测\" class=\"headerlink\" title=\"性能监测\"></a>性能监测</h2><h3 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h3><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><h2 id=\"编码层面预防\"><a href=\"#编码层面预防\" class=\"headerlink\" title=\"编码层面预防\"></a>编码层面预防</h2><h3 id=\"checklist\"><a href=\"#checklist\" class=\"headerlink\" title=\"checklist\"></a>checklist</h3><h3 id=\"插件提示\"><a href=\"#插件提示\" class=\"headerlink\" title=\"插件提示\"></a>插件提示</h3><h3 id=\"gitlab扫描\"><a href=\"#gitlab扫描\" class=\"headerlink\" title=\"gitlab扫描\"></a>gitlab扫描</h3><h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3>","site":{"data":{}},"excerpt":"<p>性能优化总的来讲可以分为下面几个方面<br>","more":"</p>\n<ul>\n<li>性能优化<ul>\n<li>启动页优化</li>\n<li>页面浏览速度</li>\n<li>操作流畅度</li>\n<li>服务端和客户端交互优化</li>\n<li>内存</li>\n</ul>\n</li>\n<li>性能监测<ul>\n<li>生产环境<ul>\n<li>APM性能监测上报</li>\n<li>线上卡顿监测</li>\n</ul>\n</li>\n<li>开发环境<ul>\n<li>instrument</li>\n<li>浮窗+内存泄漏监测     </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码层面预防<ul>\n<li>checklist</li>\n<li>插件</li>\n<li>gitlab扫描</li>\n<li>代码规范</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"启动页优化\"><a href=\"#启动页优化\" class=\"headerlink\" title=\"启动页优化\"></a>启动页优化</h3><p>iOSAPP启动过程：</p>\n<ul>\n<li>链接并加载Framework和static lib</li>\n<li>UIKit初始化</li>\n<li>应用程序callback</li>\n<li>第一个Core Animation transaction(事务)</li>\n</ul>\n<h4 id=\"链接并加载Framework和static-lib\"><a href=\"#链接并加载Framework和static-lib\" class=\"headerlink\" title=\"链接并加载Framework和static lib\"></a>链接并加载Framework和static lib</h4><ul>\n<li>每个framework都会占用启动时间和内存</li>\n<li>不必要的framework不要链接</li>\n<li>必要的framwork不要标为optinal</li>\n<li>避免创建全局C++对象</li>\n</ul>\n<h4 id=\"UIKit初始化\"><a href=\"#UIKit初始化\" class=\"headerlink\" title=\"UIKit初始化\"></a>UIKit初始化</h4><ul>\n<li>字体、状态栏、userdefualt、mainnib会被初始化</li>\n<li>保持main nib尽量下</li>\n<li>user defealt是一个plist文件，不要再里面保存图片等大数据</li>\n</ul>\n<h4 id=\"应用程序callback\"><a href=\"#应用程序callback\" class=\"headerlink\" title=\"应用程序callback\"></a>应用程序callback</h4><h4 id=\"第一个Core-Animation-transaction-事务\"><a href=\"#第一个Core-Animation-transaction-事务\" class=\"headerlink\" title=\"第一个Core Animation transaction(事务)\"></a>第一个Core Animation transaction(事务)</h4><h4 id=\"启动时间测量\"><a href=\"#启动时间测量\" class=\"headerlink\" title=\"启动时间测量\"></a>启动时间测量</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFAbsoluteTime startTime;</div><div class=\"line\">int main(int argc, char * argv[]) &#123;</div><div class=\"line\">    startTime = CFAbsoluteTimeGetCurrent();</div><div class=\"line\">    @autoreleasepool &#123;</div><div class=\"line\">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class=\"line\"></div><div class=\"line\">extern CFAbsoluteTime startTime;</div><div class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">        NSLog(@&quot;const of time %f&quot;, CFAbsoluteTimeGetCurrent()- startTime);</div><div class=\"line\">    &#125;);//该方法会在下一个runloop执行，此时动画事务已经提交，启动已经完成</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"页面浏览速度\"><a href=\"#页面浏览速度\" class=\"headerlink\" title=\"页面浏览速度\"></a>页面浏览速度</h3><h3 id=\"操作流畅度\"><a href=\"#操作流畅度\" class=\"headerlink\" title=\"操作流畅度\"></a>操作流畅度</h3><ul>\n<li>控制器跳转优化</li>\n<li>tableview优化<h3 id=\"服务端与客户端交互\"><a href=\"#服务端与客户端交互\" class=\"headerlink\" title=\"服务端与客户端交互\"></a>服务端与客户端交互</h3></li>\n<li>接口合并</li>\n</ul>\n<h3 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h3><p>内存泄漏</p>\n<h2 id=\"性能监测\"><a href=\"#性能监测\" class=\"headerlink\" title=\"性能监测\"></a>性能监测</h2><h3 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h3><h3 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h3><h2 id=\"编码层面预防\"><a href=\"#编码层面预防\" class=\"headerlink\" title=\"编码层面预防\"></a>编码层面预防</h2><h3 id=\"checklist\"><a href=\"#checklist\" class=\"headerlink\" title=\"checklist\"></a>checklist</h3><h3 id=\"插件提示\"><a href=\"#插件提示\" class=\"headerlink\" title=\"插件提示\"></a>插件提示</h3><h3 id=\"gitlab扫描\"><a href=\"#gitlab扫描\" class=\"headerlink\" title=\"gitlab扫描\"></a>gitlab扫描</h3><h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3>"},{"title":"React Native概述","date":"2016-08-02T08:13:35.000Z","tags":["RN"],"categories":"iOS","_content":"## 什么是RN\nReact 是一个用于创建用户界面的 JavaScript 函数库，通常被表述为 MVC 中的 V（View，视图）。\n\nReact 知道根据组件的状态进行重新渲染，并且保存一个虚拟 DOM 以实现高效的重新渲染。这种方法非常棒，因为我们写代码时就好像在重新渲染整个模板，而实际上 React 只会更新发生过改动的 DOM。\n>特点：JSX语法，组件化模式，Virtual DOM，单向数据流\n>基本模式：每个React应用可视为组件的组合，而每个React组件由属性和状态来配置，当状态变化的时候更新UI，组件的结构是由DOM来维护的，确保了实际更新的DOM只包括真正产生了状态变化的部分。\n\n### RN提供了哪些能力？\n- 基于原生UI组件\n- 手势识别\n- 基于FlexBox的css布局模式\n- 跨平台开发\n- 就React，jsx的组件化开发模式\n- 可使用npm中的模块\n- Chrome Dev Tool集成\n\n>说明：我们所写的任何组件，最后都会转换为对应的UIKit中的控件，最基础的如UIView，UIImageView，UILabel等，但是UITableView是没有的，因为不断的在主线程与JS线程之间通讯的消耗太大，导致操作延迟严重\n### JSX\nReact 与常见框架的最大差别在于，JavaScript 逻辑与 Markup(标记)模板使用 JSX 语法写在同一个文件中。\n\n## 开发准备\n### 环境配置\n### 初始化项目\n### 开发工具\n\n## 布局\n## \n\n## 问题\n- 更新的js文件如何下发？\n- 版本控制如何做？\n- 如何查看框架的版本？\n- 有没有环境限制，比如说不能在某种机器上跑，我现在知道肯定不能在iOS6及以下跑\n- js文件执行过程，是否与jspatch有类似之处\n- react native在mac下依赖node.js运行，那么在iOS中又是怎么运行的呢？\n- RN的运行过程，深度原理解析\n- RN在iOS平台的应用(这是重点)现有项目如何添加rn模块\n- RN是如何实现View的，当我创建一个View的时候，实际上RN做了什么事情？\n- 当我触摸屏幕的时候，RN是如何做出响应的？\n- JavaScript线程是怎么回事？\n- RN如何使用多线程？\n","source":"待发/React-Native概述.md","raw":"---\ntitle: React Native概述\ndate: 2016-08-02 16:13:35\ntags:\n- RN\ncategories: iOS\n---\n## 什么是RN\nReact 是一个用于创建用户界面的 JavaScript 函数库，通常被表述为 MVC 中的 V（View，视图）。\n\nReact 知道根据组件的状态进行重新渲染，并且保存一个虚拟 DOM 以实现高效的重新渲染。这种方法非常棒，因为我们写代码时就好像在重新渲染整个模板，而实际上 React 只会更新发生过改动的 DOM。\n>特点：JSX语法，组件化模式，Virtual DOM，单向数据流\n>基本模式：每个React应用可视为组件的组合，而每个React组件由属性和状态来配置，当状态变化的时候更新UI，组件的结构是由DOM来维护的，确保了实际更新的DOM只包括真正产生了状态变化的部分。\n\n### RN提供了哪些能力？\n- 基于原生UI组件\n- 手势识别\n- 基于FlexBox的css布局模式\n- 跨平台开发\n- 就React，jsx的组件化开发模式\n- 可使用npm中的模块\n- Chrome Dev Tool集成\n\n>说明：我们所写的任何组件，最后都会转换为对应的UIKit中的控件，最基础的如UIView，UIImageView，UILabel等，但是UITableView是没有的，因为不断的在主线程与JS线程之间通讯的消耗太大，导致操作延迟严重\n### JSX\nReact 与常见框架的最大差别在于，JavaScript 逻辑与 Markup(标记)模板使用 JSX 语法写在同一个文件中。\n\n## 开发准备\n### 环境配置\n### 初始化项目\n### 开发工具\n\n## 布局\n## \n\n## 问题\n- 更新的js文件如何下发？\n- 版本控制如何做？\n- 如何查看框架的版本？\n- 有没有环境限制，比如说不能在某种机器上跑，我现在知道肯定不能在iOS6及以下跑\n- js文件执行过程，是否与jspatch有类似之处\n- react native在mac下依赖node.js运行，那么在iOS中又是怎么运行的呢？\n- RN的运行过程，深度原理解析\n- RN在iOS平台的应用(这是重点)现有项目如何添加rn模块\n- RN是如何实现View的，当我创建一个View的时候，实际上RN做了什么事情？\n- 当我触摸屏幕的时候，RN是如何做出响应的？\n- JavaScript线程是怎么回事？\n- RN如何使用多线程？\n","updated":"2017-10-11T10:13:43.000Z","path":"待发/React-Native概述.html","comments":1,"layout":"page","_id":"cj8ns4pld001lsaua35var02m","content":"<h2 id=\"什么是RN\"><a href=\"#什么是RN\" class=\"headerlink\" title=\"什么是RN\"></a>什么是RN</h2><p>React 是一个用于创建用户界面的 JavaScript 函数库，通常被表述为 MVC 中的 V（View，视图）。</p>\n<p>React 知道根据组件的状态进行重新渲染，并且保存一个虚拟 DOM 以实现高效的重新渲染。这种方法非常棒，因为我们写代码时就好像在重新渲染整个模板，而实际上 React 只会更新发生过改动的 DOM。</p>\n<blockquote>\n<p>特点：JSX语法，组件化模式，Virtual DOM，单向数据流<br>基本模式：每个React应用可视为组件的组合，而每个React组件由属性和状态来配置，当状态变化的时候更新UI，组件的结构是由DOM来维护的，确保了实际更新的DOM只包括真正产生了状态变化的部分。</p>\n</blockquote>\n<h3 id=\"RN提供了哪些能力？\"><a href=\"#RN提供了哪些能力？\" class=\"headerlink\" title=\"RN提供了哪些能力？\"></a>RN提供了哪些能力？</h3><ul>\n<li>基于原生UI组件</li>\n<li>手势识别</li>\n<li>基于FlexBox的css布局模式</li>\n<li>跨平台开发</li>\n<li>就React，jsx的组件化开发模式</li>\n<li>可使用npm中的模块</li>\n<li>Chrome Dev Tool集成</li>\n</ul>\n<blockquote>\n<p>说明：我们所写的任何组件，最后都会转换为对应的UIKit中的控件，最基础的如UIView，UIImageView，UILabel等，但是UITableView是没有的，因为不断的在主线程与JS线程之间通讯的消耗太大，导致操作延迟严重</p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>React 与常见框架的最大差别在于，JavaScript 逻辑与 Markup(标记)模板使用 JSX 语法写在同一个文件中。</p>\n</blockquote>\n<h2 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h2><h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>## </p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li>更新的js文件如何下发？</li>\n<li>版本控制如何做？</li>\n<li>如何查看框架的版本？</li>\n<li>有没有环境限制，比如说不能在某种机器上跑，我现在知道肯定不能在iOS6及以下跑</li>\n<li>js文件执行过程，是否与jspatch有类似之处</li>\n<li>react native在mac下依赖node.js运行，那么在iOS中又是怎么运行的呢？</li>\n<li>RN的运行过程，深度原理解析</li>\n<li>RN在iOS平台的应用(这是重点)现有项目如何添加rn模块</li>\n<li>RN是如何实现View的，当我创建一个View的时候，实际上RN做了什么事情？</li>\n<li>当我触摸屏幕的时候，RN是如何做出响应的？</li>\n<li>JavaScript线程是怎么回事？</li>\n<li>RN如何使用多线程？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是RN\"><a href=\"#什么是RN\" class=\"headerlink\" title=\"什么是RN\"></a>什么是RN</h2><p>React 是一个用于创建用户界面的 JavaScript 函数库，通常被表述为 MVC 中的 V（View，视图）。</p>\n<p>React 知道根据组件的状态进行重新渲染，并且保存一个虚拟 DOM 以实现高效的重新渲染。这种方法非常棒，因为我们写代码时就好像在重新渲染整个模板，而实际上 React 只会更新发生过改动的 DOM。</p>\n<blockquote>\n<p>特点：JSX语法，组件化模式，Virtual DOM，单向数据流<br>基本模式：每个React应用可视为组件的组合，而每个React组件由属性和状态来配置，当状态变化的时候更新UI，组件的结构是由DOM来维护的，确保了实际更新的DOM只包括真正产生了状态变化的部分。</p>\n</blockquote>\n<h3 id=\"RN提供了哪些能力？\"><a href=\"#RN提供了哪些能力？\" class=\"headerlink\" title=\"RN提供了哪些能力？\"></a>RN提供了哪些能力？</h3><ul>\n<li>基于原生UI组件</li>\n<li>手势识别</li>\n<li>基于FlexBox的css布局模式</li>\n<li>跨平台开发</li>\n<li>就React，jsx的组件化开发模式</li>\n<li>可使用npm中的模块</li>\n<li>Chrome Dev Tool集成</li>\n</ul>\n<blockquote>\n<p>说明：我们所写的任何组件，最后都会转换为对应的UIKit中的控件，最基础的如UIView，UIImageView，UILabel等，但是UITableView是没有的，因为不断的在主线程与JS线程之间通讯的消耗太大，导致操作延迟严重</p>\n<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><p>React 与常见框架的最大差别在于，JavaScript 逻辑与 Markup(标记)模板使用 JSX 语法写在同一个文件中。</p>\n</blockquote>\n<h2 id=\"开发准备\"><a href=\"#开发准备\" class=\"headerlink\" title=\"开发准备\"></a>开发准备</h2><h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><p>## </p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><ul>\n<li>更新的js文件如何下发？</li>\n<li>版本控制如何做？</li>\n<li>如何查看框架的版本？</li>\n<li>有没有环境限制，比如说不能在某种机器上跑，我现在知道肯定不能在iOS6及以下跑</li>\n<li>js文件执行过程，是否与jspatch有类似之处</li>\n<li>react native在mac下依赖node.js运行，那么在iOS中又是怎么运行的呢？</li>\n<li>RN的运行过程，深度原理解析</li>\n<li>RN在iOS平台的应用(这是重点)现有项目如何添加rn模块</li>\n<li>RN是如何实现View的，当我创建一个View的时候，实际上RN做了什么事情？</li>\n<li>当我触摸屏幕的时候，RN是如何做出响应的？</li>\n<li>JavaScript线程是怎么回事？</li>\n<li>RN如何使用多线程？</li>\n</ul>\n"}],"Post":[{"title":"Mac中的二进制文件","date":"2017-10-09T10:31:22.000Z","_content":"在Unix系统中，任何文件都可以通过chmod+x命令来标记为可执行文件，但是这并不能保证这个文件是能够被执行的，这个标志只是告诉系统这个文件可以读入内容，然后寻找一个头签名，据此可以确定精确的可执行文件格式，这个文件签名通常称为\"magic\"。\n例如:\n\n- #!脚本\n- 0xcafebabe/0xbebafeca包含多种架构支持的二进制，又被称为通用二进制或者胖二进制\n- 0xfeedface(32位)，0xfeedfacf(64位)Mach-O格式或者叫OSX原生二进制格式\n\n### 胖二进制\n通用二进制只不过是其支持的各种架构的二进制文件的打包文件，这种格式的文件包含一个文件头，然后文件头后面依次拷贝了每一种支持架构的二进制文件。\n- 通用二进制文件的处理工具叫做`lipo`脂肪的意思，对应胖二进制的意思\n- 这个工具可以提取，删除和替换通用二进制文件中制定架构的二进制代码，因此可以通过这个工具对二进制文件进行瘦身\n\n### Mach-O\n\n首先看mach_header\n`otool -hV JDMobile`\n```\nMach header\n\nmagic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags\n\nMH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    68       7464   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE\n```\n\n- magic魔数代表32或者64位\n- cputype和subcuptype代表cup类型\n- filetype代表文件类型(可执行文件，库文件，核心转储文件，内核扩展)\n- ncmds和sizeofcmds用于加载的家在命令的条数和大小\n- flags代表动态连接器(dyld)的标志\n\n\n\n","source":"_posts/Mach-O文件解析.md","raw":"---\ntitle: Mac中的二进制文件\ndate: 2017-10-09 18:31:22\ntags:\n- iOS进阶\n---\n在Unix系统中，任何文件都可以通过chmod+x命令来标记为可执行文件，但是这并不能保证这个文件是能够被执行的，这个标志只是告诉系统这个文件可以读入内容，然后寻找一个头签名，据此可以确定精确的可执行文件格式，这个文件签名通常称为\"magic\"。\n例如:\n\n- #!脚本\n- 0xcafebabe/0xbebafeca包含多种架构支持的二进制，又被称为通用二进制或者胖二进制\n- 0xfeedface(32位)，0xfeedfacf(64位)Mach-O格式或者叫OSX原生二进制格式\n\n### 胖二进制\n通用二进制只不过是其支持的各种架构的二进制文件的打包文件，这种格式的文件包含一个文件头，然后文件头后面依次拷贝了每一种支持架构的二进制文件。\n- 通用二进制文件的处理工具叫做`lipo`脂肪的意思，对应胖二进制的意思\n- 这个工具可以提取，删除和替换通用二进制文件中制定架构的二进制代码，因此可以通过这个工具对二进制文件进行瘦身\n\n### Mach-O\n\n首先看mach_header\n`otool -hV JDMobile`\n```\nMach header\n\nmagic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags\n\nMH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    68       7464   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE\n```\n\n- magic魔数代表32或者64位\n- cputype和subcuptype代表cup类型\n- filetype代表文件类型(可执行文件，库文件，核心转储文件，内核扩展)\n- ncmds和sizeofcmds用于加载的家在命令的条数和大小\n- flags代表动态连接器(dyld)的标志\n\n\n\n","slug":"Mach-O文件解析","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pjx0000sauatp2x9hvc","content":"<p>在Unix系统中，任何文件都可以通过chmod+x命令来标记为可执行文件，但是这并不能保证这个文件是能够被执行的，这个标志只是告诉系统这个文件可以读入内容，然后寻找一个头签名，据此可以确定精确的可执行文件格式，这个文件签名通常称为”magic”。<br>例如:</p>\n<ul>\n<li>#!脚本</li>\n<li>0xcafebabe/0xbebafeca包含多种架构支持的二进制，又被称为通用二进制或者胖二进制</li>\n<li>0xfeedface(32位)，0xfeedfacf(64位)Mach-O格式或者叫OSX原生二进制格式</li>\n</ul>\n<h3 id=\"胖二进制\"><a href=\"#胖二进制\" class=\"headerlink\" title=\"胖二进制\"></a>胖二进制</h3><p>通用二进制只不过是其支持的各种架构的二进制文件的打包文件，这种格式的文件包含一个文件头，然后文件头后面依次拷贝了每一种支持架构的二进制文件。</p>\n<ul>\n<li>通用二进制文件的处理工具叫做<code>lipo</code>脂肪的意思，对应胖二进制的意思</li>\n<li>这个工具可以提取，删除和替换通用二进制文件中制定架构的二进制代码，因此可以通过这个工具对二进制文件进行瘦身</li>\n</ul>\n<h3 id=\"Mach-O\"><a href=\"#Mach-O\" class=\"headerlink\" title=\"Mach-O\"></a>Mach-O</h3><p>首先看mach_header<br><code>otool -hV JDMobile</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mach header</div><div class=\"line\"></div><div class=\"line\">magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class=\"line\"></div><div class=\"line\">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    68       7464   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</div></pre></td></tr></table></figure></p>\n<ul>\n<li>magic魔数代表32或者64位</li>\n<li>cputype和subcuptype代表cup类型</li>\n<li>filetype代表文件类型(可执行文件，库文件，核心转储文件，内核扩展)</li>\n<li>ncmds和sizeofcmds用于加载的家在命令的条数和大小</li>\n<li>flags代表动态连接器(dyld)的标志</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在Unix系统中，任何文件都可以通过chmod+x命令来标记为可执行文件，但是这并不能保证这个文件是能够被执行的，这个标志只是告诉系统这个文件可以读入内容，然后寻找一个头签名，据此可以确定精确的可执行文件格式，这个文件签名通常称为”magic”。<br>例如:</p>\n<ul>\n<li>#!脚本</li>\n<li>0xcafebabe/0xbebafeca包含多种架构支持的二进制，又被称为通用二进制或者胖二进制</li>\n<li>0xfeedface(32位)，0xfeedfacf(64位)Mach-O格式或者叫OSX原生二进制格式</li>\n</ul>\n<h3 id=\"胖二进制\"><a href=\"#胖二进制\" class=\"headerlink\" title=\"胖二进制\"></a>胖二进制</h3><p>通用二进制只不过是其支持的各种架构的二进制文件的打包文件，这种格式的文件包含一个文件头，然后文件头后面依次拷贝了每一种支持架构的二进制文件。</p>\n<ul>\n<li>通用二进制文件的处理工具叫做<code>lipo</code>脂肪的意思，对应胖二进制的意思</li>\n<li>这个工具可以提取，删除和替换通用二进制文件中制定架构的二进制代码，因此可以通过这个工具对二进制文件进行瘦身</li>\n</ul>\n<h3 id=\"Mach-O\"><a href=\"#Mach-O\" class=\"headerlink\" title=\"Mach-O\"></a>Mach-O</h3><p>首先看mach_header<br><code>otool -hV JDMobile</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mach header</div><div class=\"line\"></div><div class=\"line\">magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class=\"line\"></div><div class=\"line\">MH_MAGIC_64   ARM64        ALL  0x00     EXECUTE    68       7464   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE</div></pre></td></tr></table></figure></p>\n<ul>\n<li>magic魔数代表32或者64位</li>\n<li>cputype和subcuptype代表cup类型</li>\n<li>filetype代表文件类型(可执行文件，库文件，核心转储文件，内核扩展)</li>\n<li>ncmds和sizeofcmds用于加载的家在命令的条数和大小</li>\n<li>flags代表动态连接器(dyld)的标志</li>\n</ul>\n"},{"title":"c++ string用法","date":"2017-09-06T01:25:59.000Z","_content":"\n## C++ string的用法和例子(转)Mark一下\n\n### 使用场合：\n\nstring是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。 \n其中使用的代码多数都是来自cpp官网，因为例子非常全。\n<!--more-->\n#### 声明和初始化方法：\n\n想使用string首先要在头文件当中加入< string > \n声明方式也很简单\n\n#### 声明：\n```\nstring s;//声明一个string 对象\nstring ss[10];//声明一个string对象的数组\n```\n\n#### 初始化：\n\n使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s;//默认初始化，一个空字符串\n    string s1(\"ssss\");//s1是字面值“ssss”的副本\n    string s2(s1);//s2是s1的副本\n    string s3=s2;//s3是s2的副本\n    string s4(10,'c');//把s4初始化\n    string s5=\"hiya\";//拷贝初始化\n    string s6=string(10,'c');//拷贝初始化，生成一个初始化好的对象，拷贝给s6\n\n    //string s(cp,n)\n    char cs[]=\"12345\";\n    string s7(cs,3);//复制字符串cs的前3个字符到s当中\n\n    //string s(s2,pos2)\n    string s8=\"asac\";\n    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size\n\n    //string s(s2,pos2,len2)\n    string s10=\"qweqweqweq\";\n    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义\n    return 0;\n}\n```\n\n### 字符串处理：\n\n#### substr操作：\n\n注意substr没有迭代器作为参数的操作\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s=\"abcdefg\";\n\n    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串\n    string s2=s.substr(1,5);//abcde\n\n    //s.substr(pos)//得到一个pos到结尾的串\n    string s3=s.substr(4);//efg\n\n    return 0;\n}\n```\n\n如果输入的位置超过字符的长度，会抛出一个out_of_range的异常\n\n#### insert操作:\n\n代码来自cpp官网，经过自己的整理 \n注意用迭代器当参数和无符号数当参数的区别\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    string str=\"to be question\";\n    string str2=\"the \";\n    string str3=\"or not to be\";\n    string::iterator it;\n\n    //s.insert(pos,str)//在s的pos位置插入str\n    str.insert(6,str2);                 // to be the question\n\n    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符\n    str.insert(6,str3,3,4);             // to be not the question\n\n    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符\n    str.insert(10,\"that is cool\",8);    // to be not that is the question\n\n    //s.insert(pos,cstr)在s的pos位置插入cstr\n    str.insert(10,\"to be \");            // to be not to be that is the question\n\n    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch\n    str.insert(15,1,':');               // to be not to be: that is the question\n\n    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器\n    it = str.insert(str.begin()+5,','); // to be, not to be: that is the question\n\n    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch\n    str.insert (str.end(),3,'.');       // to be, not to be: that is the question...\n\n    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串\n    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...\n\n    return 0;\n}\n```\n#### erase操作：\n\n用来执行删除操作 \n删除操作有三种\n\n指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除\n迭代器，删除迭代器指向的字符\n迭代器范围，删除这一范围的字符串，范围左闭右开\n代码来自cpp官网\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n  std::string str (\"This is an example sentence.\");\n  std::cout << str << '\\n';\n                          // \"This is an example sentence.\"\n  str.erase (10,8);       //            ^^^^^^^^\n  //直接指定删除的字符串位置第十个后面的8个字符\n  std::cout << str << '\\n';\n                            // \"This is an sentence.\"\n  str.erase (str.begin()+9);//           ^\n  //删除迭代器指向的字符\n  std::cout << str << '\\n';\n                            // \"This is a sentence.\"\n                            //       ^^^^^\n  str.erase (str.begin()+5, str.end()-9);\n  //删除迭代器范围的字符\n  std::cout << str << '\\n';\n                            // \"This sentence.\"\n  return 0;\n}\n```\n\n#### append和replace操作:\n\nappend函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现 \nrepalce顾名思义，就是替换的意思，先删除，后增加。 \n代码来自cpp官网，附上自己的解释\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string str;\n    std::string str2=\"Writing \";\n    std::string str3=\"print 10 and then 5 more\";\n\n    //直接追加一个str2的字符串\n    str.append(str2);                       // \"Writing \"\n    //后面追加str3第6个字符开始的3个字符串\n    str.append(str3,6,3);                   // \"10 \"\n    //追加字符串形参的前5个字符\n    str.append(\"dots are cool\",5);          // \"dots \"\n    //直接添加\n    str.append(\"here: \");                   // \"here: \"\n    //添加10个'.'\n    str.append(10u,'.');                    // \"..........\"\n    //添加str3迭代器范围的字符串\n    str.append(str3.begin()+8,str3.end());  // \" and then 5 more\"\n    //最后这个比较特殊，意思是添加5个'A'，实际上参数里面的65对应的asc码就是65\n    str.append<int>(5,65);                // \".....\"\n    //字符串追加也可以用重载运算符实现\n    str+=\"lalala\";\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\nreplace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string base=\"this is a test string.\";\n    std::string str2=\"n example\";\n    std::string str3=\"sample phrase\";\n    std::string str4=\"useful.\";\n\n    // replace signatures used in the same order as described above:\n\n    // Using positions:                 0123456789*123456789*12345\n    std::string str=base;           // \"this is a test string.\"\n    //第9个字符以及后面的4个字符被str2代替\n    str.replace(9,5,str2);          // \"this is an example string.\" (1)\n    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替\n    str.replace(19,6,str3,7,6);     // \"this is an example phrase.\" (2)\n    //第8个字符以及后面的9个字符用字符串参数代替\n    str.replace(8,10,\"just a\");     // \"this is just a phrase.\"     (3)\n    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换\n    str.replace(8,6,\"a shorty\",7);  // \"this is a short phrase.\"    (4)\n    //第22以及后面的0个字符用3个叹号替换\n    str.replace(22,1,3,'!');        // \"this is a short phrase!!!\"  (5)\n    //迭代器的原理同上\n    // Using iterators:                                               0123456789*123456789*\n    str.replace(str.begin(),str.end()-3,str3);                    // \"sample phrase!!!\"      (1)\n    str.replace(str.begin(),str.begin()+6,\"replace\");             // \"replace phrase!!!\"     (3)\n    str.replace(str.begin()+8,str.begin()+14,\"is coolness\",7);    // \"replace is cool!!!\"    (4)\n    str.replace(str.begin()+12,str.end()-4,4,'o');                // \"replace is cooool!!!\"  (5)\n    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// \"replace is useful.\"    (6)\n    std::cout << str << '\\n';   \n    return 0;\n}\n```\n\n以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。\n\n#### assign操作： \nassign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。 \n代码来自cpp官网\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string str;\n    std::string base=\"The quick brown fox jumps over a lazy dog.\";\n\n    // used in the same order as described above:\n    //直接把base赋值给str\n    str.assign(base);\n    std::cout << str << '\\n';\n    //把base第10个字符以及后面的8个字符赋给str\n    str.assign(base,10,9);\n    std::cout << str << '\\n';         // \"brown fox\"\n    //把参数中的0到6个字符串赋给str\n    str.assign(\"pangrams are cool\",7);\n    std::cout << str << '\\n';         // \"pangram\"\n    //直接使用参数赋值\n    str.assign(\"c-string\");\n    std::cout << str << '\\n';         // \"c-string\"\n    //给str赋值10个'*'字符\n    str.assign(10,'*');\n    std::cout << str << '\\n';         // \"**********\"\n    //赋值是10个'-'\n    str.assign<int>(10,0x2D);\n    std::cout << str << '\\n';         // \"----------\"\n    //指定base迭代器范围的字符串\n    str.assign(base.begin()+16,base.end()-12);\n    std::cout << str << '\\n';         // \"fox jumps over\"\n\n    return 0;\n}\n```\n\n#### string的搜索操作:\n\nstring类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。\n\nfind和rfind函数:\n\nfind函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。 \n代码来自cpp官网\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str (\"There are two needles in this haystack with needles.\");\n    std::string str2 (\"needle\");\n\n    // different member versions of find in the same order as above:\n    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾\n    std::size_t found = str.find(str2);\n    if (found!=std::string::npos)\n    std::cout << \"first 'needle' found at: \" << found << '\\n';\n    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符\n    found=str.find(\"needles are small\",found+1,6);\n    if (found!=std::string::npos)\n    std::cout << \"second 'needle' found at: \" << found << '\\n';\n    //在str当中查找参数中的字符串\n    found=str.find(\"haystack\");\n    if (found!=std::string::npos)\n    std::cout << \"'haystack' also found at: \" << found << '\\n';\n    //查找一个字符\n    found=str.find('.');\n    if (found!=std::string::npos)\n    std::cout << \"Period found at: \" << found << '\\n';\n    //组合使用，把str2用参数表中的字符串代替\n    // let's replace the first needle:\n    str.replace(str.find(str2),str2.length(),\"preposition\");\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\nrfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str (\"The sixth sick sheik's sixth sheep's sick.\");\n    std::string key (\"sixth\");//                    ^\n    //rfind是找最后一个出现的匹配字符串\n    std::size_t found = str.rfind(key);\n    if (found!=std::string::npos)\n    {\n        cout<<found<<endl;//输出23\n        str.replace (found,key.length(),\"seventh\");//找到的sixth替换成seventh\n    }\n\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\n查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。\n\nfind_….of函数:\n\nfind_first_of(args) 查找args中任何一个字符第一次出现的位置\nfind_last_of(args) 最后一个出现的位置\nfind_fist_not_of(args) 查找第一个不在args中的字符\nfind_last_not_of 查找最后一个不在args中出现的字符\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str1 (\"Please, replace the vowels in this sentence by asterisks.\");\n    std::size_t found1 = str1.find_first_of(\"aeiou\");\n    //把所有元音找出来用*代替\n    while (found1!=std::string::npos)\n    {\n        str1[found1]='*';\n        found1=str1.find_first_of(\"aeiou\",found1+1);\n    }\n    std::cout << str1 << '\\n';\n\n    //在str2中找到第一个不是消协英文字母和空格的字符\n    std::string str2 (\"look for non-alphabetic characters...\");\n    std::size_t found2 = str2.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz \");\n    if (found2!=std::string::npos)\n    {\n        std::cout << \"The first non-alphabetic character is \" << str2[found2];\n        std::cout << \" at position \" << found2 << '\\n';\n    }\n    return 0;\n}\n```\n\nfind_last_of和find_last_not_of与first基本相同，就不写例子代码了。\n\n比较与转换:\n\n类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。 \n注意编译器bug： \n在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。\n\n#### compare函数:\n\n和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。 \n在compare当中还支持部分比较，里面有6个参数可以设置。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s1=\"123\",s2=\"123\";\n    cout<<s1.compare(s2)<<endl;//0\n\n    s1=\"123\",s2=\"1234\";\n    cout<<s1.compare(s2)<<endl;//-1\n\n    s1=\"1234\",s2=\"123\";\n    cout<<s1.compare(s2)<<endl;//1\n\n    std::string str1 (\"green apple\");\n    std::string str2 (\"red apple\");\n\n    if (str1.compare(str2) != 0)\n    std::cout << str1 << \" is not \" << str2 << '\\n';\n    //str1的第6个字符以及后面的4个字符和参数比较\n    if (str1.compare(6,5,\"apple\") == 0)\n    std::cout << \"still, \" << str1 << \" is an apple\\n\";\n\n    if (str2.compare(str2.size()-5,5,\"apple\") == 0)\n    std::cout << \"and \" << str2 << \" is also an apple\\n\";\n    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较\n    if (str1.compare(6,5,str2,4,5) == 0)\n    std::cout << \"therefore, both are apples\\n\";\n    return 0;\n}\n```\n\n由于string重载了运算符，可以直接用>,<，==来进行比较，也很方便。\n\n#### 数值转换：\n\n在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。\n\nstring和数值转换\t\nto_string(val)\t把val转换成string\nstoi(s,p,b)\t把字符串s从p开始转换成b进制的int\nstol(s,p,b)\tlong\nstoul(s,p,b)\tunsigned long\nstoll(s,p,b)\tlong long\nstoull(s,p,b)\tunsigned long long\nstof(s,p)\tfloat\nstod(s,p)\tdouble\nstold(s,p)\tlong double\n//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s1;\n    s1=to_string(100);\n    cout<<s1<<endl;\n    int a=stoi(s1,0,10)+1;\n    cout<<a<<endl;\n\n    return 0;\n}\n```\n","source":"_posts/c-string用法.md","raw":"---\ntitle: c++ string用法\ndate: 2017-09-06 09:25:59\ntags:\n- c++\n---\n\n## C++ string的用法和例子(转)Mark一下\n\n### 使用场合：\n\nstring是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。 \n其中使用的代码多数都是来自cpp官网，因为例子非常全。\n<!--more-->\n#### 声明和初始化方法：\n\n想使用string首先要在头文件当中加入< string > \n声明方式也很简单\n\n#### 声明：\n```\nstring s;//声明一个string 对象\nstring ss[10];//声明一个string对象的数组\n```\n\n#### 初始化：\n\n使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s;//默认初始化，一个空字符串\n    string s1(\"ssss\");//s1是字面值“ssss”的副本\n    string s2(s1);//s2是s1的副本\n    string s3=s2;//s3是s2的副本\n    string s4(10,'c');//把s4初始化\n    string s5=\"hiya\";//拷贝初始化\n    string s6=string(10,'c');//拷贝初始化，生成一个初始化好的对象，拷贝给s6\n\n    //string s(cp,n)\n    char cs[]=\"12345\";\n    string s7(cs,3);//复制字符串cs的前3个字符到s当中\n\n    //string s(s2,pos2)\n    string s8=\"asac\";\n    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size\n\n    //string s(s2,pos2,len2)\n    string s10=\"qweqweqweq\";\n    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义\n    return 0;\n}\n```\n\n### 字符串处理：\n\n#### substr操作：\n\n注意substr没有迭代器作为参数的操作\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s=\"abcdefg\";\n\n    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串\n    string s2=s.substr(1,5);//abcde\n\n    //s.substr(pos)//得到一个pos到结尾的串\n    string s3=s.substr(4);//efg\n\n    return 0;\n}\n```\n\n如果输入的位置超过字符的长度，会抛出一个out_of_range的异常\n\n#### insert操作:\n\n代码来自cpp官网，经过自己的整理 \n注意用迭代器当参数和无符号数当参数的区别\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    string str=\"to be question\";\n    string str2=\"the \";\n    string str3=\"or not to be\";\n    string::iterator it;\n\n    //s.insert(pos,str)//在s的pos位置插入str\n    str.insert(6,str2);                 // to be the question\n\n    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符\n    str.insert(6,str3,3,4);             // to be not the question\n\n    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符\n    str.insert(10,\"that is cool\",8);    // to be not that is the question\n\n    //s.insert(pos,cstr)在s的pos位置插入cstr\n    str.insert(10,\"to be \");            // to be not to be that is the question\n\n    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch\n    str.insert(15,1,':');               // to be not to be: that is the question\n\n    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器\n    it = str.insert(str.begin()+5,','); // to be, not to be: that is the question\n\n    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch\n    str.insert (str.end(),3,'.');       // to be, not to be: that is the question...\n\n    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串\n    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...\n\n    return 0;\n}\n```\n#### erase操作：\n\n用来执行删除操作 \n删除操作有三种\n\n指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除\n迭代器，删除迭代器指向的字符\n迭代器范围，删除这一范围的字符串，范围左闭右开\n代码来自cpp官网\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n  std::string str (\"This is an example sentence.\");\n  std::cout << str << '\\n';\n                          // \"This is an example sentence.\"\n  str.erase (10,8);       //            ^^^^^^^^\n  //直接指定删除的字符串位置第十个后面的8个字符\n  std::cout << str << '\\n';\n                            // \"This is an sentence.\"\n  str.erase (str.begin()+9);//           ^\n  //删除迭代器指向的字符\n  std::cout << str << '\\n';\n                            // \"This is a sentence.\"\n                            //       ^^^^^\n  str.erase (str.begin()+5, str.end()-9);\n  //删除迭代器范围的字符\n  std::cout << str << '\\n';\n                            // \"This sentence.\"\n  return 0;\n}\n```\n\n#### append和replace操作:\n\nappend函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现 \nrepalce顾名思义，就是替换的意思，先删除，后增加。 \n代码来自cpp官网，附上自己的解释\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string str;\n    std::string str2=\"Writing \";\n    std::string str3=\"print 10 and then 5 more\";\n\n    //直接追加一个str2的字符串\n    str.append(str2);                       // \"Writing \"\n    //后面追加str3第6个字符开始的3个字符串\n    str.append(str3,6,3);                   // \"10 \"\n    //追加字符串形参的前5个字符\n    str.append(\"dots are cool\",5);          // \"dots \"\n    //直接添加\n    str.append(\"here: \");                   // \"here: \"\n    //添加10个'.'\n    str.append(10u,'.');                    // \"..........\"\n    //添加str3迭代器范围的字符串\n    str.append(str3.begin()+8,str3.end());  // \" and then 5 more\"\n    //最后这个比较特殊，意思是添加5个'A'，实际上参数里面的65对应的asc码就是65\n    str.append<int>(5,65);                // \".....\"\n    //字符串追加也可以用重载运算符实现\n    str+=\"lalala\";\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\nreplace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string base=\"this is a test string.\";\n    std::string str2=\"n example\";\n    std::string str3=\"sample phrase\";\n    std::string str4=\"useful.\";\n\n    // replace signatures used in the same order as described above:\n\n    // Using positions:                 0123456789*123456789*12345\n    std::string str=base;           // \"this is a test string.\"\n    //第9个字符以及后面的4个字符被str2代替\n    str.replace(9,5,str2);          // \"this is an example string.\" (1)\n    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替\n    str.replace(19,6,str3,7,6);     // \"this is an example phrase.\" (2)\n    //第8个字符以及后面的9个字符用字符串参数代替\n    str.replace(8,10,\"just a\");     // \"this is just a phrase.\"     (3)\n    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换\n    str.replace(8,6,\"a shorty\",7);  // \"this is a short phrase.\"    (4)\n    //第22以及后面的0个字符用3个叹号替换\n    str.replace(22,1,3,'!');        // \"this is a short phrase!!!\"  (5)\n    //迭代器的原理同上\n    // Using iterators:                                               0123456789*123456789*\n    str.replace(str.begin(),str.end()-3,str3);                    // \"sample phrase!!!\"      (1)\n    str.replace(str.begin(),str.begin()+6,\"replace\");             // \"replace phrase!!!\"     (3)\n    str.replace(str.begin()+8,str.begin()+14,\"is coolness\",7);    // \"replace is cool!!!\"    (4)\n    str.replace(str.begin()+12,str.end()-4,4,'o');                // \"replace is cooool!!!\"  (5)\n    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// \"replace is useful.\"    (6)\n    std::cout << str << '\\n';   \n    return 0;\n}\n```\n\n以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。\n\n#### assign操作： \nassign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。 \n代码来自cpp官网\n\n```\n#include <iostream>\n#include <string>\n\nint main ()\n{\n    std::string str;\n    std::string base=\"The quick brown fox jumps over a lazy dog.\";\n\n    // used in the same order as described above:\n    //直接把base赋值给str\n    str.assign(base);\n    std::cout << str << '\\n';\n    //把base第10个字符以及后面的8个字符赋给str\n    str.assign(base,10,9);\n    std::cout << str << '\\n';         // \"brown fox\"\n    //把参数中的0到6个字符串赋给str\n    str.assign(\"pangrams are cool\",7);\n    std::cout << str << '\\n';         // \"pangram\"\n    //直接使用参数赋值\n    str.assign(\"c-string\");\n    std::cout << str << '\\n';         // \"c-string\"\n    //给str赋值10个'*'字符\n    str.assign(10,'*');\n    std::cout << str << '\\n';         // \"**********\"\n    //赋值是10个'-'\n    str.assign<int>(10,0x2D);\n    std::cout << str << '\\n';         // \"----------\"\n    //指定base迭代器范围的字符串\n    str.assign(base.begin()+16,base.end()-12);\n    std::cout << str << '\\n';         // \"fox jumps over\"\n\n    return 0;\n}\n```\n\n#### string的搜索操作:\n\nstring类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。\n\nfind和rfind函数:\n\nfind函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。 \n代码来自cpp官网\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str (\"There are two needles in this haystack with needles.\");\n    std::string str2 (\"needle\");\n\n    // different member versions of find in the same order as above:\n    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾\n    std::size_t found = str.find(str2);\n    if (found!=std::string::npos)\n    std::cout << \"first 'needle' found at: \" << found << '\\n';\n    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符\n    found=str.find(\"needles are small\",found+1,6);\n    if (found!=std::string::npos)\n    std::cout << \"second 'needle' found at: \" << found << '\\n';\n    //在str当中查找参数中的字符串\n    found=str.find(\"haystack\");\n    if (found!=std::string::npos)\n    std::cout << \"'haystack' also found at: \" << found << '\\n';\n    //查找一个字符\n    found=str.find('.');\n    if (found!=std::string::npos)\n    std::cout << \"Period found at: \" << found << '\\n';\n    //组合使用，把str2用参数表中的字符串代替\n    // let's replace the first needle:\n    str.replace(str.find(str2),str2.length(),\"preposition\");\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\nrfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str (\"The sixth sick sheik's sixth sheep's sick.\");\n    std::string key (\"sixth\");//                    ^\n    //rfind是找最后一个出现的匹配字符串\n    std::size_t found = str.rfind(key);\n    if (found!=std::string::npos)\n    {\n        cout<<found<<endl;//输出23\n        str.replace (found,key.length(),\"seventh\");//找到的sixth替换成seventh\n    }\n\n    std::cout << str << '\\n';\n    return 0;\n}\n```\n\n查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。\n\nfind_….of函数:\n\nfind_first_of(args) 查找args中任何一个字符第一次出现的位置\nfind_last_of(args) 最后一个出现的位置\nfind_fist_not_of(args) 查找第一个不在args中的字符\nfind_last_not_of 查找最后一个不在args中出现的字符\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    std::string str1 (\"Please, replace the vowels in this sentence by asterisks.\");\n    std::size_t found1 = str1.find_first_of(\"aeiou\");\n    //把所有元音找出来用*代替\n    while (found1!=std::string::npos)\n    {\n        str1[found1]='*';\n        found1=str1.find_first_of(\"aeiou\",found1+1);\n    }\n    std::cout << str1 << '\\n';\n\n    //在str2中找到第一个不是消协英文字母和空格的字符\n    std::string str2 (\"look for non-alphabetic characters...\");\n    std::size_t found2 = str2.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz \");\n    if (found2!=std::string::npos)\n    {\n        std::cout << \"The first non-alphabetic character is \" << str2[found2];\n        std::cout << \" at position \" << found2 << '\\n';\n    }\n    return 0;\n}\n```\n\nfind_last_of和find_last_not_of与first基本相同，就不写例子代码了。\n\n比较与转换:\n\n类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。 \n注意编译器bug： \n在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。\n\n#### compare函数:\n\n和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。 \n在compare当中还支持部分比较，里面有6个参数可以设置。\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s1=\"123\",s2=\"123\";\n    cout<<s1.compare(s2)<<endl;//0\n\n    s1=\"123\",s2=\"1234\";\n    cout<<s1.compare(s2)<<endl;//-1\n\n    s1=\"1234\",s2=\"123\";\n    cout<<s1.compare(s2)<<endl;//1\n\n    std::string str1 (\"green apple\");\n    std::string str2 (\"red apple\");\n\n    if (str1.compare(str2) != 0)\n    std::cout << str1 << \" is not \" << str2 << '\\n';\n    //str1的第6个字符以及后面的4个字符和参数比较\n    if (str1.compare(6,5,\"apple\") == 0)\n    std::cout << \"still, \" << str1 << \" is an apple\\n\";\n\n    if (str2.compare(str2.size()-5,5,\"apple\") == 0)\n    std::cout << \"and \" << str2 << \" is also an apple\\n\";\n    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较\n    if (str1.compare(6,5,str2,4,5) == 0)\n    std::cout << \"therefore, both are apples\\n\";\n    return 0;\n}\n```\n\n由于string重载了运算符，可以直接用>,<，==来进行比较，也很方便。\n\n#### 数值转换：\n\n在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。\n\nstring和数值转换\t\nto_string(val)\t把val转换成string\nstoi(s,p,b)\t把字符串s从p开始转换成b进制的int\nstol(s,p,b)\tlong\nstoul(s,p,b)\tunsigned long\nstoll(s,p,b)\tlong long\nstoull(s,p,b)\tunsigned long long\nstof(s,p)\tfloat\nstod(s,p)\tdouble\nstold(s,p)\tlong double\n//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    string s1;\n    s1=to_string(100);\n    cout<<s1<<endl;\n    int a=stoi(s1,0,10)+1;\n    cout<<a<<endl;\n\n    return 0;\n}\n```\n","slug":"c-string用法","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pk30002saua2mkih4o0","content":"<h2 id=\"C-string的用法和例子-转-Mark一下\"><a href=\"#C-string的用法和例子-转-Mark一下\" class=\"headerlink\" title=\"C++ string的用法和例子(转)Mark一下\"></a>C++ string的用法和例子(转)Mark一下</h2><h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><p>string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。<br>其中使用的代码多数都是来自cpp官网，因为例子非常全。<br><a id=\"more\"></a></p>\n<h4 id=\"声明和初始化方法：\"><a href=\"#声明和初始化方法：\" class=\"headerlink\" title=\"声明和初始化方法：\"></a>声明和初始化方法：</h4><p>想使用string首先要在头文件当中加入&lt; string &gt;<br>声明方式也很简单</p>\n<h4 id=\"声明：\"><a href=\"#声明：\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string s;//声明一个string 对象</div><div class=\"line\">string ss[10];//声明一个string对象的数组</div></pre></td></tr></table></figure>\n<h4 id=\"初始化：\"><a href=\"#初始化：\" class=\"headerlink\" title=\"初始化：\"></a>初始化：</h4><p>使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s;//默认初始化，一个空字符串</div><div class=\"line\">    string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本</div><div class=\"line\">    string s2(s1);//s2是s1的副本</div><div class=\"line\">    string s3=s2;//s3是s2的副本</div><div class=\"line\">    string s4(10,&apos;c&apos;);//把s4初始化</div><div class=\"line\">    string s5=&quot;hiya&quot;;//拷贝初始化</div><div class=\"line\">    string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6</div><div class=\"line\"></div><div class=\"line\">    //string s(cp,n)</div><div class=\"line\">    char cs[]=&quot;12345&quot;;</div><div class=\"line\">    string s7(cs,3);//复制字符串cs的前3个字符到s当中</div><div class=\"line\"></div><div class=\"line\">    //string s(s2,pos2)</div><div class=\"line\">    string s8=&quot;asac&quot;;</div><div class=\"line\">    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size</div><div class=\"line\"></div><div class=\"line\">    //string s(s2,pos2,len2)</div><div class=\"line\">    string s10=&quot;qweqweqweq&quot;;</div><div class=\"line\">    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"字符串处理：\"><a href=\"#字符串处理：\" class=\"headerlink\" title=\"字符串处理：\"></a>字符串处理：</h3><h4 id=\"substr操作：\"><a href=\"#substr操作：\" class=\"headerlink\" title=\"substr操作：\"></a>substr操作：</h4><p>注意substr没有迭代器作为参数的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s=&quot;abcdefg&quot;;</div><div class=\"line\"></div><div class=\"line\">    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串</div><div class=\"line\">    string s2=s.substr(1,5);//abcde</div><div class=\"line\"></div><div class=\"line\">    //s.substr(pos)//得到一个pos到结尾的串</div><div class=\"line\">    string s3=s.substr(4);//efg</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果输入的位置超过字符的长度，会抛出一个out_of_range的异常</p>\n<h4 id=\"insert操作\"><a href=\"#insert操作\" class=\"headerlink\" title=\"insert操作:\"></a>insert操作:</h4><p>代码来自cpp官网，经过自己的整理<br>注意用迭代器当参数和无符号数当参数的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string str=&quot;to be question&quot;;</div><div class=\"line\">    string str2=&quot;the &quot;;</div><div class=\"line\">    string str3=&quot;or not to be&quot;;</div><div class=\"line\">    string::iterator it;</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,str)//在s的pos位置插入str</div><div class=\"line\">    str.insert(6,str2);                 // to be the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</div><div class=\"line\">    str.insert(6,str3,3,4);             // to be not the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</div><div class=\"line\">    str.insert(10,&quot;that is cool&quot;,8);    // to be not that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,cstr)在s的pos位置插入cstr</div><div class=\"line\">    str.insert(10,&quot;to be &quot;);            // to be not to be that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch</div><div class=\"line\">    str.insert(15,1,&apos;:&apos;);               // to be not to be: that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</div><div class=\"line\">    it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</div><div class=\"line\">    str.insert (str.end(),3,&apos;.&apos;);       // to be, not to be: that is the question...</div><div class=\"line\"></div><div class=\"line\">    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</div><div class=\"line\">    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"erase操作：\"><a href=\"#erase操作：\" class=\"headerlink\" title=\"erase操作：\"></a>erase操作：</h4><p>用来执行删除操作<br>删除操作有三种</p>\n<p>指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除<br>迭代器，删除迭代器指向的字符<br>迭代器范围，删除这一范围的字符串，范围左闭右开<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">  std::string str (&quot;This is an example sentence.&quot;);</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                          // &quot;This is an example sentence.&quot;</div><div class=\"line\">  str.erase (10,8);       //            ^^^^^^^^</div><div class=\"line\">  //直接指定删除的字符串位置第十个后面的8个字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This is an sentence.&quot;</div><div class=\"line\">  str.erase (str.begin()+9);//           ^</div><div class=\"line\">  //删除迭代器指向的字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This is a sentence.&quot;</div><div class=\"line\">                            //       ^^^^^</div><div class=\"line\">  str.erase (str.begin()+5, str.end()-9);</div><div class=\"line\">  //删除迭代器范围的字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This sentence.&quot;</div><div class=\"line\">  return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"append和replace操作\"><a href=\"#append和replace操作\" class=\"headerlink\" title=\"append和replace操作:\"></a>append和replace操作:</h4><p>append函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现<br>repalce顾名思义，就是替换的意思，先删除，后增加。<br>代码来自cpp官网，附上自己的解释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string str;</div><div class=\"line\">    std::string str2=&quot;Writing &quot;;</div><div class=\"line\">    std::string str3=&quot;print 10 and then 5 more&quot;;</div><div class=\"line\"></div><div class=\"line\">    //直接追加一个str2的字符串</div><div class=\"line\">    str.append(str2);                       // &quot;Writing &quot;</div><div class=\"line\">    //后面追加str3第6个字符开始的3个字符串</div><div class=\"line\">    str.append(str3,6,3);                   // &quot;10 &quot;</div><div class=\"line\">    //追加字符串形参的前5个字符</div><div class=\"line\">    str.append(&quot;dots are cool&quot;,5);          // &quot;dots &quot;</div><div class=\"line\">    //直接添加</div><div class=\"line\">    str.append(&quot;here: &quot;);                   // &quot;here: &quot;</div><div class=\"line\">    //添加10个&apos;.&apos;</div><div class=\"line\">    str.append(10u,&apos;.&apos;);                    // &quot;..........&quot;</div><div class=\"line\">    //添加str3迭代器范围的字符串</div><div class=\"line\">    str.append(str3.begin()+8,str3.end());  // &quot; and then 5 more&quot;</div><div class=\"line\">    //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65</div><div class=\"line\">    str.append&lt;int&gt;(5,65);                // &quot;.....&quot;</div><div class=\"line\">    //字符串追加也可以用重载运算符实现</div><div class=\"line\">    str+=&quot;lalala&quot;;</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string base=&quot;this is a test string.&quot;;</div><div class=\"line\">    std::string str2=&quot;n example&quot;;</div><div class=\"line\">    std::string str3=&quot;sample phrase&quot;;</div><div class=\"line\">    std::string str4=&quot;useful.&quot;;</div><div class=\"line\"></div><div class=\"line\">    // replace signatures used in the same order as described above:</div><div class=\"line\"></div><div class=\"line\">    // Using positions:                 0123456789*123456789*12345</div><div class=\"line\">    std::string str=base;           // &quot;this is a test string.&quot;</div><div class=\"line\">    //第9个字符以及后面的4个字符被str2代替</div><div class=\"line\">    str.replace(9,5,str2);          // &quot;this is an example string.&quot; (1)</div><div class=\"line\">    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</div><div class=\"line\">    str.replace(19,6,str3,7,6);     // &quot;this is an example phrase.&quot; (2)</div><div class=\"line\">    //第8个字符以及后面的9个字符用字符串参数代替</div><div class=\"line\">    str.replace(8,10,&quot;just a&quot;);     // &quot;this is just a phrase.&quot;     (3)</div><div class=\"line\">    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换</div><div class=\"line\">    str.replace(8,6,&quot;a shorty&quot;,7);  // &quot;this is a short phrase.&quot;    (4)</div><div class=\"line\">    //第22以及后面的0个字符用3个叹号替换</div><div class=\"line\">    str.replace(22,1,3,&apos;!&apos;);        // &quot;this is a short phrase!!!&quot;  (5)</div><div class=\"line\">    //迭代器的原理同上</div><div class=\"line\">    // Using iterators:                                               0123456789*123456789*</div><div class=\"line\">    str.replace(str.begin(),str.end()-3,str3);                    // &quot;sample phrase!!!&quot;      (1)</div><div class=\"line\">    str.replace(str.begin(),str.begin()+6,&quot;replace&quot;);             // &quot;replace phrase!!!&quot;     (3)</div><div class=\"line\">    str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7);    // &quot;replace is cool!!!&quot;    (4)</div><div class=\"line\">    str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;);                // &quot;replace is cooool!!!&quot;  (5)</div><div class=\"line\">    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot;    (6)</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;   </div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。</p>\n<h4 id=\"assign操作：\"><a href=\"#assign操作：\" class=\"headerlink\" title=\"assign操作：\"></a>assign操作：</h4><p>assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string str;</div><div class=\"line\">    std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;;</div><div class=\"line\"></div><div class=\"line\">    // used in the same order as described above:</div><div class=\"line\">    //直接把base赋值给str</div><div class=\"line\">    str.assign(base);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //把base第10个字符以及后面的8个字符赋给str</div><div class=\"line\">    str.assign(base,10,9);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;brown fox&quot;</div><div class=\"line\">    //把参数中的0到6个字符串赋给str</div><div class=\"line\">    str.assign(&quot;pangrams are cool&quot;,7);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;pangram&quot;</div><div class=\"line\">    //直接使用参数赋值</div><div class=\"line\">    str.assign(&quot;c-string&quot;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;c-string&quot;</div><div class=\"line\">    //给str赋值10个&apos;*&apos;字符</div><div class=\"line\">    str.assign(10,&apos;*&apos;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;**********&quot;</div><div class=\"line\">    //赋值是10个&apos;-&apos;</div><div class=\"line\">    str.assign&lt;int&gt;(10,0x2D);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;----------&quot;</div><div class=\"line\">    //指定base迭代器范围的字符串</div><div class=\"line\">    str.assign(base.begin()+16,base.end()-12);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;fox jumps over&quot;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"string的搜索操作\"><a href=\"#string的搜索操作\" class=\"headerlink\" title=\"string的搜索操作:\"></a>string的搜索操作:</h4><p>string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p>\n<p>find和rfind函数:</p>\n<p>find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str (&quot;There are two needles in this haystack with needles.&quot;);</div><div class=\"line\">    std::string str2 (&quot;needle&quot;);</div><div class=\"line\"></div><div class=\"line\">    // different member versions of find in the same order as above:</div><div class=\"line\">    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</div><div class=\"line\">    std::size_t found = str.find(str2);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符</div><div class=\"line\">    found=str.find(&quot;needles are small&quot;,found+1,6);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //在str当中查找参数中的字符串</div><div class=\"line\">    found=str.find(&quot;haystack&quot;);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //查找一个字符</div><div class=\"line\">    found=str.find(&apos;.&apos;);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //组合使用，把str2用参数表中的字符串代替</div><div class=\"line\">    // let&apos;s replace the first needle:</div><div class=\"line\">    str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</div><div class=\"line\">    std::string key (&quot;sixth&quot;);//                    ^</div><div class=\"line\">    //rfind是找最后一个出现的匹配字符串</div><div class=\"line\">    std::size_t found = str.rfind(key);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        cout&lt;&lt;found&lt;&lt;endl;//输出23</div><div class=\"line\">        str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。</p>\n<p>find_….of函数:</p>\n<p>find_first_of(args) 查找args中任何一个字符第一次出现的位置<br>find_last_of(args) 最后一个出现的位置<br>find_fist_not_of(args) 查找第一个不在args中的字符<br>find_last_not_of 查找最后一个不在args中出现的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;);</div><div class=\"line\">    std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;);</div><div class=\"line\">    //把所有元音找出来用*代替</div><div class=\"line\">    while (found1!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        str1[found1]=&apos;*&apos;;</div><div class=\"line\">        found1=str1.find_first_of(&quot;aeiou&quot;,found1+1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    std::cout &lt;&lt; str1 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\"></div><div class=\"line\">    //在str2中找到第一个不是消协英文字母和空格的字符</div><div class=\"line\">    std::string str2 (&quot;look for non-alphabetic characters...&quot;);</div><div class=\"line\">    std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;);</div><div class=\"line\">    if (found2!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2];</div><div class=\"line\">        std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>find_last_of和find_last_not_of与first基本相同，就不写例子代码了。</p>\n<p>比较与转换:</p>\n<p>类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。<br>注意编译器bug：<br>在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。</p>\n<h4 id=\"compare函数\"><a href=\"#compare函数\" class=\"headerlink\" title=\"compare函数:\"></a>compare函数:</h4><p>和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。<br>在compare当中还支持部分比较，里面有6个参数可以设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s1=&quot;123&quot;,s2=&quot;123&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0</div><div class=\"line\"></div><div class=\"line\">    s1=&quot;123&quot;,s2=&quot;1234&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1</div><div class=\"line\"></div><div class=\"line\">    s1=&quot;1234&quot;,s2=&quot;123&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1</div><div class=\"line\"></div><div class=\"line\">    std::string str1 (&quot;green apple&quot;);</div><div class=\"line\">    std::string str2 (&quot;red apple&quot;);</div><div class=\"line\"></div><div class=\"line\">    if (str1.compare(str2) != 0)</div><div class=\"line\">    std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //str1的第6个字符以及后面的4个字符和参数比较</div><div class=\"line\">    if (str1.compare(6,5,&quot;apple&quot;) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\\n&quot;;</div><div class=\"line\"></div><div class=\"line\">    if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\\n&quot;;</div><div class=\"line\">    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</div><div class=\"line\">    if (str1.compare(6,5,str2,4,5) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;therefore, both are apples\\n&quot;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。</p>\n<h4 id=\"数值转换：\"><a href=\"#数值转换：\" class=\"headerlink\" title=\"数值转换：\"></a>数值转换：</h4><p>在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。</p>\n<p>string和数值转换<br>to_string(val)    把val转换成string<br>stoi(s,p,b)    把字符串s从p开始转换成b进制的int<br>stol(s,p,b)    long<br>stoul(s,p,b)    unsigned long<br>stoll(s,p,b)    long long<br>stoull(s,p,b)    unsigned long long<br>stof(s,p)    float<br>stod(s,p)    double<br>stold(s,p)    long double<br>//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s1;</div><div class=\"line\">    s1=to_string(100);</div><div class=\"line\">    cout&lt;&lt;s1&lt;&lt;endl;</div><div class=\"line\">    int a=stoi(s1,0,10)+1;</div><div class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"C-string的用法和例子-转-Mark一下\"><a href=\"#C-string的用法和例子-转-Mark一下\" class=\"headerlink\" title=\"C++ string的用法和例子(转)Mark一下\"></a>C++ string的用法和例子(转)Mark一下</h2><h3 id=\"使用场合：\"><a href=\"#使用场合：\" class=\"headerlink\" title=\"使用场合：\"></a>使用场合：</h3><p>string是C++标准库的一个重要的部分，主要用于字符串处理。可以使用输入输出流方式直接进行操作，也可以通过文件等手段进行操作。同时C++的算法库对string也有着很好的支持，而且string还和c语言的字符串之间有着良好的接口。虽然也有一些弊端，但是瑕不掩瑜。<br>其中使用的代码多数都是来自cpp官网，因为例子非常全。<br>","more":"</p>\n<h4 id=\"声明和初始化方法：\"><a href=\"#声明和初始化方法：\" class=\"headerlink\" title=\"声明和初始化方法：\"></a>声明和初始化方法：</h4><p>想使用string首先要在头文件当中加入&lt; string &gt;<br>声明方式也很简单</p>\n<h4 id=\"声明：\"><a href=\"#声明：\" class=\"headerlink\" title=\"声明：\"></a>声明：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">string s;//声明一个string 对象</div><div class=\"line\">string ss[10];//声明一个string对象的数组</div></pre></td></tr></table></figure>\n<h4 id=\"初始化：\"><a href=\"#初始化：\" class=\"headerlink\" title=\"初始化：\"></a>初始化：</h4><p>使用等号的初始化叫做拷贝初始化，不使用等号的初始化叫做直接初始化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s;//默认初始化，一个空字符串</div><div class=\"line\">    string s1(&quot;ssss&quot;);//s1是字面值“ssss”的副本</div><div class=\"line\">    string s2(s1);//s2是s1的副本</div><div class=\"line\">    string s3=s2;//s3是s2的副本</div><div class=\"line\">    string s4(10,&apos;c&apos;);//把s4初始化</div><div class=\"line\">    string s5=&quot;hiya&quot;;//拷贝初始化</div><div class=\"line\">    string s6=string(10,&apos;c&apos;);//拷贝初始化，生成一个初始化好的对象，拷贝给s6</div><div class=\"line\"></div><div class=\"line\">    //string s(cp,n)</div><div class=\"line\">    char cs[]=&quot;12345&quot;;</div><div class=\"line\">    string s7(cs,3);//复制字符串cs的前3个字符到s当中</div><div class=\"line\"></div><div class=\"line\">    //string s(s2,pos2)</div><div class=\"line\">    string s8=&quot;asac&quot;;</div><div class=\"line\">    string s9(s8,2);//从s2的第二个字符开始拷贝，不能超过s2的size</div><div class=\"line\"></div><div class=\"line\">    //string s(s2,pos2,len2)</div><div class=\"line\">    string s10=&quot;qweqweqweq&quot;;</div><div class=\"line\">    string s11(s10,3,4);//s4是s3从下标3开始4个字符的拷贝，超过s3.size出现未定义</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"字符串处理：\"><a href=\"#字符串处理：\" class=\"headerlink\" title=\"字符串处理：\"></a>字符串处理：</h3><h4 id=\"substr操作：\"><a href=\"#substr操作：\" class=\"headerlink\" title=\"substr操作：\"></a>substr操作：</h4><p>注意substr没有迭代器作为参数的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s=&quot;abcdefg&quot;;</div><div class=\"line\"></div><div class=\"line\">    //s.substr(pos1,n)返回字符串位置为pos1后面的n个字符组成的串</div><div class=\"line\">    string s2=s.substr(1,5);//abcde</div><div class=\"line\"></div><div class=\"line\">    //s.substr(pos)//得到一个pos到结尾的串</div><div class=\"line\">    string s3=s.substr(4);//efg</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果输入的位置超过字符的长度，会抛出一个out_of_range的异常</p>\n<h4 id=\"insert操作\"><a href=\"#insert操作\" class=\"headerlink\" title=\"insert操作:\"></a>insert操作:</h4><p>代码来自cpp官网，经过自己的整理<br>注意用迭代器当参数和无符号数当参数的区别</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string str=&quot;to be question&quot;;</div><div class=\"line\">    string str2=&quot;the &quot;;</div><div class=\"line\">    string str3=&quot;or not to be&quot;;</div><div class=\"line\">    string::iterator it;</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,str)//在s的pos位置插入str</div><div class=\"line\">    str.insert(6,str2);                 // to be the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</div><div class=\"line\">    str.insert(6,str3,3,4);             // to be not the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</div><div class=\"line\">    str.insert(10,&quot;that is cool&quot;,8);    // to be not that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,cstr)在s的pos位置插入cstr</div><div class=\"line\">    str.insert(10,&quot;to be &quot;);            // to be not to be that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(pos,n,ch)在s.pos位置上面插入n个ch</div><div class=\"line\">    str.insert(15,1,&apos;:&apos;);               // to be not to be: that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</div><div class=\"line\">    it = str.insert(str.begin()+5,&apos;,&apos;); // to be, not to be: that is the question</div><div class=\"line\"></div><div class=\"line\">    //s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</div><div class=\"line\">    str.insert (str.end(),3,&apos;.&apos;);       // to be, not to be: that is the question...</div><div class=\"line\"></div><div class=\"line\">    //s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</div><div class=\"line\">    str.insert (it+2,str3.begin(),str3.begin()+3); // to be, or not to be: that is the question...</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"erase操作：\"><a href=\"#erase操作：\" class=\"headerlink\" title=\"erase操作：\"></a>erase操作：</h4><p>用来执行删除操作<br>删除操作有三种</p>\n<p>指定pos和len，其中pos为为起始位置，pos以及后面len-1个字符串都删除<br>迭代器，删除迭代器指向的字符<br>迭代器范围，删除这一范围的字符串，范围左闭右开<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">  std::string str (&quot;This is an example sentence.&quot;);</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                          // &quot;This is an example sentence.&quot;</div><div class=\"line\">  str.erase (10,8);       //            ^^^^^^^^</div><div class=\"line\">  //直接指定删除的字符串位置第十个后面的8个字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This is an sentence.&quot;</div><div class=\"line\">  str.erase (str.begin()+9);//           ^</div><div class=\"line\">  //删除迭代器指向的字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This is a sentence.&quot;</div><div class=\"line\">                            //       ^^^^^</div><div class=\"line\">  str.erase (str.begin()+5, str.end()-9);</div><div class=\"line\">  //删除迭代器范围的字符</div><div class=\"line\">  std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">                            // &quot;This sentence.&quot;</div><div class=\"line\">  return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"append和replace操作\"><a href=\"#append和replace操作\" class=\"headerlink\" title=\"append和replace操作:\"></a>append和replace操作:</h4><p>append函数可以用来在字符串的末尾追加字符和字符串。由于string重载了运算符，也可以用+=操作实现<br>repalce顾名思义，就是替换的意思，先删除，后增加。<br>代码来自cpp官网，附上自己的解释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string str;</div><div class=\"line\">    std::string str2=&quot;Writing &quot;;</div><div class=\"line\">    std::string str3=&quot;print 10 and then 5 more&quot;;</div><div class=\"line\"></div><div class=\"line\">    //直接追加一个str2的字符串</div><div class=\"line\">    str.append(str2);                       // &quot;Writing &quot;</div><div class=\"line\">    //后面追加str3第6个字符开始的3个字符串</div><div class=\"line\">    str.append(str3,6,3);                   // &quot;10 &quot;</div><div class=\"line\">    //追加字符串形参的前5个字符</div><div class=\"line\">    str.append(&quot;dots are cool&quot;,5);          // &quot;dots &quot;</div><div class=\"line\">    //直接添加</div><div class=\"line\">    str.append(&quot;here: &quot;);                   // &quot;here: &quot;</div><div class=\"line\">    //添加10个&apos;.&apos;</div><div class=\"line\">    str.append(10u,&apos;.&apos;);                    // &quot;..........&quot;</div><div class=\"line\">    //添加str3迭代器范围的字符串</div><div class=\"line\">    str.append(str3.begin()+8,str3.end());  // &quot; and then 5 more&quot;</div><div class=\"line\">    //最后这个比较特殊，意思是添加5个&apos;A&apos;，实际上参数里面的65对应的asc码就是65</div><div class=\"line\">    str.append&lt;int&gt;(5,65);                // &quot;.....&quot;</div><div class=\"line\">    //字符串追加也可以用重载运算符实现</div><div class=\"line\">    str+=&quot;lalala&quot;;</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>replace的使用方法，replace支持使用无符号整数寻找位置，也支持用迭代器寻找位置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string base=&quot;this is a test string.&quot;;</div><div class=\"line\">    std::string str2=&quot;n example&quot;;</div><div class=\"line\">    std::string str3=&quot;sample phrase&quot;;</div><div class=\"line\">    std::string str4=&quot;useful.&quot;;</div><div class=\"line\"></div><div class=\"line\">    // replace signatures used in the same order as described above:</div><div class=\"line\"></div><div class=\"line\">    // Using positions:                 0123456789*123456789*12345</div><div class=\"line\">    std::string str=base;           // &quot;this is a test string.&quot;</div><div class=\"line\">    //第9个字符以及后面的4个字符被str2代替</div><div class=\"line\">    str.replace(9,5,str2);          // &quot;this is an example string.&quot; (1)</div><div class=\"line\">    //第19个字符串以及后面的5个字符用str的第7个字符以及后面的5个字符代替</div><div class=\"line\">    str.replace(19,6,str3,7,6);     // &quot;this is an example phrase.&quot; (2)</div><div class=\"line\">    //第8个字符以及后面的9个字符用字符串参数代替</div><div class=\"line\">    str.replace(8,10,&quot;just a&quot;);     // &quot;this is just a phrase.&quot;     (3)</div><div class=\"line\">    //第8个字符以及后面的5个字符用字符串参数的前7个字符替换</div><div class=\"line\">    str.replace(8,6,&quot;a shorty&quot;,7);  // &quot;this is a short phrase.&quot;    (4)</div><div class=\"line\">    //第22以及后面的0个字符用3个叹号替换</div><div class=\"line\">    str.replace(22,1,3,&apos;!&apos;);        // &quot;this is a short phrase!!!&quot;  (5)</div><div class=\"line\">    //迭代器的原理同上</div><div class=\"line\">    // Using iterators:                                               0123456789*123456789*</div><div class=\"line\">    str.replace(str.begin(),str.end()-3,str3);                    // &quot;sample phrase!!!&quot;      (1)</div><div class=\"line\">    str.replace(str.begin(),str.begin()+6,&quot;replace&quot;);             // &quot;replace phrase!!!&quot;     (3)</div><div class=\"line\">    str.replace(str.begin()+8,str.begin()+14,&quot;is coolness&quot;,7);    // &quot;replace is cool!!!&quot;    (4)</div><div class=\"line\">    str.replace(str.begin()+12,str.end()-4,4,&apos;o&apos;);                // &quot;replace is cooool!!!&quot;  (5)</div><div class=\"line\">    str.replace(str.begin()+11,str.end(),str4.begin(),str4.end());// &quot;replace is useful.&quot;    (6)</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;   </div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上的replace操作可以用insert和erase的操作组合替换，但是replace操作更加方便。</p>\n<h4 id=\"assign操作：\"><a href=\"#assign操作：\" class=\"headerlink\" title=\"assign操作：\"></a>assign操作：</h4><p>assign操作在一起列容器当中都存在，比如vector等等。是一个很基本的操作函数，string使用assign可以灵活的对其进行赋值。<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\"></div><div class=\"line\">int main ()</div><div class=\"line\">&#123;</div><div class=\"line\">    std::string str;</div><div class=\"line\">    std::string base=&quot;The quick brown fox jumps over a lazy dog.&quot;;</div><div class=\"line\"></div><div class=\"line\">    // used in the same order as described above:</div><div class=\"line\">    //直接把base赋值给str</div><div class=\"line\">    str.assign(base);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //把base第10个字符以及后面的8个字符赋给str</div><div class=\"line\">    str.assign(base,10,9);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;brown fox&quot;</div><div class=\"line\">    //把参数中的0到6个字符串赋给str</div><div class=\"line\">    str.assign(&quot;pangrams are cool&quot;,7);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;pangram&quot;</div><div class=\"line\">    //直接使用参数赋值</div><div class=\"line\">    str.assign(&quot;c-string&quot;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;c-string&quot;</div><div class=\"line\">    //给str赋值10个&apos;*&apos;字符</div><div class=\"line\">    str.assign(10,&apos;*&apos;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;**********&quot;</div><div class=\"line\">    //赋值是10个&apos;-&apos;</div><div class=\"line\">    str.assign&lt;int&gt;(10,0x2D);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;----------&quot;</div><div class=\"line\">    //指定base迭代器范围的字符串</div><div class=\"line\">    str.assign(base.begin()+16,base.end()-12);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;         // &quot;fox jumps over&quot;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"string的搜索操作\"><a href=\"#string的搜索操作\" class=\"headerlink\" title=\"string的搜索操作:\"></a>string的搜索操作:</h4><p>string类中提供了很多性能优秀，使用方便的成员方法。而且在泛型算法当中也有很多实用的技巧。</p>\n<p>find和rfind函数:</p>\n<p>find函数主要是查找一个字符串是否在调用的字符串中出现过，大小写敏感。<br>代码来自cpp官网</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str (&quot;There are two needles in this haystack with needles.&quot;);</div><div class=\"line\">    std::string str2 (&quot;needle&quot;);</div><div class=\"line\"></div><div class=\"line\">    // different member versions of find in the same order as above:</div><div class=\"line\">    //在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</div><div class=\"line\">    std::size_t found = str.find(str2);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;first &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //在str当中，从第found+1的位置开始查找参数字符串的前6个字符</div><div class=\"line\">    found=str.find(&quot;needles are small&quot;,found+1,6);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;second &apos;needle&apos; found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //在str当中查找参数中的字符串</div><div class=\"line\">    found=str.find(&quot;haystack&quot;);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;&apos;haystack&apos; also found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //查找一个字符</div><div class=\"line\">    found=str.find(&apos;.&apos;);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    std::cout &lt;&lt; &quot;Period found at: &quot; &lt;&lt; found &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //组合使用，把str2用参数表中的字符串代替</div><div class=\"line\">    // let&apos;s replace the first needle:</div><div class=\"line\">    str.replace(str.find(str2),str2.length(),&quot;preposition&quot;);</div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>rfind函数就是找最后一个出现的匹配字符串，返回的位置仍然是从前往后数的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str (&quot;The sixth sick sheik&apos;s sixth sheep&apos;s sick.&quot;);</div><div class=\"line\">    std::string key (&quot;sixth&quot;);//                    ^</div><div class=\"line\">    //rfind是找最后一个出现的匹配字符串</div><div class=\"line\">    std::size_t found = str.rfind(key);</div><div class=\"line\">    if (found!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        cout&lt;&lt;found&lt;&lt;endl;//输出23</div><div class=\"line\">        str.replace (found,key.length(),&quot;seventh&quot;);//找到的sixth替换成seventh</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    std::cout &lt;&lt; str &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>查找的效率非常高，我没看过stl源码剖析，但是感觉是用kmp实现的。呵呵，可以自己写一个。</p>\n<p>find_….of函数:</p>\n<p>find_first_of(args) 查找args中任何一个字符第一次出现的位置<br>find_last_of(args) 最后一个出现的位置<br>find_fist_not_of(args) 查找第一个不在args中的字符<br>find_last_not_of 查找最后一个不在args中出现的字符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    std::string str1 (&quot;Please, replace the vowels in this sentence by asterisks.&quot;);</div><div class=\"line\">    std::size_t found1 = str1.find_first_of(&quot;aeiou&quot;);</div><div class=\"line\">    //把所有元音找出来用*代替</div><div class=\"line\">    while (found1!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        str1[found1]=&apos;*&apos;;</div><div class=\"line\">        found1=str1.find_first_of(&quot;aeiou&quot;,found1+1);</div><div class=\"line\">    &#125;</div><div class=\"line\">    std::cout &lt;&lt; str1 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\"></div><div class=\"line\">    //在str2中找到第一个不是消协英文字母和空格的字符</div><div class=\"line\">    std::string str2 (&quot;look for non-alphabetic characters...&quot;);</div><div class=\"line\">    std::size_t found2 = str2.find_first_not_of(&quot;abcdefghijklmnopqrstuvwxyz &quot;);</div><div class=\"line\">    if (found2!=std::string::npos)</div><div class=\"line\">    &#123;</div><div class=\"line\">        std::cout &lt;&lt; &quot;The first non-alphabetic character is &quot; &lt;&lt; str2[found2];</div><div class=\"line\">        std::cout &lt;&lt; &quot; at position &quot; &lt;&lt; found2 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>find_last_of和find_last_not_of与first基本相同，就不写例子代码了。</p>\n<p>比较与转换:</p>\n<p>类似c语言的字符串比较函数strcmp函数一样，支持字符串比较操作，同时也类似python、C#语言中的函数一样，支持把数字和字符串转换。有些特性是C++11当中才有。<br>注意编译器bug：<br>在MinGW编译器当中如果版本低于3.8，虽然支持c++11但是里面有一个bug，就是不支持字符串和数组的转换！要更新MinGW的版本才可以，或者直接使用g++。</p>\n<h4 id=\"compare函数\"><a href=\"#compare函数\" class=\"headerlink\" title=\"compare函数:\"></a>compare函数:</h4><p>和strcmp函数一样，如果两个字符串相等，那么返回0，调用对象大于参数返回1，小于返回-1。<br>在compare当中还支持部分比较，里面有6个参数可以设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s1=&quot;123&quot;,s2=&quot;123&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//0</div><div class=\"line\"></div><div class=\"line\">    s1=&quot;123&quot;,s2=&quot;1234&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//-1</div><div class=\"line\"></div><div class=\"line\">    s1=&quot;1234&quot;,s2=&quot;123&quot;;</div><div class=\"line\">    cout&lt;&lt;s1.compare(s2)&lt;&lt;endl;//1</div><div class=\"line\"></div><div class=\"line\">    std::string str1 (&quot;green apple&quot;);</div><div class=\"line\">    std::string str2 (&quot;red apple&quot;);</div><div class=\"line\"></div><div class=\"line\">    if (str1.compare(str2) != 0)</div><div class=\"line\">    std::cout &lt;&lt; str1 &lt;&lt; &quot; is not &quot; &lt;&lt; str2 &lt;&lt; &apos;\\n&apos;;</div><div class=\"line\">    //str1的第6个字符以及后面的4个字符和参数比较</div><div class=\"line\">    if (str1.compare(6,5,&quot;apple&quot;) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;still, &quot; &lt;&lt; str1 &lt;&lt; &quot; is an apple\\n&quot;;</div><div class=\"line\"></div><div class=\"line\">    if (str2.compare(str2.size()-5,5,&quot;apple&quot;) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;and &quot; &lt;&lt; str2 &lt;&lt; &quot; is also an apple\\n&quot;;</div><div class=\"line\">    //str1的第6个字符以及后面的4个字符和str2的第4个字符以及后面的4个字符比较</div><div class=\"line\">    if (str1.compare(6,5,str2,4,5) == 0)</div><div class=\"line\">    std::cout &lt;&lt; &quot;therefore, both are apples\\n&quot;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于string重载了运算符，可以直接用&gt;,&lt;，==来进行比较，也很方便。</p>\n<h4 id=\"数值转换：\"><a href=\"#数值转换：\" class=\"headerlink\" title=\"数值转换：\"></a>数值转换：</h4><p>在io的部分有过数值和字符串相互转换的例子，使用的是stringstream函数，在c++11当中有定义好的现成的函数取调用，非常方便。</p>\n<p>string和数值转换<br>to_string(val)    把val转换成string<br>stoi(s,p,b)    把字符串s从p开始转换成b进制的int<br>stol(s,p,b)    long<br>stoul(s,p,b)    unsigned long<br>stoll(s,p,b)    long long<br>stoull(s,p,b)    unsigned long long<br>stof(s,p)    float<br>stod(s,p)    double<br>stold(s,p)    long double<br>//注意，下段代码在MinGw中会报错！即使使用c++11编译也一样，无法识别to_string！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;bits/stdc++.h&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    ios::sync_with_stdio(false);</div><div class=\"line\">    string s1;</div><div class=\"line\">    s1=to_string(100);</div><div class=\"line\">    cout&lt;&lt;s1&lt;&lt;endl;</div><div class=\"line\">    int a=stoi(s1,0,10)+1;</div><div class=\"line\">    cout&lt;&lt;a&lt;&lt;endl;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"Python多进程通信和调用","date":"2017-06-12T07:00:31.000Z","_content":"\n## python多进程通信\n>这里解决的主要是，如果是启动一个命令行，然后执行一个python脚本，如果有多个python脚本就需要多个命令行程序，这不是很明智的选择，最好的做法是，一个命令行搞定所有的python脚本，这里就涉及到两个问题\n>\n>- 如何做到并发\n>- 如何在一个文件中添加一个python的执行入口\n<!--more-->\n```\n#coding:utf-8\n\nimport os,re,time\nimport multiprocessing,commands,shutil,subprocess\nfrom pymongo import MongoClient\n\nlock = multiprocessing.Lock()\n\ndef func(name, processName, pipe):\n    p_info = 'Process[%s]  hello %s' % (processName, name)\n    print 'pipe send: ', p_info\n    pipe.send(p_info)\n    \n    print 'sub pid: %d, ppid: %d' % (os.getpid(), os.getppid())\n    time.sleep(0.1)\n\ndef serverForPull(name,pipe):\n\n    path = '/Users/jdjr/Desktop/branches.txt'\n\n    while True:\n        time.sleep(3)\n        newpath = '/Users/jdjr/Desktop/gradleDir'\n        if os.path.exists(newpath) == True:\n            os.chdir('/Users/jdjr/Documents/Build/JDJRAPPAndroid')\n\n            currentbranch = ''\n\n            branch = os.popen('git branch').read()\n\n            lines = branch.split('\\n')\n            for item in lines:\n                if '*' in item:\n                   currentbranch = item[2:]\n\n            p = subprocess.Popen(\"gradle assembleDebug\",shell=True,stdout=subprocess.PIPE)\n\n            indexcount = 0\n\n            returncode = p.poll()\n\n            while returncode is None:\n                  text = p.stdout.readline().strip()\n                  f = open('/Users/jdjr/Desktop/buildlog.txt','a')\n                  f.write(text)\n                  f.close()\n        \n                  mc = MongoClient(\"localhost\",27017)\n                  db = mc.package\n                  post_info = db.index\n\n                  dbs = post_info.find({'branchname':currentbranch})\n                  count = 0\n                  itemc = {}\n                  for itemn in dbs:\n                      itemc = itemn\n                      count = count + 1\n\n                  if count == 0:\n                     post_info.save({'branchname':currentbranch,'count':indexcount,'time':0,'lastcount':0})\n                  else:\n                     ctime = itemc['time']\n                     lastcount = itemc['lastcount']\n                     \n                     if 'Total time:' in text:\n                         indexnew = text.find(':')\n                         newtime = text[indexnew + 1:]\n\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':newtime,'lastcount':lastcount})\n                     else:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':ctime,'lastcount':lastcount})\n\n\n                     if 'BUILD SUCCESSFUL' in text:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':0,'time':ctime,'lastcount':indexcount})\n                     else:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':ctime,'lastcount':lastcount})\n\n                  indexcount = indexcount + 1\n        \n                  returncode = p.poll()\n        \n            f1 = open('/Users/jdjr/Desktop/buildlog.txt','r')\n            texts = f1.read()\n            f1.close()\n            if 'BUILD FAILED' in texts:\n                (status, output) = commands.getstatusoutput('gradle assembleDebug')\n                f2 = open('/Users/jdjr/Desktop/buildlog.txt','w')\n                texts = f2.write(output)\n                f2.close()\n\n            shutil.rmtree(newpath)\n\n            time.sleep(2)\n\n            mc = MongoClient(\"localhost\",27017)\n            db = mc.package\n            post_info = db.index\n\n            post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':20,'time':0,'lastcount':indexcount})\n\n        if os.path.exists(path):\n            f1 = open(path,'r')\n            lists = f1.readlines()\n\n            if len(lists) == 2:\n               dir = lists[0]\n               branch = lists[1]\n               \n               if 'JDJRAPPAndroid' in dir:\n                  dir = '/Users/jdjr/Documents/Build/JDJRAPPAndroid'\n\n               if 'JDMobileNew' in dir:\n                  dir = '/Users/wxg/Documents/JDMobileNew'\n\n               if len(dir) > 0:\n                   print dir\n              \n                   os.chdir(dir)         \n                   (status, output) = commands.getstatusoutput('git pull origin %s' % branch)\n                   f1 = open('/Users/jdjr/Desktop/buildlog.txt','r')\n                   text = f1.read()\n                   f1.close()\n\n                   f1 = open('/Users/jdjr/Desktop/buildlog.txt','w')\n                   text1 = text + '\\n' + output + '%i' % status\n                   f1.write(text1)\n                   f1.close()\n\n                   f2 = open(path,'w')\n                   f2.write('')\n                   f2.close()\n\n            f1.close()\n\ndef monitorForBlog(name,pipe):\n    lastTimeStr = ''\n    while True:\n      time.sleep(3)\n      os.chdir('/Users/jdjr/Documents/Blog/blogsource')\n      \n#      os.chdir('/usr/local/var/www')\n\n      (status, output) = commands.getstatusoutput('git pull origin blog')\n\n      (status, output) = commands.getstatusoutput('git log')\n\n      f = open('/Users/jdjr/Documents/Blog/logcommit.txt','w')\n      f.write(output)\n      f.close()\n\n      f1 = open('/Users/jdjr/Documents/Blog/logcommit.txt','r')\n      lines = f1.readlines()\n      firstline = lines[0]\n      f1.close()\n\n      if lastTimeStr != firstline:\n          print '推送一次博客'\n          sourcepath = '/Users/jdjr/Documents/Blog/blog/source'\n          \n          if os.path.exists(sourcepath):\n             shutil.rmtree(sourcepath)\n          \n          shutil.copytree('/Users/jdjr/Documents/Blog/blogsource/source','/Users/jdjr/Documents/Blog/blog/source')\n\n          os.chdir('/Users/jdjr/Documents/Blog/blog')\n\n#          os.popen('hexo clean')\n          os.system('hexo clean')\n          os.system('hexo g')\n          \n          filepath = '/usr/local/var/www'\n          if os.path.exists(filepath):\n             shutil.rmtree(filepath)\n\n          publicfile = '/Users/jdjr/Documents/Blog/blog/public'\n          while not os.path.exists(publicfile):\n                time.sleep(1)\n#                print 'not exist'\n\n          shutil.move(publicfile,filepath)\n          \n          lastTimeStr = firstline\n          print lastTimeStr\n\n\ndef main():\n    print 'main pid: %d, ppid: %d' % (os.getpid(), os.getppid())\n    \n    # 注意： 此处是Pipe来自multiprocessing.Pipe(), 其来源于 multiprocessing.connection import Pipe\n    pipe_parent, pipe_child = multiprocessing.Pipe(duplex=False)\n    \n    processList = []\n#    for i in xrange(4):\n#    pro = multiprocessing.Process(target=func, args=('ceshi', 'Process-' + str(10), pipe_child))\n#    pro.start()\n#    processList.append(pro)\n#    \n#    pro1 = multiprocessing.Process(target=func1, args=('waha',pipe_child))\n#    pro1.start()\n#    processList.append(pro1)\n#    \n#    pro2 = multiprocessing.Process(target=func2, args=('heihei',pipe_child))\n#    pro2.start()\n#    processList.append(pro2)\n\n    pro3 = multiprocessing.Process(target=serverForPull, args=('heihei',pipe_child))\n    pro3.start()\n    processList.append(pro3)\n\n    pro4 = multiprocessing.Process(target=monitorForBlog, args=('heihei',pipe_child))\n    pro4.start()\n    processList.append(pro4)\n    \n    for pro in processList:\n        pro.join()      # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程\n    \n    pipe_child.send(None)   # 此处等全部子进程执行完成后，输入'None'标记，表示Pipe结束接收任务，可以退出\n\n    while pipe_parent:\n          p_info = pipe_parent.recv()\n          print 'pipe get: ', p_info\n        \n          if not p_info:      # 如果接收到了'None'标记，退出Pipe\n             print 'pipe get:  None, then exit out.'\n             break\n\n# 测试\nif __name__ == '__main__':\n    main()\n    print('end.')\n\n\n```\n","source":"_posts/Python多进程通信和调用.md","raw":"---\ntitle: Python多进程通信和调用\ndate: 2017-06-12 15:00:31\ntags:\n- Python\n---\n\n## python多进程通信\n>这里解决的主要是，如果是启动一个命令行，然后执行一个python脚本，如果有多个python脚本就需要多个命令行程序，这不是很明智的选择，最好的做法是，一个命令行搞定所有的python脚本，这里就涉及到两个问题\n>\n>- 如何做到并发\n>- 如何在一个文件中添加一个python的执行入口\n<!--more-->\n```\n#coding:utf-8\n\nimport os,re,time\nimport multiprocessing,commands,shutil,subprocess\nfrom pymongo import MongoClient\n\nlock = multiprocessing.Lock()\n\ndef func(name, processName, pipe):\n    p_info = 'Process[%s]  hello %s' % (processName, name)\n    print 'pipe send: ', p_info\n    pipe.send(p_info)\n    \n    print 'sub pid: %d, ppid: %d' % (os.getpid(), os.getppid())\n    time.sleep(0.1)\n\ndef serverForPull(name,pipe):\n\n    path = '/Users/jdjr/Desktop/branches.txt'\n\n    while True:\n        time.sleep(3)\n        newpath = '/Users/jdjr/Desktop/gradleDir'\n        if os.path.exists(newpath) == True:\n            os.chdir('/Users/jdjr/Documents/Build/JDJRAPPAndroid')\n\n            currentbranch = ''\n\n            branch = os.popen('git branch').read()\n\n            lines = branch.split('\\n')\n            for item in lines:\n                if '*' in item:\n                   currentbranch = item[2:]\n\n            p = subprocess.Popen(\"gradle assembleDebug\",shell=True,stdout=subprocess.PIPE)\n\n            indexcount = 0\n\n            returncode = p.poll()\n\n            while returncode is None:\n                  text = p.stdout.readline().strip()\n                  f = open('/Users/jdjr/Desktop/buildlog.txt','a')\n                  f.write(text)\n                  f.close()\n        \n                  mc = MongoClient(\"localhost\",27017)\n                  db = mc.package\n                  post_info = db.index\n\n                  dbs = post_info.find({'branchname':currentbranch})\n                  count = 0\n                  itemc = {}\n                  for itemn in dbs:\n                      itemc = itemn\n                      count = count + 1\n\n                  if count == 0:\n                     post_info.save({'branchname':currentbranch,'count':indexcount,'time':0,'lastcount':0})\n                  else:\n                     ctime = itemc['time']\n                     lastcount = itemc['lastcount']\n                     \n                     if 'Total time:' in text:\n                         indexnew = text.find(':')\n                         newtime = text[indexnew + 1:]\n\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':newtime,'lastcount':lastcount})\n                     else:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':ctime,'lastcount':lastcount})\n\n\n                     if 'BUILD SUCCESSFUL' in text:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':0,'time':ctime,'lastcount':indexcount})\n                     else:\n                         post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':indexcount,'time':ctime,'lastcount':lastcount})\n\n                  indexcount = indexcount + 1\n        \n                  returncode = p.poll()\n        \n            f1 = open('/Users/jdjr/Desktop/buildlog.txt','r')\n            texts = f1.read()\n            f1.close()\n            if 'BUILD FAILED' in texts:\n                (status, output) = commands.getstatusoutput('gradle assembleDebug')\n                f2 = open('/Users/jdjr/Desktop/buildlog.txt','w')\n                texts = f2.write(output)\n                f2.close()\n\n            shutil.rmtree(newpath)\n\n            time.sleep(2)\n\n            mc = MongoClient(\"localhost\",27017)\n            db = mc.package\n            post_info = db.index\n\n            post_info.update({'branchname':currentbranch},{'branchname':currentbranch,'count':20,'time':0,'lastcount':indexcount})\n\n        if os.path.exists(path):\n            f1 = open(path,'r')\n            lists = f1.readlines()\n\n            if len(lists) == 2:\n               dir = lists[0]\n               branch = lists[1]\n               \n               if 'JDJRAPPAndroid' in dir:\n                  dir = '/Users/jdjr/Documents/Build/JDJRAPPAndroid'\n\n               if 'JDMobileNew' in dir:\n                  dir = '/Users/wxg/Documents/JDMobileNew'\n\n               if len(dir) > 0:\n                   print dir\n              \n                   os.chdir(dir)         \n                   (status, output) = commands.getstatusoutput('git pull origin %s' % branch)\n                   f1 = open('/Users/jdjr/Desktop/buildlog.txt','r')\n                   text = f1.read()\n                   f1.close()\n\n                   f1 = open('/Users/jdjr/Desktop/buildlog.txt','w')\n                   text1 = text + '\\n' + output + '%i' % status\n                   f1.write(text1)\n                   f1.close()\n\n                   f2 = open(path,'w')\n                   f2.write('')\n                   f2.close()\n\n            f1.close()\n\ndef monitorForBlog(name,pipe):\n    lastTimeStr = ''\n    while True:\n      time.sleep(3)\n      os.chdir('/Users/jdjr/Documents/Blog/blogsource')\n      \n#      os.chdir('/usr/local/var/www')\n\n      (status, output) = commands.getstatusoutput('git pull origin blog')\n\n      (status, output) = commands.getstatusoutput('git log')\n\n      f = open('/Users/jdjr/Documents/Blog/logcommit.txt','w')\n      f.write(output)\n      f.close()\n\n      f1 = open('/Users/jdjr/Documents/Blog/logcommit.txt','r')\n      lines = f1.readlines()\n      firstline = lines[0]\n      f1.close()\n\n      if lastTimeStr != firstline:\n          print '推送一次博客'\n          sourcepath = '/Users/jdjr/Documents/Blog/blog/source'\n          \n          if os.path.exists(sourcepath):\n             shutil.rmtree(sourcepath)\n          \n          shutil.copytree('/Users/jdjr/Documents/Blog/blogsource/source','/Users/jdjr/Documents/Blog/blog/source')\n\n          os.chdir('/Users/jdjr/Documents/Blog/blog')\n\n#          os.popen('hexo clean')\n          os.system('hexo clean')\n          os.system('hexo g')\n          \n          filepath = '/usr/local/var/www'\n          if os.path.exists(filepath):\n             shutil.rmtree(filepath)\n\n          publicfile = '/Users/jdjr/Documents/Blog/blog/public'\n          while not os.path.exists(publicfile):\n                time.sleep(1)\n#                print 'not exist'\n\n          shutil.move(publicfile,filepath)\n          \n          lastTimeStr = firstline\n          print lastTimeStr\n\n\ndef main():\n    print 'main pid: %d, ppid: %d' % (os.getpid(), os.getppid())\n    \n    # 注意： 此处是Pipe来自multiprocessing.Pipe(), 其来源于 multiprocessing.connection import Pipe\n    pipe_parent, pipe_child = multiprocessing.Pipe(duplex=False)\n    \n    processList = []\n#    for i in xrange(4):\n#    pro = multiprocessing.Process(target=func, args=('ceshi', 'Process-' + str(10), pipe_child))\n#    pro.start()\n#    processList.append(pro)\n#    \n#    pro1 = multiprocessing.Process(target=func1, args=('waha',pipe_child))\n#    pro1.start()\n#    processList.append(pro1)\n#    \n#    pro2 = multiprocessing.Process(target=func2, args=('heihei',pipe_child))\n#    pro2.start()\n#    processList.append(pro2)\n\n    pro3 = multiprocessing.Process(target=serverForPull, args=('heihei',pipe_child))\n    pro3.start()\n    processList.append(pro3)\n\n    pro4 = multiprocessing.Process(target=monitorForBlog, args=('heihei',pipe_child))\n    pro4.start()\n    processList.append(pro4)\n    \n    for pro in processList:\n        pro.join()      # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程\n    \n    pipe_child.send(None)   # 此处等全部子进程执行完成后，输入'None'标记，表示Pipe结束接收任务，可以退出\n\n    while pipe_parent:\n          p_info = pipe_parent.recv()\n          print 'pipe get: ', p_info\n        \n          if not p_info:      # 如果接收到了'None'标记，退出Pipe\n             print 'pipe get:  None, then exit out.'\n             break\n\n# 测试\nif __name__ == '__main__':\n    main()\n    print('end.')\n\n\n```\n","slug":"Python多进程通信和调用","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pk90005sauaeunr6ivd","content":"<h2 id=\"python多进程通信\"><a href=\"#python多进程通信\" class=\"headerlink\" title=\"python多进程通信\"></a>python多进程通信</h2><blockquote>\n<p>这里解决的主要是，如果是启动一个命令行，然后执行一个python脚本，如果有多个python脚本就需要多个命令行程序，这不是很明智的选择，最好的做法是，一个命令行搞定所有的python脚本，这里就涉及到两个问题</p>\n<ul>\n<li>如何做到并发</li>\n<li>如何在一个文件中添加一个python的执行入口<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div></pre></td><td class=\"code\"><pre><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">import os,re,time</div><div class=\"line\">import multiprocessing,commands,shutil,subprocess</div><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">lock = multiprocessing.Lock()</div><div class=\"line\"></div><div class=\"line\">def func(name, processName, pipe):</div><div class=\"line\">    p_info = &apos;Process[%s]  hello %s&apos; % (processName, name)</div><div class=\"line\">    print &apos;pipe send: &apos;, p_info</div><div class=\"line\">    pipe.send(p_info)</div><div class=\"line\">    </div><div class=\"line\">    print &apos;sub pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid())</div><div class=\"line\">    time.sleep(0.1)</div><div class=\"line\"></div><div class=\"line\">def serverForPull(name,pipe):</div><div class=\"line\"></div><div class=\"line\">    path = &apos;/Users/jdjr/Desktop/branches.txt&apos;</div><div class=\"line\"></div><div class=\"line\">    while True:</div><div class=\"line\">        time.sleep(3)</div><div class=\"line\">        newpath = &apos;/Users/jdjr/Desktop/gradleDir&apos;</div><div class=\"line\">        if os.path.exists(newpath) == True:</div><div class=\"line\">            os.chdir(&apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos;)</div><div class=\"line\"></div><div class=\"line\">            currentbranch = &apos;&apos;</div><div class=\"line\"></div><div class=\"line\">            branch = os.popen(&apos;git branch&apos;).read()</div><div class=\"line\"></div><div class=\"line\">            lines = branch.split(&apos;\\n&apos;)</div><div class=\"line\">            for item in lines:</div><div class=\"line\">                if &apos;*&apos; in item:</div><div class=\"line\">                   currentbranch = item[2:]</div><div class=\"line\"></div><div class=\"line\">            p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE)</div><div class=\"line\"></div><div class=\"line\">            indexcount = 0</div><div class=\"line\"></div><div class=\"line\">            returncode = p.poll()</div><div class=\"line\"></div><div class=\"line\">            while returncode is None:</div><div class=\"line\">                  text = p.stdout.readline().strip()</div><div class=\"line\">                  f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;)</div><div class=\"line\">                  f.write(text)</div><div class=\"line\">                  f.close()</div><div class=\"line\">        </div><div class=\"line\">                  mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">                  db = mc.package</div><div class=\"line\">                  post_info = db.index</div><div class=\"line\"></div><div class=\"line\">                  dbs = post_info.find(&#123;&apos;branchname&apos;:currentbranch&#125;)</div><div class=\"line\">                  count = 0</div><div class=\"line\">                  itemc = &#123;&#125;</div><div class=\"line\">                  for itemn in dbs:</div><div class=\"line\">                      itemc = itemn</div><div class=\"line\">                      count = count + 1</div><div class=\"line\"></div><div class=\"line\">                  if count == 0:</div><div class=\"line\">                     post_info.save(&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:0,&apos;lastcount&apos;:0&#125;)</div><div class=\"line\">                  else:</div><div class=\"line\">                     ctime = itemc[&apos;time&apos;]</div><div class=\"line\">                     lastcount = itemc[&apos;lastcount&apos;]</div><div class=\"line\">                     </div><div class=\"line\">                     if &apos;Total time:&apos; in text:</div><div class=\"line\">                         indexnew = text.find(&apos;:&apos;)</div><div class=\"line\">                         newtime = text[indexnew + 1:]</div><div class=\"line\"></div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:newtime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\">                     else:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">                     if &apos;BUILD SUCCESSFUL&apos; in text:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:0,&apos;time&apos;:ctime,&apos;lastcount&apos;:indexcount&#125;)</div><div class=\"line\">                     else:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\"></div><div class=\"line\">                  indexcount = indexcount + 1</div><div class=\"line\">        </div><div class=\"line\">                  returncode = p.poll()</div><div class=\"line\">        </div><div class=\"line\">            f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;)</div><div class=\"line\">            texts = f1.read()</div><div class=\"line\">            f1.close()</div><div class=\"line\">            if &apos;BUILD FAILED&apos; in texts:</div><div class=\"line\">                (status, output) = commands.getstatusoutput(&apos;gradle assembleDebug&apos;)</div><div class=\"line\">                f2 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;)</div><div class=\"line\">                texts = f2.write(output)</div><div class=\"line\">                f2.close()</div><div class=\"line\"></div><div class=\"line\">            shutil.rmtree(newpath)</div><div class=\"line\"></div><div class=\"line\">            time.sleep(2)</div><div class=\"line\"></div><div class=\"line\">            mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">            db = mc.package</div><div class=\"line\">            post_info = db.index</div><div class=\"line\"></div><div class=\"line\">            post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:20,&apos;time&apos;:0,&apos;lastcount&apos;:indexcount&#125;)</div><div class=\"line\"></div><div class=\"line\">        if os.path.exists(path):</div><div class=\"line\">            f1 = open(path,&apos;r&apos;)</div><div class=\"line\">            lists = f1.readlines()</div><div class=\"line\"></div><div class=\"line\">            if len(lists) == 2:</div><div class=\"line\">               dir = lists[0]</div><div class=\"line\">               branch = lists[1]</div><div class=\"line\">               </div><div class=\"line\">               if &apos;JDJRAPPAndroid&apos; in dir:</div><div class=\"line\">                  dir = &apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos;</div><div class=\"line\"></div><div class=\"line\">               if &apos;JDMobileNew&apos; in dir:</div><div class=\"line\">                  dir = &apos;/Users/wxg/Documents/JDMobileNew&apos;</div><div class=\"line\"></div><div class=\"line\">               if len(dir) &gt; 0:</div><div class=\"line\">                   print dir</div><div class=\"line\">              </div><div class=\"line\">                   os.chdir(dir)         </div><div class=\"line\">                   (status, output) = commands.getstatusoutput(&apos;git pull origin %s&apos; % branch)</div><div class=\"line\">                   f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;)</div><div class=\"line\">                   text = f1.read()</div><div class=\"line\">                   f1.close()</div><div class=\"line\"></div><div class=\"line\">                   f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;)</div><div class=\"line\">                   text1 = text + &apos;\\n&apos; + output + &apos;%i&apos; % status</div><div class=\"line\">                   f1.write(text1)</div><div class=\"line\">                   f1.close()</div><div class=\"line\"></div><div class=\"line\">                   f2 = open(path,&apos;w&apos;)</div><div class=\"line\">                   f2.write(&apos;&apos;)</div><div class=\"line\">                   f2.close()</div><div class=\"line\"></div><div class=\"line\">            f1.close()</div><div class=\"line\"></div><div class=\"line\">def monitorForBlog(name,pipe):</div><div class=\"line\">    lastTimeStr = &apos;&apos;</div><div class=\"line\">    while True:</div><div class=\"line\">      time.sleep(3)</div><div class=\"line\">      os.chdir(&apos;/Users/jdjr/Documents/Blog/blogsource&apos;)</div><div class=\"line\">      </div><div class=\"line\">#      os.chdir(&apos;/usr/local/var/www&apos;)</div><div class=\"line\"></div><div class=\"line\">      (status, output) = commands.getstatusoutput(&apos;git pull origin blog&apos;)</div><div class=\"line\"></div><div class=\"line\">      (status, output) = commands.getstatusoutput(&apos;git log&apos;)</div><div class=\"line\"></div><div class=\"line\">      f = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;w&apos;)</div><div class=\"line\">      f.write(output)</div><div class=\"line\">      f.close()</div><div class=\"line\"></div><div class=\"line\">      f1 = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;r&apos;)</div><div class=\"line\">      lines = f1.readlines()</div><div class=\"line\">      firstline = lines[0]</div><div class=\"line\">      f1.close()</div><div class=\"line\"></div><div class=\"line\">      if lastTimeStr != firstline:</div><div class=\"line\">          print &apos;推送一次博客&apos;</div><div class=\"line\">          sourcepath = &apos;/Users/jdjr/Documents/Blog/blog/source&apos;</div><div class=\"line\">          </div><div class=\"line\">          if os.path.exists(sourcepath):</div><div class=\"line\">             shutil.rmtree(sourcepath)</div><div class=\"line\">          </div><div class=\"line\">          shutil.copytree(&apos;/Users/jdjr/Documents/Blog/blogsource/source&apos;,&apos;/Users/jdjr/Documents/Blog/blog/source&apos;)</div><div class=\"line\"></div><div class=\"line\">          os.chdir(&apos;/Users/jdjr/Documents/Blog/blog&apos;)</div><div class=\"line\"></div><div class=\"line\">#          os.popen(&apos;hexo clean&apos;)</div><div class=\"line\">          os.system(&apos;hexo clean&apos;)</div><div class=\"line\">          os.system(&apos;hexo g&apos;)</div><div class=\"line\">          </div><div class=\"line\">          filepath = &apos;/usr/local/var/www&apos;</div><div class=\"line\">          if os.path.exists(filepath):</div><div class=\"line\">             shutil.rmtree(filepath)</div><div class=\"line\"></div><div class=\"line\">          publicfile = &apos;/Users/jdjr/Documents/Blog/blog/public&apos;</div><div class=\"line\">          while not os.path.exists(publicfile):</div><div class=\"line\">                time.sleep(1)</div><div class=\"line\">#                print &apos;not exist&apos;</div><div class=\"line\"></div><div class=\"line\">          shutil.move(publicfile,filepath)</div><div class=\"line\">          </div><div class=\"line\">          lastTimeStr = firstline</div><div class=\"line\">          print lastTimeStr</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print &apos;main pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid())</div><div class=\"line\">    </div><div class=\"line\">    # 注意： 此处是Pipe来自multiprocessing.Pipe(), 其来源于 multiprocessing.connection import Pipe</div><div class=\"line\">    pipe_parent, pipe_child = multiprocessing.Pipe(duplex=False)</div><div class=\"line\">    </div><div class=\"line\">    processList = []</div><div class=\"line\">#    for i in xrange(4):</div><div class=\"line\">#    pro = multiprocessing.Process(target=func, args=(&apos;ceshi&apos;, &apos;Process-&apos; + str(10), pipe_child))</div><div class=\"line\">#    pro.start()</div><div class=\"line\">#    processList.append(pro)</div><div class=\"line\">#    </div><div class=\"line\">#    pro1 = multiprocessing.Process(target=func1, args=(&apos;waha&apos;,pipe_child))</div><div class=\"line\">#    pro1.start()</div><div class=\"line\">#    processList.append(pro1)</div><div class=\"line\">#    </div><div class=\"line\">#    pro2 = multiprocessing.Process(target=func2, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">#    pro2.start()</div><div class=\"line\">#    processList.append(pro2)</div><div class=\"line\"></div><div class=\"line\">    pro3 = multiprocessing.Process(target=serverForPull, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">    pro3.start()</div><div class=\"line\">    processList.append(pro3)</div><div class=\"line\"></div><div class=\"line\">    pro4 = multiprocessing.Process(target=monitorForBlog, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">    pro4.start()</div><div class=\"line\">    processList.append(pro4)</div><div class=\"line\">    </div><div class=\"line\">    for pro in processList:</div><div class=\"line\">        pro.join()      # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程</div><div class=\"line\">    </div><div class=\"line\">    pipe_child.send(None)   # 此处等全部子进程执行完成后，输入&apos;None&apos;标记，表示Pipe结束接收任务，可以退出</div><div class=\"line\"></div><div class=\"line\">    while pipe_parent:</div><div class=\"line\">          p_info = pipe_parent.recv()</div><div class=\"line\">          print &apos;pipe get: &apos;, p_info</div><div class=\"line\">        </div><div class=\"line\">          if not p_info:      # 如果接收到了&apos;None&apos;标记，退出Pipe</div><div class=\"line\">             print &apos;pipe get:  None, then exit out.&apos;</div><div class=\"line\">             break</div><div class=\"line\"></div><div class=\"line\"># 测试</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">    print(&apos;end.&apos;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"python多进程通信\"><a href=\"#python多进程通信\" class=\"headerlink\" title=\"python多进程通信\"></a>python多进程通信</h2><blockquote>\n<p>这里解决的主要是，如果是启动一个命令行，然后执行一个python脚本，如果有多个python脚本就需要多个命令行程序，这不是很明智的选择，最好的做法是，一个命令行搞定所有的python脚本，这里就涉及到两个问题</p>\n<ul>\n<li>如何做到并发</li>\n<li>如何在一个文件中添加一个python的执行入口","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div></pre></td><td class=\"code\"><pre><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">import os,re,time</div><div class=\"line\">import multiprocessing,commands,shutil,subprocess</div><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">lock = multiprocessing.Lock()</div><div class=\"line\"></div><div class=\"line\">def func(name, processName, pipe):</div><div class=\"line\">    p_info = &apos;Process[%s]  hello %s&apos; % (processName, name)</div><div class=\"line\">    print &apos;pipe send: &apos;, p_info</div><div class=\"line\">    pipe.send(p_info)</div><div class=\"line\">    </div><div class=\"line\">    print &apos;sub pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid())</div><div class=\"line\">    time.sleep(0.1)</div><div class=\"line\"></div><div class=\"line\">def serverForPull(name,pipe):</div><div class=\"line\"></div><div class=\"line\">    path = &apos;/Users/jdjr/Desktop/branches.txt&apos;</div><div class=\"line\"></div><div class=\"line\">    while True:</div><div class=\"line\">        time.sleep(3)</div><div class=\"line\">        newpath = &apos;/Users/jdjr/Desktop/gradleDir&apos;</div><div class=\"line\">        if os.path.exists(newpath) == True:</div><div class=\"line\">            os.chdir(&apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos;)</div><div class=\"line\"></div><div class=\"line\">            currentbranch = &apos;&apos;</div><div class=\"line\"></div><div class=\"line\">            branch = os.popen(&apos;git branch&apos;).read()</div><div class=\"line\"></div><div class=\"line\">            lines = branch.split(&apos;\\n&apos;)</div><div class=\"line\">            for item in lines:</div><div class=\"line\">                if &apos;*&apos; in item:</div><div class=\"line\">                   currentbranch = item[2:]</div><div class=\"line\"></div><div class=\"line\">            p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE)</div><div class=\"line\"></div><div class=\"line\">            indexcount = 0</div><div class=\"line\"></div><div class=\"line\">            returncode = p.poll()</div><div class=\"line\"></div><div class=\"line\">            while returncode is None:</div><div class=\"line\">                  text = p.stdout.readline().strip()</div><div class=\"line\">                  f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;)</div><div class=\"line\">                  f.write(text)</div><div class=\"line\">                  f.close()</div><div class=\"line\">        </div><div class=\"line\">                  mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">                  db = mc.package</div><div class=\"line\">                  post_info = db.index</div><div class=\"line\"></div><div class=\"line\">                  dbs = post_info.find(&#123;&apos;branchname&apos;:currentbranch&#125;)</div><div class=\"line\">                  count = 0</div><div class=\"line\">                  itemc = &#123;&#125;</div><div class=\"line\">                  for itemn in dbs:</div><div class=\"line\">                      itemc = itemn</div><div class=\"line\">                      count = count + 1</div><div class=\"line\"></div><div class=\"line\">                  if count == 0:</div><div class=\"line\">                     post_info.save(&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:0,&apos;lastcount&apos;:0&#125;)</div><div class=\"line\">                  else:</div><div class=\"line\">                     ctime = itemc[&apos;time&apos;]</div><div class=\"line\">                     lastcount = itemc[&apos;lastcount&apos;]</div><div class=\"line\">                     </div><div class=\"line\">                     if &apos;Total time:&apos; in text:</div><div class=\"line\">                         indexnew = text.find(&apos;:&apos;)</div><div class=\"line\">                         newtime = text[indexnew + 1:]</div><div class=\"line\"></div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:newtime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\">                     else:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">                     if &apos;BUILD SUCCESSFUL&apos; in text:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:0,&apos;time&apos;:ctime,&apos;lastcount&apos;:indexcount&#125;)</div><div class=\"line\">                     else:</div><div class=\"line\">                         post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:indexcount,&apos;time&apos;:ctime,&apos;lastcount&apos;:lastcount&#125;)</div><div class=\"line\"></div><div class=\"line\">                  indexcount = indexcount + 1</div><div class=\"line\">        </div><div class=\"line\">                  returncode = p.poll()</div><div class=\"line\">        </div><div class=\"line\">            f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;)</div><div class=\"line\">            texts = f1.read()</div><div class=\"line\">            f1.close()</div><div class=\"line\">            if &apos;BUILD FAILED&apos; in texts:</div><div class=\"line\">                (status, output) = commands.getstatusoutput(&apos;gradle assembleDebug&apos;)</div><div class=\"line\">                f2 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;)</div><div class=\"line\">                texts = f2.write(output)</div><div class=\"line\">                f2.close()</div><div class=\"line\"></div><div class=\"line\">            shutil.rmtree(newpath)</div><div class=\"line\"></div><div class=\"line\">            time.sleep(2)</div><div class=\"line\"></div><div class=\"line\">            mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">            db = mc.package</div><div class=\"line\">            post_info = db.index</div><div class=\"line\"></div><div class=\"line\">            post_info.update(&#123;&apos;branchname&apos;:currentbranch&#125;,&#123;&apos;branchname&apos;:currentbranch,&apos;count&apos;:20,&apos;time&apos;:0,&apos;lastcount&apos;:indexcount&#125;)</div><div class=\"line\"></div><div class=\"line\">        if os.path.exists(path):</div><div class=\"line\">            f1 = open(path,&apos;r&apos;)</div><div class=\"line\">            lists = f1.readlines()</div><div class=\"line\"></div><div class=\"line\">            if len(lists) == 2:</div><div class=\"line\">               dir = lists[0]</div><div class=\"line\">               branch = lists[1]</div><div class=\"line\">               </div><div class=\"line\">               if &apos;JDJRAPPAndroid&apos; in dir:</div><div class=\"line\">                  dir = &apos;/Users/jdjr/Documents/Build/JDJRAPPAndroid&apos;</div><div class=\"line\"></div><div class=\"line\">               if &apos;JDMobileNew&apos; in dir:</div><div class=\"line\">                  dir = &apos;/Users/wxg/Documents/JDMobileNew&apos;</div><div class=\"line\"></div><div class=\"line\">               if len(dir) &gt; 0:</div><div class=\"line\">                   print dir</div><div class=\"line\">              </div><div class=\"line\">                   os.chdir(dir)         </div><div class=\"line\">                   (status, output) = commands.getstatusoutput(&apos;git pull origin %s&apos; % branch)</div><div class=\"line\">                   f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;r&apos;)</div><div class=\"line\">                   text = f1.read()</div><div class=\"line\">                   f1.close()</div><div class=\"line\"></div><div class=\"line\">                   f1 = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;w&apos;)</div><div class=\"line\">                   text1 = text + &apos;\\n&apos; + output + &apos;%i&apos; % status</div><div class=\"line\">                   f1.write(text1)</div><div class=\"line\">                   f1.close()</div><div class=\"line\"></div><div class=\"line\">                   f2 = open(path,&apos;w&apos;)</div><div class=\"line\">                   f2.write(&apos;&apos;)</div><div class=\"line\">                   f2.close()</div><div class=\"line\"></div><div class=\"line\">            f1.close()</div><div class=\"line\"></div><div class=\"line\">def monitorForBlog(name,pipe):</div><div class=\"line\">    lastTimeStr = &apos;&apos;</div><div class=\"line\">    while True:</div><div class=\"line\">      time.sleep(3)</div><div class=\"line\">      os.chdir(&apos;/Users/jdjr/Documents/Blog/blogsource&apos;)</div><div class=\"line\">      </div><div class=\"line\">#      os.chdir(&apos;/usr/local/var/www&apos;)</div><div class=\"line\"></div><div class=\"line\">      (status, output) = commands.getstatusoutput(&apos;git pull origin blog&apos;)</div><div class=\"line\"></div><div class=\"line\">      (status, output) = commands.getstatusoutput(&apos;git log&apos;)</div><div class=\"line\"></div><div class=\"line\">      f = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;w&apos;)</div><div class=\"line\">      f.write(output)</div><div class=\"line\">      f.close()</div><div class=\"line\"></div><div class=\"line\">      f1 = open(&apos;/Users/jdjr/Documents/Blog/logcommit.txt&apos;,&apos;r&apos;)</div><div class=\"line\">      lines = f1.readlines()</div><div class=\"line\">      firstline = lines[0]</div><div class=\"line\">      f1.close()</div><div class=\"line\"></div><div class=\"line\">      if lastTimeStr != firstline:</div><div class=\"line\">          print &apos;推送一次博客&apos;</div><div class=\"line\">          sourcepath = &apos;/Users/jdjr/Documents/Blog/blog/source&apos;</div><div class=\"line\">          </div><div class=\"line\">          if os.path.exists(sourcepath):</div><div class=\"line\">             shutil.rmtree(sourcepath)</div><div class=\"line\">          </div><div class=\"line\">          shutil.copytree(&apos;/Users/jdjr/Documents/Blog/blogsource/source&apos;,&apos;/Users/jdjr/Documents/Blog/blog/source&apos;)</div><div class=\"line\"></div><div class=\"line\">          os.chdir(&apos;/Users/jdjr/Documents/Blog/blog&apos;)</div><div class=\"line\"></div><div class=\"line\">#          os.popen(&apos;hexo clean&apos;)</div><div class=\"line\">          os.system(&apos;hexo clean&apos;)</div><div class=\"line\">          os.system(&apos;hexo g&apos;)</div><div class=\"line\">          </div><div class=\"line\">          filepath = &apos;/usr/local/var/www&apos;</div><div class=\"line\">          if os.path.exists(filepath):</div><div class=\"line\">             shutil.rmtree(filepath)</div><div class=\"line\"></div><div class=\"line\">          publicfile = &apos;/Users/jdjr/Documents/Blog/blog/public&apos;</div><div class=\"line\">          while not os.path.exists(publicfile):</div><div class=\"line\">                time.sleep(1)</div><div class=\"line\">#                print &apos;not exist&apos;</div><div class=\"line\"></div><div class=\"line\">          shutil.move(publicfile,filepath)</div><div class=\"line\">          </div><div class=\"line\">          lastTimeStr = firstline</div><div class=\"line\">          print lastTimeStr</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    print &apos;main pid: %d, ppid: %d&apos; % (os.getpid(), os.getppid())</div><div class=\"line\">    </div><div class=\"line\">    # 注意： 此处是Pipe来自multiprocessing.Pipe(), 其来源于 multiprocessing.connection import Pipe</div><div class=\"line\">    pipe_parent, pipe_child = multiprocessing.Pipe(duplex=False)</div><div class=\"line\">    </div><div class=\"line\">    processList = []</div><div class=\"line\">#    for i in xrange(4):</div><div class=\"line\">#    pro = multiprocessing.Process(target=func, args=(&apos;ceshi&apos;, &apos;Process-&apos; + str(10), pipe_child))</div><div class=\"line\">#    pro.start()</div><div class=\"line\">#    processList.append(pro)</div><div class=\"line\">#    </div><div class=\"line\">#    pro1 = multiprocessing.Process(target=func1, args=(&apos;waha&apos;,pipe_child))</div><div class=\"line\">#    pro1.start()</div><div class=\"line\">#    processList.append(pro1)</div><div class=\"line\">#    </div><div class=\"line\">#    pro2 = multiprocessing.Process(target=func2, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">#    pro2.start()</div><div class=\"line\">#    processList.append(pro2)</div><div class=\"line\"></div><div class=\"line\">    pro3 = multiprocessing.Process(target=serverForPull, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">    pro3.start()</div><div class=\"line\">    processList.append(pro3)</div><div class=\"line\"></div><div class=\"line\">    pro4 = multiprocessing.Process(target=monitorForBlog, args=(&apos;heihei&apos;,pipe_child))</div><div class=\"line\">    pro4.start()</div><div class=\"line\">    processList.append(pro4)</div><div class=\"line\">    </div><div class=\"line\">    for pro in processList:</div><div class=\"line\">        pro.join()      # 在此处阻塞子进程，可实现异步执行效果，直至子进程全部完成后再继续执行父进程</div><div class=\"line\">    </div><div class=\"line\">    pipe_child.send(None)   # 此处等全部子进程执行完成后，输入&apos;None&apos;标记，表示Pipe结束接收任务，可以退出</div><div class=\"line\"></div><div class=\"line\">    while pipe_parent:</div><div class=\"line\">          p_info = pipe_parent.recv()</div><div class=\"line\">          print &apos;pipe get: &apos;, p_info</div><div class=\"line\">        </div><div class=\"line\">          if not p_info:      # 如果接收到了&apos;None&apos;标记，退出Pipe</div><div class=\"line\">             print &apos;pipe get:  None, then exit out.&apos;</div><div class=\"line\">             break</div><div class=\"line\"></div><div class=\"line\"># 测试</div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div><div class=\"line\">    print(&apos;end.&apos;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>"},{"title":"clang插件开发","date":"2017-09-05T02:41:44.000Z","_content":"\n## 资源准备&&编译源文件\n我们需要llvm和clang的源文件，而且这些文件都存在于github上，我们如果直接从github下载会很慢，所以第一步是制作国内源。\n\n<!--more-->\n\n- 制作国内源`http://jingyan.baidu.com/article/f79b7cb367e72e9145023e40.html`\n\n还有就是不要把这些源文件放到一些需要权限执行的文件里，这样在编译过程中你会发现各种问题。\n\n- 下载源码的时候注意点就是要对照你的xcode的版本:`https://trac.macports.org/wiki/XcodeVersionInfo`\n- 然后找到对应的clang版本`https://opensource.apple.com/source/clang/clang-800.0.42.1/src/configure.auto.html`\n\n经过对比我们发现我们需要的是39版本\n\n比如现在我们在一个叫做GitHub的文件夹下遍建立了一个叫做llvm的文件\n按照顺序执行以后代码：\n\n```\ncd GitHub\nsudo mkdir llvm\nsudo chown `whoami` llvm\ncd llvm\nexport LLVM_HOME=`pwd`\n\ngit clone -b release_39 https://git.coding.net/hanshenghui/llvm.git llvm\ngit clone -b release_39 https://git.coding.net/hanshenghui/clangnew.git llvm/tools/clang\ngit clone -b release_39 https://git.coding.net/hanshenghui/clang-tools-extra.git llvm/tools/clang/tools/extra\ngit clone -b release_39 https://git.coding.net/hanshenghui/compiler-rt.git llvm/projects/compiler-rt\n\nmkdir llvm_build\ncd llvm_build\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n\n```\n最后一句`cmake -G Xcode`是关键，用这种方式cmake的话，我们就可以用Xcode来编译后边的工程\n执行完毕之后你会发现，在llvm_build这个文件夹下边你会发现有一个LLVM.xcodeproj的文件，有了这个我们可以像iOS开发样去编译任何一个库了\n\n## 编写插件代码\n- 进入文件`/llvm/tools/clang/examples`在里面新建一个目录如MyPlugin\n- 然后修改example目录的CMakeLists.txt文件，添加一项：\n```\nadd_subdirectory(MyPlugin)\n```\n- 然后进入创建的MyPlugin目录，生成三个文件，分别是：\n```\nCodingStyleUtil.hpp\nMyPlugin.cpp\nCMakeLists.txt\n```\n\nCMakeLists.txt中的内容：\n```\nadd_llvm_loadable_module(MyPlugin MyPlugin.cpp PLUGIN_TOOL clang)\n\nif(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))\n  target_link_libraries(MyPlugin ${cmake_2_8_12_PRIVATE}\n    clangAST\n    clangBasic\n    clangFrontend\n    LLVMSupport\n    )\nendif()\n```\nCodingStyleUtil.hpp\n主要是一些处理字符串的函数\n\nMyPlugin.cpp\n这个文件是关键所在，当我们编译插件的时候，主要就是这里的代码在起作用，先来个简化版的\n\n```\n\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"CodingStyleUtil.hpp\"\n#include <fstream>\n\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\n\nstring gSrcRootPath;\nstatic string kClassInterfPrefix = \"JR\";\nstatic int kMethodParamMaxLen = 15;\n//static int kMethodParamMaxParamsSingleLine = 3;\nstatic int kMethodBodyMaxLines = 500;\n\nnamespace MyPlugin\n {\n\nclass MyPluginVisitor : public RecursiveASTVisitor<MyPluginVisitor>//这里我们要声明一个class，这个class是继承自RecursiveASTVisitor的，可以随便取名字，尖括号里边就是这个visitor的名字\n    {\n    private:\n        CompilerInstance &Instance;\n        ASTContext *Context;\n        string objcClsImpl;\n        bool objcIsInstanceMethod;\n        string objcSelector;\n        string objcMethodSrcCode;\n        \n    public:\n        \n        void setASTContext (ASTContext &context)//这里定义了一个能方法，用来便捷的对context进行赋值操作\n        {\n            this -> Context = &context;\n        }\n        \n        MyPluginVisitor (CompilerInstance &Instance)\n        :Instance(Instance)\n        {\n            \n        }\n        \n        bool VisitDecl(Decl *decl) {//所有的声明分析都需要重载这个方法\n        }\n        \n    };\n\n    class MyPluginConsumer : public ASTConsumer\n    {\n        CompilerInstance &Instance;\n        std::set<std::string> ParsedTemplates;\n    public:\n        MyPluginConsumer(CompilerInstance &Instance,\n                         std::set<std::string> ParsedTemplates)\n        : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) {}\n        \n        bool HandleTopLevelDecl(DeclGroupRef DG) override\n        {\n            return true;\n        }\n        \n        void HandleTranslationUnit(ASTContext& context) override\n        {\n            visitor.setASTContext(context);\n            visitor.TraverseDecl(context.getTranslationUnitDecl());\n        }\n    private:\n        MyPluginVisitor visitor;\n    };\n    //这里是所有处理逻辑的入口，在这里调用了consumer\n    class MyPluginASTAction : public PluginASTAction\n    {\n        std::set<std::string> ParsedTemplates;\n    protected:\n        std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                       llvm::StringRef) override\n        {\n            return llvm::make_unique<MyPluginConsumer>(CI, ParsedTemplates);\n        }\n        \n        bool ParseArgs(const CompilerInstance &CI,\n                       const std::vector<std::string> &args) override {\n            return true;\n        }\n    };\n\n```\n现在先回到源码根目录，使用同样的cmake语句来更新Xcode项目，更新完成后原来的项目会多出一个叫MyPlugin的插件项目，然后对这个插件项目进行编译。编译成功后会在Debug/lib目录中多出一个名字叫做MyPlugin.dylib文件\n\n只有这个plugin文件是不够的，我们还需要一个对应的clang和clang++，那么这个文件是哪里来的呢，答案就是我们自己编译的，这个插件和clang版本必须是对应的，否则在运行工程的时候就会说symbol不存在等错误\n\n## 安装调试插件\n打开要使用插件的Xcode项目，在build settings一栏中对Other C Flags一项进行编辑，调整为：\n```\n-Xclang -load -Xclang /Users/han/GitHub/llvm/llvm_build/Debug/lib/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin\n```\n>注：最后一项-Xclang MyPlugin中的MyPlugin为插件名字，一定要是自己设置的插件名称，否则无法调用插件\n\n这个时候运行你会发现报错，error:unable to load plugin\n\n为了解决这个问题需要调整Xcode中使用的Clang编译器，将默认的编译器改为我们自己编译出来的编译器。具体的方法是在build settings中再添加两项自定义项：\n```\nCC = /Users/han/GitHub/llvm/llvm_build/Debug/bin/clang\nCXX = \"/Users/han/GitHub/llvm/llvm_build/Debug/bin/clang+\n```\n\n## clang插件作用范围\n","source":"_posts/clang插件开发.md","raw":"---\ntitle: clang插件开发\ndate: 2017-09-05 10:41:44\ntags:\n- clang插件\n---\n\n## 资源准备&&编译源文件\n我们需要llvm和clang的源文件，而且这些文件都存在于github上，我们如果直接从github下载会很慢，所以第一步是制作国内源。\n\n<!--more-->\n\n- 制作国内源`http://jingyan.baidu.com/article/f79b7cb367e72e9145023e40.html`\n\n还有就是不要把这些源文件放到一些需要权限执行的文件里，这样在编译过程中你会发现各种问题。\n\n- 下载源码的时候注意点就是要对照你的xcode的版本:`https://trac.macports.org/wiki/XcodeVersionInfo`\n- 然后找到对应的clang版本`https://opensource.apple.com/source/clang/clang-800.0.42.1/src/configure.auto.html`\n\n经过对比我们发现我们需要的是39版本\n\n比如现在我们在一个叫做GitHub的文件夹下遍建立了一个叫做llvm的文件\n按照顺序执行以后代码：\n\n```\ncd GitHub\nsudo mkdir llvm\nsudo chown `whoami` llvm\ncd llvm\nexport LLVM_HOME=`pwd`\n\ngit clone -b release_39 https://git.coding.net/hanshenghui/llvm.git llvm\ngit clone -b release_39 https://git.coding.net/hanshenghui/clangnew.git llvm/tools/clang\ngit clone -b release_39 https://git.coding.net/hanshenghui/clang-tools-extra.git llvm/tools/clang/tools/extra\ngit clone -b release_39 https://git.coding.net/hanshenghui/compiler-rt.git llvm/projects/compiler-rt\n\nmkdir llvm_build\ncd llvm_build\ncmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel\n\n```\n最后一句`cmake -G Xcode`是关键，用这种方式cmake的话，我们就可以用Xcode来编译后边的工程\n执行完毕之后你会发现，在llvm_build这个文件夹下边你会发现有一个LLVM.xcodeproj的文件，有了这个我们可以像iOS开发样去编译任何一个库了\n\n## 编写插件代码\n- 进入文件`/llvm/tools/clang/examples`在里面新建一个目录如MyPlugin\n- 然后修改example目录的CMakeLists.txt文件，添加一项：\n```\nadd_subdirectory(MyPlugin)\n```\n- 然后进入创建的MyPlugin目录，生成三个文件，分别是：\n```\nCodingStyleUtil.hpp\nMyPlugin.cpp\nCMakeLists.txt\n```\n\nCMakeLists.txt中的内容：\n```\nadd_llvm_loadable_module(MyPlugin MyPlugin.cpp PLUGIN_TOOL clang)\n\nif(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))\n  target_link_libraries(MyPlugin ${cmake_2_8_12_PRIVATE}\n    clangAST\n    clangBasic\n    clangFrontend\n    LLVMSupport\n    )\nendif()\n```\nCodingStyleUtil.hpp\n主要是一些处理字符串的函数\n\nMyPlugin.cpp\n这个文件是关键所在，当我们编译插件的时候，主要就是这里的代码在起作用，先来个简化版的\n\n```\n\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/AST/RecursiveASTVisitor.h\"\n#include \"CodingStyleUtil.hpp\"\n#include <fstream>\n\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\n\nstring gSrcRootPath;\nstatic string kClassInterfPrefix = \"JR\";\nstatic int kMethodParamMaxLen = 15;\n//static int kMethodParamMaxParamsSingleLine = 3;\nstatic int kMethodBodyMaxLines = 500;\n\nnamespace MyPlugin\n {\n\nclass MyPluginVisitor : public RecursiveASTVisitor<MyPluginVisitor>//这里我们要声明一个class，这个class是继承自RecursiveASTVisitor的，可以随便取名字，尖括号里边就是这个visitor的名字\n    {\n    private:\n        CompilerInstance &Instance;\n        ASTContext *Context;\n        string objcClsImpl;\n        bool objcIsInstanceMethod;\n        string objcSelector;\n        string objcMethodSrcCode;\n        \n    public:\n        \n        void setASTContext (ASTContext &context)//这里定义了一个能方法，用来便捷的对context进行赋值操作\n        {\n            this -> Context = &context;\n        }\n        \n        MyPluginVisitor (CompilerInstance &Instance)\n        :Instance(Instance)\n        {\n            \n        }\n        \n        bool VisitDecl(Decl *decl) {//所有的声明分析都需要重载这个方法\n        }\n        \n    };\n\n    class MyPluginConsumer : public ASTConsumer\n    {\n        CompilerInstance &Instance;\n        std::set<std::string> ParsedTemplates;\n    public:\n        MyPluginConsumer(CompilerInstance &Instance,\n                         std::set<std::string> ParsedTemplates)\n        : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) {}\n        \n        bool HandleTopLevelDecl(DeclGroupRef DG) override\n        {\n            return true;\n        }\n        \n        void HandleTranslationUnit(ASTContext& context) override\n        {\n            visitor.setASTContext(context);\n            visitor.TraverseDecl(context.getTranslationUnitDecl());\n        }\n    private:\n        MyPluginVisitor visitor;\n    };\n    //这里是所有处理逻辑的入口，在这里调用了consumer\n    class MyPluginASTAction : public PluginASTAction\n    {\n        std::set<std::string> ParsedTemplates;\n    protected:\n        std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,\n                                                       llvm::StringRef) override\n        {\n            return llvm::make_unique<MyPluginConsumer>(CI, ParsedTemplates);\n        }\n        \n        bool ParseArgs(const CompilerInstance &CI,\n                       const std::vector<std::string> &args) override {\n            return true;\n        }\n    };\n\n```\n现在先回到源码根目录，使用同样的cmake语句来更新Xcode项目，更新完成后原来的项目会多出一个叫MyPlugin的插件项目，然后对这个插件项目进行编译。编译成功后会在Debug/lib目录中多出一个名字叫做MyPlugin.dylib文件\n\n只有这个plugin文件是不够的，我们还需要一个对应的clang和clang++，那么这个文件是哪里来的呢，答案就是我们自己编译的，这个插件和clang版本必须是对应的，否则在运行工程的时候就会说symbol不存在等错误\n\n## 安装调试插件\n打开要使用插件的Xcode项目，在build settings一栏中对Other C Flags一项进行编辑，调整为：\n```\n-Xclang -load -Xclang /Users/han/GitHub/llvm/llvm_build/Debug/lib/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin\n```\n>注：最后一项-Xclang MyPlugin中的MyPlugin为插件名字，一定要是自己设置的插件名称，否则无法调用插件\n\n这个时候运行你会发现报错，error:unable to load plugin\n\n为了解决这个问题需要调整Xcode中使用的Clang编译器，将默认的编译器改为我们自己编译出来的编译器。具体的方法是在build settings中再添加两项自定义项：\n```\nCC = /Users/han/GitHub/llvm/llvm_build/Debug/bin/clang\nCXX = \"/Users/han/GitHub/llvm/llvm_build/Debug/bin/clang+\n```\n\n## clang插件作用范围\n","slug":"clang插件开发","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkb0007sauaomac232t","content":"<h2 id=\"资源准备-amp-amp-编译源文件\"><a href=\"#资源准备-amp-amp-编译源文件\" class=\"headerlink\" title=\"资源准备&amp;&amp;编译源文件\"></a>资源准备&amp;&amp;编译源文件</h2><p>我们需要llvm和clang的源文件，而且这些文件都存在于github上，我们如果直接从github下载会很慢，所以第一步是制作国内源。</p>\n<a id=\"more\"></a>\n<ul>\n<li>制作国内源<code>http://jingyan.baidu.com/article/f79b7cb367e72e9145023e40.html</code></li>\n</ul>\n<p>还有就是不要把这些源文件放到一些需要权限执行的文件里，这样在编译过程中你会发现各种问题。</p>\n<ul>\n<li>下载源码的时候注意点就是要对照你的xcode的版本:<code>https://trac.macports.org/wiki/XcodeVersionInfo</code></li>\n<li>然后找到对应的clang版本<code>https://opensource.apple.com/source/clang/clang-800.0.42.1/src/configure.auto.html</code></li>\n</ul>\n<p>经过对比我们发现我们需要的是39版本</p>\n<p>比如现在我们在一个叫做GitHub的文件夹下遍建立了一个叫做llvm的文件<br>按照顺序执行以后代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd GitHub</div><div class=\"line\">sudo mkdir llvm</div><div class=\"line\">sudo chown `whoami` llvm</div><div class=\"line\">cd llvm</div><div class=\"line\">export LLVM_HOME=`pwd`</div><div class=\"line\"></div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/llvm.git llvm</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/clangnew.git llvm/tools/clang</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/clang-tools-extra.git llvm/tools/clang/tools/extra</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/compiler-rt.git llvm/projects/compiler-rt</div><div class=\"line\"></div><div class=\"line\">mkdir llvm_build</div><div class=\"line\">cd llvm_build</div><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</div></pre></td></tr></table></figure>\n<p>最后一句<code>cmake -G Xcode</code>是关键，用这种方式cmake的话，我们就可以用Xcode来编译后边的工程<br>执行完毕之后你会发现，在llvm_build这个文件夹下边你会发现有一个LLVM.xcodeproj的文件，有了这个我们可以像iOS开发样去编译任何一个库了</p>\n<h2 id=\"编写插件代码\"><a href=\"#编写插件代码\" class=\"headerlink\" title=\"编写插件代码\"></a>编写插件代码</h2><ul>\n<li>进入文件<code>/llvm/tools/clang/examples</code>在里面新建一个目录如MyPlugin</li>\n<li><p>然后修改example目录的CMakeLists.txt文件，添加一项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_subdirectory(MyPlugin)</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后进入创建的MyPlugin目录，生成三个文件，分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CodingStyleUtil.hpp</div><div class=\"line\">MyPlugin.cpp</div><div class=\"line\">CMakeLists.txt</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>CMakeLists.txt中的内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(MyPlugin MyPlugin.cpp PLUGIN_TOOL clang)</div><div class=\"line\"></div><div class=\"line\">if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))</div><div class=\"line\">  target_link_libraries(MyPlugin $&#123;cmake_2_8_12_PRIVATE&#125;</div><div class=\"line\">    clangAST</div><div class=\"line\">    clangBasic</div><div class=\"line\">    clangFrontend</div><div class=\"line\">    LLVMSupport</div><div class=\"line\">    )</div><div class=\"line\">endif()</div></pre></td></tr></table></figure></p>\n<p>CodingStyleUtil.hpp<br>主要是一些处理字符串的函数</p>\n<p>MyPlugin.cpp<br>这个文件是关键所在，当我们编译插件的时候，主要就是这里的代码在起作用，先来个简化版的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;</div><div class=\"line\">#include &quot;clang/AST/AST.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTConsumer.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/CompilerInstance.h&quot;</div><div class=\"line\">#include &quot;clang/AST/RecursiveASTVisitor.h&quot;</div><div class=\"line\">#include &quot;CodingStyleUtil.hpp&quot;</div><div class=\"line\">#include &lt;fstream&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace clang;</div><div class=\"line\">using namespace std;</div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">string gSrcRootPath;</div><div class=\"line\">static string kClassInterfPrefix = &quot;JR&quot;;</div><div class=\"line\">static int kMethodParamMaxLen = 15;</div><div class=\"line\">//static int kMethodParamMaxParamsSingleLine = 3;</div><div class=\"line\">static int kMethodBodyMaxLines = 500;</div><div class=\"line\"></div><div class=\"line\">namespace MyPlugin</div><div class=\"line\"> &#123;</div><div class=\"line\"></div><div class=\"line\">class MyPluginVisitor : public RecursiveASTVisitor&lt;MyPluginVisitor&gt;//这里我们要声明一个class，这个class是继承自RecursiveASTVisitor的，可以随便取名字，尖括号里边就是这个visitor的名字</div><div class=\"line\">    &#123;</div><div class=\"line\">    private:</div><div class=\"line\">        CompilerInstance &amp;Instance;</div><div class=\"line\">        ASTContext *Context;</div><div class=\"line\">        string objcClsImpl;</div><div class=\"line\">        bool objcIsInstanceMethod;</div><div class=\"line\">        string objcSelector;</div><div class=\"line\">        string objcMethodSrcCode;</div><div class=\"line\">        </div><div class=\"line\">    public:</div><div class=\"line\">        </div><div class=\"line\">        void setASTContext (ASTContext &amp;context)//这里定义了一个能方法，用来便捷的对context进行赋值操作</div><div class=\"line\">        &#123;</div><div class=\"line\">            this -&gt; Context = &amp;context;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        MyPluginVisitor (CompilerInstance &amp;Instance)</div><div class=\"line\">        :Instance(Instance)</div><div class=\"line\">        &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        bool VisitDecl(Decl *decl) &#123;//所有的声明分析都需要重载这个方法</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    class MyPluginConsumer : public ASTConsumer</div><div class=\"line\">    &#123;</div><div class=\"line\">        CompilerInstance &amp;Instance;</div><div class=\"line\">        std::set&lt;std::string&gt; ParsedTemplates;</div><div class=\"line\">    public:</div><div class=\"line\">        MyPluginConsumer(CompilerInstance &amp;Instance,</div><div class=\"line\">                         std::set&lt;std::string&gt; ParsedTemplates)</div><div class=\"line\">        : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) &#123;&#125;</div><div class=\"line\">        </div><div class=\"line\">        bool HandleTopLevelDecl(DeclGroupRef DG) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        void HandleTranslationUnit(ASTContext&amp; context) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            visitor.setASTContext(context);</div><div class=\"line\">            visitor.TraverseDecl(context.getTranslationUnitDecl());</div><div class=\"line\">        &#125;</div><div class=\"line\">    private:</div><div class=\"line\">        MyPluginVisitor visitor;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    //这里是所有处理逻辑的入口，在这里调用了consumer</div><div class=\"line\">    class MyPluginASTAction : public PluginASTAction</div><div class=\"line\">    &#123;</div><div class=\"line\">        std::set&lt;std::string&gt; ParsedTemplates;</div><div class=\"line\">    protected:</div><div class=\"line\">        std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI,</div><div class=\"line\">                                                       llvm::StringRef) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            return llvm::make_unique&lt;MyPluginConsumer&gt;(CI, ParsedTemplates);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        bool ParseArgs(const CompilerInstance &amp;CI,</div><div class=\"line\">                       const std::vector&lt;std::string&gt; &amp;args) override &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>现在先回到源码根目录，使用同样的cmake语句来更新Xcode项目，更新完成后原来的项目会多出一个叫MyPlugin的插件项目，然后对这个插件项目进行编译。编译成功后会在Debug/lib目录中多出一个名字叫做MyPlugin.dylib文件</p>\n<p>只有这个plugin文件是不够的，我们还需要一个对应的clang和clang++，那么这个文件是哪里来的呢，答案就是我们自己编译的，这个插件和clang版本必须是对应的，否则在运行工程的时候就会说symbol不存在等错误</p>\n<h2 id=\"安装调试插件\"><a href=\"#安装调试插件\" class=\"headerlink\" title=\"安装调试插件\"></a>安装调试插件</h2><p>打开要使用插件的Xcode项目，在build settings一栏中对Other C Flags一项进行编辑，调整为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xclang -load -Xclang /Users/han/GitHub/llvm/llvm_build/Debug/lib/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：最后一项-Xclang MyPlugin中的MyPlugin为插件名字，一定要是自己设置的插件名称，否则无法调用插件</p>\n</blockquote>\n<p>这个时候运行你会发现报错，error:unable to load plugin</p>\n<p>为了解决这个问题需要调整Xcode中使用的Clang编译器，将默认的编译器改为我们自己编译出来的编译器。具体的方法是在build settings中再添加两项自定义项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC = /Users/han/GitHub/llvm/llvm_build/Debug/bin/clang</div><div class=\"line\">CXX = &quot;/Users/han/GitHub/llvm/llvm_build/Debug/bin/clang+</div></pre></td></tr></table></figure></p>\n<h2 id=\"clang插件作用范围\"><a href=\"#clang插件作用范围\" class=\"headerlink\" title=\"clang插件作用范围\"></a>clang插件作用范围</h2>","site":{"data":{}},"excerpt":"<h2 id=\"资源准备-amp-amp-编译源文件\"><a href=\"#资源准备-amp-amp-编译源文件\" class=\"headerlink\" title=\"资源准备&amp;&amp;编译源文件\"></a>资源准备&amp;&amp;编译源文件</h2><p>我们需要llvm和clang的源文件，而且这些文件都存在于github上，我们如果直接从github下载会很慢，所以第一步是制作国内源。</p>","more":"<ul>\n<li>制作国内源<code>http://jingyan.baidu.com/article/f79b7cb367e72e9145023e40.html</code></li>\n</ul>\n<p>还有就是不要把这些源文件放到一些需要权限执行的文件里，这样在编译过程中你会发现各种问题。</p>\n<ul>\n<li>下载源码的时候注意点就是要对照你的xcode的版本:<code>https://trac.macports.org/wiki/XcodeVersionInfo</code></li>\n<li>然后找到对应的clang版本<code>https://opensource.apple.com/source/clang/clang-800.0.42.1/src/configure.auto.html</code></li>\n</ul>\n<p>经过对比我们发现我们需要的是39版本</p>\n<p>比如现在我们在一个叫做GitHub的文件夹下遍建立了一个叫做llvm的文件<br>按照顺序执行以后代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd GitHub</div><div class=\"line\">sudo mkdir llvm</div><div class=\"line\">sudo chown `whoami` llvm</div><div class=\"line\">cd llvm</div><div class=\"line\">export LLVM_HOME=`pwd`</div><div class=\"line\"></div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/llvm.git llvm</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/clangnew.git llvm/tools/clang</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/clang-tools-extra.git llvm/tools/clang/tools/extra</div><div class=\"line\">git clone -b release_39 https://git.coding.net/hanshenghui/compiler-rt.git llvm/projects/compiler-rt</div><div class=\"line\"></div><div class=\"line\">mkdir llvm_build</div><div class=\"line\">cd llvm_build</div><div class=\"line\">cmake -G Xcode ../llvm -DCMAKE_BUILD_TYPE:STRING=MinSizeRel</div></pre></td></tr></table></figure>\n<p>最后一句<code>cmake -G Xcode</code>是关键，用这种方式cmake的话，我们就可以用Xcode来编译后边的工程<br>执行完毕之后你会发现，在llvm_build这个文件夹下边你会发现有一个LLVM.xcodeproj的文件，有了这个我们可以像iOS开发样去编译任何一个库了</p>\n<h2 id=\"编写插件代码\"><a href=\"#编写插件代码\" class=\"headerlink\" title=\"编写插件代码\"></a>编写插件代码</h2><ul>\n<li>进入文件<code>/llvm/tools/clang/examples</code>在里面新建一个目录如MyPlugin</li>\n<li><p>然后修改example目录的CMakeLists.txt文件，添加一项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_subdirectory(MyPlugin)</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后进入创建的MyPlugin目录，生成三个文件，分别是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CodingStyleUtil.hpp</div><div class=\"line\">MyPlugin.cpp</div><div class=\"line\">CMakeLists.txt</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>CMakeLists.txt中的内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">add_llvm_loadable_module(MyPlugin MyPlugin.cpp PLUGIN_TOOL clang)</div><div class=\"line\"></div><div class=\"line\">if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))</div><div class=\"line\">  target_link_libraries(MyPlugin $&#123;cmake_2_8_12_PRIVATE&#125;</div><div class=\"line\">    clangAST</div><div class=\"line\">    clangBasic</div><div class=\"line\">    clangFrontend</div><div class=\"line\">    LLVMSupport</div><div class=\"line\">    )</div><div class=\"line\">endif()</div></pre></td></tr></table></figure></p>\n<p>CodingStyleUtil.hpp<br>主要是一些处理字符串的函数</p>\n<p>MyPlugin.cpp<br>这个文件是关键所在，当我们编译插件的时候，主要就是这里的代码在起作用，先来个简化版的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;</div><div class=\"line\">#include &quot;clang/AST/AST.h&quot;</div><div class=\"line\">#include &quot;clang/AST/ASTConsumer.h&quot;</div><div class=\"line\">#include &quot;clang/Frontend/CompilerInstance.h&quot;</div><div class=\"line\">#include &quot;clang/AST/RecursiveASTVisitor.h&quot;</div><div class=\"line\">#include &quot;CodingStyleUtil.hpp&quot;</div><div class=\"line\">#include &lt;fstream&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace clang;</div><div class=\"line\">using namespace std;</div><div class=\"line\">using namespace llvm;</div><div class=\"line\"></div><div class=\"line\">string gSrcRootPath;</div><div class=\"line\">static string kClassInterfPrefix = &quot;JR&quot;;</div><div class=\"line\">static int kMethodParamMaxLen = 15;</div><div class=\"line\">//static int kMethodParamMaxParamsSingleLine = 3;</div><div class=\"line\">static int kMethodBodyMaxLines = 500;</div><div class=\"line\"></div><div class=\"line\">namespace MyPlugin</div><div class=\"line\"> &#123;</div><div class=\"line\"></div><div class=\"line\">class MyPluginVisitor : public RecursiveASTVisitor&lt;MyPluginVisitor&gt;//这里我们要声明一个class，这个class是继承自RecursiveASTVisitor的，可以随便取名字，尖括号里边就是这个visitor的名字</div><div class=\"line\">    &#123;</div><div class=\"line\">    private:</div><div class=\"line\">        CompilerInstance &amp;Instance;</div><div class=\"line\">        ASTContext *Context;</div><div class=\"line\">        string objcClsImpl;</div><div class=\"line\">        bool objcIsInstanceMethod;</div><div class=\"line\">        string objcSelector;</div><div class=\"line\">        string objcMethodSrcCode;</div><div class=\"line\">        </div><div class=\"line\">    public:</div><div class=\"line\">        </div><div class=\"line\">        void setASTContext (ASTContext &amp;context)//这里定义了一个能方法，用来便捷的对context进行赋值操作</div><div class=\"line\">        &#123;</div><div class=\"line\">            this -&gt; Context = &amp;context;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        MyPluginVisitor (CompilerInstance &amp;Instance)</div><div class=\"line\">        :Instance(Instance)</div><div class=\"line\">        &#123;</div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        bool VisitDecl(Decl *decl) &#123;//所有的声明分析都需要重载这个方法</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    class MyPluginConsumer : public ASTConsumer</div><div class=\"line\">    &#123;</div><div class=\"line\">        CompilerInstance &amp;Instance;</div><div class=\"line\">        std::set&lt;std::string&gt; ParsedTemplates;</div><div class=\"line\">    public:</div><div class=\"line\">        MyPluginConsumer(CompilerInstance &amp;Instance,</div><div class=\"line\">                         std::set&lt;std::string&gt; ParsedTemplates)</div><div class=\"line\">        : Instance(Instance), ParsedTemplates(ParsedTemplates), visitor(Instance) &#123;&#125;</div><div class=\"line\">        </div><div class=\"line\">        bool HandleTopLevelDecl(DeclGroupRef DG) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        void HandleTranslationUnit(ASTContext&amp; context) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            visitor.setASTContext(context);</div><div class=\"line\">            visitor.TraverseDecl(context.getTranslationUnitDecl());</div><div class=\"line\">        &#125;</div><div class=\"line\">    private:</div><div class=\"line\">        MyPluginVisitor visitor;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    //这里是所有处理逻辑的入口，在这里调用了consumer</div><div class=\"line\">    class MyPluginASTAction : public PluginASTAction</div><div class=\"line\">    &#123;</div><div class=\"line\">        std::set&lt;std::string&gt; ParsedTemplates;</div><div class=\"line\">    protected:</div><div class=\"line\">        std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI,</div><div class=\"line\">                                                       llvm::StringRef) override</div><div class=\"line\">        &#123;</div><div class=\"line\">            return llvm::make_unique&lt;MyPluginConsumer&gt;(CI, ParsedTemplates);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        bool ParseArgs(const CompilerInstance &amp;CI,</div><div class=\"line\">                       const std::vector&lt;std::string&gt; &amp;args) override &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p>现在先回到源码根目录，使用同样的cmake语句来更新Xcode项目，更新完成后原来的项目会多出一个叫MyPlugin的插件项目，然后对这个插件项目进行编译。编译成功后会在Debug/lib目录中多出一个名字叫做MyPlugin.dylib文件</p>\n<p>只有这个plugin文件是不够的，我们还需要一个对应的clang和clang++，那么这个文件是哪里来的呢，答案就是我们自己编译的，这个插件和clang版本必须是对应的，否则在运行工程的时候就会说symbol不存在等错误</p>\n<h2 id=\"安装调试插件\"><a href=\"#安装调试插件\" class=\"headerlink\" title=\"安装调试插件\"></a>安装调试插件</h2><p>打开要使用插件的Xcode项目，在build settings一栏中对Other C Flags一项进行编辑，调整为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-Xclang -load -Xclang /Users/han/GitHub/llvm/llvm_build/Debug/lib/MyPlugin.dylib -Xclang -add-plugin -Xclang MyPlugin</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：最后一项-Xclang MyPlugin中的MyPlugin为插件名字，一定要是自己设置的插件名称，否则无法调用插件</p>\n</blockquote>\n<p>这个时候运行你会发现报错，error:unable to load plugin</p>\n<p>为了解决这个问题需要调整Xcode中使用的Clang编译器，将默认的编译器改为我们自己编译出来的编译器。具体的方法是在build settings中再添加两项自定义项：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CC = /Users/han/GitHub/llvm/llvm_build/Debug/bin/clang</div><div class=\"line\">CXX = &quot;/Users/han/GitHub/llvm/llvm_build/Debug/bin/clang+</div></pre></td></tr></table></figure></p>\n<h2 id=\"clang插件作用范围\"><a href=\"#clang插件作用范围\" class=\"headerlink\" title=\"clang插件作用范围\"></a>clang插件作用范围</h2>"},{"title":"find与grep命令","date":"2017-09-22T01:37:29.000Z","_content":"## 区别\n- find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 \n- grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。\n\n## find\n基本格式：find  path expression\n\n### 按照文件名查找\n- `find / -name httpd.conf` #在根目录下查找文件httpd.conf，表示在整个硬盘查找\n- `find /etc -name httpd.conf` #在/etc目录下文件httpd.conf\n- `find /etc -name '*srm*'` #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件\n- `find . -name 'srm*'` #表示当前目录下查找文件名开头是字符串‘srm’的文件\n\n### 按照文件特征查找 　　　　\n- `find / -amin -10` 　　# 查找在系统中最后10分钟访问的文件(access time)\n- `find / -atime -2`　　 # 查找在系统中最后48小时访问的文件\n- `find / -empty` 　　# 查找在系统中为空的文件或者文件夹\n- `find / -group cat` 　　# 查找在系统中属于 group为cat的文件\n- `find / -mmin -5` 　　# 查找在系统中最后5分钟里修改过的文件(modify time)\n- `find / -mtime -1` 　　#查找在系统中最后24小时里修改过的文件\n- `find / -user fred` 　　#查找在系统中属于fred这个用户的文件\n- `find / -size +10000c`　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)\n- `find / -size -1000k` 　　#查找出小于1000KB的文件\n\n### 使用混合查找方式查找文件\n参数有： ！，-and(-a)，-or(-o)。\n- `find /tmp -size +10000c -and -mtime +2` #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件\n- `find / -user fred -or -user george` 　#在/目录下查找用户是fred或者george的文件文件\n- `find /tmp ! -user panda`　#在/tmp目录中查找所有不属于panda用户的文件\n\n","source":"_posts/find命令.md","raw":"---\ntitle: find与grep命令\ndate: 2017-09-22 09:37:29\ntags:\n- 命令行\n---\n## 区别\n- find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 \n- grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。\n\n## find\n基本格式：find  path expression\n\n### 按照文件名查找\n- `find / -name httpd.conf` #在根目录下查找文件httpd.conf，表示在整个硬盘查找\n- `find /etc -name httpd.conf` #在/etc目录下文件httpd.conf\n- `find /etc -name '*srm*'` #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件\n- `find . -name 'srm*'` #表示当前目录下查找文件名开头是字符串‘srm’的文件\n\n### 按照文件特征查找 　　　　\n- `find / -amin -10` 　　# 查找在系统中最后10分钟访问的文件(access time)\n- `find / -atime -2`　　 # 查找在系统中最后48小时访问的文件\n- `find / -empty` 　　# 查找在系统中为空的文件或者文件夹\n- `find / -group cat` 　　# 查找在系统中属于 group为cat的文件\n- `find / -mmin -5` 　　# 查找在系统中最后5分钟里修改过的文件(modify time)\n- `find / -mtime -1` 　　#查找在系统中最后24小时里修改过的文件\n- `find / -user fred` 　　#查找在系统中属于fred这个用户的文件\n- `find / -size +10000c`　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)\n- `find / -size -1000k` 　　#查找出小于1000KB的文件\n\n### 使用混合查找方式查找文件\n参数有： ！，-and(-a)，-or(-o)。\n- `find /tmp -size +10000c -and -mtime +2` #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件\n- `find / -user fred -or -user george` 　#在/目录下查找用户是fred或者george的文件文件\n- `find /tmp ! -user panda`　#在/tmp目录中查找所有不属于panda用户的文件\n\n","slug":"find命令","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkf0008sauafar54q20","content":"<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 </li>\n<li>grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。</li>\n</ul>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>基本格式：find  path expression</p>\n<h3 id=\"按照文件名查找\"><a href=\"#按照文件名查找\" class=\"headerlink\" title=\"按照文件名查找\"></a>按照文件名查找</h3><ul>\n<li><code>find / -name httpd.conf</code> #在根目录下查找文件httpd.conf，表示在整个硬盘查找</li>\n<li><code>find /etc -name httpd.conf</code> #在/etc目录下文件httpd.conf</li>\n<li><code>find /etc -name &#39;*srm*&#39;</code> #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件</li>\n<li><code>find . -name &#39;srm*&#39;</code> #表示当前目录下查找文件名开头是字符串‘srm’的文件</li>\n</ul>\n<h3 id=\"按照文件特征查找\"><a href=\"#按照文件特征查找\" class=\"headerlink\" title=\"按照文件特征查找 　　　　\"></a>按照文件特征查找 　　　　</h3><ul>\n<li><code>find / -amin -10</code> 　　# 查找在系统中最后10分钟访问的文件(access time)</li>\n<li><code>find / -atime -2</code>　　 # 查找在系统中最后48小时访问的文件</li>\n<li><code>find / -empty</code> 　　# 查找在系统中为空的文件或者文件夹</li>\n<li><code>find / -group cat</code> 　　# 查找在系统中属于 group为cat的文件</li>\n<li><code>find / -mmin -5</code> 　　# 查找在系统中最后5分钟里修改过的文件(modify time)</li>\n<li><code>find / -mtime -1</code> 　　#查找在系统中最后24小时里修改过的文件</li>\n<li><code>find / -user fred</code> 　　#查找在系统中属于fred这个用户的文件</li>\n<li><code>find / -size +10000c</code>　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)</li>\n<li><code>find / -size -1000k</code> 　　#查找出小于1000KB的文件</li>\n</ul>\n<h3 id=\"使用混合查找方式查找文件\"><a href=\"#使用混合查找方式查找文件\" class=\"headerlink\" title=\"使用混合查找方式查找文件\"></a>使用混合查找方式查找文件</h3><p>参数有： ！，-and(-a)，-or(-o)。</p>\n<ul>\n<li><code>find /tmp -size +10000c -and -mtime +2</code> #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</li>\n<li><code>find / -user fred -or -user george</code> 　#在/目录下查找用户是fred或者george的文件文件</li>\n<li><code>find /tmp ! -user panda</code>　#在/tmp目录中查找所有不属于panda用户的文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h2><ul>\n<li>find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 </li>\n<li>grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。</li>\n</ul>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>基本格式：find  path expression</p>\n<h3 id=\"按照文件名查找\"><a href=\"#按照文件名查找\" class=\"headerlink\" title=\"按照文件名查找\"></a>按照文件名查找</h3><ul>\n<li><code>find / -name httpd.conf</code> #在根目录下查找文件httpd.conf，表示在整个硬盘查找</li>\n<li><code>find /etc -name httpd.conf</code> #在/etc目录下文件httpd.conf</li>\n<li><code>find /etc -name &#39;*srm*&#39;</code> #使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件</li>\n<li><code>find . -name &#39;srm*&#39;</code> #表示当前目录下查找文件名开头是字符串‘srm’的文件</li>\n</ul>\n<h3 id=\"按照文件特征查找\"><a href=\"#按照文件特征查找\" class=\"headerlink\" title=\"按照文件特征查找 　　　　\"></a>按照文件特征查找 　　　　</h3><ul>\n<li><code>find / -amin -10</code> 　　# 查找在系统中最后10分钟访问的文件(access time)</li>\n<li><code>find / -atime -2</code>　　 # 查找在系统中最后48小时访问的文件</li>\n<li><code>find / -empty</code> 　　# 查找在系统中为空的文件或者文件夹</li>\n<li><code>find / -group cat</code> 　　# 查找在系统中属于 group为cat的文件</li>\n<li><code>find / -mmin -5</code> 　　# 查找在系统中最后5分钟里修改过的文件(modify time)</li>\n<li><code>find / -mtime -1</code> 　　#查找在系统中最后24小时里修改过的文件</li>\n<li><code>find / -user fred</code> 　　#查找在系统中属于fred这个用户的文件</li>\n<li><code>find / -size +10000c</code>　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)</li>\n<li><code>find / -size -1000k</code> 　　#查找出小于1000KB的文件</li>\n</ul>\n<h3 id=\"使用混合查找方式查找文件\"><a href=\"#使用混合查找方式查找文件\" class=\"headerlink\" title=\"使用混合查找方式查找文件\"></a>使用混合查找方式查找文件</h3><p>参数有： ！，-and(-a)，-or(-o)。</p>\n<ul>\n<li><code>find /tmp -size +10000c -and -mtime +2</code> #在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</li>\n<li><code>find / -user fred -or -user george</code> 　#在/目录下查找用户是fred或者george的文件文件</li>\n<li><code>find /tmp ! -user panda</code>　#在/tmp目录中查找所有不属于panda用户的文件</li>\n</ul>\n"},{"title":"hexo多端同步错误解决方案","date":"2017-10-11T14:00:15.000Z","_content":"`hexo d`这个命令是相当于直接`git push`，如果只有一台机器那么是没有问题，但是如果是两台机器，那么还少一步`git pull`，所以如果是两台机器同时维护一个库的时候需要\n\n- 进入到`.deploy_git`这个目录下\n- 然后执行`git pull origin master --allow-unrelated-histories`\n- 然后再push\n- 执行`hexo d`就好了\n\n\n\n","source":"_posts/hexo多端同步错误解决方案.md","raw":"---\ntitle: hexo多端同步错误解决方案\ndate: 2017-10-11 22:00:15\ntags:\n- hexo\n---\n`hexo d`这个命令是相当于直接`git push`，如果只有一台机器那么是没有问题，但是如果是两台机器，那么还少一步`git pull`，所以如果是两台机器同时维护一个库的时候需要\n\n- 进入到`.deploy_git`这个目录下\n- 然后执行`git pull origin master --allow-unrelated-histories`\n- 然后再push\n- 执行`hexo d`就好了\n\n\n\n","slug":"hexo多端同步错误解决方案","published":1,"updated":"2017-10-12T01:22:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkh000bsauaj6m3lu51","content":"<p><code>hexo d</code>这个命令是相当于直接<code>git push</code>，如果只有一台机器那么是没有问题，但是如果是两台机器，那么还少一步<code>git pull</code>，所以如果是两台机器同时维护一个库的时候需要</p>\n<ul>\n<li>进入到<code>.deploy_git</code>这个目录下</li>\n<li>然后执行<code>git pull origin master --allow-unrelated-histories</code></li>\n<li>然后再push</li>\n<li>执行<code>hexo d</code>就好了</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><code>hexo d</code>这个命令是相当于直接<code>git push</code>，如果只有一台机器那么是没有问题，但是如果是两台机器，那么还少一步<code>git pull</code>，所以如果是两台机器同时维护一个库的时候需要</p>\n<ul>\n<li>进入到<code>.deploy_git</code>这个目录下</li>\n<li>然后执行<code>git pull origin master --allow-unrelated-histories</code></li>\n<li>然后再push</li>\n<li>执行<code>hexo d</code>就好了</li>\n</ul>\n"},{"title":"otool作用以及使用","date":"2017-09-28T01:46:28.000Z","_content":"首先来看看那些命令\n<!--more-->\n\n- -h print the mach header打印头部\n- \n","source":"_posts/otool作用以及使用.md","raw":"---\ntitle: otool作用以及使用\ndate: 2017-09-28 09:46:28\ntags:\n- 工具\n\n---\n首先来看看那些命令\n<!--more-->\n\n- -h print the mach header打印头部\n- \n","slug":"otool作用以及使用","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pki000csauaclaqumha","content":"<p>首先来看看那些命令<br><a id=\"more\"></a></p>\n<ul>\n<li>-h print the mach header打印头部</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>首先来看看那些命令<br>","more":"</p>\n<ul>\n<li>-h print the mach header打印头部</li>\n<li></li>\n</ul>"},{"title":"itchat使用总结","date":"2017-06-14T01:23:30.000Z","_content":"\n### 登录\n```\nitchat.auto_login()\n```\n\n### 查找好友\n\n>获取任何一项等于name键值的用户\nitchat.search_friends(name='littlecodersh')\n这里的name是RemarkName', 'NickName', 'Alias\n\n\n### 发送中文\n\n要进行一个转换\n```\nf = open(path,'r')\ntext = f.read()\ntext = text.decode('utf-8')\n```\n","source":"_posts/itchat使用总结.md","raw":"---\ntitle: itchat使用总结\ndate: 2017-06-14 09:23:30\ntags:\n- python\n---\n\n### 登录\n```\nitchat.auto_login()\n```\n\n### 查找好友\n\n>获取任何一项等于name键值的用户\nitchat.search_friends(name='littlecodersh')\n这里的name是RemarkName', 'NickName', 'Alias\n\n\n### 发送中文\n\n要进行一个转换\n```\nf = open(path,'r')\ntext = f.read()\ntext = text.decode('utf-8')\n```\n","slug":"itchat使用总结","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkj000esaua416ru8cq","content":"<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">itchat.auto_login()</div></pre></td></tr></table></figure>\n<h3 id=\"查找好友\"><a href=\"#查找好友\" class=\"headerlink\" title=\"查找好友\"></a>查找好友</h3><blockquote>\n<p>获取任何一项等于name键值的用户<br>itchat.search_friends(name=’littlecodersh’)<br>这里的name是RemarkName’, ‘NickName’, ‘Alias</p>\n</blockquote>\n<h3 id=\"发送中文\"><a href=\"#发送中文\" class=\"headerlink\" title=\"发送中文\"></a>发送中文</h3><p>要进行一个转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f = open(path,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">text = text.decode(&apos;utf-8&apos;)</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">itchat.auto_login()</div></pre></td></tr></table></figure>\n<h3 id=\"查找好友\"><a href=\"#查找好友\" class=\"headerlink\" title=\"查找好友\"></a>查找好友</h3><blockquote>\n<p>获取任何一项等于name键值的用户<br>itchat.search_friends(name=’littlecodersh’)<br>这里的name是RemarkName’, ‘NickName’, ‘Alias</p>\n</blockquote>\n<h3 id=\"发送中文\"><a href=\"#发送中文\" class=\"headerlink\" title=\"发送中文\"></a>发送中文</h3><p>要进行一个转换<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">f = open(path,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">text = text.decode(&apos;utf-8&apos;)</div></pre></td></tr></table></figure></p>\n"},{"title":"python学习环境搭建-jupyter notebook","date":"2017-10-11T03:35:30.000Z","_content":"\n### 先说一下好处：\n我们学习python可以在命令行输入python直接进入python环境进行练习，但是问题是多行运行比较繁琐，这里我们推荐使用jupyter来运行代码\n\n### 再说一下环境 ：\n\nMAC台式机\n\npython:mac下自带Python 2.7.10\n\n- 1.先升级了pip安装工具：sudo python -m pip install --upgrade --force pip\n\n- 2.安装setuptools 工具：sudo pip install setuptools==33.1.1\n\n- 3.安装 Python-dateutil:sudo pip install python-dateutil==2.2\n\n- 4.安装six:sudo pip install --ignore-installed six\n\n- 5.安装jupyter：sudo install jupyter\n\n启动命令：直接在终端输入jupyter notebook\n\n折腾了半天，才搞好，以上命令是在安装的时候遇到各种问题时使用的，下面写记录一下遇到的问题 以及对应的解决办法\n\n1.ImportError: cannot import name _thread  报这个错误 解决办法：\n\nsudo pip uninstall python-dateutil\nsudo pip install python-dateutil==2.2\n2.File \"/Library/Python/2.7/site-packages/dateutil/tz/_common.py\", line 2, in <module>\n\nfrom six.moves import _thread\nImportError: cannot import name _thread\n\n解决办法：安装six 命令再上方\n\n解决了上面的问题 启动的时候 还是会报错这是个顽固的错误：\n\n  File \"/Library/Python/2.7/site-packages/packaging/requirements.py\", line 59, in <module>\n\n    MARKER_EXPR = originalTextFor(MARKER_EXPR())(\"marker\")\n\nTypeError: __call__() takes exactly 2 arguments (1 given)\n\n解决办法：根据错误信息直接找到路径中的文件，打开文件将 59 行中的函数修改\n\n59：#MARKER_EXPR = originalTextFor(MARKER_EXPR())(\"marker\")\n60：MARKER_EXPR = originalTextFor(MARKER_EXPR(\"marker\"))\n\n修改好之后直接保存文件 再次运行jupyter notebook 命令 即可启动jupyter \n\n关于six那个问题，还有一点 需要删除我们默认路径下的six 否则 即使更新成功了 也不会使用最新的six\n\n方法：先查看一下默认的six路径\n\n import six\n\n\n### 最后说一下怎么使用\n\nfile-->new-->python2","source":"_posts/python学习环境搭建-jupyter-notebook.md","raw":"---\ntitle: python学习环境搭建-jupyter notebook\ndate: 2017-10-11 11:35:30\ntags:\n- python\n---\n\n### 先说一下好处：\n我们学习python可以在命令行输入python直接进入python环境进行练习，但是问题是多行运行比较繁琐，这里我们推荐使用jupyter来运行代码\n\n### 再说一下环境 ：\n\nMAC台式机\n\npython:mac下自带Python 2.7.10\n\n- 1.先升级了pip安装工具：sudo python -m pip install --upgrade --force pip\n\n- 2.安装setuptools 工具：sudo pip install setuptools==33.1.1\n\n- 3.安装 Python-dateutil:sudo pip install python-dateutil==2.2\n\n- 4.安装six:sudo pip install --ignore-installed six\n\n- 5.安装jupyter：sudo install jupyter\n\n启动命令：直接在终端输入jupyter notebook\n\n折腾了半天，才搞好，以上命令是在安装的时候遇到各种问题时使用的，下面写记录一下遇到的问题 以及对应的解决办法\n\n1.ImportError: cannot import name _thread  报这个错误 解决办法：\n\nsudo pip uninstall python-dateutil\nsudo pip install python-dateutil==2.2\n2.File \"/Library/Python/2.7/site-packages/dateutil/tz/_common.py\", line 2, in <module>\n\nfrom six.moves import _thread\nImportError: cannot import name _thread\n\n解决办法：安装six 命令再上方\n\n解决了上面的问题 启动的时候 还是会报错这是个顽固的错误：\n\n  File \"/Library/Python/2.7/site-packages/packaging/requirements.py\", line 59, in <module>\n\n    MARKER_EXPR = originalTextFor(MARKER_EXPR())(\"marker\")\n\nTypeError: __call__() takes exactly 2 arguments (1 given)\n\n解决办法：根据错误信息直接找到路径中的文件，打开文件将 59 行中的函数修改\n\n59：#MARKER_EXPR = originalTextFor(MARKER_EXPR())(\"marker\")\n60：MARKER_EXPR = originalTextFor(MARKER_EXPR(\"marker\"))\n\n修改好之后直接保存文件 再次运行jupyter notebook 命令 即可启动jupyter \n\n关于six那个问题，还有一点 需要删除我们默认路径下的six 否则 即使更新成功了 也不会使用最新的six\n\n方法：先查看一下默认的six路径\n\n import six\n\n\n### 最后说一下怎么使用\n\nfile-->new-->python2","slug":"python学习环境搭建-jupyter-notebook","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkk000gsauak16iins1","content":"<h3 id=\"先说一下好处：\"><a href=\"#先说一下好处：\" class=\"headerlink\" title=\"先说一下好处：\"></a>先说一下好处：</h3><p>我们学习python可以在命令行输入python直接进入python环境进行练习，但是问题是多行运行比较繁琐，这里我们推荐使用jupyter来运行代码</p>\n<h3 id=\"再说一下环境-：\"><a href=\"#再说一下环境-：\" class=\"headerlink\" title=\"再说一下环境 ：\"></a>再说一下环境 ：</h3><p>MAC台式机</p>\n<p>python:mac下自带Python 2.7.10</p>\n<ul>\n<li><p>1.先升级了pip安装工具：sudo python -m pip install –upgrade –force pip</p>\n</li>\n<li><p>2.安装setuptools 工具：sudo pip install setuptools==33.1.1</p>\n</li>\n<li><p>3.安装 Python-dateutil:sudo pip install python-dateutil==2.2</p>\n</li>\n<li><p>4.安装six:sudo pip install –ignore-installed six</p>\n</li>\n<li><p>5.安装jupyter：sudo install jupyter</p>\n</li>\n</ul>\n<p>启动命令：直接在终端输入jupyter notebook</p>\n<p>折腾了半天，才搞好，以上命令是在安装的时候遇到各种问题时使用的，下面写记录一下遇到的问题 以及对应的解决办法</p>\n<p>1.ImportError: cannot import name _thread  报这个错误 解决办法：</p>\n<p>sudo pip uninstall python-dateutil<br>sudo pip install python-dateutil==2.2<br>2.File “/Library/Python/2.7/site-packages/dateutil/tz/_common.py”, line 2, in <module></module></p>\n<p>from six.moves import _thread<br>ImportError: cannot import name _thread</p>\n<p>解决办法：安装six 命令再上方</p>\n<p>解决了上面的问题 启动的时候 还是会报错这是个顽固的错误：</p>\n<p>  File “/Library/Python/2.7/site-packages/packaging/requirements.py”, line 59, in <module></module></p>\n<pre><code>MARKER_EXPR = originalTextFor(MARKER_EXPR())(&quot;marker&quot;)\n</code></pre><p>TypeError: <strong>call</strong>() takes exactly 2 arguments (1 given)</p>\n<p>解决办法：根据错误信息直接找到路径中的文件，打开文件将 59 行中的函数修改</p>\n<p>59：#MARKER_EXPR = originalTextFor(MARKER_EXPR())(“marker”)<br>60：MARKER_EXPR = originalTextFor(MARKER_EXPR(“marker”))</p>\n<p>修改好之后直接保存文件 再次运行jupyter notebook 命令 即可启动jupyter </p>\n<p>关于six那个问题，还有一点 需要删除我们默认路径下的six 否则 即使更新成功了 也不会使用最新的six</p>\n<p>方法：先查看一下默认的six路径</p>\n<p> import six</p>\n<h3 id=\"最后说一下怎么使用\"><a href=\"#最后说一下怎么使用\" class=\"headerlink\" title=\"最后说一下怎么使用\"></a>最后说一下怎么使用</h3><p>file–&gt;new–&gt;python2</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"先说一下好处：\"><a href=\"#先说一下好处：\" class=\"headerlink\" title=\"先说一下好处：\"></a>先说一下好处：</h3><p>我们学习python可以在命令行输入python直接进入python环境进行练习，但是问题是多行运行比较繁琐，这里我们推荐使用jupyter来运行代码</p>\n<h3 id=\"再说一下环境-：\"><a href=\"#再说一下环境-：\" class=\"headerlink\" title=\"再说一下环境 ：\"></a>再说一下环境 ：</h3><p>MAC台式机</p>\n<p>python:mac下自带Python 2.7.10</p>\n<ul>\n<li><p>1.先升级了pip安装工具：sudo python -m pip install –upgrade –force pip</p>\n</li>\n<li><p>2.安装setuptools 工具：sudo pip install setuptools==33.1.1</p>\n</li>\n<li><p>3.安装 Python-dateutil:sudo pip install python-dateutil==2.2</p>\n</li>\n<li><p>4.安装six:sudo pip install –ignore-installed six</p>\n</li>\n<li><p>5.安装jupyter：sudo install jupyter</p>\n</li>\n</ul>\n<p>启动命令：直接在终端输入jupyter notebook</p>\n<p>折腾了半天，才搞好，以上命令是在安装的时候遇到各种问题时使用的，下面写记录一下遇到的问题 以及对应的解决办法</p>\n<p>1.ImportError: cannot import name _thread  报这个错误 解决办法：</p>\n<p>sudo pip uninstall python-dateutil<br>sudo pip install python-dateutil==2.2<br>2.File “/Library/Python/2.7/site-packages/dateutil/tz/_common.py”, line 2, in <module></module></p>\n<p>from six.moves import _thread<br>ImportError: cannot import name _thread</p>\n<p>解决办法：安装six 命令再上方</p>\n<p>解决了上面的问题 启动的时候 还是会报错这是个顽固的错误：</p>\n<p>  File “/Library/Python/2.7/site-packages/packaging/requirements.py”, line 59, in <module></module></p>\n<pre><code>MARKER_EXPR = originalTextFor(MARKER_EXPR())(&quot;marker&quot;)\n</code></pre><p>TypeError: <strong>call</strong>() takes exactly 2 arguments (1 given)</p>\n<p>解决办法：根据错误信息直接找到路径中的文件，打开文件将 59 行中的函数修改</p>\n<p>59：#MARKER_EXPR = originalTextFor(MARKER_EXPR())(“marker”)<br>60：MARKER_EXPR = originalTextFor(MARKER_EXPR(“marker”))</p>\n<p>修改好之后直接保存文件 再次运行jupyter notebook 命令 即可启动jupyter </p>\n<p>关于six那个问题，还有一点 需要删除我们默认路径下的six 否则 即使更新成功了 也不会使用最新的six</p>\n<p>方法：先查看一下默认的six路径</p>\n<p> import six</p>\n<h3 id=\"最后说一下怎么使用\"><a href=\"#最后说一下怎么使用\" class=\"headerlink\" title=\"最后说一下怎么使用\"></a>最后说一下怎么使用</h3><p>file–&gt;new–&gt;python2</p>\n"},{"title":"python发送邮件代码记录","date":"2017-10-10T12:38:05.000Z","_content":"\n```\n#!/usr/bin/env python\n#coding:utf-8\n\nfrom email import encoders\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.application import MIMEApplication\nfrom email.utils import parseaddr, formataddr\nimport smtplib,os\n\ndef _format_addr(s):\n    name, addr = parseaddr(s)\n    return formataddr(( \\\n        Header(name, 'utf-8').encode(), \\\n        addr.encode('utf-8') if isinstance(addr, unicode) else addr))\n\ndef sendMail():\n    username = 'hanshenghui'\n    password = '11111111111'\n\n    from_addr = 'hanshenghui@jd.com'\n    to_addr = 'hanshenghui@jd.com'\n    # to_addrList = ['hanshenghui@jd.com','gaixutian@jd.com','wangzhenyang1@jd.com']\n    to_addrList = ['hanshenghui@jd.com','wangxiugang@jd.com','dingchao1@jd.com']\n    smtp_server = 'smtp.jd.local'\n\n    msg = MIMEMultipart()\n    part = MIMEText(\"这是一封测试邮件\\n\\n现在主要有以下几个待确定点:\\n1.我们可以通过对数据进行提取，做一些分析和简介作为邮件的正文，或者是一些其他什么内容\\n2.现在邮箱我添加了名字为JDJRMobile，实际上是我自己的邮箱，用哪个邮箱来发送比较合适\\n3.检测哪个分支\\n4.检测频率\\n\\n\")\n    msg.attach(part)\n    \n    basePath = os.environ['HOME']\n    reportPath = basePath + '/Documents/Build/JDJRAPPAndroid/infer-out/report.csv'\n    if os.path.exists(reportPath):    \n       part1 = MIMEApplication(open(reportPath,'rb').read())\n       part1.add_header('Content-Disposition', 'attachment', filename=\"report.csv\")\n       msg.attach(part1)\n\n    # part2 = MIMEApplication(open('cesh.png','rb').read())\n    # part2.add_header('Content-Disposition', 'attachment', filename=\"cesh.png\")\n    # msg.attach(part2)\n\n    msg['From'] = _format_addr(u'JDJRMobile <%s>' % from_addr)\n    msg['To'] = _format_addr('JDJR')\n    msg['Subject'] = Header(u'JDJR安卓源码检测报告', 'utf-8').encode()\n\n    server = smtplib.SMTP(smtp_server,25)\n    server.set_debuglevel(1)\n    server.sendmail(from_addr, to_addrList, msg.as_string())\n    server.quit()\n```","source":"_posts/python发送邮件代码记录.md","raw":"---\ntitle: python发送邮件代码记录\ndate: 2017-10-10 20:38:05\ntags:\n- python\n---\n\n```\n#!/usr/bin/env python\n#coding:utf-8\n\nfrom email import encoders\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.application import MIMEApplication\nfrom email.utils import parseaddr, formataddr\nimport smtplib,os\n\ndef _format_addr(s):\n    name, addr = parseaddr(s)\n    return formataddr(( \\\n        Header(name, 'utf-8').encode(), \\\n        addr.encode('utf-8') if isinstance(addr, unicode) else addr))\n\ndef sendMail():\n    username = 'hanshenghui'\n    password = '11111111111'\n\n    from_addr = 'hanshenghui@jd.com'\n    to_addr = 'hanshenghui@jd.com'\n    # to_addrList = ['hanshenghui@jd.com','gaixutian@jd.com','wangzhenyang1@jd.com']\n    to_addrList = ['hanshenghui@jd.com','wangxiugang@jd.com','dingchao1@jd.com']\n    smtp_server = 'smtp.jd.local'\n\n    msg = MIMEMultipart()\n    part = MIMEText(\"这是一封测试邮件\\n\\n现在主要有以下几个待确定点:\\n1.我们可以通过对数据进行提取，做一些分析和简介作为邮件的正文，或者是一些其他什么内容\\n2.现在邮箱我添加了名字为JDJRMobile，实际上是我自己的邮箱，用哪个邮箱来发送比较合适\\n3.检测哪个分支\\n4.检测频率\\n\\n\")\n    msg.attach(part)\n    \n    basePath = os.environ['HOME']\n    reportPath = basePath + '/Documents/Build/JDJRAPPAndroid/infer-out/report.csv'\n    if os.path.exists(reportPath):    \n       part1 = MIMEApplication(open(reportPath,'rb').read())\n       part1.add_header('Content-Disposition', 'attachment', filename=\"report.csv\")\n       msg.attach(part1)\n\n    # part2 = MIMEApplication(open('cesh.png','rb').read())\n    # part2.add_header('Content-Disposition', 'attachment', filename=\"cesh.png\")\n    # msg.attach(part2)\n\n    msg['From'] = _format_addr(u'JDJRMobile <%s>' % from_addr)\n    msg['To'] = _format_addr('JDJR')\n    msg['Subject'] = Header(u'JDJR安卓源码检测报告', 'utf-8').encode()\n\n    server = smtplib.SMTP(smtp_server,25)\n    server.set_debuglevel(1)\n    server.sendmail(from_addr, to_addrList, msg.as_string())\n    server.quit()\n```","slug":"python发送邮件代码记录","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkm000isauax6xcepcl","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">from email import encoders</div><div class=\"line\">from email.header import Header</div><div class=\"line\">from email.mime.text import MIMEText</div><div class=\"line\">from email.mime.multipart import MIMEMultipart</div><div class=\"line\">from email.mime.application import MIMEApplication</div><div class=\"line\">from email.utils import parseaddr, formataddr</div><div class=\"line\">import smtplib,os</div><div class=\"line\"></div><div class=\"line\">def _format_addr(s):</div><div class=\"line\">    name, addr = parseaddr(s)</div><div class=\"line\">    return formataddr(( \\</div><div class=\"line\">        Header(name, &apos;utf-8&apos;).encode(), \\</div><div class=\"line\">        addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))</div><div class=\"line\"></div><div class=\"line\">def sendMail():</div><div class=\"line\">    username = &apos;hanshenghui&apos;</div><div class=\"line\">    password = &apos;11111111111&apos;</div><div class=\"line\"></div><div class=\"line\">    from_addr = &apos;hanshenghui@jd.com&apos;</div><div class=\"line\">    to_addr = &apos;hanshenghui@jd.com&apos;</div><div class=\"line\">    # to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;gaixutian@jd.com&apos;,&apos;wangzhenyang1@jd.com&apos;]</div><div class=\"line\">    to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;wangxiugang@jd.com&apos;,&apos;dingchao1@jd.com&apos;]</div><div class=\"line\">    smtp_server = &apos;smtp.jd.local&apos;</div><div class=\"line\"></div><div class=\"line\">    msg = MIMEMultipart()</div><div class=\"line\">    part = MIMEText(&quot;这是一封测试邮件\\n\\n现在主要有以下几个待确定点:\\n1.我们可以通过对数据进行提取，做一些分析和简介作为邮件的正文，或者是一些其他什么内容\\n2.现在邮箱我添加了名字为JDJRMobile，实际上是我自己的邮箱，用哪个邮箱来发送比较合适\\n3.检测哪个分支\\n4.检测频率\\n\\n&quot;)</div><div class=\"line\">    msg.attach(part)</div><div class=\"line\">    </div><div class=\"line\">    basePath = os.environ[&apos;HOME&apos;]</div><div class=\"line\">    reportPath = basePath + &apos;/Documents/Build/JDJRAPPAndroid/infer-out/report.csv&apos;</div><div class=\"line\">    if os.path.exists(reportPath):    </div><div class=\"line\">       part1 = MIMEApplication(open(reportPath,&apos;rb&apos;).read())</div><div class=\"line\">       part1.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;report.csv&quot;)</div><div class=\"line\">       msg.attach(part1)</div><div class=\"line\"></div><div class=\"line\">    # part2 = MIMEApplication(open(&apos;cesh.png&apos;,&apos;rb&apos;).read())</div><div class=\"line\">    # part2.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;cesh.png&quot;)</div><div class=\"line\">    # msg.attach(part2)</div><div class=\"line\"></div><div class=\"line\">    msg[&apos;From&apos;] = _format_addr(u&apos;JDJRMobile &lt;%s&gt;&apos; % from_addr)</div><div class=\"line\">    msg[&apos;To&apos;] = _format_addr(&apos;JDJR&apos;)</div><div class=\"line\">    msg[&apos;Subject&apos;] = Header(u&apos;JDJR安卓源码检测报告&apos;, &apos;utf-8&apos;).encode()</div><div class=\"line\"></div><div class=\"line\">    server = smtplib.SMTP(smtp_server,25)</div><div class=\"line\">    server.set_debuglevel(1)</div><div class=\"line\">    server.sendmail(from_addr, to_addrList, msg.as_string())</div><div class=\"line\">    server.quit()</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/env python</div><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">from email import encoders</div><div class=\"line\">from email.header import Header</div><div class=\"line\">from email.mime.text import MIMEText</div><div class=\"line\">from email.mime.multipart import MIMEMultipart</div><div class=\"line\">from email.mime.application import MIMEApplication</div><div class=\"line\">from email.utils import parseaddr, formataddr</div><div class=\"line\">import smtplib,os</div><div class=\"line\"></div><div class=\"line\">def _format_addr(s):</div><div class=\"line\">    name, addr = parseaddr(s)</div><div class=\"line\">    return formataddr(( \\</div><div class=\"line\">        Header(name, &apos;utf-8&apos;).encode(), \\</div><div class=\"line\">        addr.encode(&apos;utf-8&apos;) if isinstance(addr, unicode) else addr))</div><div class=\"line\"></div><div class=\"line\">def sendMail():</div><div class=\"line\">    username = &apos;hanshenghui&apos;</div><div class=\"line\">    password = &apos;11111111111&apos;</div><div class=\"line\"></div><div class=\"line\">    from_addr = &apos;hanshenghui@jd.com&apos;</div><div class=\"line\">    to_addr = &apos;hanshenghui@jd.com&apos;</div><div class=\"line\">    # to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;gaixutian@jd.com&apos;,&apos;wangzhenyang1@jd.com&apos;]</div><div class=\"line\">    to_addrList = [&apos;hanshenghui@jd.com&apos;,&apos;wangxiugang@jd.com&apos;,&apos;dingchao1@jd.com&apos;]</div><div class=\"line\">    smtp_server = &apos;smtp.jd.local&apos;</div><div class=\"line\"></div><div class=\"line\">    msg = MIMEMultipart()</div><div class=\"line\">    part = MIMEText(&quot;这是一封测试邮件\\n\\n现在主要有以下几个待确定点:\\n1.我们可以通过对数据进行提取，做一些分析和简介作为邮件的正文，或者是一些其他什么内容\\n2.现在邮箱我添加了名字为JDJRMobile，实际上是我自己的邮箱，用哪个邮箱来发送比较合适\\n3.检测哪个分支\\n4.检测频率\\n\\n&quot;)</div><div class=\"line\">    msg.attach(part)</div><div class=\"line\">    </div><div class=\"line\">    basePath = os.environ[&apos;HOME&apos;]</div><div class=\"line\">    reportPath = basePath + &apos;/Documents/Build/JDJRAPPAndroid/infer-out/report.csv&apos;</div><div class=\"line\">    if os.path.exists(reportPath):    </div><div class=\"line\">       part1 = MIMEApplication(open(reportPath,&apos;rb&apos;).read())</div><div class=\"line\">       part1.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;report.csv&quot;)</div><div class=\"line\">       msg.attach(part1)</div><div class=\"line\"></div><div class=\"line\">    # part2 = MIMEApplication(open(&apos;cesh.png&apos;,&apos;rb&apos;).read())</div><div class=\"line\">    # part2.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&quot;cesh.png&quot;)</div><div class=\"line\">    # msg.attach(part2)</div><div class=\"line\"></div><div class=\"line\">    msg[&apos;From&apos;] = _format_addr(u&apos;JDJRMobile &lt;%s&gt;&apos; % from_addr)</div><div class=\"line\">    msg[&apos;To&apos;] = _format_addr(&apos;JDJR&apos;)</div><div class=\"line\">    msg[&apos;Subject&apos;] = Header(u&apos;JDJR安卓源码检测报告&apos;, &apos;utf-8&apos;).encode()</div><div class=\"line\"></div><div class=\"line\">    server = smtplib.SMTP(smtp_server,25)</div><div class=\"line\">    server.set_debuglevel(1)</div><div class=\"line\">    server.sendmail(from_addr, to_addrList, msg.as_string())</div><div class=\"line\">    server.quit()</div></pre></td></tr></table></figure>"},{"title":"xcode多版本自动化打包设置","date":"2017-10-10T04:29:12.000Z","_content":"\n如果你升级了xcode但是这个时候你又想降级回去，你发现appstore已经不要指望了，我们需要下载一个你需要版本的xcode。\n下载各个Xcode版本的地址`https://developer.apple.com/download/more`\n然后放置到我们的程序目录下，改个名字比如说叫Xcode2\n但是现在问题又来了，加入你是个打包服务器，你使用的是xcodebuild来打包的，这个时候两个版本的xcode同时存在，它如何选择sdk进行打包呢？\n- 首先查看sdk版本 \t`xcodebuild -showsdks`\n- 然后切换默认的xcode `sudo xcode-select -switch /Applications/Xcode2.app`\n- 然后在执行`xcodebuild -showsdks`\n\n你会发现sdk已经变了，这个时候你使用xcodebuild来打包可以选择你需要的这个版本的sdk了\n","source":"_posts/xcode多版本自动化打包记录.md","raw":"---\ntitle: xcode多版本自动化打包设置\ndate: 2017-10-10 12:29:12\ntags:\n- 工具\n- xcode\n---\n\n如果你升级了xcode但是这个时候你又想降级回去，你发现appstore已经不要指望了，我们需要下载一个你需要版本的xcode。\n下载各个Xcode版本的地址`https://developer.apple.com/download/more`\n然后放置到我们的程序目录下，改个名字比如说叫Xcode2\n但是现在问题又来了，加入你是个打包服务器，你使用的是xcodebuild来打包的，这个时候两个版本的xcode同时存在，它如何选择sdk进行打包呢？\n- 首先查看sdk版本 \t`xcodebuild -showsdks`\n- 然后切换默认的xcode `sudo xcode-select -switch /Applications/Xcode2.app`\n- 然后在执行`xcodebuild -showsdks`\n\n你会发现sdk已经变了，这个时候你使用xcodebuild来打包可以选择你需要的这个版本的sdk了\n","slug":"xcode多版本自动化打包记录","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pko000ksauarmslobst","content":"<p>如果你升级了xcode但是这个时候你又想降级回去，你发现appstore已经不要指望了，我们需要下载一个你需要版本的xcode。<br>下载各个Xcode版本的地址<code>https://developer.apple.com/download/more</code><br>然后放置到我们的程序目录下，改个名字比如说叫Xcode2<br>但是现在问题又来了，加入你是个打包服务器，你使用的是xcodebuild来打包的，这个时候两个版本的xcode同时存在，它如何选择sdk进行打包呢？</p>\n<ul>\n<li>首先查看sdk版本     <code>xcodebuild -showsdks</code></li>\n<li>然后切换默认的xcode <code>sudo xcode-select -switch /Applications/Xcode2.app</code></li>\n<li>然后在执行<code>xcodebuild -showsdks</code></li>\n</ul>\n<p>你会发现sdk已经变了，这个时候你使用xcodebuild来打包可以选择你需要的这个版本的sdk了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你升级了xcode但是这个时候你又想降级回去，你发现appstore已经不要指望了，我们需要下载一个你需要版本的xcode。<br>下载各个Xcode版本的地址<code>https://developer.apple.com/download/more</code><br>然后放置到我们的程序目录下，改个名字比如说叫Xcode2<br>但是现在问题又来了，加入你是个打包服务器，你使用的是xcodebuild来打包的，这个时候两个版本的xcode同时存在，它如何选择sdk进行打包呢？</p>\n<ul>\n<li>首先查看sdk版本     <code>xcodebuild -showsdks</code></li>\n<li>然后切换默认的xcode <code>sudo xcode-select -switch /Applications/Xcode2.app</code></li>\n<li>然后在执行<code>xcodebuild -showsdks</code></li>\n</ul>\n<p>你会发现sdk已经变了，这个时候你使用xcodebuild来打包可以选择你需要的这个版本的sdk了</p>\n"},{"title":"xcode工程加密思路","date":"2017-10-10T11:45:46.000Z","_content":"\n现在有这么一个需求，如何做到如果不安装我们的开发环境，就无法查看iOS工程。\n首先我们如果对所有的代码进行加密这肯定是一个浩大的工程，所以我们选择是对project加密，\n\n```\n/usr/bin/env python\n#coding:utf-8\n\nfrom Crypto.Cipher import AES  \nfrom binascii import b2a_hex,a2b_hex  \n  \nclass prpcrypt():   #定义一个类  \n    def __init__(self,key):  \n        self.key=key  \n        self.mode=AES.MODE_CBC  \n    def encrypt(self,text):  \n        cryptor=AES.new(self.key,self.mode,self.key)  \n        x = len(text) % 16  \n        if x != 0:  \n            text = text + '0' * (16 - x)     #不满16，32，64位补0  \n        self.ciphertext=cryptor.encrypt(text)  \n        return b2a_hex(self.ciphertext)  \n    def decrypt(self,text):  \n        cryptor=AES.new(self.key,self.mode,self.key)  \n        plain_text=cryptor.decrypt(a2b_hex(text))  \n        return plain_text.rstrip('\\0')  \n  \npc=prpcrypt('tecentbluewhaleA') #自己设定的密钥\n\nf = open('project.pbxproj','r')\ntext = f.read()\nliens = text.split('\\n')\n\nif len(liens) > 10:\n    item = liens[10]\n    print item\n    # item = pc.decrypt(item)\n    item = pc.encrypt(item)\n    item = item.replace('000000000000000','')\n    print item\n    liens[10] = item\n\nfor i in range(0,len(liens) - 1):\n    liens[i] = liens[i] + '\\n'\n\nstrings = ''.join(liens)\n\nf = open('project.pbxproj','w')\nf.writelines(strings)\nf.close()\n```\n这里我们使用到了pycrypto库，安装的时候需要先卸载\n`sudo pip uninstall crypto`\n`sudo pip uninstall pycrypto`\n\n然后\n`sudo pip install pycrypto`这样就安装好了需要的库\n\n关于我们加密那哪些东西，其实主要是project文件里边的解析文件，将一些关键是被符号进行加密，其实如果查看git操作记录是可以发现该如何还原的，这个时候就需要靠多行替换来增大替换的工作量来人为设置门槛\n\n另外需要配合改装的git，在commit的时候进行加密然后commit，在pull的时候也是解密然后commit一下，这样我们就做到了，在远端库里边是不能被直接有序查看的代码，在本地需要配合我们的git才能被顺畅的使用\n","source":"_posts/xcode工程加密思路.md","raw":"---\ntitle: xcode工程加密思路\ndate: 2017-10-10 19:45:46\ntags:\n- xcode\n- git\n---\n\n现在有这么一个需求，如何做到如果不安装我们的开发环境，就无法查看iOS工程。\n首先我们如果对所有的代码进行加密这肯定是一个浩大的工程，所以我们选择是对project加密，\n\n```\n/usr/bin/env python\n#coding:utf-8\n\nfrom Crypto.Cipher import AES  \nfrom binascii import b2a_hex,a2b_hex  \n  \nclass prpcrypt():   #定义一个类  \n    def __init__(self,key):  \n        self.key=key  \n        self.mode=AES.MODE_CBC  \n    def encrypt(self,text):  \n        cryptor=AES.new(self.key,self.mode,self.key)  \n        x = len(text) % 16  \n        if x != 0:  \n            text = text + '0' * (16 - x)     #不满16，32，64位补0  \n        self.ciphertext=cryptor.encrypt(text)  \n        return b2a_hex(self.ciphertext)  \n    def decrypt(self,text):  \n        cryptor=AES.new(self.key,self.mode,self.key)  \n        plain_text=cryptor.decrypt(a2b_hex(text))  \n        return plain_text.rstrip('\\0')  \n  \npc=prpcrypt('tecentbluewhaleA') #自己设定的密钥\n\nf = open('project.pbxproj','r')\ntext = f.read()\nliens = text.split('\\n')\n\nif len(liens) > 10:\n    item = liens[10]\n    print item\n    # item = pc.decrypt(item)\n    item = pc.encrypt(item)\n    item = item.replace('000000000000000','')\n    print item\n    liens[10] = item\n\nfor i in range(0,len(liens) - 1):\n    liens[i] = liens[i] + '\\n'\n\nstrings = ''.join(liens)\n\nf = open('project.pbxproj','w')\nf.writelines(strings)\nf.close()\n```\n这里我们使用到了pycrypto库，安装的时候需要先卸载\n`sudo pip uninstall crypto`\n`sudo pip uninstall pycrypto`\n\n然后\n`sudo pip install pycrypto`这样就安装好了需要的库\n\n关于我们加密那哪些东西，其实主要是project文件里边的解析文件，将一些关键是被符号进行加密，其实如果查看git操作记录是可以发现该如何还原的，这个时候就需要靠多行替换来增大替换的工作量来人为设置门槛\n\n另外需要配合改装的git，在commit的时候进行加密然后commit，在pull的时候也是解密然后commit一下，这样我们就做到了，在远端库里边是不能被直接有序查看的代码，在本地需要配合我们的git才能被顺畅的使用\n","slug":"xcode工程加密思路","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkp000msaua2t3a1hx4","content":"<p>现在有这么一个需求，如何做到如果不安装我们的开发环境，就无法查看iOS工程。<br>首先我们如果对所有的代码进行加密这肯定是一个浩大的工程，所以我们选择是对project加密，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">/usr/bin/env python</div><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">from Crypto.Cipher import AES  </div><div class=\"line\">from binascii import b2a_hex,a2b_hex  </div><div class=\"line\">  </div><div class=\"line\">class prpcrypt():   #定义一个类  </div><div class=\"line\">    def __init__(self,key):  </div><div class=\"line\">        self.key=key  </div><div class=\"line\">        self.mode=AES.MODE_CBC  </div><div class=\"line\">    def encrypt(self,text):  </div><div class=\"line\">        cryptor=AES.new(self.key,self.mode,self.key)  </div><div class=\"line\">        x = len(text) % 16  </div><div class=\"line\">        if x != 0:  </div><div class=\"line\">            text = text + &apos;0&apos; * (16 - x)     #不满16，32，64位补0  </div><div class=\"line\">        self.ciphertext=cryptor.encrypt(text)  </div><div class=\"line\">        return b2a_hex(self.ciphertext)  </div><div class=\"line\">    def decrypt(self,text):  </div><div class=\"line\">        cryptor=AES.new(self.key,self.mode,self.key)  </div><div class=\"line\">        plain_text=cryptor.decrypt(a2b_hex(text))  </div><div class=\"line\">        return plain_text.rstrip(&apos;\\0&apos;)  </div><div class=\"line\">  </div><div class=\"line\">pc=prpcrypt(&apos;tecentbluewhaleA&apos;) #自己设定的密钥</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;project.pbxproj&apos;,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">liens = text.split(&apos;\\n&apos;)</div><div class=\"line\"></div><div class=\"line\">if len(liens) &gt; 10:</div><div class=\"line\">    item = liens[10]</div><div class=\"line\">    print item</div><div class=\"line\">    # item = pc.decrypt(item)</div><div class=\"line\">    item = pc.encrypt(item)</div><div class=\"line\">    item = item.replace(&apos;000000000000000&apos;,&apos;&apos;)</div><div class=\"line\">    print item</div><div class=\"line\">    liens[10] = item</div><div class=\"line\"></div><div class=\"line\">for i in range(0,len(liens) - 1):</div><div class=\"line\">    liens[i] = liens[i] + &apos;\\n&apos;</div><div class=\"line\"></div><div class=\"line\">strings = &apos;&apos;.join(liens)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;project.pbxproj&apos;,&apos;w&apos;)</div><div class=\"line\">f.writelines(strings)</div><div class=\"line\">f.close()</div></pre></td></tr></table></figure>\n<p>这里我们使用到了pycrypto库，安装的时候需要先卸载<br><code>sudo pip uninstall crypto</code><br><code>sudo pip uninstall pycrypto</code></p>\n<p>然后<br><code>sudo pip install pycrypto</code>这样就安装好了需要的库</p>\n<p>关于我们加密那哪些东西，其实主要是project文件里边的解析文件，将一些关键是被符号进行加密，其实如果查看git操作记录是可以发现该如何还原的，这个时候就需要靠多行替换来增大替换的工作量来人为设置门槛</p>\n<p>另外需要配合改装的git，在commit的时候进行加密然后commit，在pull的时候也是解密然后commit一下，这样我们就做到了，在远端库里边是不能被直接有序查看的代码，在本地需要配合我们的git才能被顺畅的使用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在有这么一个需求，如何做到如果不安装我们的开发环境，就无法查看iOS工程。<br>首先我们如果对所有的代码进行加密这肯定是一个浩大的工程，所以我们选择是对project加密，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">/usr/bin/env python</div><div class=\"line\">#coding:utf-8</div><div class=\"line\"></div><div class=\"line\">from Crypto.Cipher import AES  </div><div class=\"line\">from binascii import b2a_hex,a2b_hex  </div><div class=\"line\">  </div><div class=\"line\">class prpcrypt():   #定义一个类  </div><div class=\"line\">    def __init__(self,key):  </div><div class=\"line\">        self.key=key  </div><div class=\"line\">        self.mode=AES.MODE_CBC  </div><div class=\"line\">    def encrypt(self,text):  </div><div class=\"line\">        cryptor=AES.new(self.key,self.mode,self.key)  </div><div class=\"line\">        x = len(text) % 16  </div><div class=\"line\">        if x != 0:  </div><div class=\"line\">            text = text + &apos;0&apos; * (16 - x)     #不满16，32，64位补0  </div><div class=\"line\">        self.ciphertext=cryptor.encrypt(text)  </div><div class=\"line\">        return b2a_hex(self.ciphertext)  </div><div class=\"line\">    def decrypt(self,text):  </div><div class=\"line\">        cryptor=AES.new(self.key,self.mode,self.key)  </div><div class=\"line\">        plain_text=cryptor.decrypt(a2b_hex(text))  </div><div class=\"line\">        return plain_text.rstrip(&apos;\\0&apos;)  </div><div class=\"line\">  </div><div class=\"line\">pc=prpcrypt(&apos;tecentbluewhaleA&apos;) #自己设定的密钥</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;project.pbxproj&apos;,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">liens = text.split(&apos;\\n&apos;)</div><div class=\"line\"></div><div class=\"line\">if len(liens) &gt; 10:</div><div class=\"line\">    item = liens[10]</div><div class=\"line\">    print item</div><div class=\"line\">    # item = pc.decrypt(item)</div><div class=\"line\">    item = pc.encrypt(item)</div><div class=\"line\">    item = item.replace(&apos;000000000000000&apos;,&apos;&apos;)</div><div class=\"line\">    print item</div><div class=\"line\">    liens[10] = item</div><div class=\"line\"></div><div class=\"line\">for i in range(0,len(liens) - 1):</div><div class=\"line\">    liens[i] = liens[i] + &apos;\\n&apos;</div><div class=\"line\"></div><div class=\"line\">strings = &apos;&apos;.join(liens)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;project.pbxproj&apos;,&apos;w&apos;)</div><div class=\"line\">f.writelines(strings)</div><div class=\"line\">f.close()</div></pre></td></tr></table></figure>\n<p>这里我们使用到了pycrypto库，安装的时候需要先卸载<br><code>sudo pip uninstall crypto</code><br><code>sudo pip uninstall pycrypto</code></p>\n<p>然后<br><code>sudo pip install pycrypto</code>这样就安装好了需要的库</p>\n<p>关于我们加密那哪些东西，其实主要是project文件里边的解析文件，将一些关键是被符号进行加密，其实如果查看git操作记录是可以发现该如何还原的，这个时候就需要靠多行替换来增大替换的工作量来人为设置门槛</p>\n<p>另外需要配合改装的git，在commit的时候进行加密然后commit，在pull的时候也是解密然后commit一下，这样我们就做到了，在远端库里边是不能被直接有序查看的代码，在本地需要配合我们的git才能被顺畅的使用</p>\n"},{"title":"数据结构算法-概论","date":"2017-07-17T03:03:53.000Z","_content":"### 绪论\n- 算法不一定是程序，算法需要有穷性\n- 算法组重要的是效率，速度尽可能快，存储空间尽可能少\n- DSA\n\n### 方法论\n- 如果问题实例有很多，那么很明显我们无法一一解决，那么我们的思路就是对问题进行分类，然后去解决这一类问题\n- 如果你想改进和优化一个东西，你首先需要能够准确的测量它，你需要一把尺子\n- 复杂的问题只有简化之后我们才能抓住主要的矛盾，而简化的方法就是忽略那些不重要的东西\n- 去粗存精\n- 迭代乃人工，递归乃神通\n- 凡治众如治寡，分而治之\n- 复杂问题分解为两个，一个是规模减小的问题，另一个是平凡问题\n\n\n\n### 算法分析\n时间成本和空间成本，我们更关注时间成本\n\n## 渐进分析\n\n### 大O记号\n\nn足够大的时候成立就好\n\n- 常数项可忽略\n- 低次项可忽略\n\n![大O](../images/Ojihao.png)\n\n#### 具体的刻度\n- O(1)，再大的常数都是这个复杂度2023x239238\n- O(logn)\n- O(n^c)多项式复杂度\n\n### 复杂度分析主要方法\n- 迭代：级数求和\n- 递归：递归跟踪和递归方程\n- 猜测+验证\n\n#### 级数(迭代)\n![](../images/jishu.png)\n![](../images/jishu1.png)\n![](../images/jishu2.png)\n![](../images/jishu3.png)\n\n估算：\n- 一天是10^5s\n- 一世纪是3 x 10^9\n- 普通的pc一秒是10^9次运算\n- 最厉害的机器是10^15次运算\n\n#### 递归(更高级的做法，但是效率不应最好)\n![](../images/fenerzhizhi.png)\n","source":"_posts/数据结构算法-概论.md","raw":"---\ntitle: 数据结构算法-概论\ndate: 2017-07-17 11:03:53\ntags:\n- 数据结构算法\n---\n### 绪论\n- 算法不一定是程序，算法需要有穷性\n- 算法组重要的是效率，速度尽可能快，存储空间尽可能少\n- DSA\n\n### 方法论\n- 如果问题实例有很多，那么很明显我们无法一一解决，那么我们的思路就是对问题进行分类，然后去解决这一类问题\n- 如果你想改进和优化一个东西，你首先需要能够准确的测量它，你需要一把尺子\n- 复杂的问题只有简化之后我们才能抓住主要的矛盾，而简化的方法就是忽略那些不重要的东西\n- 去粗存精\n- 迭代乃人工，递归乃神通\n- 凡治众如治寡，分而治之\n- 复杂问题分解为两个，一个是规模减小的问题，另一个是平凡问题\n\n\n\n### 算法分析\n时间成本和空间成本，我们更关注时间成本\n\n## 渐进分析\n\n### 大O记号\n\nn足够大的时候成立就好\n\n- 常数项可忽略\n- 低次项可忽略\n\n![大O](../images/Ojihao.png)\n\n#### 具体的刻度\n- O(1)，再大的常数都是这个复杂度2023x239238\n- O(logn)\n- O(n^c)多项式复杂度\n\n### 复杂度分析主要方法\n- 迭代：级数求和\n- 递归：递归跟踪和递归方程\n- 猜测+验证\n\n#### 级数(迭代)\n![](../images/jishu.png)\n![](../images/jishu1.png)\n![](../images/jishu2.png)\n![](../images/jishu3.png)\n\n估算：\n- 一天是10^5s\n- 一世纪是3 x 10^9\n- 普通的pc一秒是10^9次运算\n- 最厉害的机器是10^15次运算\n\n#### 递归(更高级的做法，但是效率不应最好)\n![](../images/fenerzhizhi.png)\n","slug":"数据结构算法-概论","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkr000osauadx5ku899","content":"<h3 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h3><ul>\n<li>算法不一定是程序，算法需要有穷性</li>\n<li>算法组重要的是效率，速度尽可能快，存储空间尽可能少</li>\n<li>DSA</li>\n</ul>\n<h3 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h3><ul>\n<li>如果问题实例有很多，那么很明显我们无法一一解决，那么我们的思路就是对问题进行分类，然后去解决这一类问题</li>\n<li>如果你想改进和优化一个东西，你首先需要能够准确的测量它，你需要一把尺子</li>\n<li>复杂的问题只有简化之后我们才能抓住主要的矛盾，而简化的方法就是忽略那些不重要的东西</li>\n<li>去粗存精</li>\n<li>迭代乃人工，递归乃神通</li>\n<li>凡治众如治寡，分而治之</li>\n<li>复杂问题分解为两个，一个是规模减小的问题，另一个是平凡问题</li>\n</ul>\n<h3 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>时间成本和空间成本，我们更关注时间成本</p>\n<h2 id=\"渐进分析\"><a href=\"#渐进分析\" class=\"headerlink\" title=\"渐进分析\"></a>渐进分析</h2><h3 id=\"大O记号\"><a href=\"#大O记号\" class=\"headerlink\" title=\"大O记号\"></a>大O记号</h3><p>n足够大的时候成立就好</p>\n<ul>\n<li>常数项可忽略</li>\n<li>低次项可忽略</li>\n</ul>\n<p><img src=\"../images/Ojihao.png\" alt=\"大O\"></p>\n<h4 id=\"具体的刻度\"><a href=\"#具体的刻度\" class=\"headerlink\" title=\"具体的刻度\"></a>具体的刻度</h4><ul>\n<li>O(1)，再大的常数都是这个复杂度2023x239238</li>\n<li>O(logn)</li>\n<li>O(n^c)多项式复杂度</li>\n</ul>\n<h3 id=\"复杂度分析主要方法\"><a href=\"#复杂度分析主要方法\" class=\"headerlink\" title=\"复杂度分析主要方法\"></a>复杂度分析主要方法</h3><ul>\n<li>迭代：级数求和</li>\n<li>递归：递归跟踪和递归方程</li>\n<li>猜测+验证</li>\n</ul>\n<h4 id=\"级数-迭代\"><a href=\"#级数-迭代\" class=\"headerlink\" title=\"级数(迭代)\"></a>级数(迭代)</h4><p><img src=\"../images/jishu.png\" alt=\"\"><br><img src=\"../images/jishu1.png\" alt=\"\"><br><img src=\"../images/jishu2.png\" alt=\"\"><br><img src=\"../images/jishu3.png\" alt=\"\"></p>\n<p>估算：</p>\n<ul>\n<li>一天是10^5s</li>\n<li>一世纪是3 x 10^9</li>\n<li>普通的pc一秒是10^9次运算</li>\n<li>最厉害的机器是10^15次运算</li>\n</ul>\n<h4 id=\"递归-更高级的做法，但是效率不应最好\"><a href=\"#递归-更高级的做法，但是效率不应最好\" class=\"headerlink\" title=\"递归(更高级的做法，但是效率不应最好)\"></a>递归(更高级的做法，但是效率不应最好)</h4><p><img src=\"../images/fenerzhizhi.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h3><ul>\n<li>算法不一定是程序，算法需要有穷性</li>\n<li>算法组重要的是效率，速度尽可能快，存储空间尽可能少</li>\n<li>DSA</li>\n</ul>\n<h3 id=\"方法论\"><a href=\"#方法论\" class=\"headerlink\" title=\"方法论\"></a>方法论</h3><ul>\n<li>如果问题实例有很多，那么很明显我们无法一一解决，那么我们的思路就是对问题进行分类，然后去解决这一类问题</li>\n<li>如果你想改进和优化一个东西，你首先需要能够准确的测量它，你需要一把尺子</li>\n<li>复杂的问题只有简化之后我们才能抓住主要的矛盾，而简化的方法就是忽略那些不重要的东西</li>\n<li>去粗存精</li>\n<li>迭代乃人工，递归乃神通</li>\n<li>凡治众如治寡，分而治之</li>\n<li>复杂问题分解为两个，一个是规模减小的问题，另一个是平凡问题</li>\n</ul>\n<h3 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h3><p>时间成本和空间成本，我们更关注时间成本</p>\n<h2 id=\"渐进分析\"><a href=\"#渐进分析\" class=\"headerlink\" title=\"渐进分析\"></a>渐进分析</h2><h3 id=\"大O记号\"><a href=\"#大O记号\" class=\"headerlink\" title=\"大O记号\"></a>大O记号</h3><p>n足够大的时候成立就好</p>\n<ul>\n<li>常数项可忽略</li>\n<li>低次项可忽略</li>\n</ul>\n<p><img src=\"../images/Ojihao.png\" alt=\"大O\"></p>\n<h4 id=\"具体的刻度\"><a href=\"#具体的刻度\" class=\"headerlink\" title=\"具体的刻度\"></a>具体的刻度</h4><ul>\n<li>O(1)，再大的常数都是这个复杂度2023x239238</li>\n<li>O(logn)</li>\n<li>O(n^c)多项式复杂度</li>\n</ul>\n<h3 id=\"复杂度分析主要方法\"><a href=\"#复杂度分析主要方法\" class=\"headerlink\" title=\"复杂度分析主要方法\"></a>复杂度分析主要方法</h3><ul>\n<li>迭代：级数求和</li>\n<li>递归：递归跟踪和递归方程</li>\n<li>猜测+验证</li>\n</ul>\n<h4 id=\"级数-迭代\"><a href=\"#级数-迭代\" class=\"headerlink\" title=\"级数(迭代)\"></a>级数(迭代)</h4><p><img src=\"../images/jishu.png\" alt=\"\"><br><img src=\"../images/jishu1.png\" alt=\"\"><br><img src=\"../images/jishu2.png\" alt=\"\"><br><img src=\"../images/jishu3.png\" alt=\"\"></p>\n<p>估算：</p>\n<ul>\n<li>一天是10^5s</li>\n<li>一世纪是3 x 10^9</li>\n<li>普通的pc一秒是10^9次运算</li>\n<li>最厉害的机器是10^15次运算</li>\n</ul>\n<h4 id=\"递归-更高级的做法，但是效率不应最好\"><a href=\"#递归-更高级的做法，但是效率不应最好\" class=\"headerlink\" title=\"递归(更高级的做法，但是效率不应最好)\"></a>递归(更高级的做法，但是效率不应最好)</h4><p><img src=\"../images/fenerzhizhi.png\" alt=\"\"></p>\n"},{"title":"利用hexo搭建团队博客系统","date":"2017-06-12T07:08:39.000Z","_content":"\n### hexo搭建个人博客的原理\n- 将md渲染为html\n- 将html以及资源文件上传到github，利用githubpages功能进行展示\n- 解析的过程是将目录下source/_post文件中的东西，渲染为publick中的html文件，然后将该文件夹下的文件复制到.deploy_git文件下，然后利用git操作将该文件夹下的文件push到对应的git库\n<!--more-->\n\n### 使用hexo制作团队博客的困难\n- 内网不能直接依赖于github\n- 团队开发的权限管理问题\n- 团队开发的作者识别问题\n- 团队开发的文件冲突问题\n\n\n### 问题的解决方案\n\n\n\n\n","source":"_posts/利用hexo搭建团队博客系统.md","raw":"---\ntitle: 利用hexo搭建团队博客系统\ndate: 2017-06-12 15:08:39\ntags:\n- python\n- hexo\n---\n\n### hexo搭建个人博客的原理\n- 将md渲染为html\n- 将html以及资源文件上传到github，利用githubpages功能进行展示\n- 解析的过程是将目录下source/_post文件中的东西，渲染为publick中的html文件，然后将该文件夹下的文件复制到.deploy_git文件下，然后利用git操作将该文件夹下的文件push到对应的git库\n<!--more-->\n\n### 使用hexo制作团队博客的困难\n- 内网不能直接依赖于github\n- 团队开发的权限管理问题\n- 团队开发的作者识别问题\n- 团队开发的文件冲突问题\n\n\n### 问题的解决方案\n\n\n\n\n","slug":"利用hexo搭建团队博客系统","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pks000psaua9cnonjub","content":"<h3 id=\"hexo搭建个人博客的原理\"><a href=\"#hexo搭建个人博客的原理\" class=\"headerlink\" title=\"hexo搭建个人博客的原理\"></a>hexo搭建个人博客的原理</h3><ul>\n<li>将md渲染为html</li>\n<li>将html以及资源文件上传到github，利用githubpages功能进行展示</li>\n<li>解析的过程是将目录下source/_post文件中的东西，渲染为publick中的html文件，然后将该文件夹下的文件复制到.deploy_git文件下，然后利用git操作将该文件夹下的文件push到对应的git库<a id=\"more\"></a>\n</li>\n</ul>\n<h3 id=\"使用hexo制作团队博客的困难\"><a href=\"#使用hexo制作团队博客的困难\" class=\"headerlink\" title=\"使用hexo制作团队博客的困难\"></a>使用hexo制作团队博客的困难</h3><ul>\n<li>内网不能直接依赖于github</li>\n<li>团队开发的权限管理问题</li>\n<li>团队开发的作者识别问题</li>\n<li>团队开发的文件冲突问题</li>\n</ul>\n<h3 id=\"问题的解决方案\"><a href=\"#问题的解决方案\" class=\"headerlink\" title=\"问题的解决方案\"></a>问题的解决方案</h3>","site":{"data":{}},"excerpt":"<h3 id=\"hexo搭建个人博客的原理\"><a href=\"#hexo搭建个人博客的原理\" class=\"headerlink\" title=\"hexo搭建个人博客的原理\"></a>hexo搭建个人博客的原理</h3><ul>\n<li>将md渲染为html</li>\n<li>将html以及资源文件上传到github，利用githubpages功能进行展示</li>\n<li>解析的过程是将目录下source/_post文件中的东西，渲染为publick中的html文件，然后将该文件夹下的文件复制到.deploy_git文件下，然后利用git操作将该文件夹下的文件push到对应的git库","more":"</li>\n</ul>\n<h3 id=\"使用hexo制作团队博客的困难\"><a href=\"#使用hexo制作团队博客的困难\" class=\"headerlink\" title=\"使用hexo制作团队博客的困难\"></a>使用hexo制作团队博客的困难</h3><ul>\n<li>内网不能直接依赖于github</li>\n<li>团队开发的权限管理问题</li>\n<li>团队开发的作者识别问题</li>\n<li>团队开发的文件冲突问题</li>\n</ul>\n<h3 id=\"问题的解决方案\"><a href=\"#问题的解决方案\" class=\"headerlink\" title=\"问题的解决方案\"></a>问题的解决方案</h3>"},{"title":"深度学习概论","date":"2017-06-16T09:42:33.000Z","_content":"\n### 深度学习与神经网络\n首先人工智能范畴大于机器学习，深度学习是机器学习的一个分支，深度学习的深度指的就是多层的神经网络，所以多层神经网络=深度学习\n","source":"_posts/深度学习概论.md","raw":"---\ntitle: 深度学习概论\ndate: 2017-06-16 17:42:33\ntags:\n- 深度学习\n---\n\n### 深度学习与神经网络\n首先人工智能范畴大于机器学习，深度学习是机器学习的一个分支，深度学习的深度指的就是多层的神经网络，所以多层神经网络=深度学习\n","slug":"深度学习概论","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkv000ssauaw82fwtyw","content":"<h3 id=\"深度学习与神经网络\"><a href=\"#深度学习与神经网络\" class=\"headerlink\" title=\"深度学习与神经网络\"></a>深度学习与神经网络</h3><p>首先人工智能范畴大于机器学习，深度学习是机器学习的一个分支，深度学习的深度指的就是多层的神经网络，所以多层神经网络=深度学习</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"深度学习与神经网络\"><a href=\"#深度学习与神经网络\" class=\"headerlink\" title=\"深度学习与神经网络\"></a>深度学习与神经网络</h3><p>首先人工智能范畴大于机器学习，深度学习是机器学习的一个分支，深度学习的深度指的就是多层的神经网络，所以多层神经网络=深度学习</p>\n"},{"title":"算法题汇总","date":"2017-07-18T01:43:22.000Z","_content":"\nGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\n\n```\nExample 1:\nInput: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n```\n\n这了做法是先排序，然后每两个一组，取小的，取大小本来就是python的功能，min和max函数\n其实python也提供了sorted排序函数，而且相当的高效，我自己试了一下排序算法，并没有python做的好\n```\nclass Solution(object):\n    \n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        itemcurrent = sorted(nums)\n        \n        n = len(itemcurrent) / 2\n\n        total = 0\n\n        for i in range(n):\n            a = itemcurrent[2 * i]\n            b = itemcurrent[2 * i + 1]\n            c = min(a,b)\n            total = total + c\n\n        return total\n```","source":"_posts/算法题汇总.md","raw":"---\ntitle: 算法题汇总\ndate: 2017-07-18 09:43:22\ntags:\n---\n\nGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\n\n```\nExample 1:\nInput: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n```\n\n这了做法是先排序，然后每两个一组，取小的，取大小本来就是python的功能，min和max函数\n其实python也提供了sorted排序函数，而且相当的高效，我自己试了一下排序算法，并没有python做的好\n```\nclass Solution(object):\n    \n    def arrayPairSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        itemcurrent = sorted(nums)\n        \n        n = len(itemcurrent) / 2\n\n        total = 0\n\n        for i in range(n):\n            a = itemcurrent[2 * i]\n            b = itemcurrent[2 * i + 1]\n            c = min(a,b)\n            total = total + c\n\n        return total\n```","slug":"算法题汇总","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkw000tsauaxyj2c3xy","content":"<p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Example 1:</div><div class=\"line\">Input: [1,4,3,2]</div><div class=\"line\"></div><div class=\"line\">Output: 4</div><div class=\"line\">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</div></pre></td></tr></table></figure>\n<p>这了做法是先排序，然后每两个一组，取小的，取大小本来就是python的功能，min和max函数<br>其实python也提供了sorted排序函数，而且相当的高效，我自己试了一下排序算法，并没有python做的好<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    </div><div class=\"line\">    def arrayPairSum(self, nums):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type nums: List[int]</div><div class=\"line\">        :rtype: int</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        itemcurrent = sorted(nums)</div><div class=\"line\">        </div><div class=\"line\">        n = len(itemcurrent) / 2</div><div class=\"line\"></div><div class=\"line\">        total = 0</div><div class=\"line\"></div><div class=\"line\">        for i in range(n):</div><div class=\"line\">            a = itemcurrent[2 * i]</div><div class=\"line\">            b = itemcurrent[2 * i + 1]</div><div class=\"line\">            c = min(a,b)</div><div class=\"line\">            total = total + c</div><div class=\"line\"></div><div class=\"line\">        return total</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Example 1:</div><div class=\"line\">Input: [1,4,3,2]</div><div class=\"line\"></div><div class=\"line\">Output: 4</div><div class=\"line\">Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</div></pre></td></tr></table></figure>\n<p>这了做法是先排序，然后每两个一组，取小的，取大小本来就是python的功能，min和max函数<br>其实python也提供了sorted排序函数，而且相当的高效，我自己试了一下排序算法，并没有python做的好<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution(object):</div><div class=\"line\">    </div><div class=\"line\">    def arrayPairSum(self, nums):</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        :type nums: List[int]</div><div class=\"line\">        :rtype: int</div><div class=\"line\">        &quot;&quot;&quot;</div><div class=\"line\">        itemcurrent = sorted(nums)</div><div class=\"line\">        </div><div class=\"line\">        n = len(itemcurrent) / 2</div><div class=\"line\"></div><div class=\"line\">        total = 0</div><div class=\"line\"></div><div class=\"line\">        for i in range(n):</div><div class=\"line\">            a = itemcurrent[2 * i]</div><div class=\"line\">            b = itemcurrent[2 * i + 1]</div><div class=\"line\">            c = min(a,b)</div><div class=\"line\">            total = total + c</div><div class=\"line\"></div><div class=\"line\">        return total</div></pre></td></tr></table></figure></p>\n"},{"title":"自然语言处理概念基础","date":"2017-06-27T04:23:08.000Z","_content":"markAllAsReadSuccess\n分词，词频，词性\n\nhttps://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&source=jrm&sid=\n\nhttp://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&source=jrm\n\n\n","source":"_posts/自然语言处理概念基础.md","raw":"---\ntitle: 自然语言处理概念基础\ndate: 2017-06-27 12:23:08\ntags:\n---\nmarkAllAsReadSuccess\n分词，词频，词性\n\nhttps://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&source=jrm&sid=\n\nhttp://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&source=jrm\n\n\n","slug":"自然语言处理概念基础","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pkx000vsaua02ya8aeq","content":"<p>markAllAsReadSuccess<br>分词，词频，词性</p>\n<p><a href=\"https://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&amp;source=jrm&amp;sid=\" target=\"_blank\" rel=\"external\">https://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&amp;source=jrm&amp;sid=</a></p>\n<p><a href=\"http://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&amp;source=jrm\" target=\"_blank\" rel=\"external\">http://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&amp;source=jrm</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>markAllAsReadSuccess<br>分词，词频，词性</p>\n<p><a href=\"https://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&amp;source=jrm&amp;sid=\" target=\"_blank\" rel=\"external\">https://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000103&amp;source=jrm&amp;sid=</a></p>\n<p><a href=\"http://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&amp;source=jrm\" target=\"_blank\" rel=\"external\">http://m.jr.jd.com/bzx/fillpolicy.html?iteamid=10000901&amp;source=jrm</a></p>\n"},{"title":"NSString && NSData","date":"2016-11-15T10:08:53.000Z","_content":"### 内存简述，Copy与Strong关键字\n#### 内存简述\n为了方便观察引用计数，这里在MRC下来进行测试。先重新定义NSLog让其不打印时间戳。再编写一个打印宏，用来打印NSString对象的类、内存地址、值、引用计数。\n<!--more-->\n```\n#define NSLog(FORMAT, ...) fprintf(stderr,\"%s\\n\",[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);\n#define YLog(_var) ({ NSString *name = @#_var; NSLog(@\"%@: %@ -> %p : %@  %tu\", name, [_var class], _var, _var, [_var retainCount]); })\n```\n再新建一个StrObject类，用于测试。该类创建实例时，将打印一个NSString，内容为\"Str\"。\n```\n@interface StrObject : NSObject\n\n@end\n\n@implementation StrObject\n\n- (id)init {\n\n  self = [super init];\n\n  if (self) {\n    NSLog(@\"StrObj Create\");\n    NSString *strA = @\"Str\";\n    YLog(strA);\n}\n\nreturn self;\n}\n\n- (void)dealloc {\n\n  [super dealloc];\n\n  NSLog(@\"StrObj Dealloc\");\n}\n```\n之后运行以下代码。\n（一般来说我们可以用以下几种方法来创建NSString对象，其中stringWithString在iOS 6之后已变为多余的方法（redundant），因其等同于字面量创建法，使用这方法编译器会给出警告，）\n\n```\n//创建并释放StrObject对象\nStrObject *obj = [StrObject new];\n[obj release];\n\n//创建一些字符串\nNSString *str1 = @\"Str\"; YLog(str1);\nNSString *str2 = @\"Str\"; YLog(str2);\nNSString *str3 = [NSString stringWithString:@\"Str\"]; YLog(str3);\nNSString *str4 = [NSString stringWithFormat:@\"Str\"]; YLog(str4);\nNSString *str5 = [str1 retain]; YLog(str5);\nNSString *str6 = [str1 copy]; YLog(str6);\nNSString *str7 = [str1 mutableCopy]; YLog(str7);\n\n//改变NSString变量的字符串内容\nstr1 = @\"StrNew\"; YLog(str1);\nstr2 = str1; YLog(str2);\n\n//创建一个字符串并将其释放\nNSString *str8 = @\"Str\";\n[str8 retain];\n[str8 release];\n[str8 release];\nYLog(str8);\n\n//=======输出结果========\n//创建并释放StrObject对象\n//StrObj Create\n//strA: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//StrObj Dealloc\n\n//创建一些字符串\n//str1: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str2: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str3: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str4: NSTaggedPointerString -> 0xa000000007274533 : Str  18446744073709551615\n//str5: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str6: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str7: __NSCFString -> 0x7f951a409c80 : Str  1\n\n//改变NSString变量的字符串内容\n//str1: __NSCFConstantString -> 0x10d2ce1e8 : StrNew  18446744073709551615\n//str2: __NSCFConstantString -> 0x10d2ce1e8 : StrNew  18446744073709551615\n\n//创建一个字符串并将其释放\n//str8: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n```\n\n可观察到，虽然我们通过不同方法创建了不同的NSString对象，但字符串内容一致，结果显示strA、str1、str2、str3、str5、str6都指向同一个地址。即便@\"Str\"首先在StrObject对象中出现，赋值给strA，释放了之后，str1和其他对象仍然指向同一个地址。\n\n将一个新的字符串内容@\"Str a\"赋值给str1，并且将str1赋值给str2后，从结果看到str1、str2的内存地址改变了，且指向同一个地址。\n\n之后创建的str8，对其进行多次release后，内存地址（和strA地址相同）和retaionCount都不曾变化。\n\n##### __NSCFConstantString\n\n这些对象地址相同，是因为他们都是__NSCFConstantString对象，也就是字符串常量对象，可以看到其isa都是__NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。\n\n当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。\n\n总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。\n\n##### __NSCFString\n\n在上面的输出结果中，我们看到另外还有两类isa分别是：__NSCFString和NSTaggedPointerString，先来看__NSCFString。\n\n在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。\n```\nNSString *str1 = [NSString stringWithFormat:@\"ThisIsAStr\"];\nYLog(str1);\nNSString *str2 = [str1 retain];\nYLog(str1);\nYLog(str2);\n\nNSString *str3 = [str1 copy];\nYLog(str1);\nYLog(str2);\nYLog(str3);\n\n//输出结果\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  1\n\n//str1 retain后赋值给str2\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n\n//str3由str1浅复制得来\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n//str3: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n\n//对str1进行release\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str3: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n```\n##### NSTaggedPointerString\n\n这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。\n\n对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。\n\n```\nNSString *str1 = @\"123456789\"; YLog(str1);\nNSString *str2 = [NSString stringWithFormat:@\"123456789\"]; YLog(str2);\nNSString *str3 = [NSString stringWithFormat:@\"1234567890\"]; YLog(str3);\nNSString *str4 = [NSString stringWithFormat:@\"五\"]; YLog(str4);\n\n//输出结果\n//str1: __NSCFConstantString -> 0x10a0c5108 : 123456789  18446744073709551615\n//str2: NSTaggedPointerString -> 0xa1ea1f72bb30ab19 : 123456789  18446744073709551615\n//str3: __NSCFString -> 0x7f8183c02630 : 1234567890  1\n//str4: __NSCFString -> 0x7f8183c0fae0 : 五  1\n```\n\n#### 声明NSSting为属性时用copy还是strong\n声明NSString属性一般来说用copy，因为父类指针可以指向子类对象，而NSMutableNSString是NSString的子类，使用strong的话该NSString属性可能指向一个NSMutableNSString可变对象，如果这个可变对象的内容在外部被修改了，那该属性所属的对象可能对此毫不知情。\n\n先来看正常的情况，NSString属性指向一个不可变对象。\n```\n//Person对象\n@interface Person : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n\n@implementation Person\n@end\n\n//测试代码\nNSString *strA = @\"Susan_Miller\";\nPerson *personA = [Person new];\npersonA.name = strA;\nYLog(strA);\nYLog(personA.name);\n\nstrA = @\"Susan_Test\";\nYLog(strA);\nYLog(personA.name);\n\n//输出结果\n//strA: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n//personA.name: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n//strA: __NSCFConstantString -> 0x102f20148 : Susan_Test  18446744073709551615\n//personA.name: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n```\n\n从结果可观察到此时的name属性指向一个不可变的字符串常量，就算strA因为内容变化而生成了新地址，对name属性不会有影响，无论声明name属性时关键字用copy还是strong（不可变对象的copy是浅复制，strong也是指针引用，所以strA内容改变后地址同时改变，不会影响name属性）。\n\n再来看name属性指向一个可变对象的情况，属性关键字用strong。\n```\n//属性关键字为strong\n@property (nonatomic, strong) NSString *name;\n\n//测试代码\nNSMutableString *strB = [@\"Susan_Miller\" mutableCopy];\nPerson *personB = [Person new];\npersonB.name = strB;\nYLog(strB);\nYLog(personB.name);\n\n[strB setString:@\"Susan_Test\"];\nYLog(strB);\nYLog(personB.name);\n\n//输出结果\n//strB: __NSCFString -> 0x7ff9b2c1a090 : Susan_Miller  2\n//personB.name: __NSCFString -> 0x7ff9b2c1a090 : Susan_Miller  2\n//strB: __NSCFString -> 0x7ff9b2c1a090 : Susan_Test  2\n//personB.name: __NSCFString -> 0x7ff9b2c1a090 : Susan_Test  2\n```\n从结果可看出，name属性指向了一个可变对象strB，当strB的内容改变时，name属性也跟着改变，而person对此不知情，可能会产生错误。\n\n继续来看name属性关键字使用copy时的情况。\n```\n//属性关键字为copy\n@property (nonatomic, copy) NSString *name;\n\n//测试代码\nNSMutableString *strB = [@\"Susan_Miller\" mutableCopy];\nPerson *personB = [Person new];\npersonB.name = strB;\nYLog(strB);\nYLog(personB.name);\n\n[strB setString:@\"Susan_Test\"];\nYLog(strB);\nYLog(personB.name);\n\n//输出结果\n//strB: __NSCFString -> 0x7fb15af31360 : Susan_Miller  1**\n//personB.name: __NSCFString -> 0x7fb15af26620 : Susan_Miller  1**\n//strB: __NSCFString -> 0x7fb15af31360 : Susan_Test  1**\n//personB.name: __NSCFString -> 0x7fb15af26620 : Susan_Miller  1**\n```\n此时，因为对NSMutableString进行copy是深复制（即内容拷贝），所以name属性与strB指向不同的地址，strB的内容更改不会影响到name属性。\n\n所以，声明NSString为属性时，如果希望保护属性封装性不受外界影响，则应该使用copy关键字，让所属对象持有的是一份“不可变”（immutable）副本，不用担心字符串内容无意间变动。\n\n### 去除字符串中的中文\n```\n- (NSString *)removeChinese:(NSString *)string {\n\n    NSString *chi = [self getChineseStringWithString:string];\n\n    return [string stringByReplacingOccurrencesOfString:chi withString:@\"\"];\n}\n\n- (NSString *)getChineseStringWithString:(NSString *)string\n{\n    //(unicode中文编码范围是0x4e00~0x9fa5)\n    for (int i = 0; i < string.length; i++) {\n        int utfCode = 0;\n        void *buffer = &utfCode;\n        NSRange range = NSMakeRange(i, 1);\n\n        BOOL b = [string getBytes:buffer maxLength:2 usedLength:NULL encoding:NSUTF16LittleEndianStringEncoding options:NSStringEncodingConversionExternalRepresentation range:range remainingRange:NULL];\n\n        if (b && (utfCode >= 0x4e00 && utfCode <= 0x9fa5)) {\n            return [string substringFromIndex:i];\n        }\n    }\n    return nil;\n}\n```\n\n### - (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用\n\n### NSString的各种转换\n#### NSData 与 NSString\n```\n　　NSData --> NSString\n　　NSString *aString = [[NSString alloc] initWithData:adata encoding:NSUTF8StringEncoding];\n　　NSString --> NSData\n　　NSString *aString = @\"1234\";\n　　NSData *aData = [aString dataUsingEncoding: NSUTF8StringEncoding];\n```\n\n#### NSString转化为UNICODE String：\n```\n(NSString*)fname ＝ @“Test”;\nchar fnameStr[10];\nmemcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));\n与strcpy相比，memcpy并不是遇到'\\0'就结束，而是一定会拷贝完n个字节\n```\n\n#### NSString 转化为 char *\n```\nNSString * str＝ @“Test”;\nconst char * a =[str UTF8String];\n```\n\n#### char * 转化为 NSString\n```\nNSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding];\n```\n\n#### char * 转化 NSData\n```\n方法一： char * a = (char*)malloc(sizeof(byte)*16); NSData *data = [NSData dataWithBytes: a length:strlen(a)]; \n方法二： 转换为NSString： - (id)initWithUTF8String:(const char *)bytes 然后用NSString的 - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding\n```\n\n#### NSData 转化 char *\n```\nNSData data ； \nchar* a=[data bytes];\n```\n\n#### NSString 转化 NSURL\n```\n//NSURL *url = [NSURL URLWithString:[str  stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]];\n\nNSString *urlString=[@\"http://www.google.com/search?client=safari&rls=en&q=搜索&ie=UTF-8&oe=UTF-8\" stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n\n#### NSURL 转化 NSString\n```\nNSURL *url=[NSURL URLWithString:urlString];\n\nNSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n\n#### NSData 与 Byte\n```\n　　NSData --> Byte\n　　NSString *testString = @\"1234567890\";\n　　NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding];\n　　Byte *testByte = (Byte *)[testData bytes];\n　　Byte --> NSData\n　　Byte byte[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23};\n　　NSData *adata = [[NSData alloc] initWithBytes:byte length:24];\n```\n#### NSData 与 UIImage\n```\n　　NSData --> UIImage\n　　UIImage *aimage = [UIImage imageWithData: imageData];\n　　//例：从本地文件沙盒中取图片并转换为NSData\n　　NSString *path = [[NSBundle mainBundle] bundlePath];\n　　NSString *name = [NSString stringWithFormat:@\"ceshi.png\"];\n　　NSString *finalPath = [path stringByAppendingPathComponent:name];\n　　NSData *imageData = [NSData dataWithContentsOfFile: finalPath];\n　　UIImage *aimage = [UIImage imageWithData: imageData];\n　　UIImage－> NSData\n　　NSData *imageData = UIImagePNGRepresentation(aimae);\n```\n#### NSData 与 NSMutableData\n```\n　　NSData --> MSMutableData\n　　NSData *data=[[NSData alloc]init];\n　　NSMutableData *mdata=[[NSMutableData alloc]init];\n　　mdata=[NSData dataWithData:data];\n```\n#### NSData合并为一个NSMutableData\n```\n- (NSString *)filePathWithName:(NSString *)filename\n{\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nreturn [documentsDirectory stringByAppendingPathComponent:filename];\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n//音频文件路径\nNSString *mp3Path1 = [[NSBundle mainBundle] pathForResource:@\"1\" ofType:@\"mp3\"];\nNSString *mp3Path2 = [[NSBundle mainBundle] pathForResource:@\"2\" ofType:@\"mp3\"];\n//音频数据\nNSData *sound1Data = [[NSData alloc] initWithContentsOfFile: mp3Path1];\nNSData *sound2Data = [[NSData alloc] initWithContentsOfFile: mp3Path2];\n//合并音频\nNSMutableData *sounds = [NSMutableData alloc];\n[sounds appendData:sound1Data];\n[sounds appendData:sound2Data];\n//保存音频\n\nNSLog(@\"data length:%d\", [sounds length]);\n\n[sounds writeToFile:[self filePathWithName:@\"tmp.mp3\"] atomically:YES];\n\n[window makeKeyAndVisible];\n\nreturn YES;\n}\n```\n\n### 转译字符\n> 转义字符 意义 ASCII码值(十进制)\n\\a 响铃(BEL) 007\n\\b 退格(BS) 008\n\\f 换页(FF) 012\n\\n 换行(LF) 010\n\\r 回车(CR) 013\n\\t 水平制表(HT) 009\n\\v 垂直制表(VT) 011\n\\\\ 反斜杠 092\n\\? 问号字符 063\n\\' 单引号字符 039\n\\\" 双引号字符 034\n\\0 空字符(NULL) 000\n\\ddd 任意字符 三位八进制\n\\xhh 任意字符 二位十六进制\n\\a:蜂鸣，响铃\n\\b:回退：向后退一格\n\\f:换页\n\\n:换行，光标到下行行首\n\\r:回车，光标到本行行首\n\\t:水平制表\n\\v:垂直制表\n\\\\:反斜杠\n\\':单引号\n\\\":双引号\n\\?:问号\n\\ddd:三位八进制\n\\xhh:二位十六进制\n\\0:空字符(NULL),什么都不做\n注：\n1，\\v垂直制表和\\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。\n2，\\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。\n3，\\t 光标向前移动四格或八格，可以在编译器里设置\n4，\\' 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ' 即可。\n5，\\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。\n\n\n### 常用的富文本\n#### 单纯改变一句话中的某些字的颜色（一种颜色）\n```\n/**\n*  单纯改变一句话中的某些字的颜色（一种颜色）\n*\n*  @param color    需要改变成的颜色\n*  @param totalStr 总的字符串\n*  @param subArray 需要改变颜色的文字数组(要是有相同的 只取第一个)\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeCorlorWithColor:(UIColor *)color TotalString:(NSString *)totalStr SubStringArray:(NSArray *)subArray {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalStr];\nfor (NSString *rangeStr in subArray) {\n\nNSRange range = [totalStr rangeOfString:rangeStr options:NSBackwardsSearch];\n[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];\n}\n\nreturn attributedStr;\n}\n```\n\n#### 改变每行的字间距\n```\n/**\n*  单纯改变句子的字间距（需要 <CoreText/CoreText.h>）\n*\n*  @param totalString 需要更改的字符串\n*  @param space       字间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeSpaceWithTotalString:(NSString *)totalString Space:(CGFloat)space {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\nlong number = space;\nCFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&number);\n[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];\nCFRelease(num);\n\nreturn attributedStr;\n}\n```\n\n#### 改变行间距\n```\n/**\n*  单纯改变段落的行间距\n*\n*  @param totalString 需要更改的字符串\n*  @param lineSpace   行间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeLineSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nNSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];\n[paragraphStyle setLineSpacing:lineSpace];\n\n[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];\n\nreturn attributedStr;\n}\n```\n\n#### 同时更改行间距和字间距\n```\n/**\n*  同时更改行间距和字间距\n*\n*  @param totalString 需要改变的字符串\n*  @param lineSpace   行间距\n*  @param textSpace   字间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeLineAndTextSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace textSpace:(CGFloat)textSpace {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nNSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];\n[paragraphStyle setLineSpacing:lineSpace];\n\n[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];\n\nlong number = textSpace;\nCFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&number);\n[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];\nCFRelease(num);\n\nreturn attributedStr;\n}\n```\n\n#### 更改某些文字的颜色并修改其字体，突出重点强调\n```\n/**\n*  改变某些文字的颜色 并单独设置其字体\n*\n*  @param font        设置的字体\n*  @param color       颜色\n*  @param totalString 总的字符串\n*  @param subArray    想要变色的字符数组\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeFontAndColor:(UIFont *)font Color:(UIColor *)color TotalString:(NSString *)totalString SubStringArray:(NSArray *)subArray {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nfor (NSString *rangeStr in subArray) {\n\nNSRange range = [totalString rangeOfString:rangeStr options:NSBackwardsSearch];\n\n[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];\n[attributedStr addAttribute:NSFontAttributeName value:font range:range];\n}\n\nreturn attributedStr;\n```\n\n### 富文本相关属性汇总\n>- NSFontAttributeName ：字体字号\n    - value值：UIFont类型\n- NSParagraphStyleAttributeName ： 段落样式\n    - value值：NSParagraphStyle类型（其属性如下）\n    - lineSpacing 行间距(具体用法可查看上面的设置行间距API)\n    - paragraphSpacing 段落间距\n    - alignment 对齐方式\n    - firstLineHeadIndent 指定段落开始的缩进像素\n    - headIndent 调整全部文字的缩进像素\n- NSForegroundColorAttributeName 字体颜色\n    - value值：UIColor类型\n- NSBackgroundColorAttributeName 背景颜色\n    - value值：UIColor类型\n- NSObliquenessAttributeName 字体粗倾斜\n    - value值：NSNumber类型\n- NSExpansionAttributeName 字体加粗\n    - value值：NSNumber类型(比例) 0就是不变 1增加一倍\n- NSKernAttributeName 字间距\n    - value值：CGFloat类型\n- NSUnderlineStyleAttributeName 下划线\n    - value值：1或0\n- NSUnderlineColorAttributeName 下划线颜色\n    - value值：UIColor类型\n- NSStrikethroughStyleAttributeName 删除线\n    - value值：1或0\n- NSStrikethroughColorAttributeName 删除线颜色\n    - value值：UIColor类型\n- NSStrokeColorAttributeName 字体颜色\n    - value值：UIColor类型\n- NSStrokeWidthAttributeName 字体描边\n    - value值：CGFloat\n- NSLigatureAttributeName 连笔字\n    - value值：1或0\n- NSShadowAttributeName 阴影\n    - value值：NSShawdow类型（下面是其属性）\n    - shadowOffset 影子与字符串的偏移量\n    - shadowBlurRadius 影子的模糊程度\n    - shadowColor 影子的颜色\n- NSTextEffectAttributeName 设置文本特殊效果,目前只有图版印刷效果可用\n    - value值：NSString类型\n- NSAttachmentAttributeName 设置文本附件\n    - value值：NSTextAttachment类型（没研究过，可自行百度研究）\n- NSLinkAttributeName 链接\n    - value值：NSURL (preferred) or NSString类型\n- NSBaselineOffsetAttributeName 基准线偏移\n    - value值：NSNumber类型\n- NSWritingDirectionAttributeName 文字方向 分别代表不同的文字出现方向\n    - value值：@[@(1),@(2)]\n- NSVerticalGlyphFormAttributeName 水平或者竖直文本 在iOS没卵用，不支持竖版\n    - value值：1竖直 0水平\n\n### 获取汉字的拼音 \n```\n+ (NSString *)transform:(NSString *)chinese\n{\n//将NSString装换成NSMutableString\nNSMutableString *pinyin = [chinese mutableCopy];\n//将汉字转换为拼音(带音标)\nCFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);\nNSLog(@\"%@\", pinyin);\n//去掉拼音的音标\nCFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);\nNSLog(@\"%@\", pinyin);\n//返回最近结果\nreturn pinyin;\n}\n```\n","source":"_posts/2014/Foundation系列-NSString.md","raw":"---\ntitle: NSString && NSData\ndate: 2016-11-15 18:08:53\ntags:\n- iOS\n---\n### 内存简述，Copy与Strong关键字\n#### 内存简述\n为了方便观察引用计数，这里在MRC下来进行测试。先重新定义NSLog让其不打印时间戳。再编写一个打印宏，用来打印NSString对象的类、内存地址、值、引用计数。\n<!--more-->\n```\n#define NSLog(FORMAT, ...) fprintf(stderr,\"%s\\n\",[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);\n#define YLog(_var) ({ NSString *name = @#_var; NSLog(@\"%@: %@ -> %p : %@  %tu\", name, [_var class], _var, _var, [_var retainCount]); })\n```\n再新建一个StrObject类，用于测试。该类创建实例时，将打印一个NSString，内容为\"Str\"。\n```\n@interface StrObject : NSObject\n\n@end\n\n@implementation StrObject\n\n- (id)init {\n\n  self = [super init];\n\n  if (self) {\n    NSLog(@\"StrObj Create\");\n    NSString *strA = @\"Str\";\n    YLog(strA);\n}\n\nreturn self;\n}\n\n- (void)dealloc {\n\n  [super dealloc];\n\n  NSLog(@\"StrObj Dealloc\");\n}\n```\n之后运行以下代码。\n（一般来说我们可以用以下几种方法来创建NSString对象，其中stringWithString在iOS 6之后已变为多余的方法（redundant），因其等同于字面量创建法，使用这方法编译器会给出警告，）\n\n```\n//创建并释放StrObject对象\nStrObject *obj = [StrObject new];\n[obj release];\n\n//创建一些字符串\nNSString *str1 = @\"Str\"; YLog(str1);\nNSString *str2 = @\"Str\"; YLog(str2);\nNSString *str3 = [NSString stringWithString:@\"Str\"]; YLog(str3);\nNSString *str4 = [NSString stringWithFormat:@\"Str\"]; YLog(str4);\nNSString *str5 = [str1 retain]; YLog(str5);\nNSString *str6 = [str1 copy]; YLog(str6);\nNSString *str7 = [str1 mutableCopy]; YLog(str7);\n\n//改变NSString变量的字符串内容\nstr1 = @\"StrNew\"; YLog(str1);\nstr2 = str1; YLog(str2);\n\n//创建一个字符串并将其释放\nNSString *str8 = @\"Str\";\n[str8 retain];\n[str8 release];\n[str8 release];\nYLog(str8);\n\n//=======输出结果========\n//创建并释放StrObject对象\n//StrObj Create\n//strA: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//StrObj Dealloc\n\n//创建一些字符串\n//str1: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str2: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str3: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str4: NSTaggedPointerString -> 0xa000000007274533 : Str  18446744073709551615\n//str5: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str6: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n//str7: __NSCFString -> 0x7f951a409c80 : Str  1\n\n//改变NSString变量的字符串内容\n//str1: __NSCFConstantString -> 0x10d2ce1e8 : StrNew  18446744073709551615\n//str2: __NSCFConstantString -> 0x10d2ce1e8 : StrNew  18446744073709551615\n\n//创建一个字符串并将其释放\n//str8: __NSCFConstantString -> 0x10d2ce088 : Str  18446744073709551615\n```\n\n可观察到，虽然我们通过不同方法创建了不同的NSString对象，但字符串内容一致，结果显示strA、str1、str2、str3、str5、str6都指向同一个地址。即便@\"Str\"首先在StrObject对象中出现，赋值给strA，释放了之后，str1和其他对象仍然指向同一个地址。\n\n将一个新的字符串内容@\"Str a\"赋值给str1，并且将str1赋值给str2后，从结果看到str1、str2的内存地址改变了，且指向同一个地址。\n\n之后创建的str8，对其进行多次release后，内存地址（和strA地址相同）和retaionCount都不曾变化。\n\n##### __NSCFConstantString\n\n这些对象地址相同，是因为他们都是__NSCFConstantString对象，也就是字符串常量对象，可以看到其isa都是__NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。\n\n当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。\n\n总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。\n\n##### __NSCFString\n\n在上面的输出结果中，我们看到另外还有两类isa分别是：__NSCFString和NSTaggedPointerString，先来看__NSCFString。\n\n在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。\n```\nNSString *str1 = [NSString stringWithFormat:@\"ThisIsAStr\"];\nYLog(str1);\nNSString *str2 = [str1 retain];\nYLog(str1);\nYLog(str2);\n\nNSString *str3 = [str1 copy];\nYLog(str1);\nYLog(str2);\nYLog(str3);\n\n//输出结果\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  1\n\n//str1 retain后赋值给str2\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n\n//str3由str1浅复制得来\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n//str3: __NSCFString -> 0x100206c70 : ThisIsAStr  3\n\n//对str1进行release\n//str1: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str2: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n//str3: __NSCFString -> 0x100206c70 : ThisIsAStr  2\n```\n##### NSTaggedPointerString\n\n这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。\n\n对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。\n\n```\nNSString *str1 = @\"123456789\"; YLog(str1);\nNSString *str2 = [NSString stringWithFormat:@\"123456789\"]; YLog(str2);\nNSString *str3 = [NSString stringWithFormat:@\"1234567890\"]; YLog(str3);\nNSString *str4 = [NSString stringWithFormat:@\"五\"]; YLog(str4);\n\n//输出结果\n//str1: __NSCFConstantString -> 0x10a0c5108 : 123456789  18446744073709551615\n//str2: NSTaggedPointerString -> 0xa1ea1f72bb30ab19 : 123456789  18446744073709551615\n//str3: __NSCFString -> 0x7f8183c02630 : 1234567890  1\n//str4: __NSCFString -> 0x7f8183c0fae0 : 五  1\n```\n\n#### 声明NSSting为属性时用copy还是strong\n声明NSString属性一般来说用copy，因为父类指针可以指向子类对象，而NSMutableNSString是NSString的子类，使用strong的话该NSString属性可能指向一个NSMutableNSString可变对象，如果这个可变对象的内容在外部被修改了，那该属性所属的对象可能对此毫不知情。\n\n先来看正常的情况，NSString属性指向一个不可变对象。\n```\n//Person对象\n@interface Person : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n\n@implementation Person\n@end\n\n//测试代码\nNSString *strA = @\"Susan_Miller\";\nPerson *personA = [Person new];\npersonA.name = strA;\nYLog(strA);\nYLog(personA.name);\n\nstrA = @\"Susan_Test\";\nYLog(strA);\nYLog(personA.name);\n\n//输出结果\n//strA: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n//personA.name: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n//strA: __NSCFConstantString -> 0x102f20148 : Susan_Test  18446744073709551615\n//personA.name: __NSCFConstantString -> 0x102f20108 : Susan_Miller  18446744073709551615\n```\n\n从结果可观察到此时的name属性指向一个不可变的字符串常量，就算strA因为内容变化而生成了新地址，对name属性不会有影响，无论声明name属性时关键字用copy还是strong（不可变对象的copy是浅复制，strong也是指针引用，所以strA内容改变后地址同时改变，不会影响name属性）。\n\n再来看name属性指向一个可变对象的情况，属性关键字用strong。\n```\n//属性关键字为strong\n@property (nonatomic, strong) NSString *name;\n\n//测试代码\nNSMutableString *strB = [@\"Susan_Miller\" mutableCopy];\nPerson *personB = [Person new];\npersonB.name = strB;\nYLog(strB);\nYLog(personB.name);\n\n[strB setString:@\"Susan_Test\"];\nYLog(strB);\nYLog(personB.name);\n\n//输出结果\n//strB: __NSCFString -> 0x7ff9b2c1a090 : Susan_Miller  2\n//personB.name: __NSCFString -> 0x7ff9b2c1a090 : Susan_Miller  2\n//strB: __NSCFString -> 0x7ff9b2c1a090 : Susan_Test  2\n//personB.name: __NSCFString -> 0x7ff9b2c1a090 : Susan_Test  2\n```\n从结果可看出，name属性指向了一个可变对象strB，当strB的内容改变时，name属性也跟着改变，而person对此不知情，可能会产生错误。\n\n继续来看name属性关键字使用copy时的情况。\n```\n//属性关键字为copy\n@property (nonatomic, copy) NSString *name;\n\n//测试代码\nNSMutableString *strB = [@\"Susan_Miller\" mutableCopy];\nPerson *personB = [Person new];\npersonB.name = strB;\nYLog(strB);\nYLog(personB.name);\n\n[strB setString:@\"Susan_Test\"];\nYLog(strB);\nYLog(personB.name);\n\n//输出结果\n//strB: __NSCFString -> 0x7fb15af31360 : Susan_Miller  1**\n//personB.name: __NSCFString -> 0x7fb15af26620 : Susan_Miller  1**\n//strB: __NSCFString -> 0x7fb15af31360 : Susan_Test  1**\n//personB.name: __NSCFString -> 0x7fb15af26620 : Susan_Miller  1**\n```\n此时，因为对NSMutableString进行copy是深复制（即内容拷贝），所以name属性与strB指向不同的地址，strB的内容更改不会影响到name属性。\n\n所以，声明NSString为属性时，如果希望保护属性封装性不受外界影响，则应该使用copy关键字，让所属对象持有的是一份“不可变”（immutable）副本，不用担心字符串内容无意间变动。\n\n### 去除字符串中的中文\n```\n- (NSString *)removeChinese:(NSString *)string {\n\n    NSString *chi = [self getChineseStringWithString:string];\n\n    return [string stringByReplacingOccurrencesOfString:chi withString:@\"\"];\n}\n\n- (NSString *)getChineseStringWithString:(NSString *)string\n{\n    //(unicode中文编码范围是0x4e00~0x9fa5)\n    for (int i = 0; i < string.length; i++) {\n        int utfCode = 0;\n        void *buffer = &utfCode;\n        NSRange range = NSMakeRange(i, 1);\n\n        BOOL b = [string getBytes:buffer maxLength:2 usedLength:NULL encoding:NSUTF16LittleEndianStringEncoding options:NSStringEncodingConversionExternalRepresentation range:range remainingRange:NULL];\n\n        if (b && (utfCode >= 0x4e00 && utfCode <= 0x9fa5)) {\n            return [string substringFromIndex:i];\n        }\n    }\n    return nil;\n}\n```\n\n### - (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用\n\n### NSString的各种转换\n#### NSData 与 NSString\n```\n　　NSData --> NSString\n　　NSString *aString = [[NSString alloc] initWithData:adata encoding:NSUTF8StringEncoding];\n　　NSString --> NSData\n　　NSString *aString = @\"1234\";\n　　NSData *aData = [aString dataUsingEncoding: NSUTF8StringEncoding];\n```\n\n#### NSString转化为UNICODE String：\n```\n(NSString*)fname ＝ @“Test”;\nchar fnameStr[10];\nmemcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));\n与strcpy相比，memcpy并不是遇到'\\0'就结束，而是一定会拷贝完n个字节\n```\n\n#### NSString 转化为 char *\n```\nNSString * str＝ @“Test”;\nconst char * a =[str UTF8String];\n```\n\n#### char * 转化为 NSString\n```\nNSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding];\n```\n\n#### char * 转化 NSData\n```\n方法一： char * a = (char*)malloc(sizeof(byte)*16); NSData *data = [NSData dataWithBytes: a length:strlen(a)]; \n方法二： 转换为NSString： - (id)initWithUTF8String:(const char *)bytes 然后用NSString的 - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding\n```\n\n#### NSData 转化 char *\n```\nNSData data ； \nchar* a=[data bytes];\n```\n\n#### NSString 转化 NSURL\n```\n//NSURL *url = [NSURL URLWithString:[str  stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]];\n\nNSString *urlString=[@\"http://www.google.com/search?client=safari&rls=en&q=搜索&ie=UTF-8&oe=UTF-8\" stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n\n#### NSURL 转化 NSString\n```\nNSURL *url=[NSURL URLWithString:urlString];\n\nNSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n```\n\n#### NSData 与 Byte\n```\n　　NSData --> Byte\n　　NSString *testString = @\"1234567890\";\n　　NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding];\n　　Byte *testByte = (Byte *)[testData bytes];\n　　Byte --> NSData\n　　Byte byte[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23};\n　　NSData *adata = [[NSData alloc] initWithBytes:byte length:24];\n```\n#### NSData 与 UIImage\n```\n　　NSData --> UIImage\n　　UIImage *aimage = [UIImage imageWithData: imageData];\n　　//例：从本地文件沙盒中取图片并转换为NSData\n　　NSString *path = [[NSBundle mainBundle] bundlePath];\n　　NSString *name = [NSString stringWithFormat:@\"ceshi.png\"];\n　　NSString *finalPath = [path stringByAppendingPathComponent:name];\n　　NSData *imageData = [NSData dataWithContentsOfFile: finalPath];\n　　UIImage *aimage = [UIImage imageWithData: imageData];\n　　UIImage－> NSData\n　　NSData *imageData = UIImagePNGRepresentation(aimae);\n```\n#### NSData 与 NSMutableData\n```\n　　NSData --> MSMutableData\n　　NSData *data=[[NSData alloc]init];\n　　NSMutableData *mdata=[[NSMutableData alloc]init];\n　　mdata=[NSData dataWithData:data];\n```\n#### NSData合并为一个NSMutableData\n```\n- (NSString *)filePathWithName:(NSString *)filename\n{\nNSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);\nNSString *documentsDirectory = [paths objectAtIndex:0];\nreturn [documentsDirectory stringByAppendingPathComponent:filename];\n}\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n//音频文件路径\nNSString *mp3Path1 = [[NSBundle mainBundle] pathForResource:@\"1\" ofType:@\"mp3\"];\nNSString *mp3Path2 = [[NSBundle mainBundle] pathForResource:@\"2\" ofType:@\"mp3\"];\n//音频数据\nNSData *sound1Data = [[NSData alloc] initWithContentsOfFile: mp3Path1];\nNSData *sound2Data = [[NSData alloc] initWithContentsOfFile: mp3Path2];\n//合并音频\nNSMutableData *sounds = [NSMutableData alloc];\n[sounds appendData:sound1Data];\n[sounds appendData:sound2Data];\n//保存音频\n\nNSLog(@\"data length:%d\", [sounds length]);\n\n[sounds writeToFile:[self filePathWithName:@\"tmp.mp3\"] atomically:YES];\n\n[window makeKeyAndVisible];\n\nreturn YES;\n}\n```\n\n### 转译字符\n> 转义字符 意义 ASCII码值(十进制)\n\\a 响铃(BEL) 007\n\\b 退格(BS) 008\n\\f 换页(FF) 012\n\\n 换行(LF) 010\n\\r 回车(CR) 013\n\\t 水平制表(HT) 009\n\\v 垂直制表(VT) 011\n\\\\ 反斜杠 092\n\\? 问号字符 063\n\\' 单引号字符 039\n\\\" 双引号字符 034\n\\0 空字符(NULL) 000\n\\ddd 任意字符 三位八进制\n\\xhh 任意字符 二位十六进制\n\\a:蜂鸣，响铃\n\\b:回退：向后退一格\n\\f:换页\n\\n:换行，光标到下行行首\n\\r:回车，光标到本行行首\n\\t:水平制表\n\\v:垂直制表\n\\\\:反斜杠\n\\':单引号\n\\\":双引号\n\\?:问号\n\\ddd:三位八进制\n\\xhh:二位十六进制\n\\0:空字符(NULL),什么都不做\n注：\n1，\\v垂直制表和\\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。\n2，\\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。\n3，\\t 光标向前移动四格或八格，可以在编译器里设置\n4，\\' 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ' 即可。\n5，\\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。\n\n\n### 常用的富文本\n#### 单纯改变一句话中的某些字的颜色（一种颜色）\n```\n/**\n*  单纯改变一句话中的某些字的颜色（一种颜色）\n*\n*  @param color    需要改变成的颜色\n*  @param totalStr 总的字符串\n*  @param subArray 需要改变颜色的文字数组(要是有相同的 只取第一个)\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeCorlorWithColor:(UIColor *)color TotalString:(NSString *)totalStr SubStringArray:(NSArray *)subArray {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalStr];\nfor (NSString *rangeStr in subArray) {\n\nNSRange range = [totalStr rangeOfString:rangeStr options:NSBackwardsSearch];\n[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];\n}\n\nreturn attributedStr;\n}\n```\n\n#### 改变每行的字间距\n```\n/**\n*  单纯改变句子的字间距（需要 <CoreText/CoreText.h>）\n*\n*  @param totalString 需要更改的字符串\n*  @param space       字间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeSpaceWithTotalString:(NSString *)totalString Space:(CGFloat)space {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\nlong number = space;\nCFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&number);\n[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];\nCFRelease(num);\n\nreturn attributedStr;\n}\n```\n\n#### 改变行间距\n```\n/**\n*  单纯改变段落的行间距\n*\n*  @param totalString 需要更改的字符串\n*  @param lineSpace   行间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeLineSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nNSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];\n[paragraphStyle setLineSpacing:lineSpace];\n\n[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];\n\nreturn attributedStr;\n}\n```\n\n#### 同时更改行间距和字间距\n```\n/**\n*  同时更改行间距和字间距\n*\n*  @param totalString 需要改变的字符串\n*  @param lineSpace   行间距\n*  @param textSpace   字间距\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeLineAndTextSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace textSpace:(CGFloat)textSpace {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nNSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];\n[paragraphStyle setLineSpacing:lineSpace];\n\n[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];\n\nlong number = textSpace;\nCFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&number);\n[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];\nCFRelease(num);\n\nreturn attributedStr;\n}\n```\n\n#### 更改某些文字的颜色并修改其字体，突出重点强调\n```\n/**\n*  改变某些文字的颜色 并单独设置其字体\n*\n*  @param font        设置的字体\n*  @param color       颜色\n*  @param totalString 总的字符串\n*  @param subArray    想要变色的字符数组\n*\n*  @return 生成的富文本\n*/\n+ (NSMutableAttributedString *)ls_changeFontAndColor:(UIFont *)font Color:(UIColor *)color TotalString:(NSString *)totalString SubStringArray:(NSArray *)subArray {\n\nNSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];\n\nfor (NSString *rangeStr in subArray) {\n\nNSRange range = [totalString rangeOfString:rangeStr options:NSBackwardsSearch];\n\n[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];\n[attributedStr addAttribute:NSFontAttributeName value:font range:range];\n}\n\nreturn attributedStr;\n```\n\n### 富文本相关属性汇总\n>- NSFontAttributeName ：字体字号\n    - value值：UIFont类型\n- NSParagraphStyleAttributeName ： 段落样式\n    - value值：NSParagraphStyle类型（其属性如下）\n    - lineSpacing 行间距(具体用法可查看上面的设置行间距API)\n    - paragraphSpacing 段落间距\n    - alignment 对齐方式\n    - firstLineHeadIndent 指定段落开始的缩进像素\n    - headIndent 调整全部文字的缩进像素\n- NSForegroundColorAttributeName 字体颜色\n    - value值：UIColor类型\n- NSBackgroundColorAttributeName 背景颜色\n    - value值：UIColor类型\n- NSObliquenessAttributeName 字体粗倾斜\n    - value值：NSNumber类型\n- NSExpansionAttributeName 字体加粗\n    - value值：NSNumber类型(比例) 0就是不变 1增加一倍\n- NSKernAttributeName 字间距\n    - value值：CGFloat类型\n- NSUnderlineStyleAttributeName 下划线\n    - value值：1或0\n- NSUnderlineColorAttributeName 下划线颜色\n    - value值：UIColor类型\n- NSStrikethroughStyleAttributeName 删除线\n    - value值：1或0\n- NSStrikethroughColorAttributeName 删除线颜色\n    - value值：UIColor类型\n- NSStrokeColorAttributeName 字体颜色\n    - value值：UIColor类型\n- NSStrokeWidthAttributeName 字体描边\n    - value值：CGFloat\n- NSLigatureAttributeName 连笔字\n    - value值：1或0\n- NSShadowAttributeName 阴影\n    - value值：NSShawdow类型（下面是其属性）\n    - shadowOffset 影子与字符串的偏移量\n    - shadowBlurRadius 影子的模糊程度\n    - shadowColor 影子的颜色\n- NSTextEffectAttributeName 设置文本特殊效果,目前只有图版印刷效果可用\n    - value值：NSString类型\n- NSAttachmentAttributeName 设置文本附件\n    - value值：NSTextAttachment类型（没研究过，可自行百度研究）\n- NSLinkAttributeName 链接\n    - value值：NSURL (preferred) or NSString类型\n- NSBaselineOffsetAttributeName 基准线偏移\n    - value值：NSNumber类型\n- NSWritingDirectionAttributeName 文字方向 分别代表不同的文字出现方向\n    - value值：@[@(1),@(2)]\n- NSVerticalGlyphFormAttributeName 水平或者竖直文本 在iOS没卵用，不支持竖版\n    - value值：1竖直 0水平\n\n### 获取汉字的拼音 \n```\n+ (NSString *)transform:(NSString *)chinese\n{\n//将NSString装换成NSMutableString\nNSMutableString *pinyin = [chinese mutableCopy];\n//将汉字转换为拼音(带音标)\nCFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);\nNSLog(@\"%@\", pinyin);\n//去掉拼音的音标\nCFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);\nNSLog(@\"%@\", pinyin);\n//返回最近结果\nreturn pinyin;\n}\n```\n","slug":"2014/Foundation系列-NSString","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4plx001msauacz7v1aur","content":"<h3 id=\"内存简述，Copy与Strong关键字\"><a href=\"#内存简述，Copy与Strong关键字\" class=\"headerlink\" title=\"内存简述，Copy与Strong关键字\"></a>内存简述，Copy与Strong关键字</h3><h4 id=\"内存简述\"><a href=\"#内存简述\" class=\"headerlink\" title=\"内存简述\"></a>内存简述</h4><p>为了方便观察引用计数，这里在MRC下来进行测试。先重新定义NSLog让其不打印时间戳。再编写一个打印宏，用来打印NSString对象的类、内存地址、值、引用计数。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define NSLog(FORMAT, ...) fprintf(stderr,&quot;%s\\n&quot;,[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);</div><div class=\"line\">#define YLog(_var) (&#123; NSString *name = @#_var; NSLog(@&quot;%@: %@ -&gt; %p : %@  %tu&quot;, name, [_var class], _var, _var, [_var retainCount]); &#125;)</div></pre></td></tr></table></figure></p>\n<p>再新建一个StrObject类，用于测试。该类创建实例时，将打印一个NSString，内容为”Str”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface StrObject : NSObject</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation StrObject</div><div class=\"line\"></div><div class=\"line\">- (id)init &#123;</div><div class=\"line\"></div><div class=\"line\">  self = [super init];</div><div class=\"line\"></div><div class=\"line\">  if (self) &#123;</div><div class=\"line\">    NSLog(@&quot;StrObj Create&quot;);</div><div class=\"line\">    NSString *strA = @&quot;Str&quot;;</div><div class=\"line\">    YLog(strA);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">  [super dealloc];</div><div class=\"line\"></div><div class=\"line\">  NSLog(@&quot;StrObj Dealloc&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后运行以下代码。<br>（一般来说我们可以用以下几种方法来创建NSString对象，其中stringWithString在iOS 6之后已变为多余的方法（redundant），因其等同于字面量创建法，使用这方法编译器会给出警告，）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建并释放StrObject对象</div><div class=\"line\">StrObject *obj = [StrObject new];</div><div class=\"line\">[obj release];</div><div class=\"line\"></div><div class=\"line\">//创建一些字符串</div><div class=\"line\">NSString *str1 = @&quot;Str&quot;; YLog(str1);</div><div class=\"line\">NSString *str2 = @&quot;Str&quot;; YLog(str2);</div><div class=\"line\">NSString *str3 = [NSString stringWithString:@&quot;Str&quot;]; YLog(str3);</div><div class=\"line\">NSString *str4 = [NSString stringWithFormat:@&quot;Str&quot;]; YLog(str4);</div><div class=\"line\">NSString *str5 = [str1 retain]; YLog(str5);</div><div class=\"line\">NSString *str6 = [str1 copy]; YLog(str6);</div><div class=\"line\">NSString *str7 = [str1 mutableCopy]; YLog(str7);</div><div class=\"line\"></div><div class=\"line\">//改变NSString变量的字符串内容</div><div class=\"line\">str1 = @&quot;StrNew&quot;; YLog(str1);</div><div class=\"line\">str2 = str1; YLog(str2);</div><div class=\"line\"></div><div class=\"line\">//创建一个字符串并将其释放</div><div class=\"line\">NSString *str8 = @&quot;Str&quot;;</div><div class=\"line\">[str8 retain];</div><div class=\"line\">[str8 release];</div><div class=\"line\">[str8 release];</div><div class=\"line\">YLog(str8);</div><div class=\"line\"></div><div class=\"line\">//=======输出结果========</div><div class=\"line\">//创建并释放StrObject对象</div><div class=\"line\">//StrObj Create</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//StrObj Dealloc</div><div class=\"line\"></div><div class=\"line\">//创建一些字符串</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str2: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str3: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str4: NSTaggedPointerString -&gt; 0xa000000007274533 : Str  18446744073709551615</div><div class=\"line\">//str5: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str6: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str7: __NSCFString -&gt; 0x7f951a409c80 : Str  1</div><div class=\"line\"></div><div class=\"line\">//改变NSString变量的字符串内容</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew  18446744073709551615</div><div class=\"line\">//str2: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew  18446744073709551615</div><div class=\"line\"></div><div class=\"line\">//创建一个字符串并将其释放</div><div class=\"line\">//str8: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div></pre></td></tr></table></figure>\n<p>可观察到，虽然我们通过不同方法创建了不同的NSString对象，但字符串内容一致，结果显示strA、str1、str2、str3、str5、str6都指向同一个地址。即便@”Str”首先在StrObject对象中出现，赋值给strA，释放了之后，str1和其他对象仍然指向同一个地址。</p>\n<p>将一个新的字符串内容@”Str a”赋值给str1，并且将str1赋值给str2后，从结果看到str1、str2的内存地址改变了，且指向同一个地址。</p>\n<p>之后创建的str8，对其进行多次release后，内存地址（和strA地址相同）和retaionCount都不曾变化。</p>\n<h5 id=\"NSCFConstantString\"><a href=\"#NSCFConstantString\" class=\"headerlink\" title=\"__NSCFConstantString\"></a>__NSCFConstantString</h5><p>这些对象地址相同，是因为他们都是<strong>NSCFConstantString对象，也就是字符串常量对象，可以看到其isa都是</strong>NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。</p>\n<p>当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。</p>\n<p>总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。</p>\n<h5 id=\"NSCFString\"><a href=\"#NSCFString\" class=\"headerlink\" title=\"__NSCFString\"></a>__NSCFString</h5><p>在上面的输出结果中，我们看到另外还有两类isa分别是：<strong>NSCFString和NSTaggedPointerString，先来看</strong>NSCFString。</p>\n<p>在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str1 = [NSString stringWithFormat:@&quot;ThisIsAStr&quot;];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">NSString *str2 = [str1 retain];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">YLog(str2);</div><div class=\"line\"></div><div class=\"line\">NSString *str3 = [str1 copy];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">YLog(str2);</div><div class=\"line\">YLog(str3);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  1</div><div class=\"line\"></div><div class=\"line\">//str1 retain后赋值给str2</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\"></div><div class=\"line\">//str3由str1浅复制得来</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\">//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\"></div><div class=\"line\">//对str1进行release</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div></pre></td></tr></table></figure></p>\n<h5 id=\"NSTaggedPointerString\"><a href=\"#NSTaggedPointerString\" class=\"headerlink\" title=\"NSTaggedPointerString\"></a>NSTaggedPointerString</h5><p>这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。</p>\n<p>对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str1 = @&quot;123456789&quot;; YLog(str1);</div><div class=\"line\">NSString *str2 = [NSString stringWithFormat:@&quot;123456789&quot;]; YLog(str2);</div><div class=\"line\">NSString *str3 = [NSString stringWithFormat:@&quot;1234567890&quot;]; YLog(str3);</div><div class=\"line\">NSString *str4 = [NSString stringWithFormat:@&quot;五&quot;]; YLog(str4);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10a0c5108 : 123456789  18446744073709551615</div><div class=\"line\">//str2: NSTaggedPointerString -&gt; 0xa1ea1f72bb30ab19 : 123456789  18446744073709551615</div><div class=\"line\">//str3: __NSCFString -&gt; 0x7f8183c02630 : 1234567890  1</div><div class=\"line\">//str4: __NSCFString -&gt; 0x7f8183c0fae0 : 五  1</div></pre></td></tr></table></figure>\n<h4 id=\"声明NSSting为属性时用copy还是strong\"><a href=\"#声明NSSting为属性时用copy还是strong\" class=\"headerlink\" title=\"声明NSSting为属性时用copy还是strong\"></a>声明NSSting为属性时用copy还是strong</h4><p>声明NSString属性一般来说用copy，因为父类指针可以指向子类对象，而NSMutableNSString是NSString的子类，使用strong的话该NSString属性可能指向一个NSMutableNSString可变对象，如果这个可变对象的内容在外部被修改了，那该属性所属的对象可能对此毫不知情。</p>\n<p>先来看正常的情况，NSString属性指向一个不可变对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Person对象</div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">@property (nonatomic, strong) NSString *name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSString *strA = @&quot;Susan_Miller&quot;;</div><div class=\"line\">Person *personA = [Person new];</div><div class=\"line\">personA.name = strA;</div><div class=\"line\">YLog(strA);</div><div class=\"line\">YLog(personA.name);</div><div class=\"line\"></div><div class=\"line\">strA = @&quot;Susan_Test&quot;;</div><div class=\"line\">YLog(strA);</div><div class=\"line\">YLog(personA.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div><div class=\"line\">//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x102f20148 : Susan_Test  18446744073709551615</div><div class=\"line\">//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div></pre></td></tr></table></figure></p>\n<p>从结果可观察到此时的name属性指向一个不可变的字符串常量，就算strA因为内容变化而生成了新地址，对name属性不会有影响，无论声明name属性时关键字用copy还是strong（不可变对象的copy是浅复制，strong也是指针引用，所以strA内容改变后地址同时改变，不会影响name属性）。</p>\n<p>再来看name属性指向一个可变对象的情况，属性关键字用strong。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//属性关键字为strong</div><div class=\"line\">@property (nonatomic, strong) NSString *name;</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];</div><div class=\"line\">Person *personB = [Person new];</div><div class=\"line\">personB.name = strB;</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">[strB setString:@&quot;Susan_Test&quot;];</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller  2</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller  2</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test  2</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test  2</div></pre></td></tr></table></figure></p>\n<p>从结果可看出，name属性指向了一个可变对象strB，当strB的内容改变时，name属性也跟着改变，而person对此不知情，可能会产生错误。</p>\n<p>继续来看name属性关键字使用copy时的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//属性关键字为copy</div><div class=\"line\">@property (nonatomic, copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];</div><div class=\"line\">Person *personB = [Person new];</div><div class=\"line\">personB.name = strB;</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">[strB setString:@&quot;Susan_Test&quot;];</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Miller  1**</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller  1**</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Test  1**</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller  1**</div></pre></td></tr></table></figure></p>\n<p>此时，因为对NSMutableString进行copy是深复制（即内容拷贝），所以name属性与strB指向不同的地址，strB的内容更改不会影响到name属性。</p>\n<p>所以，声明NSString为属性时，如果希望保护属性封装性不受外界影响，则应该使用copy关键字，让所属对象持有的是一份“不可变”（immutable）副本，不用担心字符串内容无意间变动。</p>\n<h3 id=\"去除字符串中的中文\"><a href=\"#去除字符串中的中文\" class=\"headerlink\" title=\"去除字符串中的中文\"></a>去除字符串中的中文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)removeChinese:(NSString *)string &#123;</div><div class=\"line\"></div><div class=\"line\">    NSString *chi = [self getChineseStringWithString:string];</div><div class=\"line\"></div><div class=\"line\">    return [string stringByReplacingOccurrencesOfString:chi withString:@&quot;&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSString *)getChineseStringWithString:(NSString *)string</div><div class=\"line\">&#123;</div><div class=\"line\">    //(unicode中文编码范围是0x4e00~0x9fa5)</div><div class=\"line\">    for (int i = 0; i &lt; string.length; i++) &#123;</div><div class=\"line\">        int utfCode = 0;</div><div class=\"line\">        void *buffer = &amp;utfCode;</div><div class=\"line\">        NSRange range = NSMakeRange(i, 1);</div><div class=\"line\"></div><div class=\"line\">        BOOL b = [string getBytes:buffer maxLength:2 usedLength:NULL encoding:NSUTF16LittleEndianStringEncoding options:NSStringEncodingConversionExternalRepresentation range:range remainingRange:NULL];</div><div class=\"line\"></div><div class=\"line\">        if (b &amp;&amp; (utfCode &gt;= 0x4e00 &amp;&amp; utfCode &lt;= 0x9fa5)) &#123;</div><div class=\"line\">            return [string substringFromIndex:i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BOOL-containsString-NSString-str-NS-AVAILABLE-10-10-8-0-7以下不可用\"><a href=\"#BOOL-containsString-NSString-str-NS-AVAILABLE-10-10-8-0-7以下不可用\" class=\"headerlink\" title=\"- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用\"></a>- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用</h3><h3 id=\"NSString的各种转换\"><a href=\"#NSString的各种转换\" class=\"headerlink\" title=\"NSString的各种转换\"></a>NSString的各种转换</h3><h4 id=\"NSData-与-NSString\"><a href=\"#NSData-与-NSString\" class=\"headerlink\" title=\"NSData 与 NSString\"></a>NSData 与 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; NSString</div><div class=\"line\">　　NSString *aString = [[NSString alloc] initWithData:adata encoding:NSUTF8StringEncoding];</div><div class=\"line\">　　NSString --&gt; NSData</div><div class=\"line\">　　NSString *aString = @&quot;1234&quot;;</div><div class=\"line\">　　NSData *aData = [aString dataUsingEncoding: NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSString转化为UNICODE-String：\"><a href=\"#NSString转化为UNICODE-String：\" class=\"headerlink\" title=\"NSString转化为UNICODE String：\"></a>NSString转化为UNICODE String：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(NSString*)fname ＝ @“Test”;</div><div class=\"line\">char fnameStr[10];</div><div class=\"line\">memcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));</div><div class=\"line\">与strcpy相比，memcpy并不是遇到&apos;\\0&apos;就结束，而是一定会拷贝完n个字节</div></pre></td></tr></table></figure>\n<h4 id=\"NSString-转化为-char\"><a href=\"#NSString-转化为-char\" class=\"headerlink\" title=\"NSString 转化为 char *\"></a>NSString 转化为 char *</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString * str＝ @“Test”;</div><div class=\"line\">const char * a =[str UTF8String];</div></pre></td></tr></table></figure>\n<h4 id=\"char-转化为-NSString\"><a href=\"#char-转化为-NSString\" class=\"headerlink\" title=\"char * 转化为 NSString\"></a>char * 转化为 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"char-转化-NSData\"><a href=\"#char-转化-NSData\" class=\"headerlink\" title=\"char * 转化 NSData\"></a>char * 转化 NSData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法一： char * a = (char*)malloc(sizeof(byte)*16); NSData *data = [NSData dataWithBytes: a length:strlen(a)]; </div><div class=\"line\">方法二： 转换为NSString： - (id)initWithUTF8String:(const char *)bytes 然后用NSString的 - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-转化-char\"><a href=\"#NSData-转化-char\" class=\"headerlink\" title=\"NSData 转化 char *\"></a>NSData 转化 char *</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSData data ； </div><div class=\"line\">char* a=[data bytes];</div></pre></td></tr></table></figure>\n<h4 id=\"NSString-转化-NSURL\"><a href=\"#NSString-转化-NSURL\" class=\"headerlink\" title=\"NSString 转化 NSURL\"></a>NSString 转化 NSURL</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//NSURL *url = [NSURL URLWithString:[str  stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]];</div><div class=\"line\"></div><div class=\"line\">NSString *urlString=[@&quot;http://www.google.com/search?client=safari&amp;rls=en&amp;q=搜索&amp;ie=UTF-8&amp;oe=UTF-8&quot; stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSURL-转化-NSString\"><a href=\"#NSURL-转化-NSString\" class=\"headerlink\" title=\"NSURL 转化 NSString\"></a>NSURL 转化 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSURL *url=[NSURL URLWithString:urlString];</div><div class=\"line\"></div><div class=\"line\">NSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-Byte\"><a href=\"#NSData-与-Byte\" class=\"headerlink\" title=\"NSData 与 Byte\"></a>NSData 与 Byte</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; Byte</div><div class=\"line\">　　NSString *testString = @&quot;1234567890&quot;;</div><div class=\"line\">　　NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding];</div><div class=\"line\">　　Byte *testByte = (Byte *)[testData bytes];</div><div class=\"line\">　　Byte --&gt; NSData</div><div class=\"line\">　　Byte byte[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23&#125;;</div><div class=\"line\">　　NSData *adata = [[NSData alloc] initWithBytes:byte length:24];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-UIImage\"><a href=\"#NSData-与-UIImage\" class=\"headerlink\" title=\"NSData 与 UIImage\"></a>NSData 与 UIImage</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; UIImage</div><div class=\"line\">　　UIImage *aimage = [UIImage imageWithData: imageData];</div><div class=\"line\">　　//例：从本地文件沙盒中取图片并转换为NSData</div><div class=\"line\">　　NSString *path = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">　　NSString *name = [NSString stringWithFormat:@&quot;ceshi.png&quot;];</div><div class=\"line\">　　NSString *finalPath = [path stringByAppendingPathComponent:name];</div><div class=\"line\">　　NSData *imageData = [NSData dataWithContentsOfFile: finalPath];</div><div class=\"line\">　　UIImage *aimage = [UIImage imageWithData: imageData];</div><div class=\"line\">　　UIImage－&gt; NSData</div><div class=\"line\">　　NSData *imageData = UIImagePNGRepresentation(aimae);</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-NSMutableData\"><a href=\"#NSData-与-NSMutableData\" class=\"headerlink\" title=\"NSData 与 NSMutableData\"></a>NSData 与 NSMutableData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; MSMutableData</div><div class=\"line\">　　NSData *data=[[NSData alloc]init];</div><div class=\"line\">　　NSMutableData *mdata=[[NSMutableData alloc]init];</div><div class=\"line\">　　mdata=[NSData dataWithData:data];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData合并为一个NSMutableData\"><a href=\"#NSData合并为一个NSMutableData\" class=\"headerlink\" title=\"NSData合并为一个NSMutableData\"></a>NSData合并为一个NSMutableData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)filePathWithName:(NSString *)filename</div><div class=\"line\">&#123;</div><div class=\"line\">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class=\"line\">NSString *documentsDirectory = [paths objectAtIndex:0];</div><div class=\"line\">return [documentsDirectory stringByAppendingPathComponent:filename];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class=\"line\">//音频文件路径</div><div class=\"line\">NSString *mp3Path1 = [[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;mp3&quot;];</div><div class=\"line\">NSString *mp3Path2 = [[NSBundle mainBundle] pathForResource:@&quot;2&quot; ofType:@&quot;mp3&quot;];</div><div class=\"line\">//音频数据</div><div class=\"line\">NSData *sound1Data = [[NSData alloc] initWithContentsOfFile: mp3Path1];</div><div class=\"line\">NSData *sound2Data = [[NSData alloc] initWithContentsOfFile: mp3Path2];</div><div class=\"line\">//合并音频</div><div class=\"line\">NSMutableData *sounds = [NSMutableData alloc];</div><div class=\"line\">[sounds appendData:sound1Data];</div><div class=\"line\">[sounds appendData:sound2Data];</div><div class=\"line\">//保存音频</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;data length:%d&quot;, [sounds length]);</div><div class=\"line\"></div><div class=\"line\">[sounds writeToFile:[self filePathWithName:@&quot;tmp.mp3&quot;] atomically:YES];</div><div class=\"line\"></div><div class=\"line\">[window makeKeyAndVisible];</div><div class=\"line\"></div><div class=\"line\">return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"转译字符\"><a href=\"#转译字符\" class=\"headerlink\" title=\"转译字符\"></a>转译字符</h3><blockquote>\n<p>转义字符 意义 ASCII码值(十进制)<br>\\a 响铃(BEL) 007<br>\\b 退格(BS) 008<br>\\f 换页(FF) 012<br>\\n 换行(LF) 010<br>\\r 回车(CR) 013<br>\\t 水平制表(HT) 009<br>\\v 垂直制表(VT) 011<br>\\ 反斜杠 092<br>\\? 问号字符 063<br>\\’ 单引号字符 039<br>\\” 双引号字符 034<br>\\0 空字符(NULL) 000<br>\\ddd 任意字符 三位八进制<br>\\xhh 任意字符 二位十六进制<br>\\a:蜂鸣，响铃<br>\\b:回退：向后退一格<br>\\f:换页<br>\\n:换行，光标到下行行首<br>\\r:回车，光标到本行行首<br>\\t:水平制表<br>\\v:垂直制表<br>\\:反斜杠<br>\\’:单引号<br>\\”:双引号<br>\\?:问号<br>\\ddd:三位八进制<br>\\xhh:二位十六进制<br>\\0:空字符(NULL),什么都不做<br>注：<br>1，\\v垂直制表和\\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。<br>2，\\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。<br>3，\\t 光标向前移动四格或八格，可以在编译器里设置<br>4，\\’ 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ‘ 即可。<br>5，\\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。</p>\n</blockquote>\n<h3 id=\"常用的富文本\"><a href=\"#常用的富文本\" class=\"headerlink\" title=\"常用的富文本\"></a>常用的富文本</h3><h4 id=\"单纯改变一句话中的某些字的颜色（一种颜色）\"><a href=\"#单纯改变一句话中的某些字的颜色（一种颜色）\" class=\"headerlink\" title=\"单纯改变一句话中的某些字的颜色（一种颜色）\"></a>单纯改变一句话中的某些字的颜色（一种颜色）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变一句话中的某些字的颜色（一种颜色）</div><div class=\"line\">*</div><div class=\"line\">*  @param color    需要改变成的颜色</div><div class=\"line\">*  @param totalStr 总的字符串</div><div class=\"line\">*  @param subArray 需要改变颜色的文字数组(要是有相同的 只取第一个)</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeCorlorWithColor:(UIColor *)color TotalString:(NSString *)totalStr SubStringArray:(NSArray *)subArray &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalStr];</div><div class=\"line\">for (NSString *rangeStr in subArray) &#123;</div><div class=\"line\"></div><div class=\"line\">NSRange range = [totalStr rangeOfString:rangeStr options:NSBackwardsSearch];</div><div class=\"line\">[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"改变每行的字间距\"><a href=\"#改变每行的字间距\" class=\"headerlink\" title=\"改变每行的字间距\"></a>改变每行的字间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变句子的字间距（需要 &lt;CoreText/CoreText.h&gt;）</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要更改的字符串</div><div class=\"line\">*  @param space       字间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeSpaceWithTotalString:(NSString *)totalString Space:(CGFloat)space &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\">long number = space;</div><div class=\"line\">CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</div><div class=\"line\">[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];</div><div class=\"line\">CFRelease(num);</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"改变行间距\"><a href=\"#改变行间距\" class=\"headerlink\" title=\"改变行间距\"></a>改变行间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变段落的行间距</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要更改的字符串</div><div class=\"line\">*  @param lineSpace   行间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeLineSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">[paragraphStyle setLineSpacing:lineSpace];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"同时更改行间距和字间距\"><a href=\"#同时更改行间距和字间距\" class=\"headerlink\" title=\"同时更改行间距和字间距\"></a>同时更改行间距和字间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  同时更改行间距和字间距</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要改变的字符串</div><div class=\"line\">*  @param lineSpace   行间距</div><div class=\"line\">*  @param textSpace   字间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeLineAndTextSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace textSpace:(CGFloat)textSpace &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">[paragraphStyle setLineSpacing:lineSpace];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];</div><div class=\"line\"></div><div class=\"line\">long number = textSpace;</div><div class=\"line\">CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</div><div class=\"line\">[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];</div><div class=\"line\">CFRelease(num);</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"更改某些文字的颜色并修改其字体，突出重点强调\"><a href=\"#更改某些文字的颜色并修改其字体，突出重点强调\" class=\"headerlink\" title=\"更改某些文字的颜色并修改其字体，突出重点强调\"></a>更改某些文字的颜色并修改其字体，突出重点强调</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  改变某些文字的颜色 并单独设置其字体</div><div class=\"line\">*</div><div class=\"line\">*  @param font        设置的字体</div><div class=\"line\">*  @param color       颜色</div><div class=\"line\">*  @param totalString 总的字符串</div><div class=\"line\">*  @param subArray    想要变色的字符数组</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeFontAndColor:(UIFont *)font Color:(UIColor *)color TotalString:(NSString *)totalString SubStringArray:(NSArray *)subArray &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">for (NSString *rangeStr in subArray) &#123;</div><div class=\"line\"></div><div class=\"line\">NSRange range = [totalString rangeOfString:rangeStr options:NSBackwardsSearch];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];</div><div class=\"line\">[attributedStr addAttribute:NSFontAttributeName value:font range:range];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div></pre></td></tr></table></figure>\n<h3 id=\"富文本相关属性汇总\"><a href=\"#富文本相关属性汇总\" class=\"headerlink\" title=\"富文本相关属性汇总\"></a>富文本相关属性汇总</h3><blockquote>\n<ul>\n<li>NSFontAttributeName ：字体字号<ul>\n<li>value值：UIFont类型</li>\n</ul>\n</li>\n<li>NSParagraphStyleAttributeName ： 段落样式<ul>\n<li>value值：NSParagraphStyle类型（其属性如下）</li>\n<li>lineSpacing 行间距(具体用法可查看上面的设置行间距API)</li>\n<li>paragraphSpacing 段落间距</li>\n<li>alignment 对齐方式</li>\n<li>firstLineHeadIndent 指定段落开始的缩进像素</li>\n<li>headIndent 调整全部文字的缩进像素</li>\n</ul>\n</li>\n<li>NSForegroundColorAttributeName 字体颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSBackgroundColorAttributeName 背景颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSObliquenessAttributeName 字体粗倾斜<ul>\n<li>value值：NSNumber类型</li>\n</ul>\n</li>\n<li>NSExpansionAttributeName 字体加粗<ul>\n<li>value值：NSNumber类型(比例) 0就是不变 1增加一倍</li>\n</ul>\n</li>\n<li>NSKernAttributeName 字间距<ul>\n<li>value值：CGFloat类型</li>\n</ul>\n</li>\n<li>NSUnderlineStyleAttributeName 下划线<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSUnderlineColorAttributeName 下划线颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrikethroughStyleAttributeName 删除线<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSStrikethroughColorAttributeName 删除线颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrokeColorAttributeName 字体颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrokeWidthAttributeName 字体描边<ul>\n<li>value值：CGFloat</li>\n</ul>\n</li>\n<li>NSLigatureAttributeName 连笔字<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSShadowAttributeName 阴影<ul>\n<li>value值：NSShawdow类型（下面是其属性）</li>\n<li>shadowOffset 影子与字符串的偏移量</li>\n<li>shadowBlurRadius 影子的模糊程度</li>\n<li>shadowColor 影子的颜色</li>\n</ul>\n</li>\n<li>NSTextEffectAttributeName 设置文本特殊效果,目前只有图版印刷效果可用<ul>\n<li>value值：NSString类型</li>\n</ul>\n</li>\n<li>NSAttachmentAttributeName 设置文本附件<ul>\n<li>value值：NSTextAttachment类型（没研究过，可自行百度研究）</li>\n</ul>\n</li>\n<li>NSLinkAttributeName 链接<ul>\n<li>value值：NSURL (preferred) or NSString类型</li>\n</ul>\n</li>\n<li>NSBaselineOffsetAttributeName 基准线偏移<ul>\n<li>value值：NSNumber类型</li>\n</ul>\n</li>\n<li>NSWritingDirectionAttributeName 文字方向 分别代表不同的文字出现方向<ul>\n<li>value值：@[@(1),@(2)]</li>\n</ul>\n</li>\n<li>NSVerticalGlyphFormAttributeName 水平或者竖直文本 在iOS没卵用，不支持竖版<ul>\n<li>value值：1竖直 0水平</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"获取汉字的拼音\"><a href=\"#获取汉字的拼音\" class=\"headerlink\" title=\"获取汉字的拼音\"></a>获取汉字的拼音</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)transform:(NSString *)chinese</div><div class=\"line\">&#123;</div><div class=\"line\">//将NSString装换成NSMutableString</div><div class=\"line\">NSMutableString *pinyin = [chinese mutableCopy];</div><div class=\"line\">//将汉字转换为拼音(带音标)</div><div class=\"line\">CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);</div><div class=\"line\">NSLog(@&quot;%@&quot;, pinyin);</div><div class=\"line\">//去掉拼音的音标</div><div class=\"line\">CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);</div><div class=\"line\">NSLog(@&quot;%@&quot;, pinyin);</div><div class=\"line\">//返回最近结果</div><div class=\"line\">return pinyin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"内存简述，Copy与Strong关键字\"><a href=\"#内存简述，Copy与Strong关键字\" class=\"headerlink\" title=\"内存简述，Copy与Strong关键字\"></a>内存简述，Copy与Strong关键字</h3><h4 id=\"内存简述\"><a href=\"#内存简述\" class=\"headerlink\" title=\"内存简述\"></a>内存简述</h4><p>为了方便观察引用计数，这里在MRC下来进行测试。先重新定义NSLog让其不打印时间戳。再编写一个打印宏，用来打印NSString对象的类、内存地址、值、引用计数。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define NSLog(FORMAT, ...) fprintf(stderr,&quot;%s\\n&quot;,[[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);</div><div class=\"line\">#define YLog(_var) (&#123; NSString *name = @#_var; NSLog(@&quot;%@: %@ -&gt; %p : %@  %tu&quot;, name, [_var class], _var, _var, [_var retainCount]); &#125;)</div></pre></td></tr></table></figure></p>\n<p>再新建一个StrObject类，用于测试。该类创建实例时，将打印一个NSString，内容为”Str”。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface StrObject : NSObject</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation StrObject</div><div class=\"line\"></div><div class=\"line\">- (id)init &#123;</div><div class=\"line\"></div><div class=\"line\">  self = [super init];</div><div class=\"line\"></div><div class=\"line\">  if (self) &#123;</div><div class=\"line\">    NSLog(@&quot;StrObj Create&quot;);</div><div class=\"line\">    NSString *strA = @&quot;Str&quot;;</div><div class=\"line\">    YLog(strA);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)dealloc &#123;</div><div class=\"line\"></div><div class=\"line\">  [super dealloc];</div><div class=\"line\"></div><div class=\"line\">  NSLog(@&quot;StrObj Dealloc&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后运行以下代码。<br>（一般来说我们可以用以下几种方法来创建NSString对象，其中stringWithString在iOS 6之后已变为多余的方法（redundant），因其等同于字面量创建法，使用这方法编译器会给出警告，）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">//创建并释放StrObject对象</div><div class=\"line\">StrObject *obj = [StrObject new];</div><div class=\"line\">[obj release];</div><div class=\"line\"></div><div class=\"line\">//创建一些字符串</div><div class=\"line\">NSString *str1 = @&quot;Str&quot;; YLog(str1);</div><div class=\"line\">NSString *str2 = @&quot;Str&quot;; YLog(str2);</div><div class=\"line\">NSString *str3 = [NSString stringWithString:@&quot;Str&quot;]; YLog(str3);</div><div class=\"line\">NSString *str4 = [NSString stringWithFormat:@&quot;Str&quot;]; YLog(str4);</div><div class=\"line\">NSString *str5 = [str1 retain]; YLog(str5);</div><div class=\"line\">NSString *str6 = [str1 copy]; YLog(str6);</div><div class=\"line\">NSString *str7 = [str1 mutableCopy]; YLog(str7);</div><div class=\"line\"></div><div class=\"line\">//改变NSString变量的字符串内容</div><div class=\"line\">str1 = @&quot;StrNew&quot;; YLog(str1);</div><div class=\"line\">str2 = str1; YLog(str2);</div><div class=\"line\"></div><div class=\"line\">//创建一个字符串并将其释放</div><div class=\"line\">NSString *str8 = @&quot;Str&quot;;</div><div class=\"line\">[str8 retain];</div><div class=\"line\">[str8 release];</div><div class=\"line\">[str8 release];</div><div class=\"line\">YLog(str8);</div><div class=\"line\"></div><div class=\"line\">//=======输出结果========</div><div class=\"line\">//创建并释放StrObject对象</div><div class=\"line\">//StrObj Create</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//StrObj Dealloc</div><div class=\"line\"></div><div class=\"line\">//创建一些字符串</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str2: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str3: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str4: NSTaggedPointerString -&gt; 0xa000000007274533 : Str  18446744073709551615</div><div class=\"line\">//str5: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str6: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div><div class=\"line\">//str7: __NSCFString -&gt; 0x7f951a409c80 : Str  1</div><div class=\"line\"></div><div class=\"line\">//改变NSString变量的字符串内容</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew  18446744073709551615</div><div class=\"line\">//str2: __NSCFConstantString -&gt; 0x10d2ce1e8 : StrNew  18446744073709551615</div><div class=\"line\"></div><div class=\"line\">//创建一个字符串并将其释放</div><div class=\"line\">//str8: __NSCFConstantString -&gt; 0x10d2ce088 : Str  18446744073709551615</div></pre></td></tr></table></figure>\n<p>可观察到，虽然我们通过不同方法创建了不同的NSString对象，但字符串内容一致，结果显示strA、str1、str2、str3、str5、str6都指向同一个地址。即便@”Str”首先在StrObject对象中出现，赋值给strA，释放了之后，str1和其他对象仍然指向同一个地址。</p>\n<p>将一个新的字符串内容@”Str a”赋值给str1，并且将str1赋值给str2后，从结果看到str1、str2的内存地址改变了，且指向同一个地址。</p>\n<p>之后创建的str8，对其进行多次release后，内存地址（和strA地址相同）和retaionCount都不曾变化。</p>\n<h5 id=\"NSCFConstantString\"><a href=\"#NSCFConstantString\" class=\"headerlink\" title=\"__NSCFConstantString\"></a>__NSCFConstantString</h5><p>这些对象地址相同，是因为他们都是<strong>NSCFConstantString对象，也就是字符串常量对象，可以看到其isa都是</strong>NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。</p>\n<p>当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。</p>\n<p>总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。</p>\n<h5 id=\"NSCFString\"><a href=\"#NSCFString\" class=\"headerlink\" title=\"__NSCFString\"></a>__NSCFString</h5><p>在上面的输出结果中，我们看到另外还有两类isa分别是：<strong>NSCFString和NSTaggedPointerString，先来看</strong>NSCFString。</p>\n<p>在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str1 = [NSString stringWithFormat:@&quot;ThisIsAStr&quot;];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">NSString *str2 = [str1 retain];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">YLog(str2);</div><div class=\"line\"></div><div class=\"line\">NSString *str3 = [str1 copy];</div><div class=\"line\">YLog(str1);</div><div class=\"line\">YLog(str2);</div><div class=\"line\">YLog(str3);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  1</div><div class=\"line\"></div><div class=\"line\">//str1 retain后赋值给str2</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\"></div><div class=\"line\">//str3由str1浅复制得来</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\">//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  3</div><div class=\"line\"></div><div class=\"line\">//对str1进行release</div><div class=\"line\">//str1: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str2: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div><div class=\"line\">//str3: __NSCFString -&gt; 0x100206c70 : ThisIsAStr  2</div></pre></td></tr></table></figure></p>\n<h5 id=\"NSTaggedPointerString\"><a href=\"#NSTaggedPointerString\" class=\"headerlink\" title=\"NSTaggedPointerString\"></a>NSTaggedPointerString</h5><p>这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。</p>\n<p>对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str1 = @&quot;123456789&quot;; YLog(str1);</div><div class=\"line\">NSString *str2 = [NSString stringWithFormat:@&quot;123456789&quot;]; YLog(str2);</div><div class=\"line\">NSString *str3 = [NSString stringWithFormat:@&quot;1234567890&quot;]; YLog(str3);</div><div class=\"line\">NSString *str4 = [NSString stringWithFormat:@&quot;五&quot;]; YLog(str4);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//str1: __NSCFConstantString -&gt; 0x10a0c5108 : 123456789  18446744073709551615</div><div class=\"line\">//str2: NSTaggedPointerString -&gt; 0xa1ea1f72bb30ab19 : 123456789  18446744073709551615</div><div class=\"line\">//str3: __NSCFString -&gt; 0x7f8183c02630 : 1234567890  1</div><div class=\"line\">//str4: __NSCFString -&gt; 0x7f8183c0fae0 : 五  1</div></pre></td></tr></table></figure>\n<h4 id=\"声明NSSting为属性时用copy还是strong\"><a href=\"#声明NSSting为属性时用copy还是strong\" class=\"headerlink\" title=\"声明NSSting为属性时用copy还是strong\"></a>声明NSSting为属性时用copy还是strong</h4><p>声明NSString属性一般来说用copy，因为父类指针可以指向子类对象，而NSMutableNSString是NSString的子类，使用strong的话该NSString属性可能指向一个NSMutableNSString可变对象，如果这个可变对象的内容在外部被修改了，那该属性所属的对象可能对此毫不知情。</p>\n<p>先来看正常的情况，NSString属性指向一个不可变对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Person对象</div><div class=\"line\">@interface Person : NSObject</div><div class=\"line\">@property (nonatomic, strong) NSString *name;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation Person</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSString *strA = @&quot;Susan_Miller&quot;;</div><div class=\"line\">Person *personA = [Person new];</div><div class=\"line\">personA.name = strA;</div><div class=\"line\">YLog(strA);</div><div class=\"line\">YLog(personA.name);</div><div class=\"line\"></div><div class=\"line\">strA = @&quot;Susan_Test&quot;;</div><div class=\"line\">YLog(strA);</div><div class=\"line\">YLog(personA.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div><div class=\"line\">//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div><div class=\"line\">//strA: __NSCFConstantString -&gt; 0x102f20148 : Susan_Test  18446744073709551615</div><div class=\"line\">//personA.name: __NSCFConstantString -&gt; 0x102f20108 : Susan_Miller  18446744073709551615</div></pre></td></tr></table></figure></p>\n<p>从结果可观察到此时的name属性指向一个不可变的字符串常量，就算strA因为内容变化而生成了新地址，对name属性不会有影响，无论声明name属性时关键字用copy还是strong（不可变对象的copy是浅复制，strong也是指针引用，所以strA内容改变后地址同时改变，不会影响name属性）。</p>\n<p>再来看name属性指向一个可变对象的情况，属性关键字用strong。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//属性关键字为strong</div><div class=\"line\">@property (nonatomic, strong) NSString *name;</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];</div><div class=\"line\">Person *personB = [Person new];</div><div class=\"line\">personB.name = strB;</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">[strB setString:@&quot;Susan_Test&quot;];</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller  2</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Miller  2</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test  2</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7ff9b2c1a090 : Susan_Test  2</div></pre></td></tr></table></figure></p>\n<p>从结果可看出，name属性指向了一个可变对象strB，当strB的内容改变时，name属性也跟着改变，而person对此不知情，可能会产生错误。</p>\n<p>继续来看name属性关键字使用copy时的情况。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//属性关键字为copy</div><div class=\"line\">@property (nonatomic, copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">//测试代码</div><div class=\"line\">NSMutableString *strB = [@&quot;Susan_Miller&quot; mutableCopy];</div><div class=\"line\">Person *personB = [Person new];</div><div class=\"line\">personB.name = strB;</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">[strB setString:@&quot;Susan_Test&quot;];</div><div class=\"line\">YLog(strB);</div><div class=\"line\">YLog(personB.name);</div><div class=\"line\"></div><div class=\"line\">//输出结果</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Miller  1**</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller  1**</div><div class=\"line\">//strB: __NSCFString -&gt; 0x7fb15af31360 : Susan_Test  1**</div><div class=\"line\">//personB.name: __NSCFString -&gt; 0x7fb15af26620 : Susan_Miller  1**</div></pre></td></tr></table></figure></p>\n<p>此时，因为对NSMutableString进行copy是深复制（即内容拷贝），所以name属性与strB指向不同的地址，strB的内容更改不会影响到name属性。</p>\n<p>所以，声明NSString为属性时，如果希望保护属性封装性不受外界影响，则应该使用copy关键字，让所属对象持有的是一份“不可变”（immutable）副本，不用担心字符串内容无意间变动。</p>\n<h3 id=\"去除字符串中的中文\"><a href=\"#去除字符串中的中文\" class=\"headerlink\" title=\"去除字符串中的中文\"></a>去除字符串中的中文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)removeChinese:(NSString *)string &#123;</div><div class=\"line\"></div><div class=\"line\">    NSString *chi = [self getChineseStringWithString:string];</div><div class=\"line\"></div><div class=\"line\">    return [string stringByReplacingOccurrencesOfString:chi withString:@&quot;&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSString *)getChineseStringWithString:(NSString *)string</div><div class=\"line\">&#123;</div><div class=\"line\">    //(unicode中文编码范围是0x4e00~0x9fa5)</div><div class=\"line\">    for (int i = 0; i &lt; string.length; i++) &#123;</div><div class=\"line\">        int utfCode = 0;</div><div class=\"line\">        void *buffer = &amp;utfCode;</div><div class=\"line\">        NSRange range = NSMakeRange(i, 1);</div><div class=\"line\"></div><div class=\"line\">        BOOL b = [string getBytes:buffer maxLength:2 usedLength:NULL encoding:NSUTF16LittleEndianStringEncoding options:NSStringEncodingConversionExternalRepresentation range:range remainingRange:NULL];</div><div class=\"line\"></div><div class=\"line\">        if (b &amp;&amp; (utfCode &gt;= 0x4e00 &amp;&amp; utfCode &lt;= 0x9fa5)) &#123;</div><div class=\"line\">            return [string substringFromIndex:i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"BOOL-containsString-NSString-str-NS-AVAILABLE-10-10-8-0-7以下不可用\"><a href=\"#BOOL-containsString-NSString-str-NS-AVAILABLE-10-10-8-0-7以下不可用\" class=\"headerlink\" title=\"- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用\"></a>- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0);//7以下不可用</h3><h3 id=\"NSString的各种转换\"><a href=\"#NSString的各种转换\" class=\"headerlink\" title=\"NSString的各种转换\"></a>NSString的各种转换</h3><h4 id=\"NSData-与-NSString\"><a href=\"#NSData-与-NSString\" class=\"headerlink\" title=\"NSData 与 NSString\"></a>NSData 与 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; NSString</div><div class=\"line\">　　NSString *aString = [[NSString alloc] initWithData:adata encoding:NSUTF8StringEncoding];</div><div class=\"line\">　　NSString --&gt; NSData</div><div class=\"line\">　　NSString *aString = @&quot;1234&quot;;</div><div class=\"line\">　　NSData *aData = [aString dataUsingEncoding: NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSString转化为UNICODE-String：\"><a href=\"#NSString转化为UNICODE-String：\" class=\"headerlink\" title=\"NSString转化为UNICODE String：\"></a>NSString转化为UNICODE String：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(NSString*)fname ＝ @“Test”;</div><div class=\"line\">char fnameStr[10];</div><div class=\"line\">memcpy(fnameStr, [fname cStringUsingEncoding:NSUnicodeStringEncoding], 2*([fname length]));</div><div class=\"line\">与strcpy相比，memcpy并不是遇到&apos;\\0&apos;就结束，而是一定会拷贝完n个字节</div></pre></td></tr></table></figure>\n<h4 id=\"NSString-转化为-char\"><a href=\"#NSString-转化为-char\" class=\"headerlink\" title=\"NSString 转化为 char *\"></a>NSString 转化为 char *</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString * str＝ @“Test”;</div><div class=\"line\">const char * a =[str UTF8String];</div></pre></td></tr></table></figure>\n<h4 id=\"char-转化为-NSString\"><a href=\"#char-转化为-NSString\" class=\"headerlink\" title=\"char * 转化为 NSString\"></a>char * 转化为 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *str=[NSString stringWithCString encoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"char-转化-NSData\"><a href=\"#char-转化-NSData\" class=\"headerlink\" title=\"char * 转化 NSData\"></a>char * 转化 NSData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法一： char * a = (char*)malloc(sizeof(byte)*16); NSData *data = [NSData dataWithBytes: a length:strlen(a)]; </div><div class=\"line\">方法二： 转换为NSString： - (id)initWithUTF8String:(const char *)bytes 然后用NSString的 - (NSData *)dataUsingEncoding:(NSStringEncoding)encoding</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-转化-char\"><a href=\"#NSData-转化-char\" class=\"headerlink\" title=\"NSData 转化 char *\"></a>NSData 转化 char *</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSData data ； </div><div class=\"line\">char* a=[data bytes];</div></pre></td></tr></table></figure>\n<h4 id=\"NSString-转化-NSURL\"><a href=\"#NSString-转化-NSURL\" class=\"headerlink\" title=\"NSString 转化 NSURL\"></a>NSString 转化 NSURL</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//NSURL *url = [NSURL URLWithString:[str  stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding ]];</div><div class=\"line\"></div><div class=\"line\">NSString *urlString=[@&quot;http://www.google.com/search?client=safari&amp;rls=en&amp;q=搜索&amp;ie=UTF-8&amp;oe=UTF-8&quot; stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSURL-转化-NSString\"><a href=\"#NSURL-转化-NSString\" class=\"headerlink\" title=\"NSURL 转化 NSString\"></a>NSURL 转化 NSString</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSURL *url=[NSURL URLWithString:urlString];</div><div class=\"line\"></div><div class=\"line\">NSString *s=[[url absoluteString] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-Byte\"><a href=\"#NSData-与-Byte\" class=\"headerlink\" title=\"NSData 与 Byte\"></a>NSData 与 Byte</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; Byte</div><div class=\"line\">　　NSString *testString = @&quot;1234567890&quot;;</div><div class=\"line\">　　NSData *testData = [testString dataUsingEncoding: NSUTF8StringEncoding];</div><div class=\"line\">　　Byte *testByte = (Byte *)[testData bytes];</div><div class=\"line\">　　Byte --&gt; NSData</div><div class=\"line\">　　Byte byte[] = &#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23&#125;;</div><div class=\"line\">　　NSData *adata = [[NSData alloc] initWithBytes:byte length:24];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-UIImage\"><a href=\"#NSData-与-UIImage\" class=\"headerlink\" title=\"NSData 与 UIImage\"></a>NSData 与 UIImage</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; UIImage</div><div class=\"line\">　　UIImage *aimage = [UIImage imageWithData: imageData];</div><div class=\"line\">　　//例：从本地文件沙盒中取图片并转换为NSData</div><div class=\"line\">　　NSString *path = [[NSBundle mainBundle] bundlePath];</div><div class=\"line\">　　NSString *name = [NSString stringWithFormat:@&quot;ceshi.png&quot;];</div><div class=\"line\">　　NSString *finalPath = [path stringByAppendingPathComponent:name];</div><div class=\"line\">　　NSData *imageData = [NSData dataWithContentsOfFile: finalPath];</div><div class=\"line\">　　UIImage *aimage = [UIImage imageWithData: imageData];</div><div class=\"line\">　　UIImage－&gt; NSData</div><div class=\"line\">　　NSData *imageData = UIImagePNGRepresentation(aimae);</div></pre></td></tr></table></figure>\n<h4 id=\"NSData-与-NSMutableData\"><a href=\"#NSData-与-NSMutableData\" class=\"headerlink\" title=\"NSData 与 NSMutableData\"></a>NSData 与 NSMutableData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　NSData --&gt; MSMutableData</div><div class=\"line\">　　NSData *data=[[NSData alloc]init];</div><div class=\"line\">　　NSMutableData *mdata=[[NSMutableData alloc]init];</div><div class=\"line\">　　mdata=[NSData dataWithData:data];</div></pre></td></tr></table></figure>\n<h4 id=\"NSData合并为一个NSMutableData\"><a href=\"#NSData合并为一个NSMutableData\" class=\"headerlink\" title=\"NSData合并为一个NSMutableData\"></a>NSData合并为一个NSMutableData</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)filePathWithName:(NSString *)filename</div><div class=\"line\">&#123;</div><div class=\"line\">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</div><div class=\"line\">NSString *documentsDirectory = [paths objectAtIndex:0];</div><div class=\"line\">return [documentsDirectory stringByAppendingPathComponent:filename];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class=\"line\">//音频文件路径</div><div class=\"line\">NSString *mp3Path1 = [[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;mp3&quot;];</div><div class=\"line\">NSString *mp3Path2 = [[NSBundle mainBundle] pathForResource:@&quot;2&quot; ofType:@&quot;mp3&quot;];</div><div class=\"line\">//音频数据</div><div class=\"line\">NSData *sound1Data = [[NSData alloc] initWithContentsOfFile: mp3Path1];</div><div class=\"line\">NSData *sound2Data = [[NSData alloc] initWithContentsOfFile: mp3Path2];</div><div class=\"line\">//合并音频</div><div class=\"line\">NSMutableData *sounds = [NSMutableData alloc];</div><div class=\"line\">[sounds appendData:sound1Data];</div><div class=\"line\">[sounds appendData:sound2Data];</div><div class=\"line\">//保存音频</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;data length:%d&quot;, [sounds length]);</div><div class=\"line\"></div><div class=\"line\">[sounds writeToFile:[self filePathWithName:@&quot;tmp.mp3&quot;] atomically:YES];</div><div class=\"line\"></div><div class=\"line\">[window makeKeyAndVisible];</div><div class=\"line\"></div><div class=\"line\">return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"转译字符\"><a href=\"#转译字符\" class=\"headerlink\" title=\"转译字符\"></a>转译字符</h3><blockquote>\n<p>转义字符 意义 ASCII码值(十进制)<br>\\a 响铃(BEL) 007<br>\\b 退格(BS) 008<br>\\f 换页(FF) 012<br>\\n 换行(LF) 010<br>\\r 回车(CR) 013<br>\\t 水平制表(HT) 009<br>\\v 垂直制表(VT) 011<br>\\ 反斜杠 092<br>\\? 问号字符 063<br>\\’ 单引号字符 039<br>\\” 双引号字符 034<br>\\0 空字符(NULL) 000<br>\\ddd 任意字符 三位八进制<br>\\xhh 任意字符 二位十六进制<br>\\a:蜂鸣，响铃<br>\\b:回退：向后退一格<br>\\f:换页<br>\\n:换行，光标到下行行首<br>\\r:回车，光标到本行行首<br>\\t:水平制表<br>\\v:垂直制表<br>\\:反斜杠<br>\\’:单引号<br>\\”:双引号<br>\\?:问号<br>\\ddd:三位八进制<br>\\xhh:二位十六进制<br>\\0:空字符(NULL),什么都不做<br>注：<br>1，\\v垂直制表和\\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。<br>2，\\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。<br>3，\\t 光标向前移动四格或八格，可以在编译器里设置<br>4，\\’ 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ‘ 即可。<br>5，\\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。</p>\n</blockquote>\n<h3 id=\"常用的富文本\"><a href=\"#常用的富文本\" class=\"headerlink\" title=\"常用的富文本\"></a>常用的富文本</h3><h4 id=\"单纯改变一句话中的某些字的颜色（一种颜色）\"><a href=\"#单纯改变一句话中的某些字的颜色（一种颜色）\" class=\"headerlink\" title=\"单纯改变一句话中的某些字的颜色（一种颜色）\"></a>单纯改变一句话中的某些字的颜色（一种颜色）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变一句话中的某些字的颜色（一种颜色）</div><div class=\"line\">*</div><div class=\"line\">*  @param color    需要改变成的颜色</div><div class=\"line\">*  @param totalStr 总的字符串</div><div class=\"line\">*  @param subArray 需要改变颜色的文字数组(要是有相同的 只取第一个)</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeCorlorWithColor:(UIColor *)color TotalString:(NSString *)totalStr SubStringArray:(NSArray *)subArray &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalStr];</div><div class=\"line\">for (NSString *rangeStr in subArray) &#123;</div><div class=\"line\"></div><div class=\"line\">NSRange range = [totalStr rangeOfString:rangeStr options:NSBackwardsSearch];</div><div class=\"line\">[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"改变每行的字间距\"><a href=\"#改变每行的字间距\" class=\"headerlink\" title=\"改变每行的字间距\"></a>改变每行的字间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变句子的字间距（需要 &lt;CoreText/CoreText.h&gt;）</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要更改的字符串</div><div class=\"line\">*  @param space       字间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeSpaceWithTotalString:(NSString *)totalString Space:(CGFloat)space &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\">long number = space;</div><div class=\"line\">CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</div><div class=\"line\">[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];</div><div class=\"line\">CFRelease(num);</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"改变行间距\"><a href=\"#改变行间距\" class=\"headerlink\" title=\"改变行间距\"></a>改变行间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  单纯改变段落的行间距</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要更改的字符串</div><div class=\"line\">*  @param lineSpace   行间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeLineSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">[paragraphStyle setLineSpacing:lineSpace];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"同时更改行间距和字间距\"><a href=\"#同时更改行间距和字间距\" class=\"headerlink\" title=\"同时更改行间距和字间距\"></a>同时更改行间距和字间距</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  同时更改行间距和字间距</div><div class=\"line\">*</div><div class=\"line\">*  @param totalString 需要改变的字符串</div><div class=\"line\">*  @param lineSpace   行间距</div><div class=\"line\">*  @param textSpace   字间距</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeLineAndTextSpaceWithTotalString:(NSString *)totalString LineSpace:(CGFloat)lineSpace textSpace:(CGFloat)textSpace &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">NSMutableParagraphStyle * paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">[paragraphStyle setLineSpacing:lineSpace];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [totalString length])];</div><div class=\"line\"></div><div class=\"line\">long number = textSpace;</div><div class=\"line\">CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</div><div class=\"line\">[attributedStr addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[attributedStr length])];</div><div class=\"line\">CFRelease(num);</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"更改某些文字的颜色并修改其字体，突出重点强调\"><a href=\"#更改某些文字的颜色并修改其字体，突出重点强调\" class=\"headerlink\" title=\"更改某些文字的颜色并修改其字体，突出重点强调\"></a>更改某些文字的颜色并修改其字体，突出重点强调</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">*  改变某些文字的颜色 并单独设置其字体</div><div class=\"line\">*</div><div class=\"line\">*  @param font        设置的字体</div><div class=\"line\">*  @param color       颜色</div><div class=\"line\">*  @param totalString 总的字符串</div><div class=\"line\">*  @param subArray    想要变色的字符数组</div><div class=\"line\">*</div><div class=\"line\">*  @return 生成的富文本</div><div class=\"line\">*/</div><div class=\"line\">+ (NSMutableAttributedString *)ls_changeFontAndColor:(UIFont *)font Color:(UIColor *)color TotalString:(NSString *)totalString SubStringArray:(NSArray *)subArray &#123;</div><div class=\"line\"></div><div class=\"line\">NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:totalString];</div><div class=\"line\"></div><div class=\"line\">for (NSString *rangeStr in subArray) &#123;</div><div class=\"line\"></div><div class=\"line\">NSRange range = [totalString rangeOfString:rangeStr options:NSBackwardsSearch];</div><div class=\"line\"></div><div class=\"line\">[attributedStr addAttribute:NSForegroundColorAttributeName value:color range:range];</div><div class=\"line\">[attributedStr addAttribute:NSFontAttributeName value:font range:range];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return attributedStr;</div></pre></td></tr></table></figure>\n<h3 id=\"富文本相关属性汇总\"><a href=\"#富文本相关属性汇总\" class=\"headerlink\" title=\"富文本相关属性汇总\"></a>富文本相关属性汇总</h3><blockquote>\n<ul>\n<li>NSFontAttributeName ：字体字号<ul>\n<li>value值：UIFont类型</li>\n</ul>\n</li>\n<li>NSParagraphStyleAttributeName ： 段落样式<ul>\n<li>value值：NSParagraphStyle类型（其属性如下）</li>\n<li>lineSpacing 行间距(具体用法可查看上面的设置行间距API)</li>\n<li>paragraphSpacing 段落间距</li>\n<li>alignment 对齐方式</li>\n<li>firstLineHeadIndent 指定段落开始的缩进像素</li>\n<li>headIndent 调整全部文字的缩进像素</li>\n</ul>\n</li>\n<li>NSForegroundColorAttributeName 字体颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSBackgroundColorAttributeName 背景颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSObliquenessAttributeName 字体粗倾斜<ul>\n<li>value值：NSNumber类型</li>\n</ul>\n</li>\n<li>NSExpansionAttributeName 字体加粗<ul>\n<li>value值：NSNumber类型(比例) 0就是不变 1增加一倍</li>\n</ul>\n</li>\n<li>NSKernAttributeName 字间距<ul>\n<li>value值：CGFloat类型</li>\n</ul>\n</li>\n<li>NSUnderlineStyleAttributeName 下划线<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSUnderlineColorAttributeName 下划线颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrikethroughStyleAttributeName 删除线<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSStrikethroughColorAttributeName 删除线颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrokeColorAttributeName 字体颜色<ul>\n<li>value值：UIColor类型</li>\n</ul>\n</li>\n<li>NSStrokeWidthAttributeName 字体描边<ul>\n<li>value值：CGFloat</li>\n</ul>\n</li>\n<li>NSLigatureAttributeName 连笔字<ul>\n<li>value值：1或0</li>\n</ul>\n</li>\n<li>NSShadowAttributeName 阴影<ul>\n<li>value值：NSShawdow类型（下面是其属性）</li>\n<li>shadowOffset 影子与字符串的偏移量</li>\n<li>shadowBlurRadius 影子的模糊程度</li>\n<li>shadowColor 影子的颜色</li>\n</ul>\n</li>\n<li>NSTextEffectAttributeName 设置文本特殊效果,目前只有图版印刷效果可用<ul>\n<li>value值：NSString类型</li>\n</ul>\n</li>\n<li>NSAttachmentAttributeName 设置文本附件<ul>\n<li>value值：NSTextAttachment类型（没研究过，可自行百度研究）</li>\n</ul>\n</li>\n<li>NSLinkAttributeName 链接<ul>\n<li>value值：NSURL (preferred) or NSString类型</li>\n</ul>\n</li>\n<li>NSBaselineOffsetAttributeName 基准线偏移<ul>\n<li>value值：NSNumber类型</li>\n</ul>\n</li>\n<li>NSWritingDirectionAttributeName 文字方向 分别代表不同的文字出现方向<ul>\n<li>value值：@[@(1),@(2)]</li>\n</ul>\n</li>\n<li>NSVerticalGlyphFormAttributeName 水平或者竖直文本 在iOS没卵用，不支持竖版<ul>\n<li>value值：1竖直 0水平</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"获取汉字的拼音\"><a href=\"#获取汉字的拼音\" class=\"headerlink\" title=\"获取汉字的拼音\"></a>获取汉字的拼音</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSString *)transform:(NSString *)chinese</div><div class=\"line\">&#123;</div><div class=\"line\">//将NSString装换成NSMutableString</div><div class=\"line\">NSMutableString *pinyin = [chinese mutableCopy];</div><div class=\"line\">//将汉字转换为拼音(带音标)</div><div class=\"line\">CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO);</div><div class=\"line\">NSLog(@&quot;%@&quot;, pinyin);</div><div class=\"line\">//去掉拼音的音标</div><div class=\"line\">CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO);</div><div class=\"line\">NSLog(@&quot;%@&quot;, pinyin);</div><div class=\"line\">//返回最近结果</div><div class=\"line\">return pinyin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UIKit系列---UIButton","date":"2014-12-03T12:03:53.000Z","_content":"\n### 1.一个界面内有多个button要防止同时点击\n每个button都设置该属性\n```\n[btn setExclusiveTouch:YES];\n```\n<!--more-->\n### 2.button不同状态下图片切换失效\n如果你设置了normal状态下的button的图片，然后你设置disable状态下图片为nil，你会发现当你切换状态的时候，图片并不会变成nil，你许雅做的事，做一张像素为空的图片，然后在disable状态下，把按钮的图片设置为这个像素为空的图片\n\n### 3.iOS7的UIButton第二次调用settiltle方法失效\n这种情况下需要自定义button，替换button本身的方法，典型的应用场景是，按钮显示倒计时，或者切换关注和未关注状态\n```\n#define iOS7  ( [[[UIDevice currentDevice] systemVersion] compare:@\"7.0\"] != NSOrderedAscending )\n\n@(11-经典bug)interface SongShowReleaseButton()\n@property (nonatomic, strong) UILabel *theNewTitleLable;\n@end\n\n@implementation SongShowReleaseButton\n/**theNewTiltleLable*/\n- (UILabel *)theNewTitleLable {\n    if (_theNewTitleLable == nil) {\n        _theNewTitleLable = [[UILabel alloc] init];\n        _theNewTitleLable.font = [UIFont boldSystemFontOfSize:16];\n    }\n    return _theNewTitleLable;\n}\n\n- (void)setTitle:(NSString *)title forState:(UIControlState)state {\n    DLog(@\"----%@\", title);\n    if (iOS7) {\n        self.theNewTitleLable.text = title;\n        [self.theNewTitleLable sizeToFit];\n        self.theNewTitleLable.center = CGPointMake(self.width / 2, self.height / 2);\n        [self addSubview:self.theNewTitleLable];\n    }else {\n        [super setTitle:title forState:state];\n    }\n}\n\n- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state {\n    if (iOS7) {\n        self.theNewTitleLable.textColor = color;\n    }else {\n        [super setTitleColor:color forState:state];\n    }\n}\n```\n\n### 4.target的方法被多次调用\n检查是否添加target的方法被执行了多次\n\n### 5.button实现双击调用\n```\n  [button addTarget:self action:@selector(onTouchUpInside:withEvent:) forControlEvents:UIControlEventTouchUpInside];\n\n   -(void)onTouchUpInside:(id)sender withEvent:(UIEvent*)event \n{\n    UITouch* touch = [[event allTouches] anyObject];\n    NSLog(@\"onTouchUpInside tagCount:%d\",touch.tapCount);\n\n    //判断点击次数\n    if (touch.tapCount == 1) \n    {\n\n       //todo\n    }\n}\n```\n\n### 5.button长按事件\n```\nUIButton *aBtn=[UIButton buttonWithType:UIButtonTypeCustom];  \n    [aBtn setFrame:CGRectMake(40, 100, 60, 60)];  \n    [aBtn setBackgroundImage:[UIImage imageNamed:@\"111.png\"]forState:UIControlStateNormal];  \n    //button点击事件  \n    [aBtn addTarget:self action:@selector(btnShort:)forControlEvents:UIControlEventTouchUpInside];  \n    //button长按事件  \n    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:selfaction:@selector(btnLong:)];   \n    longPress.minimumPressDuration = 0.8; //定义按的时间  \n    [aBtn addGestureRecognizer:longPress];  \n  \n-(void)btnLong:(UILongPressGestureRecognizer*)gestureRecognizer{  \n    if ([gestureRecognizer state] == UIGestureRecognizerStateBegan) {  \n        NSLog(@\"长按事件\");  \n        UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@\"消息\" message:@\"确定删除该模式吗？\" delegate:selfcancelButtonTitle:@\"取消\" otherButtonTitles:@\"删除\", nil nil];  \n        [alert show];  \n    }  \n}  \n```\n\n### 6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\n\n\n### 7.在UIButton中addSubview的问题\n\n>UIView的userInteractionEnabled值默认为YES，必须设置UIButton所有的subview的userInteractionEnabled为NO，才能让UIButton正常响应点击。\n但是如果设置了UIView的setUserInteractionEnabled为NO，其子view都将得不到响应。\n\n### 8.扩大按钮点击范围\n```\nimport <UIKit/UIKit.h>\n\n@interface UIButton (EnlargeTouchArea)\n\n- (void)setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left;\n\n@end\n\n\n\n#import \"UIButton+EnlargeTouchArea.h\"\n#import <objc/runtime.h>\n@implementation UIButton (EnlargeTouchArea)\n\n\nstatic char topNameKey;\nstatic char rightNameKey;\nstatic char bottomNameKey;\nstatic char leftNameKey;\n\n- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left\n{\n    objc_setAssociatedObject(self, &topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n- (CGRect) enlargedRect\n{\n    NSNumber* topEdge = objc_getAssociatedObject(self, &topNameKey);\n    NSNumber* rightEdge = objc_getAssociatedObject(self, &rightNameKey);\n    NSNumber* bottomEdge = objc_getAssociatedObject(self, &bottomNameKey);\n    NSNumber* leftEdge = objc_getAssociatedObject(self, &leftNameKey);\n    if (topEdge && rightEdge && bottomEdge && leftEdge)\n    {\n        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,\n                          self.bounds.origin.y - topEdge.floatValue,\n                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,\n                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);\n    }\n    else\n    {\n        return self.bounds;\n    }\n}\n\n- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event\n{\n    CGRect rect = [self enlargedRect];\n    if (CGRectEqualToRect(rect, self.bounds))\n    {\n        return [super hitTest:point withEvent:event];\n    }\n    return CGRectContainsPoint(rect, point) ? self : nil;\n} \n```\n","source":"_posts/2014/UIKit系列-UIButton.md","raw":"---\ntitle: UIKit系列---UIButton\ndate: 2014-12-3 20:03:53\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\n### 1.一个界面内有多个button要防止同时点击\n每个button都设置该属性\n```\n[btn setExclusiveTouch:YES];\n```\n<!--more-->\n### 2.button不同状态下图片切换失效\n如果你设置了normal状态下的button的图片，然后你设置disable状态下图片为nil，你会发现当你切换状态的时候，图片并不会变成nil，你许雅做的事，做一张像素为空的图片，然后在disable状态下，把按钮的图片设置为这个像素为空的图片\n\n### 3.iOS7的UIButton第二次调用settiltle方法失效\n这种情况下需要自定义button，替换button本身的方法，典型的应用场景是，按钮显示倒计时，或者切换关注和未关注状态\n```\n#define iOS7  ( [[[UIDevice currentDevice] systemVersion] compare:@\"7.0\"] != NSOrderedAscending )\n\n@(11-经典bug)interface SongShowReleaseButton()\n@property (nonatomic, strong) UILabel *theNewTitleLable;\n@end\n\n@implementation SongShowReleaseButton\n/**theNewTiltleLable*/\n- (UILabel *)theNewTitleLable {\n    if (_theNewTitleLable == nil) {\n        _theNewTitleLable = [[UILabel alloc] init];\n        _theNewTitleLable.font = [UIFont boldSystemFontOfSize:16];\n    }\n    return _theNewTitleLable;\n}\n\n- (void)setTitle:(NSString *)title forState:(UIControlState)state {\n    DLog(@\"----%@\", title);\n    if (iOS7) {\n        self.theNewTitleLable.text = title;\n        [self.theNewTitleLable sizeToFit];\n        self.theNewTitleLable.center = CGPointMake(self.width / 2, self.height / 2);\n        [self addSubview:self.theNewTitleLable];\n    }else {\n        [super setTitle:title forState:state];\n    }\n}\n\n- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state {\n    if (iOS7) {\n        self.theNewTitleLable.textColor = color;\n    }else {\n        [super setTitleColor:color forState:state];\n    }\n}\n```\n\n### 4.target的方法被多次调用\n检查是否添加target的方法被执行了多次\n\n### 5.button实现双击调用\n```\n  [button addTarget:self action:@selector(onTouchUpInside:withEvent:) forControlEvents:UIControlEventTouchUpInside];\n\n   -(void)onTouchUpInside:(id)sender withEvent:(UIEvent*)event \n{\n    UITouch* touch = [[event allTouches] anyObject];\n    NSLog(@\"onTouchUpInside tagCount:%d\",touch.tapCount);\n\n    //判断点击次数\n    if (touch.tapCount == 1) \n    {\n\n       //todo\n    }\n}\n```\n\n### 5.button长按事件\n```\nUIButton *aBtn=[UIButton buttonWithType:UIButtonTypeCustom];  \n    [aBtn setFrame:CGRectMake(40, 100, 60, 60)];  \n    [aBtn setBackgroundImage:[UIImage imageNamed:@\"111.png\"]forState:UIControlStateNormal];  \n    //button点击事件  \n    [aBtn addTarget:self action:@selector(btnShort:)forControlEvents:UIControlEventTouchUpInside];  \n    //button长按事件  \n    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:selfaction:@selector(btnLong:)];   \n    longPress.minimumPressDuration = 0.8; //定义按的时间  \n    [aBtn addGestureRecognizer:longPress];  \n  \n-(void)btnLong:(UILongPressGestureRecognizer*)gestureRecognizer{  \n    if ([gestureRecognizer state] == UIGestureRecognizerStateBegan) {  \n        NSLog(@\"长按事件\");  \n        UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@\"消息\" message:@\"确定删除该模式吗？\" delegate:selfcancelButtonTitle:@\"取消\" otherButtonTitles:@\"删除\", nil nil];  \n        [alert show];  \n    }  \n}  \n```\n\n### 6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\n\n\n### 7.在UIButton中addSubview的问题\n\n>UIView的userInteractionEnabled值默认为YES，必须设置UIButton所有的subview的userInteractionEnabled为NO，才能让UIButton正常响应点击。\n但是如果设置了UIView的setUserInteractionEnabled为NO，其子view都将得不到响应。\n\n### 8.扩大按钮点击范围\n```\nimport <UIKit/UIKit.h>\n\n@interface UIButton (EnlargeTouchArea)\n\n- (void)setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left;\n\n@end\n\n\n\n#import \"UIButton+EnlargeTouchArea.h\"\n#import <objc/runtime.h>\n@implementation UIButton (EnlargeTouchArea)\n\n\nstatic char topNameKey;\nstatic char rightNameKey;\nstatic char bottomNameKey;\nstatic char leftNameKey;\n\n- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left\n{\n    objc_setAssociatedObject(self, &topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);\n    objc_setAssociatedObject(self, &leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n- (CGRect) enlargedRect\n{\n    NSNumber* topEdge = objc_getAssociatedObject(self, &topNameKey);\n    NSNumber* rightEdge = objc_getAssociatedObject(self, &rightNameKey);\n    NSNumber* bottomEdge = objc_getAssociatedObject(self, &bottomNameKey);\n    NSNumber* leftEdge = objc_getAssociatedObject(self, &leftNameKey);\n    if (topEdge && rightEdge && bottomEdge && leftEdge)\n    {\n        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,\n                          self.bounds.origin.y - topEdge.floatValue,\n                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,\n                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);\n    }\n    else\n    {\n        return self.bounds;\n    }\n}\n\n- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event\n{\n    CGRect rect = [self enlargedRect];\n    if (CGRectEqualToRect(rect, self.bounds))\n    {\n        return [super hitTest:point withEvent:event];\n    }\n    return CGRectContainsPoint(rect, point) ? self : nil;\n} \n```\n","slug":"2014/UIKit系列-UIButton","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4plz001nsauag3d4qph3","content":"<h3 id=\"1-一个界面内有多个button要防止同时点击\"><a href=\"#1-一个界面内有多个button要防止同时点击\" class=\"headerlink\" title=\"1.一个界面内有多个button要防止同时点击\"></a>1.一个界面内有多个button要防止同时点击</h3><p>每个button都设置该属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn setExclusiveTouch:YES];</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"2-button不同状态下图片切换失效\"><a href=\"#2-button不同状态下图片切换失效\" class=\"headerlink\" title=\"2.button不同状态下图片切换失效\"></a>2.button不同状态下图片切换失效</h3><p>如果你设置了normal状态下的button的图片，然后你设置disable状态下图片为nil，你会发现当你切换状态的时候，图片并不会变成nil，你许雅做的事，做一张像素为空的图片，然后在disable状态下，把按钮的图片设置为这个像素为空的图片</p>\n<h3 id=\"3-iOS7的UIButton第二次调用settiltle方法失效\"><a href=\"#3-iOS7的UIButton第二次调用settiltle方法失效\" class=\"headerlink\" title=\"3.iOS7的UIButton第二次调用settiltle方法失效\"></a>3.iOS7的UIButton第二次调用settiltle方法失效</h3><p>这种情况下需要自定义button，替换button本身的方法，典型的应用场景是，按钮显示倒计时，或者切换关注和未关注状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define iOS7  ( [[[UIDevice currentDevice] systemVersion] compare:@&quot;7.0&quot;] != NSOrderedAscending )</div><div class=\"line\"></div><div class=\"line\">@(11-经典bug)interface SongShowReleaseButton()</div><div class=\"line\">@property (nonatomic, strong) UILabel *theNewTitleLable;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation SongShowReleaseButton</div><div class=\"line\">/**theNewTiltleLable*/</div><div class=\"line\">- (UILabel *)theNewTitleLable &#123;</div><div class=\"line\">    if (_theNewTitleLable == nil) &#123;</div><div class=\"line\">        _theNewTitleLable = [[UILabel alloc] init];</div><div class=\"line\">        _theNewTitleLable.font = [UIFont boldSystemFontOfSize:16];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _theNewTitleLable;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setTitle:(NSString *)title forState:(UIControlState)state &#123;</div><div class=\"line\">    DLog(@&quot;----%@&quot;, title);</div><div class=\"line\">    if (iOS7) &#123;</div><div class=\"line\">        self.theNewTitleLable.text = title;</div><div class=\"line\">        [self.theNewTitleLable sizeToFit];</div><div class=\"line\">        self.theNewTitleLable.center = CGPointMake(self.width / 2, self.height / 2);</div><div class=\"line\">        [self addSubview:self.theNewTitleLable];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        [super setTitle:title forState:state];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state &#123;</div><div class=\"line\">    if (iOS7) &#123;</div><div class=\"line\">        self.theNewTitleLable.textColor = color;</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        [super setTitleColor:color forState:state];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-target的方法被多次调用\"><a href=\"#4-target的方法被多次调用\" class=\"headerlink\" title=\"4.target的方法被多次调用\"></a>4.target的方法被多次调用</h3><p>检查是否添加target的方法被执行了多次</p>\n<h3 id=\"5-button实现双击调用\"><a href=\"#5-button实现双击调用\" class=\"headerlink\" title=\"5.button实现双击调用\"></a>5.button实现双击调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">  [button addTarget:self action:@selector(onTouchUpInside:withEvent:) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">   -(void)onTouchUpInside:(id)sender withEvent:(UIEvent*)event </div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch* touch = [[event allTouches] anyObject];</div><div class=\"line\">    NSLog(@&quot;onTouchUpInside tagCount:%d&quot;,touch.tapCount);</div><div class=\"line\"></div><div class=\"line\">    //判断点击次数</div><div class=\"line\">    if (touch.tapCount == 1) </div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">       //todo</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-button长按事件\"><a href=\"#5-button长按事件\" class=\"headerlink\" title=\"5.button长按事件\"></a>5.button长按事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIButton *aBtn=[UIButton buttonWithType:UIButtonTypeCustom];  </div><div class=\"line\">    [aBtn setFrame:CGRectMake(40, 100, 60, 60)];  </div><div class=\"line\">    [aBtn setBackgroundImage:[UIImage imageNamed:@&quot;111.png&quot;]forState:UIControlStateNormal];  </div><div class=\"line\">    //button点击事件  </div><div class=\"line\">    [aBtn addTarget:self action:@selector(btnShort:)forControlEvents:UIControlEventTouchUpInside];  </div><div class=\"line\">    //button长按事件  </div><div class=\"line\">    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:selfaction:@selector(btnLong:)];   </div><div class=\"line\">    longPress.minimumPressDuration = 0.8; //定义按的时间  </div><div class=\"line\">    [aBtn addGestureRecognizer:longPress];  </div><div class=\"line\">  </div><div class=\"line\">-(void)btnLong:(UILongPressGestureRecognizer*)gestureRecognizer&#123;  </div><div class=\"line\">    if ([gestureRecognizer state] == UIGestureRecognizerStateBegan) &#123;  </div><div class=\"line\">        NSLog(@&quot;长按事件&quot;);  </div><div class=\"line\">        UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@&quot;消息&quot; message:@&quot;确定删除该模式吗？&quot; delegate:selfcancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;删除&quot;, nil nil];  </div><div class=\"line\">        [alert show];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\"><a href=\"#6-button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\" class=\"headerlink\" title=\"6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\"></a>6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件</h3><h3 id=\"7-在UIButton中addSubview的问题\"><a href=\"#7-在UIButton中addSubview的问题\" class=\"headerlink\" title=\"7.在UIButton中addSubview的问题\"></a>7.在UIButton中addSubview的问题</h3><blockquote>\n<p>UIView的userInteractionEnabled值默认为YES，必须设置UIButton所有的subview的userInteractionEnabled为NO，才能让UIButton正常响应点击。<br>但是如果设置了UIView的setUserInteractionEnabled为NO，其子view都将得不到响应。</p>\n</blockquote>\n<h3 id=\"8-扩大按钮点击范围\"><a href=\"#8-扩大按钮点击范围\" class=\"headerlink\" title=\"8.扩大按钮点击范围\"></a>8.扩大按钮点击范围</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface UIButton (EnlargeTouchArea)</div><div class=\"line\"></div><div class=\"line\">- (void)setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;UIButton+EnlargeTouchArea.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UIButton (EnlargeTouchArea)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">static char topNameKey;</div><div class=\"line\">static char rightNameKey;</div><div class=\"line\">static char bottomNameKey;</div><div class=\"line\">static char leftNameKey;</div><div class=\"line\"></div><div class=\"line\">- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (CGRect) enlargedRect</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber* topEdge = objc_getAssociatedObject(self, &amp;topNameKey);</div><div class=\"line\">    NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;rightNameKey);</div><div class=\"line\">    NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;bottomNameKey);</div><div class=\"line\">    NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;leftNameKey);</div><div class=\"line\">    if (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge)</div><div class=\"line\">    &#123;</div><div class=\"line\">        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,</div><div class=\"line\">                          self.bounds.origin.y - topEdge.floatValue,</div><div class=\"line\">                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</div><div class=\"line\">                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        return self.bounds;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = [self enlargedRect];</div><div class=\"line\">    if (CGRectEqualToRect(rect, self.bounds))</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [super hitTest:point withEvent:event];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return CGRectContainsPoint(rect, point) ? self : nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-一个界面内有多个button要防止同时点击\"><a href=\"#1-一个界面内有多个button要防止同时点击\" class=\"headerlink\" title=\"1.一个界面内有多个button要防止同时点击\"></a>1.一个界面内有多个button要防止同时点击</h3><p>每个button都设置该属性<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[btn setExclusiveTouch:YES];</div></pre></td></tr></table></figure></p>","more":"<h3 id=\"2-button不同状态下图片切换失效\"><a href=\"#2-button不同状态下图片切换失效\" class=\"headerlink\" title=\"2.button不同状态下图片切换失效\"></a>2.button不同状态下图片切换失效</h3><p>如果你设置了normal状态下的button的图片，然后你设置disable状态下图片为nil，你会发现当你切换状态的时候，图片并不会变成nil，你许雅做的事，做一张像素为空的图片，然后在disable状态下，把按钮的图片设置为这个像素为空的图片</p>\n<h3 id=\"3-iOS7的UIButton第二次调用settiltle方法失效\"><a href=\"#3-iOS7的UIButton第二次调用settiltle方法失效\" class=\"headerlink\" title=\"3.iOS7的UIButton第二次调用settiltle方法失效\"></a>3.iOS7的UIButton第二次调用settiltle方法失效</h3><p>这种情况下需要自定义button，替换button本身的方法，典型的应用场景是，按钮显示倒计时，或者切换关注和未关注状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define iOS7  ( [[[UIDevice currentDevice] systemVersion] compare:@&quot;7.0&quot;] != NSOrderedAscending )</div><div class=\"line\"></div><div class=\"line\">@(11-经典bug)interface SongShowReleaseButton()</div><div class=\"line\">@property (nonatomic, strong) UILabel *theNewTitleLable;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation SongShowReleaseButton</div><div class=\"line\">/**theNewTiltleLable*/</div><div class=\"line\">- (UILabel *)theNewTitleLable &#123;</div><div class=\"line\">    if (_theNewTitleLable == nil) &#123;</div><div class=\"line\">        _theNewTitleLable = [[UILabel alloc] init];</div><div class=\"line\">        _theNewTitleLable.font = [UIFont boldSystemFontOfSize:16];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _theNewTitleLable;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setTitle:(NSString *)title forState:(UIControlState)state &#123;</div><div class=\"line\">    DLog(@&quot;----%@&quot;, title);</div><div class=\"line\">    if (iOS7) &#123;</div><div class=\"line\">        self.theNewTitleLable.text = title;</div><div class=\"line\">        [self.theNewTitleLable sizeToFit];</div><div class=\"line\">        self.theNewTitleLable.center = CGPointMake(self.width / 2, self.height / 2);</div><div class=\"line\">        [self addSubview:self.theNewTitleLable];</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        [super setTitle:title forState:state];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state &#123;</div><div class=\"line\">    if (iOS7) &#123;</div><div class=\"line\">        self.theNewTitleLable.textColor = color;</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        [super setTitleColor:color forState:state];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"4-target的方法被多次调用\"><a href=\"#4-target的方法被多次调用\" class=\"headerlink\" title=\"4.target的方法被多次调用\"></a>4.target的方法被多次调用</h3><p>检查是否添加target的方法被执行了多次</p>\n<h3 id=\"5-button实现双击调用\"><a href=\"#5-button实现双击调用\" class=\"headerlink\" title=\"5.button实现双击调用\"></a>5.button实现双击调用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">  [button addTarget:self action:@selector(onTouchUpInside:withEvent:) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">   -(void)onTouchUpInside:(id)sender withEvent:(UIEvent*)event </div><div class=\"line\">&#123;</div><div class=\"line\">    UITouch* touch = [[event allTouches] anyObject];</div><div class=\"line\">    NSLog(@&quot;onTouchUpInside tagCount:%d&quot;,touch.tapCount);</div><div class=\"line\"></div><div class=\"line\">    //判断点击次数</div><div class=\"line\">    if (touch.tapCount == 1) </div><div class=\"line\">    &#123;</div><div class=\"line\"></div><div class=\"line\">       //todo</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"5-button长按事件\"><a href=\"#5-button长按事件\" class=\"headerlink\" title=\"5.button长按事件\"></a>5.button长按事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIButton *aBtn=[UIButton buttonWithType:UIButtonTypeCustom];  </div><div class=\"line\">    [aBtn setFrame:CGRectMake(40, 100, 60, 60)];  </div><div class=\"line\">    [aBtn setBackgroundImage:[UIImage imageNamed:@&quot;111.png&quot;]forState:UIControlStateNormal];  </div><div class=\"line\">    //button点击事件  </div><div class=\"line\">    [aBtn addTarget:self action:@selector(btnShort:)forControlEvents:UIControlEventTouchUpInside];  </div><div class=\"line\">    //button长按事件  </div><div class=\"line\">    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:selfaction:@selector(btnLong:)];   </div><div class=\"line\">    longPress.minimumPressDuration = 0.8; //定义按的时间  </div><div class=\"line\">    [aBtn addGestureRecognizer:longPress];  </div><div class=\"line\">  </div><div class=\"line\">-(void)btnLong:(UILongPressGestureRecognizer*)gestureRecognizer&#123;  </div><div class=\"line\">    if ([gestureRecognizer state] == UIGestureRecognizerStateBegan) &#123;  </div><div class=\"line\">        NSLog(@&quot;长按事件&quot;);  </div><div class=\"line\">        UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@&quot;消息&quot; message:@&quot;确定删除该模式吗？&quot; delegate:selfcancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;删除&quot;, nil nil];  </div><div class=\"line\">        [alert show];  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6-button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\"><a href=\"#6-button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\" class=\"headerlink\" title=\"6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件\"></a>6.button在被点击完之后如果是耗时操作可以禁止点击，防止多次触发，等事件返回之后再放开按钮点击事件</h3><h3 id=\"7-在UIButton中addSubview的问题\"><a href=\"#7-在UIButton中addSubview的问题\" class=\"headerlink\" title=\"7.在UIButton中addSubview的问题\"></a>7.在UIButton中addSubview的问题</h3><blockquote>\n<p>UIView的userInteractionEnabled值默认为YES，必须设置UIButton所有的subview的userInteractionEnabled为NO，才能让UIButton正常响应点击。<br>但是如果设置了UIView的setUserInteractionEnabled为NO，其子view都将得不到响应。</p>\n</blockquote>\n<h3 id=\"8-扩大按钮点击范围\"><a href=\"#8-扩大按钮点击范围\" class=\"headerlink\" title=\"8.扩大按钮点击范围\"></a>8.扩大按钮点击范围</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &lt;UIKit/UIKit.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface UIButton (EnlargeTouchArea)</div><div class=\"line\"></div><div class=\"line\">- (void)setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;UIButton+EnlargeTouchArea.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UIButton (EnlargeTouchArea)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">static char topNameKey;</div><div class=\"line\">static char rightNameKey;</div><div class=\"line\">static char bottomNameKey;</div><div class=\"line\">static char leftNameKey;</div><div class=\"line\"></div><div class=\"line\">- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">    objc_setAssociatedObject(self, &amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (CGRect) enlargedRect</div><div class=\"line\">&#123;</div><div class=\"line\">    NSNumber* topEdge = objc_getAssociatedObject(self, &amp;topNameKey);</div><div class=\"line\">    NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;rightNameKey);</div><div class=\"line\">    NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;bottomNameKey);</div><div class=\"line\">    NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;leftNameKey);</div><div class=\"line\">    if (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge)</div><div class=\"line\">    &#123;</div><div class=\"line\">        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,</div><div class=\"line\">                          self.bounds.origin.y - topEdge.floatValue,</div><div class=\"line\">                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</div><div class=\"line\">                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</div><div class=\"line\">    &#125;</div><div class=\"line\">    else</div><div class=\"line\">    &#123;</div><div class=\"line\">        return self.bounds;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIView*) hitTest:(CGPoint) point withEvent:(UIEvent*) event</div><div class=\"line\">&#123;</div><div class=\"line\">    CGRect rect = [self enlargedRect];</div><div class=\"line\">    if (CGRectEqualToRect(rect, self.bounds))</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [super hitTest:point withEvent:event];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return CGRectContainsPoint(rect, point) ? self : nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"UIKit系列--UILable","date":"2014-11-16T02:17:32.000Z","_content":"\n### 多行UILabel的高度计算1\n```\nUILabel *titleLabel = [UILabel new];\ntitleLabel.font = [UIFont systemFontOfSize:14];\nNSString *titleContent = @\"亲，欢迎您通过以下方式与我们的营销顾问取得联系，交流您再营销推广工作中遇到的问题，营销顾问将免费为您提供咨询服务。\";\ntitleLabel.text = titleContent;\ntitleLabel.numberOfLines = 0;//多行显示，计算高度\ntitleLabel.textColor = [UIColor lightGrayColor];\nCGSize titleSize = [titleContent boundingRectWithSize:CGSizeMake(kScreen_Width, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:14]} context:nil].size;\ntitleLabel.size = titleSize;\ntitleLabel.x = 0;\ntitleLabel.y = 0;\n\n[self.view addSubview:titleLabel];\n```\n\n### 多行UILabel的高度计算2\n\n```\n- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text {\n    \n    [self setLineSpace:lineSpace andMaxWidth:maxWidth andMaxHeight:maxHeight andFont:font textColor:color withText:text andLeftSpace:0];\n}\n\n- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text andLeftSpace:(CGFloat)width {\n    if (!text) {\n        text = @\"\";\n    }\n    self.numberOfLines = 0;\n    NSMutableParagraphStyle* parag = [[NSMutableParagraphStyle alloc] init];\n    \n    [parag setLineSpacing:lineSpace];\n    parag.lineBreakMode = NSLineBreakByCharWrapping;\n    \n    NSDictionary *attributes = @{NSFontAttributeName:font,NSParagraphStyleAttributeName:parag,NSForegroundColorAttributeName:color};\n    if (width != 0) {\n        [parag setFirstLineHeadIndent:width];//首行缩进\n    }\n    self.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attributes];\n    \n    NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init];\n    paraStyle.lineBreakMode = NSLineBreakByCharWrapping;\n    paraStyle.lineSpacing = lineSpace;\n    if (width != 0) {\n        [paraStyle setFirstLineHeadIndent:width];//首行缩进\n    }\n    NSDictionary *dic = @{NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.1f\n                          };\n    CGFloat maxH = MAXFLOAT;\n    if (maxHeight != 0) {\n        maxH = maxHeight;\n    }\n    \n    CGSize sizeH = [text boundingRectWithSize:CGSizeMake(maxWidth, maxH) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size;\n    \n    CGRect frame = self.frame;\n    CGPoint position = frame.origin;\n    self.frame = CGRectMake(position.x, position.y, maxWidth, sizeH.height);\n    self.lineBreakMode = NSLineBreakByTruncatingTail;\n}\n```\n上边的代码基本上做到了，设置好文字的宽度和高度，然后给一段文字可以自动的折行，自动的点点点，这样还有一个问题就是，如果文字只有一行，那么高度可能会有不准，所以在末尾可以进行一下修正\n```\nself.desLabel.textAlignment = NSTextAlignmentCenter;\n\n[self.desLabel sizeToFit];\n\nif (self.desLabel.height_jr > 30) {\n    self.desLabel.height_jr = 30;\n}\n```\nsizeToFit方法基本上是会不改变文字的宽度，然后会让折行消失，然后再到下边设置一下这个高度，高度也是比较容易找到的，只要打印一下想要的行数就可以得到。\n\n\n","source":"_posts/2014/UIKit系列-UILable.md","raw":"---\ntitle: UIKit系列--UILable\ndate: 2014-11-16 10:17:32\ntags:\n- iOS\n---\n\n### 多行UILabel的高度计算1\n```\nUILabel *titleLabel = [UILabel new];\ntitleLabel.font = [UIFont systemFontOfSize:14];\nNSString *titleContent = @\"亲，欢迎您通过以下方式与我们的营销顾问取得联系，交流您再营销推广工作中遇到的问题，营销顾问将免费为您提供咨询服务。\";\ntitleLabel.text = titleContent;\ntitleLabel.numberOfLines = 0;//多行显示，计算高度\ntitleLabel.textColor = [UIColor lightGrayColor];\nCGSize titleSize = [titleContent boundingRectWithSize:CGSizeMake(kScreen_Width, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:14]} context:nil].size;\ntitleLabel.size = titleSize;\ntitleLabel.x = 0;\ntitleLabel.y = 0;\n\n[self.view addSubview:titleLabel];\n```\n\n### 多行UILabel的高度计算2\n\n```\n- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text {\n    \n    [self setLineSpace:lineSpace andMaxWidth:maxWidth andMaxHeight:maxHeight andFont:font textColor:color withText:text andLeftSpace:0];\n}\n\n- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text andLeftSpace:(CGFloat)width {\n    if (!text) {\n        text = @\"\";\n    }\n    self.numberOfLines = 0;\n    NSMutableParagraphStyle* parag = [[NSMutableParagraphStyle alloc] init];\n    \n    [parag setLineSpacing:lineSpace];\n    parag.lineBreakMode = NSLineBreakByCharWrapping;\n    \n    NSDictionary *attributes = @{NSFontAttributeName:font,NSParagraphStyleAttributeName:parag,NSForegroundColorAttributeName:color};\n    if (width != 0) {\n        [parag setFirstLineHeadIndent:width];//首行缩进\n    }\n    self.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attributes];\n    \n    NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init];\n    paraStyle.lineBreakMode = NSLineBreakByCharWrapping;\n    paraStyle.lineSpacing = lineSpace;\n    if (width != 0) {\n        [paraStyle setFirstLineHeadIndent:width];//首行缩进\n    }\n    NSDictionary *dic = @{NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.1f\n                          };\n    CGFloat maxH = MAXFLOAT;\n    if (maxHeight != 0) {\n        maxH = maxHeight;\n    }\n    \n    CGSize sizeH = [text boundingRectWithSize:CGSizeMake(maxWidth, maxH) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size;\n    \n    CGRect frame = self.frame;\n    CGPoint position = frame.origin;\n    self.frame = CGRectMake(position.x, position.y, maxWidth, sizeH.height);\n    self.lineBreakMode = NSLineBreakByTruncatingTail;\n}\n```\n上边的代码基本上做到了，设置好文字的宽度和高度，然后给一段文字可以自动的折行，自动的点点点，这样还有一个问题就是，如果文字只有一行，那么高度可能会有不准，所以在末尾可以进行一下修正\n```\nself.desLabel.textAlignment = NSTextAlignmentCenter;\n\n[self.desLabel sizeToFit];\n\nif (self.desLabel.height_jr > 30) {\n    self.desLabel.height_jr = 30;\n}\n```\nsizeToFit方法基本上是会不改变文字的宽度，然后会让折行消失，然后再到下边设置一下这个高度，高度也是比较容易找到的，只要打印一下想要的行数就可以得到。\n\n\n","slug":"2014/UIKit系列-UILable","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pm0001psauaxr8fnzks","content":"<h3 id=\"多行UILabel的高度计算1\"><a href=\"#多行UILabel的高度计算1\" class=\"headerlink\" title=\"多行UILabel的高度计算1\"></a>多行UILabel的高度计算1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">UILabel *titleLabel = [UILabel new];</div><div class=\"line\">titleLabel.font = [UIFont systemFontOfSize:14];</div><div class=\"line\">NSString *titleContent = @&quot;亲，欢迎您通过以下方式与我们的营销顾问取得联系，交流您再营销推广工作中遇到的问题，营销顾问将免费为您提供咨询服务。&quot;;</div><div class=\"line\">titleLabel.text = titleContent;</div><div class=\"line\">titleLabel.numberOfLines = 0;//多行显示，计算高度</div><div class=\"line\">titleLabel.textColor = [UIColor lightGrayColor];</div><div class=\"line\">CGSize titleSize = [titleContent boundingRectWithSize:CGSizeMake(kScreen_Width, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125; context:nil].size;</div><div class=\"line\">titleLabel.size = titleSize;</div><div class=\"line\">titleLabel.x = 0;</div><div class=\"line\">titleLabel.y = 0;</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:titleLabel];</div></pre></td></tr></table></figure>\n<h3 id=\"多行UILabel的高度计算2\"><a href=\"#多行UILabel的高度计算2\" class=\"headerlink\" title=\"多行UILabel的高度计算2\"></a>多行UILabel的高度计算2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text &#123;</div><div class=\"line\">    </div><div class=\"line\">    [self setLineSpace:lineSpace andMaxWidth:maxWidth andMaxHeight:maxHeight andFont:font textColor:color withText:text andLeftSpace:0];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text andLeftSpace:(CGFloat)width &#123;</div><div class=\"line\">    if (!text) &#123;</div><div class=\"line\">        text = @&quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.numberOfLines = 0;</div><div class=\"line\">    NSMutableParagraphStyle* parag = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    [parag setLineSpacing:lineSpace];</div><div class=\"line\">    parag.lineBreakMode = NSLineBreakByCharWrapping;</div><div class=\"line\">    </div><div class=\"line\">    NSDictionary *attributes = @&#123;NSFontAttributeName:font,NSParagraphStyleAttributeName:parag,NSForegroundColorAttributeName:color&#125;;</div><div class=\"line\">    if (width != 0) &#123;</div><div class=\"line\">        [parag setFirstLineHeadIndent:width];//首行缩进</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attributes];</div><div class=\"line\">    </div><div class=\"line\">    NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">    paraStyle.lineBreakMode = NSLineBreakByCharWrapping;</div><div class=\"line\">    paraStyle.lineSpacing = lineSpace;</div><div class=\"line\">    if (width != 0) &#123;</div><div class=\"line\">        [paraStyle setFirstLineHeadIndent:width];//首行缩进</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.1f</div><div class=\"line\">                          &#125;;</div><div class=\"line\">    CGFloat maxH = MAXFLOAT;</div><div class=\"line\">    if (maxHeight != 0) &#123;</div><div class=\"line\">        maxH = maxHeight;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    CGSize sizeH = [text boundingRectWithSize:CGSizeMake(maxWidth, maxH) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size;</div><div class=\"line\">    </div><div class=\"line\">    CGRect frame = self.frame;</div><div class=\"line\">    CGPoint position = frame.origin;</div><div class=\"line\">    self.frame = CGRectMake(position.x, position.y, maxWidth, sizeH.height);</div><div class=\"line\">    self.lineBreakMode = NSLineBreakByTruncatingTail;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上边的代码基本上做到了，设置好文字的宽度和高度，然后给一段文字可以自动的折行，自动的点点点，这样还有一个问题就是，如果文字只有一行，那么高度可能会有不准，所以在末尾可以进行一下修正<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.desLabel.textAlignment = NSTextAlignmentCenter;</div><div class=\"line\"></div><div class=\"line\">[self.desLabel sizeToFit];</div><div class=\"line\"></div><div class=\"line\">if (self.desLabel.height_jr &gt; 30) &#123;</div><div class=\"line\">    self.desLabel.height_jr = 30;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>sizeToFit方法基本上是会不改变文字的宽度，然后会让折行消失，然后再到下边设置一下这个高度，高度也是比较容易找到的，只要打印一下想要的行数就可以得到。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"多行UILabel的高度计算1\"><a href=\"#多行UILabel的高度计算1\" class=\"headerlink\" title=\"多行UILabel的高度计算1\"></a>多行UILabel的高度计算1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">UILabel *titleLabel = [UILabel new];</div><div class=\"line\">titleLabel.font = [UIFont systemFontOfSize:14];</div><div class=\"line\">NSString *titleContent = @&quot;亲，欢迎您通过以下方式与我们的营销顾问取得联系，交流您再营销推广工作中遇到的问题，营销顾问将免费为您提供咨询服务。&quot;;</div><div class=\"line\">titleLabel.text = titleContent;</div><div class=\"line\">titleLabel.numberOfLines = 0;//多行显示，计算高度</div><div class=\"line\">titleLabel.textColor = [UIColor lightGrayColor];</div><div class=\"line\">CGSize titleSize = [titleContent boundingRectWithSize:CGSizeMake(kScreen_Width, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125; context:nil].size;</div><div class=\"line\">titleLabel.size = titleSize;</div><div class=\"line\">titleLabel.x = 0;</div><div class=\"line\">titleLabel.y = 0;</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:titleLabel];</div></pre></td></tr></table></figure>\n<h3 id=\"多行UILabel的高度计算2\"><a href=\"#多行UILabel的高度计算2\" class=\"headerlink\" title=\"多行UILabel的高度计算2\"></a>多行UILabel的高度计算2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text &#123;</div><div class=\"line\">    </div><div class=\"line\">    [self setLineSpace:lineSpace andMaxWidth:maxWidth andMaxHeight:maxHeight andFont:font textColor:color withText:text andLeftSpace:0];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setLineSpace:(CGFloat)lineSpace andMaxWidth:(CGFloat)maxWidth andMaxHeight:(CGFloat)maxHeight andFont:(UIFont *)font textColor:(UIColor *)color withText:(NSString *)text andLeftSpace:(CGFloat)width &#123;</div><div class=\"line\">    if (!text) &#123;</div><div class=\"line\">        text = @&quot;&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.numberOfLines = 0;</div><div class=\"line\">    NSMutableParagraphStyle* parag = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">    </div><div class=\"line\">    [parag setLineSpacing:lineSpace];</div><div class=\"line\">    parag.lineBreakMode = NSLineBreakByCharWrapping;</div><div class=\"line\">    </div><div class=\"line\">    NSDictionary *attributes = @&#123;NSFontAttributeName:font,NSParagraphStyleAttributeName:parag,NSForegroundColorAttributeName:color&#125;;</div><div class=\"line\">    if (width != 0) &#123;</div><div class=\"line\">        [parag setFirstLineHeadIndent:width];//首行缩进</div><div class=\"line\">    &#125;</div><div class=\"line\">    self.attributedText = [[NSAttributedString alloc] initWithString:text attributes:attributes];</div><div class=\"line\">    </div><div class=\"line\">    NSMutableParagraphStyle *paraStyle = [[NSMutableParagraphStyle alloc] init];</div><div class=\"line\">    paraStyle.lineBreakMode = NSLineBreakByCharWrapping;</div><div class=\"line\">    paraStyle.lineSpacing = lineSpace;</div><div class=\"line\">    if (width != 0) &#123;</div><div class=\"line\">        [paraStyle setFirstLineHeadIndent:width];//首行缩进</div><div class=\"line\">    &#125;</div><div class=\"line\">    NSDictionary *dic = @&#123;NSFontAttributeName:font, NSParagraphStyleAttributeName:paraStyle, NSKernAttributeName:@1.1f</div><div class=\"line\">                          &#125;;</div><div class=\"line\">    CGFloat maxH = MAXFLOAT;</div><div class=\"line\">    if (maxHeight != 0) &#123;</div><div class=\"line\">        maxH = maxHeight;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    CGSize sizeH = [text boundingRectWithSize:CGSizeMake(maxWidth, maxH) options:NSStringDrawingUsesLineFragmentOrigin attributes:dic context:nil].size;</div><div class=\"line\">    </div><div class=\"line\">    CGRect frame = self.frame;</div><div class=\"line\">    CGPoint position = frame.origin;</div><div class=\"line\">    self.frame = CGRectMake(position.x, position.y, maxWidth, sizeH.height);</div><div class=\"line\">    self.lineBreakMode = NSLineBreakByTruncatingTail;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上边的代码基本上做到了，设置好文字的宽度和高度，然后给一段文字可以自动的折行，自动的点点点，这样还有一个问题就是，如果文字只有一行，那么高度可能会有不准，所以在末尾可以进行一下修正<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.desLabel.textAlignment = NSTextAlignmentCenter;</div><div class=\"line\"></div><div class=\"line\">[self.desLabel sizeToFit];</div><div class=\"line\"></div><div class=\"line\">if (self.desLabel.height_jr &gt; 30) &#123;</div><div class=\"line\">    self.desLabel.height_jr = 30;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>sizeToFit方法基本上是会不改变文字的宽度，然后会让折行消失，然后再到下边设置一下这个高度，高度也是比较容易找到的，只要打印一下想要的行数就可以得到。</p>\n"},{"title":"UIKit系列-UICollectionView","date":"2016-11-15T06:36:57.000Z","_content":"\n### iOS中的新变化\n在iOS10中，重用的加载机制发生了变化，会提前加在一个cell，这就意味着，cellforrow会被提前一个调用，这个可以通过属性直接关闭，这里要注意\n","source":"_posts/2014/UIKit系列-UICollectionView.md","raw":"---\ntitle: UIKit系列-UICollectionView\ndate: 2016-11-15 14:36:57\ntags:\n- iOS\n---\n\n### iOS中的新变化\n在iOS10中，重用的加载机制发生了变化，会提前加在一个cell，这就意味着，cellforrow会被提前一个调用，这个可以通过属性直接关闭，这里要注意\n","slug":"2014/UIKit系列-UICollectionView","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pm2001rsauazwyi7dn7","content":"<h3 id=\"iOS中的新变化\"><a href=\"#iOS中的新变化\" class=\"headerlink\" title=\"iOS中的新变化\"></a>iOS中的新变化</h3><p>在iOS10中，重用的加载机制发生了变化，会提前加在一个cell，这就意味着，cellforrow会被提前一个调用，这个可以通过属性直接关闭，这里要注意</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"iOS中的新变化\"><a href=\"#iOS中的新变化\" class=\"headerlink\" title=\"iOS中的新变化\"></a>iOS中的新变化</h3><p>在iOS10中，重用的加载机制发生了变化，会提前加在一个cell，这就意味着，cellforrow会被提前一个调用，这个可以通过属性直接关闭，这里要注意</p>\n"},{"title":"UIKit系列-UIPikerView-日期选择器","date":"2014-12-15T03:52:49.000Z","_content":"\n## 日期选择器\n<!--more-->\n```\n//\n//  ViewController.m\n//  ceshi\n//\n//  Created by Hanson on 16/11/15.\n//  Copyright © 2016年 wxg. All rights reserved.\n//\n\n#import \"ViewController.h\"\n\n@interface ViewController ()<UIPickerViewDataSource,UIPickerViewDelegate>\n@property (nonatomic, strong) NSMutableArray *yearArr;\n@property (nonatomic, strong) NSMutableArray *monthArr;\n@property (nonatomic, strong) NSMutableArray *dayArr;\n\n@property (nonatomic, strong) UIPickerView *pickerView;\n\n@property (nonatomic, strong) UIButton *confirmBtn;\n\n@property (nonatomic, assign) NSInteger month;\n@property (nonatomic, assign) NSInteger day;\n\n@property (nonatomic, strong) NSMutableArray *singleMonth;\n@property (nonatomic, strong) NSMutableArray *doubleMonth;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n[super viewDidLoad];\n\nUIPickerView *pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 100, 320, 216)];\nself.pickerView = pickerView;\n// 显示选中框\npickerView.showsSelectionIndicator=YES;\npickerView.dataSource = self;\npickerView.delegate = self;\n[self.view addSubview:pickerView];\n\n[self.view addSubview:self.confirmBtn];\n}\n\n#pragma Mark -- UIPickerViewDataSource\n// pickerView 列数\n- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {\nreturn 3;\n}\n\n// pickerView 每列个数\n- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component {\nswitch (component) {\ncase 0:\n{\nreturn self.yearArr.count;\n}\nbreak;\ncase 1:\n{\nreturn self.monthArr.count;\n}\nbreak;\ncase 2:\n{\nreturn self.dayArr.count;\n}\nbreak;\ndefault:\n{\nreturn 0;\n}\nbreak;\n}\n}\n\n// 每列宽度\n- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component {\n\n    return 110;\n}\n// 返回选中的行\n- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component\n{\n    if (component == 1) {\n    self.month = row;\n    NSString *month = [self.monthArr objectAtIndex:row];\n    NSString *day = [self.dayArr objectAtIndex:self.day];\n    [self handleUnselecteDay:day andMonth:month];\n    } else if(component == 2){\n    self.day = row;\n    NSString *day = [self.dayArr objectAtIndex:row];\n    NSString *month = [self.monthArr objectAtIndex:self.month];\n    [self handleUnselecteDay:day andMonth:month];\n    }\n}\n\n- (void)handleUnselecteDay:(NSString *)day andMonth:(NSString *)month {\n\n    if ([self.doubleMonth containsObject:month]) {\n    if ([day isEqualToString:@\"31日\"]) {\n    [self.pickerView selectRow:30 inComponent:2 animated:YES];\n    }\n    }else if ([month isEqualToString:@\"2月\"]) {\n    if ([day isEqualToString:@\"31日\"] || [day isEqualToString:@\"30日\"]) {\n    [self.pickerView selectRow:29 inComponent:2 animated:YES];\n    }\n    }\n}\n\n- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view {\n\n    UILabel *titleLabel;\n    if (view) {\n    titleLabel = (UILabel *)view;\n    }else {\n    titleLabel = [[UILabel alloc] init];\n    }\n\n    NSString *title;\n    switch (component) {\n    case 0:\n    {\n    title = [self.yearArr objectAtIndex:row];\n    }\n    break;\n    case 1:\n    {\n    title = [self.monthArr objectAtIndex:row];\n    }\n    break;\n    case 2:\n    {\n    title = [self.dayArr objectAtIndex:row];\n    }\n    break;\n\n    default:\n    break;\n}\n\ntitleLabel.text = title;\n[titleLabel sizeToFit];\n\ntitleLabel.textColor = [UIColor blueColor];\n\nreturn titleLabel;\n}\n\n//返回当前行的内容,此处是将数组中数值添加到滚动的那个显示栏上\n-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component\n{\n    switch (component) {\n    case 0:\n    {\n        return [self.yearArr objectAtIndex:row];\n    }\n    break;\n    case 1:\n    {\n        return [self.monthArr objectAtIndex:row];\n    }\n    break;\n    case 2:\n    {\n        return [self.dayArr objectAtIndex:row];\n    }\n    break;\n\n    default:\n    {\n        return nil;\n    }\n    break;\n    }\n}\n\n- (void)confirmClick {\n    NSInteger row0 = [self.pickerView selectedRowInComponent:0];\n    NSInteger row1 = [self.pickerView selectedRowInComponent:1];\n    NSInteger row2 = [self.pickerView selectedRowInComponent:2];\n\n    NSString *year = self.yearArr[row0];\n    NSString *month = self.monthArr[row1];\n    NSString *day = self.dayArr[row2];\n\n    NSLog(@\"%@%@%@\", year, month, day);\n}\n\n#pragma setter and getter\n- (NSMutableArray *)yearArr {\n    if (!_yearArr) {\n        _yearArr = [NSMutableArray array];\n        for (int i = 1990; i < 2017; i++) {\n            [_yearArr addObject:[NSString stringWithFormat:@\"%d年\", i]];\n        }\n    }\nreturn _yearArr;\n}\n\n- (NSMutableArray *)monthArr {\n    if (!_monthArr) {\n        _monthArr = [NSMutableArray array];\n        for (int i  = 1; i < 13; i++) {\n        [_monthArr addObject:[NSString stringWithFormat:@\"%d月\", i]];\n    }\n    }\n    return _monthArr;\n}\n\n- (NSMutableArray *)dayArr {\n    if (!_dayArr) {\n        _dayArr = [NSMutableArray array];\n        for (int i = 0; i < 32; i++) {\n        [_dayArr addObject:[NSString stringWithFormat:@\"%d日\", i]];\n    }\n    }\n    return _dayArr;\n}\n\n- (UIButton *)confirmBtn {\nif (!_confirmBtn) {\n    _confirmBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_confirmBtn setTitle:@\"确定\" forState:UIControlStateNormal];\n        [_confirmBtn sizeToFit];\n        [_confirmBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n        [_confirmBtn addTarget:self action:@selector(confirmClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n    return _confirmBtn;\n}\n\n- (NSMutableArray *)singleMonth {//31天\nif (!_singleMonth) {\n        _singleMonth = [NSMutableArray array];\n        [_singleMonth addObjectsFromArray:@[@\"1月\",@\"3月\",@\"5月\",@\"7月\",@\"8月\",@\"10月\",@\"12月\"]];\n   }\n   return _singleMonth;\n}\n\n- (NSMutableArray *)doubleMonth {\nif (!_doubleMonth) {\n    _doubleMonth = [NSMutableArray array];\n    [_doubleMonth addObjectsFromArray:@[@\"4月\",@\"6月\",@\"9月\",@\"11月\"]];\n  }\n  return _doubleMonth;\n}\n@end\n\n```\n","source":"_posts/2014/UIKit系列-UIPikerView-日期选择器.md","raw":"---\ntitle: UIKit系列-UIPikerView-日期选择器\ndate: 2014-12-15 11:52:49\ntags:\n- IOS\n---\n\n## 日期选择器\n<!--more-->\n```\n//\n//  ViewController.m\n//  ceshi\n//\n//  Created by Hanson on 16/11/15.\n//  Copyright © 2016年 wxg. All rights reserved.\n//\n\n#import \"ViewController.h\"\n\n@interface ViewController ()<UIPickerViewDataSource,UIPickerViewDelegate>\n@property (nonatomic, strong) NSMutableArray *yearArr;\n@property (nonatomic, strong) NSMutableArray *monthArr;\n@property (nonatomic, strong) NSMutableArray *dayArr;\n\n@property (nonatomic, strong) UIPickerView *pickerView;\n\n@property (nonatomic, strong) UIButton *confirmBtn;\n\n@property (nonatomic, assign) NSInteger month;\n@property (nonatomic, assign) NSInteger day;\n\n@property (nonatomic, strong) NSMutableArray *singleMonth;\n@property (nonatomic, strong) NSMutableArray *doubleMonth;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n[super viewDidLoad];\n\nUIPickerView *pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 100, 320, 216)];\nself.pickerView = pickerView;\n// 显示选中框\npickerView.showsSelectionIndicator=YES;\npickerView.dataSource = self;\npickerView.delegate = self;\n[self.view addSubview:pickerView];\n\n[self.view addSubview:self.confirmBtn];\n}\n\n#pragma Mark -- UIPickerViewDataSource\n// pickerView 列数\n- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView {\nreturn 3;\n}\n\n// pickerView 每列个数\n- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component {\nswitch (component) {\ncase 0:\n{\nreturn self.yearArr.count;\n}\nbreak;\ncase 1:\n{\nreturn self.monthArr.count;\n}\nbreak;\ncase 2:\n{\nreturn self.dayArr.count;\n}\nbreak;\ndefault:\n{\nreturn 0;\n}\nbreak;\n}\n}\n\n// 每列宽度\n- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component {\n\n    return 110;\n}\n// 返回选中的行\n- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component\n{\n    if (component == 1) {\n    self.month = row;\n    NSString *month = [self.monthArr objectAtIndex:row];\n    NSString *day = [self.dayArr objectAtIndex:self.day];\n    [self handleUnselecteDay:day andMonth:month];\n    } else if(component == 2){\n    self.day = row;\n    NSString *day = [self.dayArr objectAtIndex:row];\n    NSString *month = [self.monthArr objectAtIndex:self.month];\n    [self handleUnselecteDay:day andMonth:month];\n    }\n}\n\n- (void)handleUnselecteDay:(NSString *)day andMonth:(NSString *)month {\n\n    if ([self.doubleMonth containsObject:month]) {\n    if ([day isEqualToString:@\"31日\"]) {\n    [self.pickerView selectRow:30 inComponent:2 animated:YES];\n    }\n    }else if ([month isEqualToString:@\"2月\"]) {\n    if ([day isEqualToString:@\"31日\"] || [day isEqualToString:@\"30日\"]) {\n    [self.pickerView selectRow:29 inComponent:2 animated:YES];\n    }\n    }\n}\n\n- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view {\n\n    UILabel *titleLabel;\n    if (view) {\n    titleLabel = (UILabel *)view;\n    }else {\n    titleLabel = [[UILabel alloc] init];\n    }\n\n    NSString *title;\n    switch (component) {\n    case 0:\n    {\n    title = [self.yearArr objectAtIndex:row];\n    }\n    break;\n    case 1:\n    {\n    title = [self.monthArr objectAtIndex:row];\n    }\n    break;\n    case 2:\n    {\n    title = [self.dayArr objectAtIndex:row];\n    }\n    break;\n\n    default:\n    break;\n}\n\ntitleLabel.text = title;\n[titleLabel sizeToFit];\n\ntitleLabel.textColor = [UIColor blueColor];\n\nreturn titleLabel;\n}\n\n//返回当前行的内容,此处是将数组中数值添加到滚动的那个显示栏上\n-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component\n{\n    switch (component) {\n    case 0:\n    {\n        return [self.yearArr objectAtIndex:row];\n    }\n    break;\n    case 1:\n    {\n        return [self.monthArr objectAtIndex:row];\n    }\n    break;\n    case 2:\n    {\n        return [self.dayArr objectAtIndex:row];\n    }\n    break;\n\n    default:\n    {\n        return nil;\n    }\n    break;\n    }\n}\n\n- (void)confirmClick {\n    NSInteger row0 = [self.pickerView selectedRowInComponent:0];\n    NSInteger row1 = [self.pickerView selectedRowInComponent:1];\n    NSInteger row2 = [self.pickerView selectedRowInComponent:2];\n\n    NSString *year = self.yearArr[row0];\n    NSString *month = self.monthArr[row1];\n    NSString *day = self.dayArr[row2];\n\n    NSLog(@\"%@%@%@\", year, month, day);\n}\n\n#pragma setter and getter\n- (NSMutableArray *)yearArr {\n    if (!_yearArr) {\n        _yearArr = [NSMutableArray array];\n        for (int i = 1990; i < 2017; i++) {\n            [_yearArr addObject:[NSString stringWithFormat:@\"%d年\", i]];\n        }\n    }\nreturn _yearArr;\n}\n\n- (NSMutableArray *)monthArr {\n    if (!_monthArr) {\n        _monthArr = [NSMutableArray array];\n        for (int i  = 1; i < 13; i++) {\n        [_monthArr addObject:[NSString stringWithFormat:@\"%d月\", i]];\n    }\n    }\n    return _monthArr;\n}\n\n- (NSMutableArray *)dayArr {\n    if (!_dayArr) {\n        _dayArr = [NSMutableArray array];\n        for (int i = 0; i < 32; i++) {\n        [_dayArr addObject:[NSString stringWithFormat:@\"%d日\", i]];\n    }\n    }\n    return _dayArr;\n}\n\n- (UIButton *)confirmBtn {\nif (!_confirmBtn) {\n    _confirmBtn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_confirmBtn setTitle:@\"确定\" forState:UIControlStateNormal];\n        [_confirmBtn sizeToFit];\n        [_confirmBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n        [_confirmBtn addTarget:self action:@selector(confirmClick) forControlEvents:UIControlEventTouchUpInside];\n    }\n    return _confirmBtn;\n}\n\n- (NSMutableArray *)singleMonth {//31天\nif (!_singleMonth) {\n        _singleMonth = [NSMutableArray array];\n        [_singleMonth addObjectsFromArray:@[@\"1月\",@\"3月\",@\"5月\",@\"7月\",@\"8月\",@\"10月\",@\"12月\"]];\n   }\n   return _singleMonth;\n}\n\n- (NSMutableArray *)doubleMonth {\nif (!_doubleMonth) {\n    _doubleMonth = [NSMutableArray array];\n    [_doubleMonth addObjectsFromArray:@[@\"4月\",@\"6月\",@\"9月\",@\"11月\"]];\n  }\n  return _doubleMonth;\n}\n@end\n\n```\n","slug":"2014/UIKit系列-UIPikerView-日期选择器","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pm5001ssauapuqz7vx1","content":"<h2 id=\"日期选择器\"><a href=\"#日期选择器\" class=\"headerlink\" title=\"日期选择器\"></a>日期选择器</h2><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div></pre></td><td class=\"code\"><pre><div class=\"line\">//</div><div class=\"line\">//  ViewController.m</div><div class=\"line\">//  ceshi</div><div class=\"line\">//</div><div class=\"line\">//  Created by Hanson on 16/11/15.</div><div class=\"line\">//  Copyright © 2016年 wxg. All rights reserved.</div><div class=\"line\">//</div><div class=\"line\"></div><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()&lt;UIPickerViewDataSource,UIPickerViewDelegate&gt;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *yearArr;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *monthArr;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *dayArr;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) UIPickerView *pickerView;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) UIButton *confirmBtn;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, assign) NSInteger month;</div><div class=\"line\">@property (nonatomic, assign) NSInteger day;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *singleMonth;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *doubleMonth;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">[super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">UIPickerView *pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 100, 320, 216)];</div><div class=\"line\">self.pickerView = pickerView;</div><div class=\"line\">// 显示选中框</div><div class=\"line\">pickerView.showsSelectionIndicator=YES;</div><div class=\"line\">pickerView.dataSource = self;</div><div class=\"line\">pickerView.delegate = self;</div><div class=\"line\">[self.view addSubview:pickerView];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:self.confirmBtn];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma Mark -- UIPickerViewDataSource</div><div class=\"line\">// pickerView 列数</div><div class=\"line\">- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123;</div><div class=\"line\">return 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// pickerView 每列个数</div><div class=\"line\">- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component &#123;</div><div class=\"line\">switch (component) &#123;</div><div class=\"line\">case 0:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.yearArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">case 1:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.monthArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">case 2:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.dayArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">default:</div><div class=\"line\">&#123;</div><div class=\"line\">return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 每列宽度</div><div class=\"line\">- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component &#123;</div><div class=\"line\"></div><div class=\"line\">    return 110;</div><div class=\"line\">&#125;</div><div class=\"line\">// 返回选中的行</div><div class=\"line\">- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component</div><div class=\"line\">&#123;</div><div class=\"line\">    if (component == 1) &#123;</div><div class=\"line\">    self.month = row;</div><div class=\"line\">    NSString *month = [self.monthArr objectAtIndex:row];</div><div class=\"line\">    NSString *day = [self.dayArr objectAtIndex:self.day];</div><div class=\"line\">    [self handleUnselecteDay:day andMonth:month];</div><div class=\"line\">    &#125; else if(component == 2)&#123;</div><div class=\"line\">    self.day = row;</div><div class=\"line\">    NSString *day = [self.dayArr objectAtIndex:row];</div><div class=\"line\">    NSString *month = [self.monthArr objectAtIndex:self.month];</div><div class=\"line\">    [self handleUnselecteDay:day andMonth:month];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)handleUnselecteDay:(NSString *)day andMonth:(NSString *)month &#123;</div><div class=\"line\"></div><div class=\"line\">    if ([self.doubleMonth containsObject:month]) &#123;</div><div class=\"line\">    if ([day isEqualToString:@&quot;31日&quot;]) &#123;</div><div class=\"line\">    [self.pickerView selectRow:30 inComponent:2 animated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;else if ([month isEqualToString:@&quot;2月&quot;]) &#123;</div><div class=\"line\">    if ([day isEqualToString:@&quot;31日&quot;] || [day isEqualToString:@&quot;30日&quot;]) &#123;</div><div class=\"line\">    [self.pickerView selectRow:29 inComponent:2 animated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;</div><div class=\"line\"></div><div class=\"line\">    UILabel *titleLabel;</div><div class=\"line\">    if (view) &#123;</div><div class=\"line\">    titleLabel = (UILabel *)view;</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    titleLabel = [[UILabel alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSString *title;</div><div class=\"line\">    switch (component) &#123;</div><div class=\"line\">    case 0:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.yearArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 1:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.monthArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 2:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.dayArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\"></div><div class=\"line\">    default:</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">titleLabel.text = title;</div><div class=\"line\">[titleLabel sizeToFit];</div><div class=\"line\"></div><div class=\"line\">titleLabel.textColor = [UIColor blueColor];</div><div class=\"line\"></div><div class=\"line\">return titleLabel;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//返回当前行的内容,此处是将数组中数值添加到滚动的那个显示栏上</div><div class=\"line\">-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component</div><div class=\"line\">&#123;</div><div class=\"line\">    switch (component) &#123;</div><div class=\"line\">    case 0:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.yearArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 1:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.monthArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 2:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.dayArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\"></div><div class=\"line\">    default:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)confirmClick &#123;</div><div class=\"line\">    NSInteger row0 = [self.pickerView selectedRowInComponent:0];</div><div class=\"line\">    NSInteger row1 = [self.pickerView selectedRowInComponent:1];</div><div class=\"line\">    NSInteger row2 = [self.pickerView selectedRowInComponent:2];</div><div class=\"line\"></div><div class=\"line\">    NSString *year = self.yearArr[row0];</div><div class=\"line\">    NSString *month = self.monthArr[row1];</div><div class=\"line\">    NSString *day = self.dayArr[row2];</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@%@%@&quot;, year, month, day);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma setter and getter</div><div class=\"line\">- (NSMutableArray *)yearArr &#123;</div><div class=\"line\">    if (!_yearArr) &#123;</div><div class=\"line\">        _yearArr = [NSMutableArray array];</div><div class=\"line\">        for (int i = 1990; i &lt; 2017; i++) &#123;</div><div class=\"line\">            [_yearArr addObject:[NSString stringWithFormat:@&quot;%d年&quot;, i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">return _yearArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)monthArr &#123;</div><div class=\"line\">    if (!_monthArr) &#123;</div><div class=\"line\">        _monthArr = [NSMutableArray array];</div><div class=\"line\">        for (int i  = 1; i &lt; 13; i++) &#123;</div><div class=\"line\">        [_monthArr addObject:[NSString stringWithFormat:@&quot;%d月&quot;, i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _monthArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)dayArr &#123;</div><div class=\"line\">    if (!_dayArr) &#123;</div><div class=\"line\">        _dayArr = [NSMutableArray array];</div><div class=\"line\">        for (int i = 0; i &lt; 32; i++) &#123;</div><div class=\"line\">        [_dayArr addObject:[NSString stringWithFormat:@&quot;%d日&quot;, i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dayArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)confirmBtn &#123;</div><div class=\"line\">if (!_confirmBtn) &#123;</div><div class=\"line\">    _confirmBtn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_confirmBtn setTitle:@&quot;确定&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_confirmBtn sizeToFit];</div><div class=\"line\">        [_confirmBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">        [_confirmBtn addTarget:self action:@selector(confirmClick) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _confirmBtn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)singleMonth &#123;//31天</div><div class=\"line\">if (!_singleMonth) &#123;</div><div class=\"line\">        _singleMonth = [NSMutableArray array];</div><div class=\"line\">        [_singleMonth addObjectsFromArray:@[@&quot;1月&quot;,@&quot;3月&quot;,@&quot;5月&quot;,@&quot;7月&quot;,@&quot;8月&quot;,@&quot;10月&quot;,@&quot;12月&quot;]];</div><div class=\"line\">   &#125;</div><div class=\"line\">   return _singleMonth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)doubleMonth &#123;</div><div class=\"line\">if (!_doubleMonth) &#123;</div><div class=\"line\">    _doubleMonth = [NSMutableArray array];</div><div class=\"line\">    [_doubleMonth addObjectsFromArray:@[@&quot;4月&quot;,@&quot;6月&quot;,@&quot;9月&quot;,@&quot;11月&quot;]];</div><div class=\"line\">  &#125;</div><div class=\"line\">  return _doubleMonth;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"日期选择器\"><a href=\"#日期选择器\" class=\"headerlink\" title=\"日期选择器\"></a>日期选择器</h2>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div><div class=\"line\">239</div><div class=\"line\">240</div><div class=\"line\">241</div><div class=\"line\">242</div><div class=\"line\">243</div><div class=\"line\">244</div><div class=\"line\">245</div></pre></td><td class=\"code\"><pre><div class=\"line\">//</div><div class=\"line\">//  ViewController.m</div><div class=\"line\">//  ceshi</div><div class=\"line\">//</div><div class=\"line\">//  Created by Hanson on 16/11/15.</div><div class=\"line\">//  Copyright © 2016年 wxg. All rights reserved.</div><div class=\"line\">//</div><div class=\"line\"></div><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()&lt;UIPickerViewDataSource,UIPickerViewDelegate&gt;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *yearArr;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *monthArr;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *dayArr;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) UIPickerView *pickerView;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) UIButton *confirmBtn;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, assign) NSInteger month;</div><div class=\"line\">@property (nonatomic, assign) NSInteger day;</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *singleMonth;</div><div class=\"line\">@property (nonatomic, strong) NSMutableArray *doubleMonth;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">[super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">UIPickerView *pickerView = [[UIPickerView alloc] initWithFrame:CGRectMake(0, 100, 320, 216)];</div><div class=\"line\">self.pickerView = pickerView;</div><div class=\"line\">// 显示选中框</div><div class=\"line\">pickerView.showsSelectionIndicator=YES;</div><div class=\"line\">pickerView.dataSource = self;</div><div class=\"line\">pickerView.delegate = self;</div><div class=\"line\">[self.view addSubview:pickerView];</div><div class=\"line\"></div><div class=\"line\">[self.view addSubview:self.confirmBtn];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma Mark -- UIPickerViewDataSource</div><div class=\"line\">// pickerView 列数</div><div class=\"line\">- (NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView &#123;</div><div class=\"line\">return 3;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// pickerView 每列个数</div><div class=\"line\">- (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component &#123;</div><div class=\"line\">switch (component) &#123;</div><div class=\"line\">case 0:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.yearArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">case 1:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.monthArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">case 2:</div><div class=\"line\">&#123;</div><div class=\"line\">return self.dayArr.count;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">default:</div><div class=\"line\">&#123;</div><div class=\"line\">return 0;</div><div class=\"line\">&#125;</div><div class=\"line\">break;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 每列宽度</div><div class=\"line\">- (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component &#123;</div><div class=\"line\"></div><div class=\"line\">    return 110;</div><div class=\"line\">&#125;</div><div class=\"line\">// 返回选中的行</div><div class=\"line\">- (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component</div><div class=\"line\">&#123;</div><div class=\"line\">    if (component == 1) &#123;</div><div class=\"line\">    self.month = row;</div><div class=\"line\">    NSString *month = [self.monthArr objectAtIndex:row];</div><div class=\"line\">    NSString *day = [self.dayArr objectAtIndex:self.day];</div><div class=\"line\">    [self handleUnselecteDay:day andMonth:month];</div><div class=\"line\">    &#125; else if(component == 2)&#123;</div><div class=\"line\">    self.day = row;</div><div class=\"line\">    NSString *day = [self.dayArr objectAtIndex:row];</div><div class=\"line\">    NSString *month = [self.monthArr objectAtIndex:self.month];</div><div class=\"line\">    [self handleUnselecteDay:day andMonth:month];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)handleUnselecteDay:(NSString *)day andMonth:(NSString *)month &#123;</div><div class=\"line\"></div><div class=\"line\">    if ([self.doubleMonth containsObject:month]) &#123;</div><div class=\"line\">    if ([day isEqualToString:@&quot;31日&quot;]) &#123;</div><div class=\"line\">    [self.pickerView selectRow:30 inComponent:2 animated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;else if ([month isEqualToString:@&quot;2月&quot;]) &#123;</div><div class=\"line\">    if ([day isEqualToString:@&quot;31日&quot;] || [day isEqualToString:@&quot;30日&quot;]) &#123;</div><div class=\"line\">    [self.pickerView selectRow:29 inComponent:2 animated:YES];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;</div><div class=\"line\"></div><div class=\"line\">    UILabel *titleLabel;</div><div class=\"line\">    if (view) &#123;</div><div class=\"line\">    titleLabel = (UILabel *)view;</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">    titleLabel = [[UILabel alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    NSString *title;</div><div class=\"line\">    switch (component) &#123;</div><div class=\"line\">    case 0:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.yearArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 1:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.monthArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 2:</div><div class=\"line\">    &#123;</div><div class=\"line\">    title = [self.dayArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\"></div><div class=\"line\">    default:</div><div class=\"line\">    break;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">titleLabel.text = title;</div><div class=\"line\">[titleLabel sizeToFit];</div><div class=\"line\"></div><div class=\"line\">titleLabel.textColor = [UIColor blueColor];</div><div class=\"line\"></div><div class=\"line\">return titleLabel;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//返回当前行的内容,此处是将数组中数值添加到滚动的那个显示栏上</div><div class=\"line\">-(NSString*)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component</div><div class=\"line\">&#123;</div><div class=\"line\">    switch (component) &#123;</div><div class=\"line\">    case 0:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.yearArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 1:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.monthArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    case 2:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return [self.dayArr objectAtIndex:row];</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\"></div><div class=\"line\">    default:</div><div class=\"line\">    &#123;</div><div class=\"line\">        return nil;</div><div class=\"line\">    &#125;</div><div class=\"line\">    break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)confirmClick &#123;</div><div class=\"line\">    NSInteger row0 = [self.pickerView selectedRowInComponent:0];</div><div class=\"line\">    NSInteger row1 = [self.pickerView selectedRowInComponent:1];</div><div class=\"line\">    NSInteger row2 = [self.pickerView selectedRowInComponent:2];</div><div class=\"line\"></div><div class=\"line\">    NSString *year = self.yearArr[row0];</div><div class=\"line\">    NSString *month = self.monthArr[row1];</div><div class=\"line\">    NSString *day = self.dayArr[row2];</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@%@%@&quot;, year, month, day);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">#pragma setter and getter</div><div class=\"line\">- (NSMutableArray *)yearArr &#123;</div><div class=\"line\">    if (!_yearArr) &#123;</div><div class=\"line\">        _yearArr = [NSMutableArray array];</div><div class=\"line\">        for (int i = 1990; i &lt; 2017; i++) &#123;</div><div class=\"line\">            [_yearArr addObject:[NSString stringWithFormat:@&quot;%d年&quot;, i]];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">return _yearArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)monthArr &#123;</div><div class=\"line\">    if (!_monthArr) &#123;</div><div class=\"line\">        _monthArr = [NSMutableArray array];</div><div class=\"line\">        for (int i  = 1; i &lt; 13; i++) &#123;</div><div class=\"line\">        [_monthArr addObject:[NSString stringWithFormat:@&quot;%d月&quot;, i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _monthArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)dayArr &#123;</div><div class=\"line\">    if (!_dayArr) &#123;</div><div class=\"line\">        _dayArr = [NSMutableArray array];</div><div class=\"line\">        for (int i = 0; i &lt; 32; i++) &#123;</div><div class=\"line\">        [_dayArr addObject:[NSString stringWithFormat:@&quot;%d日&quot;, i]];</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _dayArr;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)confirmBtn &#123;</div><div class=\"line\">if (!_confirmBtn) &#123;</div><div class=\"line\">    _confirmBtn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_confirmBtn setTitle:@&quot;确定&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_confirmBtn sizeToFit];</div><div class=\"line\">        [_confirmBtn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">        [_confirmBtn addTarget:self action:@selector(confirmClick) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _confirmBtn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)singleMonth &#123;//31天</div><div class=\"line\">if (!_singleMonth) &#123;</div><div class=\"line\">        _singleMonth = [NSMutableArray array];</div><div class=\"line\">        [_singleMonth addObjectsFromArray:@[@&quot;1月&quot;,@&quot;3月&quot;,@&quot;5月&quot;,@&quot;7月&quot;,@&quot;8月&quot;,@&quot;10月&quot;,@&quot;12月&quot;]];</div><div class=\"line\">   &#125;</div><div class=\"line\">   return _singleMonth;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSMutableArray *)doubleMonth &#123;</div><div class=\"line\">if (!_doubleMonth) &#123;</div><div class=\"line\">    _doubleMonth = [NSMutableArray array];</div><div class=\"line\">    [_doubleMonth addObjectsFromArray:@[@&quot;4月&quot;,@&quot;6月&quot;,@&quot;9月&quot;,@&quot;11月&quot;]];</div><div class=\"line\">  &#125;</div><div class=\"line\">  return _doubleMonth;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>"},{"title":"UIKit系列---UITextField","date":"2014-12-12T12:05:50.000Z","_content":"\n\n### 总述\n我们监听textfield的事件总结来看有两种途径，第一种是代理，第二种是通知，代理能够监听的更加广泛一些\n<!--more-->\n```\n- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        // return NO to disallow editing.\n- (void)textFieldDidBeginEditing:(UITextField *)textField;           // became first responder\n- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;          // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end\n- (void)textFieldDidEndEditing:(UITextField *)textField;             // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called\n\n- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text\n\n- (BOOL)textFieldShouldClear:(UITextField *)textField;               // called when clear button pressed. return NO to ignore (no notifications)\n- (BOOL)textFieldShouldReturn:(UITextField *)textField;              // called when 'return' key pressed. return NO to ignore.\n\n@end\n\nUIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;\nUIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;\nUIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;\n```\n\n### 监听输入\n```\n[textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];\n- (void) textFieldDidChange:(UITextField *) TextField{ }\n```\n\n### 输入限制\n#### 长度\n>注意这里得到的string是你输入的那个string，不一定是显示的那个string，经过判断如果你返回yes，那么这个数字将会显示到textfield里边，否则就不会显示的\n>并且这里的string，是单个字母或者汉字\n\n```\n- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;\n{ //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反\n\nif ([string isEqualToString:@\"\\n\"]) //按会车可以改变\n   {\n       return YES;\n   }\n\n   NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容，注意，这里如果直接取textField.text那么你得到的是少一个字母的，也就是你这个取到的string\n\n   if (self.myTextField == textField) //判断是否时我们想要限定的那个输入框\n   {\n       if ([toBeString length] > 20) { //如果输入框内容大于20则弹出警告\n            textField.text = [toBeString substringToIndex:20];\n           UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@\"超过最大字数不能输入了\" delegate:nil cancelButtonTitle:@\"Ok\" otherButtonTitles:nil, nil] autorelease];\n           [alert show];\n           return NO;\n       }\n   }\n   return YES;\n}\n```\n上边的方法有个问题就是不能有效的统计中文，因为输入中文的时候它首先是输入英文，然后当你选了某个中文文字，英文字符串才会被替换掉，那么我们需要一种更为精准的方法\n```\n- (void)textFieldLimitWithTextField:(UITextField*)textField length:(NSInteger)length{\n    NSString *toBeString = textField.text;\n    NSString *lang = [[UITextInputMode currentInputMode] primaryLanguage]; // 键盘输入模式\n    if ([lang isEqualToString:@\"zh-Hans\"]) { // 简体中文输入，包括简体拼音，健体五笔，简体手写\n        UITextRange *selectedRange = [textField markedTextRange];\n        //获取高亮部分\n        UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0];\n        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制\n        if (!position) {\n            if (toBeString.length > length) {\n                textField.text = [toBeString substringToIndex:length];\n            }\n        }\n        // 有高亮选择的字符串，则暂不对文字进行统计和限制\n        else{\n\n        }\n    }\n    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况\n    else{\n        if (toBeString.length > length) {\n            textField.text = [toBeString substringToIndex:length];\n        }\n    }\n}\n```\n直接将textfield和要限制的字数传入就好，不过我们需要不断地传入这个textfield\n配合使用\n```\n- (void)checkInputValid{\n//    _userClearBtn.hidden = (0 == _userTextField.text.length );\n\n    [self textFieldLimitWithTextField:_userTextField length:20];\n\n    BOOL isUserValid = (_userTextField.text.length >= 1 && _userTextField.text.length <=20);\n    BOOL isPwdValid = (_pwdTextField.text.length >= 1) ;\n\n    [self setLoginBtnEnabled:isUserValid && isPwdValid];\n//    [self setClearBtnShow:isUserValid];\n}\n```\n```\n[tf addTarget:self action:@selector(textFieldChanged:) forControlEvents:UIControlEventEditingChanged];\n```\n#### 数值不能超过xx\n#### 限制输入的类型\n```\n- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string{\n\n   NSString*match =nil;;\n   if(textField ==_userTextField){\n        match =@\"^([0-9]){0,}$\";\n    }else{\n        match =@\"^([0-9a-zA-Z]|[\\\\s|-]){0,}$\";\n    }\n\n   if(textField ==self.userTextField) {\n       if(range.location<_lastLength) {\n           self.pwdTextField.text=@\"\";\n            [selfcheckInputValid];\n        }\n    }\n\n   DLog(@\"%@--%@\", NSStringFromRange(range) , [NSString stringWithFormat:@\"%ld\", (long)self.lastLength]);\n\n   if(textField ==self.userTextField) {\n        self.lastLength= range.location;\n    }\n\n   NSPredicate*predicate = [NSPredicatepredicateWithFormat:@\"SELF MATCHES %@\", match];\n   return[predicateevaluateWithObject:string];\n}\n```\n### 样式设置\n```\nsearchTextField=[[UITextField alloc]initWithFrame:CGRectMake(1.0,0.0,searchBackGroundImageView.frame.size.width, searchBackGroundImageView.frame.size.height)];//创建一个UITextField对象，及设置其位置及大小\n//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容\nsearchTextField.clearButtonMode = UITextFieldViewModeAlways;\ntext.clearsOnBeginEditing = YES;//再次编辑就清空\nsearchTextField.contentVerticalAlignment=UIControlContentVerticalAlignmentCenter;//设置其输入内容竖直居中\n\nUIImageView* imgV=[[UIImageViewalloc]initWithImage:[UIImageimageNamed:@\"search_ico\"]];\n\nsearchTextField.leftView=imgV;//设置输入框内左边的图标\n\n[self.tf11setClearButtonMode:UITextFieldViewModeWhileEditing];//右侧删除按钮\n\nsearchTextField.leftViewMode=UITextFieldViewModeAlways;\n\nsearchTextField.placeholder=@\"请输入关键字\";//默认显示的字\n\nsearchTextField.secureTextEntry=YES;//设置成密码格式\n\nsearchTextField.keyboardType=UIKeyboardTypeDefault;//设置键盘类型为默认的\n\nsearchTextField.returnKeyType=UIReturnKeyDefault;//返回键的类型\n/*\ntypedef enum {\n\n    UIReturnKeyDefault, 默认 灰色按钮，标有Return\n\n    UIReturnKeyGo,      标有Go的蓝色按钮\n\n    UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索\n\n    UIReturnKeyJoin,标有Join的蓝色按钮\n\n    UIReturnKeyNext,标有Next的蓝色按钮\n\n    UIReturnKeyRoute,标有Route的蓝色按钮\n\n    UIReturnKeySearch,标有Search的蓝色按钮\n\n    UIReturnKeySend,标有Send的蓝色按钮\n\n    UIReturnKeyYahoo,标有Yahoo的蓝色按钮\n\n    UIReturnKeyYahoo,标有Yahoo的蓝色按钮\n\n    UIReturnKeyEmergencyCall, 紧急呼叫按钮\n\n} UIReturnKeyType;\n*/\n\nsearchTextField.delegate=self;//设置委托\n\ntextFied.adjustsFontSizeToFitWidth = YES;//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动，与下边的配合使用\n\ntext.minimumFontSize = 20;//设置自动缩小显示的最小字体大小\n\ntext.autocapitalizationType = UITextAutocapitalizationTypeNone;//首字母是否大写\ntext.enablesReturnKeyAutomatically = YES;//输入框没有字的时候return变成灰色\n\n```\n#### 光标显示位置调整\n设置leftView，同是设置以下两个方法：\n```\nsearchTextField.leftView=imgV;//设置输入框内左边的图标\n\nsearchTextField.leftViewMode=UITextFieldViewModeAlways;\n\n```\n#### 设置textfiled的边框的颜色和样式\n尽量使用layer的属性来设置\n\n#### 设置光标颜色\n```\n//设置光标颜色1\nself.tintColor = [UIColor redColor];\n```\n#### 设置占位文字颜色\n\n```\n// 设置光标的颜色2\n\nUIColor *color = [UIColor whiteColor];  \n    _userName.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@\"用户名\" attributes:@{NSForegroundColorAttributeName: color}];  \n```\n### 各种小技巧\n\n#### 监听删除\n```\n- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string{\n\n   NSString*match =nil;;\n   if(textField ==_userTextField){\n        match =@\"^([0-9]){0,}$\";\n    }else{\n        match =@\"^([0-9a-zA-Z]|[\\\\s|-]){0,}$\";\n    }\n\n   if(textField ==self.userTextField) {\n       if(range.length==1) {\n           self.pwdTextField.text=@\"\";\n            [selfcheckInputValid];\n        }\n    }\n}\n\n在这个方法里边拿到range，如果length为0说明在正向输入，如果为1说明在删除字符\n```\n#### 密文变明文光标错位\n```\n思路：删除内容，然后重新赋值\n\n- (void)pwdShowBtnClick:(UIButton*)btn{\n    btn.selected= !(btn.selected);\n   _pwdTextField.secureTextEntry= !(btn.selected);\n   NSString*pwd =_pwdTextField.text;\n   _pwdTextField.text=@\"\";\n//    [_pwdTextField resignFirstResponder];\n   _pwdTextField.text= pwd;\n    [_pwdTextFieldbecomeFirstResponder];\n}\n```\n#### 各种收起键盘\n- 点击背景view的任何地方\n- 点击return\n\n```\n[self.textField resignFirstResponder];\n\n[self.view endEditing:YES];//最彻底的办法\n\n-(BOOL)textFieldShouldReturn:(UITextField *)textField\n{\n    [textField resignFirstResponder];\n    returnYES;\n}\n```\n#### 虚拟键盘挡住textfield\n- 设置inputAccessoryView，在这个上边添加另外一个textfield\n- 监听键盘弹出事件，此时将firstresponder设置为该textfield\n\n#### 给数字键盘添加取消或者其他按钮\n\n```\n@implementation ViewController\n- (UITextField *)textField {\n    if (!_textField) {\n        _textField = [[UITextField alloc] init];\n        _textField.frame = CGRectMake(100, 100, 200, 50);\n        _textField.keyboardType = UIKeyboardTypeNumberPad;\n        _textField.backgroundColor = [UIColor blueColor];\n    }\n    return _textField;\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShowOnDelay:) name:UIKeyboardWillShowNotification object:nil];\n self.littlecancleButton.backgroundColor = [UIColor clearColor];//这句主要是为了提前加载button，如果在键盘的通知中添加button\n ，就会自动加上动画\n    [self.view addSubview:self.textField];\n}\n\n- (void)windowDidShow:(NSNotification *)noti {\n    NSLog(@\"------\");\n}\n\n- (void)keyboardWillShowOnDelay:(NSNotification *)noti {\n\n    UIWindow *keyboardWindow = nil;\n    \n    for (UIWindow *testWindow in [[UIApplication sharedApplication] windows]) {\n        if ([NSStringFromClass([testWindow class]) isEqualToString:@\"UIRemoteKeyboardWindow\"]) {\n            keyboardWindow = testWindow;\n            break;\n        }\n    }\n    \n    if (!keyboardWindow) return;\n    \n    [keyboardWindow addSubview:self.littlecancleButton];\n    [UIView animateWithDuration:0.1 animations:^{\n        self.littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);\n    }];\n   \n}\n\n- (UIButton *)littlecancleButton {\n    if (!_littlecancleButton) {\n        _littlecancleButton = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_littlecancleButton setTitle:@\"取消\" forState:UIControlStateNormal];\n        _littlecancleButton.titleLabel.font = [UIFont systemFontOfSize:20];\n        [_littlecancleButton sizeToFit];\n        [_littlecancleButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n        _littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height + 216 - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);\n        [_littlecancleButton addTarget:self action:@selector(cancleBtnClick) forControlEvents:UIControlEventTouchUpInside];\n\n    }\n    return _littlecancleButton;\n}\n\n- (void)cancleBtnClick {\n    NSLog(@\"1111111\");\n}\n\n@end\n```\n\n#### 虚拟键盘遮挡提示弹框\n解决思路同添加取消按钮，就是将提示框添加到键盘的window上\n\n#### textfield随着键盘移动\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillChangeFrameNotification object:nil];\n    \n    [self.view addSubview:self.textField];\n    \n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];\n    [self.view addGestureRecognizer:tap];\n}\n\n- (void)tap {\n    [self.view endEditing:YES];\n}\n\n- (void)keyboardWillShow:(NSNotification *)noti {\n    double duration = [noti.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];\n    \n    CGFloat keyboardY = [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y;\n    CGFloat ty = keyboardY - kScreenH;\n    \n    [UIView animateWithDuration:duration animations:^{\n        self.textField.transform = CGAffineTransformMakeTranslation(0, ty);\n    }];\n}\n```\n\n### 配合使用正则表达式\n- 校验是否为有效手机号\n```\n//是否为有效手机号的判断\n- (NSString *)valiMobile:(NSString *)mobile{\nif (mobile.length < 11)\n{\nreturn @\"请填写有效的手机号\";\n}else{\n/**\n* 移动号段正则表达式\n*/\nNSString *CM_NUM = @\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$\";\n/**\n* 联通号段正则表达式\n*/\nNSString *CU_NUM = @\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$\";\n/**\n* 电信号段正则表达式\n*/\nNSString *CT_NUM = @\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$\";\nNSPredicate *pred1 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM_NUM];\nBOOL isMatch1 = [pred1 evaluateWithObject:mobile];\nNSPredicate *pred2 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU_NUM];\nBOOL isMatch2 = [pred2 evaluateWithObject:mobile];\nNSPredicate *pred3 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT_NUM];\nBOOL isMatch3 = [pred3 evaluateWithObject:mobile];\n\nif (isMatch1 || isMatch2 || isMatch3) {\nreturn nil;\n}else{\nreturn @\"请填写有效的手机号\";\n}\n}\nreturn nil;\n}\n```\n\n\n","source":"_posts/2014/UIKit系列-UITextField.md","raw":"---\ntitle: UIKit系列---UITextField\ndate: 2014-12-12 20:05:50\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\n\n### 总述\n我们监听textfield的事件总结来看有两种途径，第一种是代理，第二种是通知，代理能够监听的更加广泛一些\n<!--more-->\n```\n- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        // return NO to disallow editing.\n- (void)textFieldDidBeginEditing:(UITextField *)textField;           // became first responder\n- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;          // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end\n- (void)textFieldDidEndEditing:(UITextField *)textField;             // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called\n\n- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text\n\n- (BOOL)textFieldShouldClear:(UITextField *)textField;               // called when clear button pressed. return NO to ignore (no notifications)\n- (BOOL)textFieldShouldReturn:(UITextField *)textField;              // called when 'return' key pressed. return NO to ignore.\n\n@end\n\nUIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;\nUIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;\nUIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;\n```\n\n### 监听输入\n```\n[textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];\n- (void) textFieldDidChange:(UITextField *) TextField{ }\n```\n\n### 输入限制\n#### 长度\n>注意这里得到的string是你输入的那个string，不一定是显示的那个string，经过判断如果你返回yes，那么这个数字将会显示到textfield里边，否则就不会显示的\n>并且这里的string，是单个字母或者汉字\n\n```\n- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;\n{ //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反\n\nif ([string isEqualToString:@\"\\n\"]) //按会车可以改变\n   {\n       return YES;\n   }\n\n   NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容，注意，这里如果直接取textField.text那么你得到的是少一个字母的，也就是你这个取到的string\n\n   if (self.myTextField == textField) //判断是否时我们想要限定的那个输入框\n   {\n       if ([toBeString length] > 20) { //如果输入框内容大于20则弹出警告\n            textField.text = [toBeString substringToIndex:20];\n           UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@\"超过最大字数不能输入了\" delegate:nil cancelButtonTitle:@\"Ok\" otherButtonTitles:nil, nil] autorelease];\n           [alert show];\n           return NO;\n       }\n   }\n   return YES;\n}\n```\n上边的方法有个问题就是不能有效的统计中文，因为输入中文的时候它首先是输入英文，然后当你选了某个中文文字，英文字符串才会被替换掉，那么我们需要一种更为精准的方法\n```\n- (void)textFieldLimitWithTextField:(UITextField*)textField length:(NSInteger)length{\n    NSString *toBeString = textField.text;\n    NSString *lang = [[UITextInputMode currentInputMode] primaryLanguage]; // 键盘输入模式\n    if ([lang isEqualToString:@\"zh-Hans\"]) { // 简体中文输入，包括简体拼音，健体五笔，简体手写\n        UITextRange *selectedRange = [textField markedTextRange];\n        //获取高亮部分\n        UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0];\n        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制\n        if (!position) {\n            if (toBeString.length > length) {\n                textField.text = [toBeString substringToIndex:length];\n            }\n        }\n        // 有高亮选择的字符串，则暂不对文字进行统计和限制\n        else{\n\n        }\n    }\n    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况\n    else{\n        if (toBeString.length > length) {\n            textField.text = [toBeString substringToIndex:length];\n        }\n    }\n}\n```\n直接将textfield和要限制的字数传入就好，不过我们需要不断地传入这个textfield\n配合使用\n```\n- (void)checkInputValid{\n//    _userClearBtn.hidden = (0 == _userTextField.text.length );\n\n    [self textFieldLimitWithTextField:_userTextField length:20];\n\n    BOOL isUserValid = (_userTextField.text.length >= 1 && _userTextField.text.length <=20);\n    BOOL isPwdValid = (_pwdTextField.text.length >= 1) ;\n\n    [self setLoginBtnEnabled:isUserValid && isPwdValid];\n//    [self setClearBtnShow:isUserValid];\n}\n```\n```\n[tf addTarget:self action:@selector(textFieldChanged:) forControlEvents:UIControlEventEditingChanged];\n```\n#### 数值不能超过xx\n#### 限制输入的类型\n```\n- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string{\n\n   NSString*match =nil;;\n   if(textField ==_userTextField){\n        match =@\"^([0-9]){0,}$\";\n    }else{\n        match =@\"^([0-9a-zA-Z]|[\\\\s|-]){0,}$\";\n    }\n\n   if(textField ==self.userTextField) {\n       if(range.location<_lastLength) {\n           self.pwdTextField.text=@\"\";\n            [selfcheckInputValid];\n        }\n    }\n\n   DLog(@\"%@--%@\", NSStringFromRange(range) , [NSString stringWithFormat:@\"%ld\", (long)self.lastLength]);\n\n   if(textField ==self.userTextField) {\n        self.lastLength= range.location;\n    }\n\n   NSPredicate*predicate = [NSPredicatepredicateWithFormat:@\"SELF MATCHES %@\", match];\n   return[predicateevaluateWithObject:string];\n}\n```\n### 样式设置\n```\nsearchTextField=[[UITextField alloc]initWithFrame:CGRectMake(1.0,0.0,searchBackGroundImageView.frame.size.width, searchBackGroundImageView.frame.size.height)];//创建一个UITextField对象，及设置其位置及大小\n//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容\nsearchTextField.clearButtonMode = UITextFieldViewModeAlways;\ntext.clearsOnBeginEditing = YES;//再次编辑就清空\nsearchTextField.contentVerticalAlignment=UIControlContentVerticalAlignmentCenter;//设置其输入内容竖直居中\n\nUIImageView* imgV=[[UIImageViewalloc]initWithImage:[UIImageimageNamed:@\"search_ico\"]];\n\nsearchTextField.leftView=imgV;//设置输入框内左边的图标\n\n[self.tf11setClearButtonMode:UITextFieldViewModeWhileEditing];//右侧删除按钮\n\nsearchTextField.leftViewMode=UITextFieldViewModeAlways;\n\nsearchTextField.placeholder=@\"请输入关键字\";//默认显示的字\n\nsearchTextField.secureTextEntry=YES;//设置成密码格式\n\nsearchTextField.keyboardType=UIKeyboardTypeDefault;//设置键盘类型为默认的\n\nsearchTextField.returnKeyType=UIReturnKeyDefault;//返回键的类型\n/*\ntypedef enum {\n\n    UIReturnKeyDefault, 默认 灰色按钮，标有Return\n\n    UIReturnKeyGo,      标有Go的蓝色按钮\n\n    UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索\n\n    UIReturnKeyJoin,标有Join的蓝色按钮\n\n    UIReturnKeyNext,标有Next的蓝色按钮\n\n    UIReturnKeyRoute,标有Route的蓝色按钮\n\n    UIReturnKeySearch,标有Search的蓝色按钮\n\n    UIReturnKeySend,标有Send的蓝色按钮\n\n    UIReturnKeyYahoo,标有Yahoo的蓝色按钮\n\n    UIReturnKeyYahoo,标有Yahoo的蓝色按钮\n\n    UIReturnKeyEmergencyCall, 紧急呼叫按钮\n\n} UIReturnKeyType;\n*/\n\nsearchTextField.delegate=self;//设置委托\n\ntextFied.adjustsFontSizeToFitWidth = YES;//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动，与下边的配合使用\n\ntext.minimumFontSize = 20;//设置自动缩小显示的最小字体大小\n\ntext.autocapitalizationType = UITextAutocapitalizationTypeNone;//首字母是否大写\ntext.enablesReturnKeyAutomatically = YES;//输入框没有字的时候return变成灰色\n\n```\n#### 光标显示位置调整\n设置leftView，同是设置以下两个方法：\n```\nsearchTextField.leftView=imgV;//设置输入框内左边的图标\n\nsearchTextField.leftViewMode=UITextFieldViewModeAlways;\n\n```\n#### 设置textfiled的边框的颜色和样式\n尽量使用layer的属性来设置\n\n#### 设置光标颜色\n```\n//设置光标颜色1\nself.tintColor = [UIColor redColor];\n```\n#### 设置占位文字颜色\n\n```\n// 设置光标的颜色2\n\nUIColor *color = [UIColor whiteColor];  \n    _userName.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@\"用户名\" attributes:@{NSForegroundColorAttributeName: color}];  \n```\n### 各种小技巧\n\n#### 监听删除\n```\n- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string{\n\n   NSString*match =nil;;\n   if(textField ==_userTextField){\n        match =@\"^([0-9]){0,}$\";\n    }else{\n        match =@\"^([0-9a-zA-Z]|[\\\\s|-]){0,}$\";\n    }\n\n   if(textField ==self.userTextField) {\n       if(range.length==1) {\n           self.pwdTextField.text=@\"\";\n            [selfcheckInputValid];\n        }\n    }\n}\n\n在这个方法里边拿到range，如果length为0说明在正向输入，如果为1说明在删除字符\n```\n#### 密文变明文光标错位\n```\n思路：删除内容，然后重新赋值\n\n- (void)pwdShowBtnClick:(UIButton*)btn{\n    btn.selected= !(btn.selected);\n   _pwdTextField.secureTextEntry= !(btn.selected);\n   NSString*pwd =_pwdTextField.text;\n   _pwdTextField.text=@\"\";\n//    [_pwdTextField resignFirstResponder];\n   _pwdTextField.text= pwd;\n    [_pwdTextFieldbecomeFirstResponder];\n}\n```\n#### 各种收起键盘\n- 点击背景view的任何地方\n- 点击return\n\n```\n[self.textField resignFirstResponder];\n\n[self.view endEditing:YES];//最彻底的办法\n\n-(BOOL)textFieldShouldReturn:(UITextField *)textField\n{\n    [textField resignFirstResponder];\n    returnYES;\n}\n```\n#### 虚拟键盘挡住textfield\n- 设置inputAccessoryView，在这个上边添加另外一个textfield\n- 监听键盘弹出事件，此时将firstresponder设置为该textfield\n\n#### 给数字键盘添加取消或者其他按钮\n\n```\n@implementation ViewController\n- (UITextField *)textField {\n    if (!_textField) {\n        _textField = [[UITextField alloc] init];\n        _textField.frame = CGRectMake(100, 100, 200, 50);\n        _textField.keyboardType = UIKeyboardTypeNumberPad;\n        _textField.backgroundColor = [UIColor blueColor];\n    }\n    return _textField;\n}\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShowOnDelay:) name:UIKeyboardWillShowNotification object:nil];\n self.littlecancleButton.backgroundColor = [UIColor clearColor];//这句主要是为了提前加载button，如果在键盘的通知中添加button\n ，就会自动加上动画\n    [self.view addSubview:self.textField];\n}\n\n- (void)windowDidShow:(NSNotification *)noti {\n    NSLog(@\"------\");\n}\n\n- (void)keyboardWillShowOnDelay:(NSNotification *)noti {\n\n    UIWindow *keyboardWindow = nil;\n    \n    for (UIWindow *testWindow in [[UIApplication sharedApplication] windows]) {\n        if ([NSStringFromClass([testWindow class]) isEqualToString:@\"UIRemoteKeyboardWindow\"]) {\n            keyboardWindow = testWindow;\n            break;\n        }\n    }\n    \n    if (!keyboardWindow) return;\n    \n    [keyboardWindow addSubview:self.littlecancleButton];\n    [UIView animateWithDuration:0.1 animations:^{\n        self.littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);\n    }];\n   \n}\n\n- (UIButton *)littlecancleButton {\n    if (!_littlecancleButton) {\n        _littlecancleButton = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_littlecancleButton setTitle:@\"取消\" forState:UIControlStateNormal];\n        _littlecancleButton.titleLabel.font = [UIFont systemFontOfSize:20];\n        [_littlecancleButton sizeToFit];\n        [_littlecancleButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];\n        _littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height + 216 - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);\n        [_littlecancleButton addTarget:self action:@selector(cancleBtnClick) forControlEvents:UIControlEventTouchUpInside];\n\n    }\n    return _littlecancleButton;\n}\n\n- (void)cancleBtnClick {\n    NSLog(@\"1111111\");\n}\n\n@end\n```\n\n#### 虚拟键盘遮挡提示弹框\n解决思路同添加取消按钮，就是将提示框添加到键盘的window上\n\n#### textfield随着键盘移动\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n   \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillChangeFrameNotification object:nil];\n    \n    [self.view addSubview:self.textField];\n    \n    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];\n    [self.view addGestureRecognizer:tap];\n}\n\n- (void)tap {\n    [self.view endEditing:YES];\n}\n\n- (void)keyboardWillShow:(NSNotification *)noti {\n    double duration = [noti.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];\n    \n    CGFloat keyboardY = [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y;\n    CGFloat ty = keyboardY - kScreenH;\n    \n    [UIView animateWithDuration:duration animations:^{\n        self.textField.transform = CGAffineTransformMakeTranslation(0, ty);\n    }];\n}\n```\n\n### 配合使用正则表达式\n- 校验是否为有效手机号\n```\n//是否为有效手机号的判断\n- (NSString *)valiMobile:(NSString *)mobile{\nif (mobile.length < 11)\n{\nreturn @\"请填写有效的手机号\";\n}else{\n/**\n* 移动号段正则表达式\n*/\nNSString *CM_NUM = @\"^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d{8}|(1705)\\\\d{7}$\";\n/**\n* 联通号段正则表达式\n*/\nNSString *CU_NUM = @\"^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d{8}|(1709)\\\\d{7}$\";\n/**\n* 电信号段正则表达式\n*/\nNSString *CT_NUM = @\"^((133)|(153)|(177)|(18[0,1,9]))\\\\d{8}$\";\nNSPredicate *pred1 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CM_NUM];\nBOOL isMatch1 = [pred1 evaluateWithObject:mobile];\nNSPredicate *pred2 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CU_NUM];\nBOOL isMatch2 = [pred2 evaluateWithObject:mobile];\nNSPredicate *pred3 = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", CT_NUM];\nBOOL isMatch3 = [pred3 evaluateWithObject:mobile];\n\nif (isMatch1 || isMatch2 || isMatch3) {\nreturn nil;\n}else{\nreturn @\"请填写有效的手机号\";\n}\n}\nreturn nil;\n}\n```\n\n\n","slug":"2014/UIKit系列-UITextField","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pm7001vsauamebp7zhb","content":"<h3 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h3><p>我们监听textfield的事件总结来看有两种途径，第一种是代理，第二种是通知，代理能够监听的更加广泛一些<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        // return NO to disallow editing.</div><div class=\"line\">- (void)textFieldDidBeginEditing:(UITextField *)textField;           // became first responder</div><div class=\"line\">- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;          // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end</div><div class=\"line\">- (void)textFieldDidEndEditing:(UITextField *)textField;             // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called</div><div class=\"line\"></div><div class=\"line\">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text</div><div class=\"line\"></div><div class=\"line\">- (BOOL)textFieldShouldClear:(UITextField *)textField;               // called when clear button pressed. return NO to ignore (no notifications)</div><div class=\"line\">- (BOOL)textFieldShouldReturn:(UITextField *)textField;              // called when &apos;return&apos; key pressed. return NO to ignore.</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;</div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;</div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</div></pre></td></tr></table></figure></p>\n<h3 id=\"监听输入\"><a href=\"#监听输入\" class=\"headerlink\" title=\"监听输入\"></a>监听输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];</div><div class=\"line\">- (void) textFieldDidChange:(UITextField *) TextField&#123; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"输入限制\"><a href=\"#输入限制\" class=\"headerlink\" title=\"输入限制\"></a>输入限制</h3><h4 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h4><blockquote>\n<p>注意这里得到的string是你输入的那个string，不一定是显示的那个string，经过判断如果你返回yes，那么这个数字将会显示到textfield里边，否则就不会显示的<br>并且这里的string，是单个字母或者汉字</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;</div><div class=\"line\">&#123; //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反</div><div class=\"line\"></div><div class=\"line\">if ([string isEqualToString:@&quot;\\n&quot;]) //按会车可以改变</div><div class=\"line\">   &#123;</div><div class=\"line\">       return YES;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容，注意，这里如果直接取textField.text那么你得到的是少一个字母的，也就是你这个取到的string</div><div class=\"line\"></div><div class=\"line\">   if (self.myTextField == textField) //判断是否时我们想要限定的那个输入框</div><div class=\"line\">   &#123;</div><div class=\"line\">       if ([toBeString length] &gt; 20) &#123; //如果输入框内容大于20则弹出警告</div><div class=\"line\">            textField.text = [toBeString substringToIndex:20];</div><div class=\"line\">           UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@&quot;超过最大字数不能输入了&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil] autorelease];</div><div class=\"line\">           [alert show];</div><div class=\"line\">           return NO;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上边的方法有个问题就是不能有效的统计中文，因为输入中文的时候它首先是输入英文，然后当你选了某个中文文字，英文字符串才会被替换掉，那么我们需要一种更为精准的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)textFieldLimitWithTextField:(UITextField*)textField length:(NSInteger)length&#123;</div><div class=\"line\">    NSString *toBeString = textField.text;</div><div class=\"line\">    NSString *lang = [[UITextInputMode currentInputMode] primaryLanguage]; // 键盘输入模式</div><div class=\"line\">    if ([lang isEqualToString:@&quot;zh-Hans&quot;]) &#123; // 简体中文输入，包括简体拼音，健体五笔，简体手写</div><div class=\"line\">        UITextRange *selectedRange = [textField markedTextRange];</div><div class=\"line\">        //获取高亮部分</div><div class=\"line\">        UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0];</div><div class=\"line\">        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制</div><div class=\"line\">        if (!position) &#123;</div><div class=\"line\">            if (toBeString.length &gt; length) &#123;</div><div class=\"line\">                textField.text = [toBeString substringToIndex:length];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 有高亮选择的字符串，则暂不对文字进行统计和限制</div><div class=\"line\">        else&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</div><div class=\"line\">    else&#123;</div><div class=\"line\">        if (toBeString.length &gt; length) &#123;</div><div class=\"line\">            textField.text = [toBeString substringToIndex:length];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>直接将textfield和要限制的字数传入就好，不过我们需要不断地传入这个textfield<br>配合使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)checkInputValid&#123;</div><div class=\"line\">//    _userClearBtn.hidden = (0 == _userTextField.text.length );</div><div class=\"line\"></div><div class=\"line\">    [self textFieldLimitWithTextField:_userTextField length:20];</div><div class=\"line\"></div><div class=\"line\">    BOOL isUserValid = (_userTextField.text.length &gt;= 1 &amp;&amp; _userTextField.text.length &lt;=20);</div><div class=\"line\">    BOOL isPwdValid = (_pwdTextField.text.length &gt;= 1) ;</div><div class=\"line\"></div><div class=\"line\">    [self setLoginBtnEnabled:isUserValid &amp;&amp; isPwdValid];</div><div class=\"line\">//    [self setClearBtnShow:isUserValid];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[tf addTarget:self action:@selector(textFieldChanged:) forControlEvents:UIControlEventEditingChanged];</div></pre></td></tr></table></figure>\n<h4 id=\"数值不能超过xx\"><a href=\"#数值不能超过xx\" class=\"headerlink\" title=\"数值不能超过xx\"></a>数值不能超过xx</h4><h4 id=\"限制输入的类型\"><a href=\"#限制输入的类型\" class=\"headerlink\" title=\"限制输入的类型\"></a>限制输入的类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string&#123;</div><div class=\"line\"></div><div class=\"line\">   NSString*match =nil;;</div><div class=\"line\">   if(textField ==_userTextField)&#123;</div><div class=\"line\">        match =@&quot;^([0-9])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        match =@&quot;^([0-9a-zA-Z]|[\\\\s|-])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">       if(range.location&lt;_lastLength) &#123;</div><div class=\"line\">           self.pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">            [selfcheckInputValid];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   DLog(@&quot;%@--%@&quot;, NSStringFromRange(range) , [NSString stringWithFormat:@&quot;%ld&quot;, (long)self.lastLength]);</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">        self.lastLength= range.location;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   NSPredicate*predicate = [NSPredicatepredicateWithFormat:@&quot;SELF MATCHES %@&quot;, match];</div><div class=\"line\">   return[predicateevaluateWithObject:string];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">searchTextField=[[UITextField alloc]initWithFrame:CGRectMake(1.0,0.0,searchBackGroundImageView.frame.size.width, searchBackGroundImageView.frame.size.height)];//创建一个UITextField对象，及设置其位置及大小</div><div class=\"line\">//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容</div><div class=\"line\">searchTextField.clearButtonMode = UITextFieldViewModeAlways;</div><div class=\"line\">text.clearsOnBeginEditing = YES;//再次编辑就清空</div><div class=\"line\">searchTextField.contentVerticalAlignment=UIControlContentVerticalAlignmentCenter;//设置其输入内容竖直居中</div><div class=\"line\"></div><div class=\"line\">UIImageView* imgV=[[UIImageViewalloc]initWithImage:[UIImageimageNamed:@&quot;search_ico&quot;]];</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftView=imgV;//设置输入框内左边的图标</div><div class=\"line\"></div><div class=\"line\">[self.tf11setClearButtonMode:UITextFieldViewModeWhileEditing];//右侧删除按钮</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftViewMode=UITextFieldViewModeAlways;</div><div class=\"line\"></div><div class=\"line\">searchTextField.placeholder=@&quot;请输入关键字&quot;;//默认显示的字</div><div class=\"line\"></div><div class=\"line\">searchTextField.secureTextEntry=YES;//设置成密码格式</div><div class=\"line\"></div><div class=\"line\">searchTextField.keyboardType=UIKeyboardTypeDefault;//设置键盘类型为默认的</div><div class=\"line\"></div><div class=\"line\">searchTextField.returnKeyType=UIReturnKeyDefault;//返回键的类型</div><div class=\"line\">/*</div><div class=\"line\">typedef enum &#123;</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyDefault, 默认 灰色按钮，标有Return</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyGo,      标有Go的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyJoin,标有Join的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyNext,标有Next的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyRoute,标有Route的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeySearch,标有Search的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeySend,标有Send的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyYahoo,标有Yahoo的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyYahoo,标有Yahoo的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyEmergencyCall, 紧急呼叫按钮</div><div class=\"line\"></div><div class=\"line\">&#125; UIReturnKeyType;</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">searchTextField.delegate=self;//设置委托</div><div class=\"line\"></div><div class=\"line\">textFied.adjustsFontSizeToFitWidth = YES;//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动，与下边的配合使用</div><div class=\"line\"></div><div class=\"line\">text.minimumFontSize = 20;//设置自动缩小显示的最小字体大小</div><div class=\"line\"></div><div class=\"line\">text.autocapitalizationType = UITextAutocapitalizationTypeNone;//首字母是否大写</div><div class=\"line\">text.enablesReturnKeyAutomatically = YES;//输入框没有字的时候return变成灰色</div></pre></td></tr></table></figure>\n<h4 id=\"光标显示位置调整\"><a href=\"#光标显示位置调整\" class=\"headerlink\" title=\"光标显示位置调整\"></a>光标显示位置调整</h4><p>设置leftView，同是设置以下两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">searchTextField.leftView=imgV;//设置输入框内左边的图标</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftViewMode=UITextFieldViewModeAlways;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设置textfiled的边框的颜色和样式\"><a href=\"#设置textfiled的边框的颜色和样式\" class=\"headerlink\" title=\"设置textfiled的边框的颜色和样式\"></a>设置textfiled的边框的颜色和样式</h4><p>尽量使用layer的属性来设置</p>\n<h4 id=\"设置光标颜色\"><a href=\"#设置光标颜色\" class=\"headerlink\" title=\"设置光标颜色\"></a>设置光标颜色</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置光标颜色1</div><div class=\"line\">self.tintColor = [UIColor redColor];</div></pre></td></tr></table></figure>\n<h4 id=\"设置占位文字颜色\"><a href=\"#设置占位文字颜色\" class=\"headerlink\" title=\"设置占位文字颜色\"></a>设置占位文字颜色</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 设置光标的颜色2</div><div class=\"line\"></div><div class=\"line\">UIColor *color = [UIColor whiteColor];  </div><div class=\"line\">    _userName.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@&quot;用户名&quot; attributes:@&#123;NSForegroundColorAttributeName: color&#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"各种小技巧\"><a href=\"#各种小技巧\" class=\"headerlink\" title=\"各种小技巧\"></a>各种小技巧</h3><h4 id=\"监听删除\"><a href=\"#监听删除\" class=\"headerlink\" title=\"监听删除\"></a>监听删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string&#123;</div><div class=\"line\"></div><div class=\"line\">   NSString*match =nil;;</div><div class=\"line\">   if(textField ==_userTextField)&#123;</div><div class=\"line\">        match =@&quot;^([0-9])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        match =@&quot;^([0-9a-zA-Z]|[\\\\s|-])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">       if(range.length==1) &#123;</div><div class=\"line\">           self.pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">            [selfcheckInputValid];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">在这个方法里边拿到range，如果length为0说明在正向输入，如果为1说明在删除字符</div></pre></td></tr></table></figure>\n<h4 id=\"密文变明文光标错位\"><a href=\"#密文变明文光标错位\" class=\"headerlink\" title=\"密文变明文光标错位\"></a>密文变明文光标错位</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">思路：删除内容，然后重新赋值</div><div class=\"line\"></div><div class=\"line\">- (void)pwdShowBtnClick:(UIButton*)btn&#123;</div><div class=\"line\">    btn.selected= !(btn.selected);</div><div class=\"line\">   _pwdTextField.secureTextEntry= !(btn.selected);</div><div class=\"line\">   NSString*pwd =_pwdTextField.text;</div><div class=\"line\">   _pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">//    [_pwdTextField resignFirstResponder];</div><div class=\"line\">   _pwdTextField.text= pwd;</div><div class=\"line\">    [_pwdTextFieldbecomeFirstResponder];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"各种收起键盘\"><a href=\"#各种收起键盘\" class=\"headerlink\" title=\"各种收起键盘\"></a>各种收起键盘</h4><ul>\n<li>点击背景view的任何地方</li>\n<li>点击return</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.textField resignFirstResponder];</div><div class=\"line\"></div><div class=\"line\">[self.view endEditing:YES];//最彻底的办法</div><div class=\"line\"></div><div class=\"line\">-(BOOL)textFieldShouldReturn:(UITextField *)textField</div><div class=\"line\">&#123;</div><div class=\"line\">    [textField resignFirstResponder];</div><div class=\"line\">    returnYES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"虚拟键盘挡住textfield\"><a href=\"#虚拟键盘挡住textfield\" class=\"headerlink\" title=\"虚拟键盘挡住textfield\"></a>虚拟键盘挡住textfield</h4><ul>\n<li>设置inputAccessoryView，在这个上边添加另外一个textfield</li>\n<li>监听键盘弹出事件，此时将firstresponder设置为该textfield</li>\n</ul>\n<h4 id=\"给数字键盘添加取消或者其他按钮\"><a href=\"#给数字键盘添加取消或者其他按钮\" class=\"headerlink\" title=\"给数字键盘添加取消或者其他按钮\"></a>给数字键盘添加取消或者其他按钮</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (UITextField *)textField &#123;</div><div class=\"line\">    if (!_textField) &#123;</div><div class=\"line\">        _textField = [[UITextField alloc] init];</div><div class=\"line\">        _textField.frame = CGRectMake(100, 100, 200, 50);</div><div class=\"line\">        _textField.keyboardType = UIKeyboardTypeNumberPad;</div><div class=\"line\">        _textField.backgroundColor = [UIColor blueColor];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _textField;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShowOnDelay:) name:UIKeyboardWillShowNotification object:nil];</div><div class=\"line\"> self.littlecancleButton.backgroundColor = [UIColor clearColor];//这句主要是为了提前加载button，如果在键盘的通知中添加button</div><div class=\"line\"> ，就会自动加上动画</div><div class=\"line\">    [self.view addSubview:self.textField];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)windowDidShow:(NSNotification *)noti &#123;</div><div class=\"line\">    NSLog(@&quot;------&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)keyboardWillShowOnDelay:(NSNotification *)noti &#123;</div><div class=\"line\"></div><div class=\"line\">    UIWindow *keyboardWindow = nil;</div><div class=\"line\">    </div><div class=\"line\">    for (UIWindow *testWindow in [[UIApplication sharedApplication] windows]) &#123;</div><div class=\"line\">        if ([NSStringFromClass([testWindow class]) isEqualToString:@&quot;UIRemoteKeyboardWindow&quot;]) &#123;</div><div class=\"line\">            keyboardWindow = testWindow;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (!keyboardWindow) return;</div><div class=\"line\">    </div><div class=\"line\">    [keyboardWindow addSubview:self.littlecancleButton];</div><div class=\"line\">    [UIView animateWithDuration:0.1 animations:^&#123;</div><div class=\"line\">        self.littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);</div><div class=\"line\">    &#125;];</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)littlecancleButton &#123;</div><div class=\"line\">    if (!_littlecancleButton) &#123;</div><div class=\"line\">        _littlecancleButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_littlecancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal];</div><div class=\"line\">        _littlecancleButton.titleLabel.font = [UIFont systemFontOfSize:20];</div><div class=\"line\">        [_littlecancleButton sizeToFit];</div><div class=\"line\">        [_littlecancleButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</div><div class=\"line\">        _littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height + 216 - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);</div><div class=\"line\">        [_littlecancleButton addTarget:self action:@selector(cancleBtnClick) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return _littlecancleButton;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)cancleBtnClick &#123;</div><div class=\"line\">    NSLog(@&quot;1111111&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"虚拟键盘遮挡提示弹框\"><a href=\"#虚拟键盘遮挡提示弹框\" class=\"headerlink\" title=\"虚拟键盘遮挡提示弹框\"></a>虚拟键盘遮挡提示弹框</h4><p>解决思路同添加取消按钮，就是将提示框添加到键盘的window上</p>\n<h4 id=\"textfield随着键盘移动\"><a href=\"#textfield随着键盘移动\" class=\"headerlink\" title=\"textfield随着键盘移动\"></a>textfield随着键盘移动</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">   </div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillChangeFrameNotification object:nil];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.textField];</div><div class=\"line\">    </div><div class=\"line\">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];</div><div class=\"line\">    [self.view addGestureRecognizer:tap];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)tap &#123;</div><div class=\"line\">    [self.view endEditing:YES];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)keyboardWillShow:(NSNotification *)noti &#123;</div><div class=\"line\">    double duration = [noti.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];</div><div class=\"line\">    </div><div class=\"line\">    CGFloat keyboardY = [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y;</div><div class=\"line\">    CGFloat ty = keyboardY - kScreenH;</div><div class=\"line\">    </div><div class=\"line\">    [UIView animateWithDuration:duration animations:^&#123;</div><div class=\"line\">        self.textField.transform = CGAffineTransformMakeTranslation(0, ty);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"配合使用正则表达式\"><a href=\"#配合使用正则表达式\" class=\"headerlink\" title=\"配合使用正则表达式\"></a>配合使用正则表达式</h3><ul>\n<li>校验是否为有效手机号<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否为有效手机号的判断</div><div class=\"line\">- (NSString *)valiMobile:(NSString *)mobile&#123;</div><div class=\"line\">if (mobile.length &lt; 11)</div><div class=\"line\">&#123;</div><div class=\"line\">return @&quot;请填写有效的手机号&quot;;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">/**</div><div class=\"line\">* 移动号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CM_NUM = @&quot;^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d&#123;8&#125;|(1705)\\\\d&#123;7&#125;$&quot;;</div><div class=\"line\">/**</div><div class=\"line\">* 联通号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CU_NUM = @&quot;^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d&#123;8&#125;|(1709)\\\\d&#123;7&#125;$&quot;;</div><div class=\"line\">/**</div><div class=\"line\">* 电信号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CT_NUM = @&quot;^((133)|(153)|(177)|(18[0,1,9]))\\\\d&#123;8&#125;$&quot;;</div><div class=\"line\">NSPredicate *pred1 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM_NUM];</div><div class=\"line\">BOOL isMatch1 = [pred1 evaluateWithObject:mobile];</div><div class=\"line\">NSPredicate *pred2 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU_NUM];</div><div class=\"line\">BOOL isMatch2 = [pred2 evaluateWithObject:mobile];</div><div class=\"line\">NSPredicate *pred3 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT_NUM];</div><div class=\"line\">BOOL isMatch3 = [pred3 evaluateWithObject:mobile];</div><div class=\"line\"></div><div class=\"line\">if (isMatch1 || isMatch2 || isMatch3) &#123;</div><div class=\"line\">return nil;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">return @&quot;请填写有效的手机号&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h3><p>我们监听textfield的事件总结来看有两种途径，第一种是代理，第二种是通知，代理能够监听的更加广泛一些<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        // return NO to disallow editing.</div><div class=\"line\">- (void)textFieldDidBeginEditing:(UITextField *)textField;           // became first responder</div><div class=\"line\">- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;          // return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end</div><div class=\"line\">- (void)textFieldDidEndEditing:(UITextField *)textField;             // may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called</div><div class=\"line\"></div><div class=\"line\">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   // return NO to not change text</div><div class=\"line\"></div><div class=\"line\">- (BOOL)textFieldShouldClear:(UITextField *)textField;               // called when clear button pressed. return NO to ignore (no notifications)</div><div class=\"line\">- (BOOL)textFieldShouldReturn:(UITextField *)textField;              // called when &apos;return&apos; key pressed. return NO to ignore.</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidBeginEditingNotification;</div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidEndEditingNotification;</div><div class=\"line\">UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</div></pre></td></tr></table></figure></p>\n<h3 id=\"监听输入\"><a href=\"#监听输入\" class=\"headerlink\" title=\"监听输入\"></a>监听输入</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged];</div><div class=\"line\">- (void) textFieldDidChange:(UITextField *) TextField&#123; &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"输入限制\"><a href=\"#输入限制\" class=\"headerlink\" title=\"输入限制\"></a>输入限制</h3><h4 id=\"长度\"><a href=\"#长度\" class=\"headerlink\" title=\"长度\"></a>长度</h4><blockquote>\n<p>注意这里得到的string是你输入的那个string，不一定是显示的那个string，经过判断如果你返回yes，那么这个数字将会显示到textfield里边，否则就不会显示的<br>并且这里的string，是单个字母或者汉字</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;</div><div class=\"line\">&#123; //string就是此时输入的那个字符textField就是此时正在输入的那个输入框返回YES就是可以改变输入框的值NO相反</div><div class=\"line\"></div><div class=\"line\">if ([string isEqualToString:@&quot;\\n&quot;]) //按会车可以改变</div><div class=\"line\">   &#123;</div><div class=\"line\">       return YES;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   NSString * toBeString = [textField.text stringByReplacingCharactersInRange:range withString:string]; //得到输入框的内容，注意，这里如果直接取textField.text那么你得到的是少一个字母的，也就是你这个取到的string</div><div class=\"line\"></div><div class=\"line\">   if (self.myTextField == textField) //判断是否时我们想要限定的那个输入框</div><div class=\"line\">   &#123;</div><div class=\"line\">       if ([toBeString length] &gt; 20) &#123; //如果输入框内容大于20则弹出警告</div><div class=\"line\">            textField.text = [toBeString substringToIndex:20];</div><div class=\"line\">           UIAlertView *alert = [[[UIAlertView alloc] initWithTitle:nil message:@&quot;超过最大字数不能输入了&quot; delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil, nil] autorelease];</div><div class=\"line\">           [alert show];</div><div class=\"line\">           return NO;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上边的方法有个问题就是不能有效的统计中文，因为输入中文的时候它首先是输入英文，然后当你选了某个中文文字，英文字符串才会被替换掉，那么我们需要一种更为精准的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)textFieldLimitWithTextField:(UITextField*)textField length:(NSInteger)length&#123;</div><div class=\"line\">    NSString *toBeString = textField.text;</div><div class=\"line\">    NSString *lang = [[UITextInputMode currentInputMode] primaryLanguage]; // 键盘输入模式</div><div class=\"line\">    if ([lang isEqualToString:@&quot;zh-Hans&quot;]) &#123; // 简体中文输入，包括简体拼音，健体五笔，简体手写</div><div class=\"line\">        UITextRange *selectedRange = [textField markedTextRange];</div><div class=\"line\">        //获取高亮部分</div><div class=\"line\">        UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0];</div><div class=\"line\">        // 没有高亮选择的字，则对已输入的文字进行字数统计和限制</div><div class=\"line\">        if (!position) &#123;</div><div class=\"line\">            if (toBeString.length &gt; length) &#123;</div><div class=\"line\">                textField.text = [toBeString substringToIndex:length];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 有高亮选择的字符串，则暂不对文字进行统计和限制</div><div class=\"line\">        else&#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 中文输入法以外的直接对其统计限制即可，不考虑其他语种情况</div><div class=\"line\">    else&#123;</div><div class=\"line\">        if (toBeString.length &gt; length) &#123;</div><div class=\"line\">            textField.text = [toBeString substringToIndex:length];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>直接将textfield和要限制的字数传入就好，不过我们需要不断地传入这个textfield<br>配合使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)checkInputValid&#123;</div><div class=\"line\">//    _userClearBtn.hidden = (0 == _userTextField.text.length );</div><div class=\"line\"></div><div class=\"line\">    [self textFieldLimitWithTextField:_userTextField length:20];</div><div class=\"line\"></div><div class=\"line\">    BOOL isUserValid = (_userTextField.text.length &gt;= 1 &amp;&amp; _userTextField.text.length &lt;=20);</div><div class=\"line\">    BOOL isPwdValid = (_pwdTextField.text.length &gt;= 1) ;</div><div class=\"line\"></div><div class=\"line\">    [self setLoginBtnEnabled:isUserValid &amp;&amp; isPwdValid];</div><div class=\"line\">//    [self setClearBtnShow:isUserValid];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[tf addTarget:self action:@selector(textFieldChanged:) forControlEvents:UIControlEventEditingChanged];</div></pre></td></tr></table></figure>\n<h4 id=\"数值不能超过xx\"><a href=\"#数值不能超过xx\" class=\"headerlink\" title=\"数值不能超过xx\"></a>数值不能超过xx</h4><h4 id=\"限制输入的类型\"><a href=\"#限制输入的类型\" class=\"headerlink\" title=\"限制输入的类型\"></a>限制输入的类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string&#123;</div><div class=\"line\"></div><div class=\"line\">   NSString*match =nil;;</div><div class=\"line\">   if(textField ==_userTextField)&#123;</div><div class=\"line\">        match =@&quot;^([0-9])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        match =@&quot;^([0-9a-zA-Z]|[\\\\s|-])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">       if(range.location&lt;_lastLength) &#123;</div><div class=\"line\">           self.pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">            [selfcheckInputValid];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   DLog(@&quot;%@--%@&quot;, NSStringFromRange(range) , [NSString stringWithFormat:@&quot;%ld&quot;, (long)self.lastLength]);</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">        self.lastLength= range.location;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   NSPredicate*predicate = [NSPredicatepredicateWithFormat:@&quot;SELF MATCHES %@&quot;, match];</div><div class=\"line\">   return[predicateevaluateWithObject:string];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"样式设置\"><a href=\"#样式设置\" class=\"headerlink\" title=\"样式设置\"></a>样式设置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">searchTextField=[[UITextField alloc]initWithFrame:CGRectMake(1.0,0.0,searchBackGroundImageView.frame.size.width, searchBackGroundImageView.frame.size.height)];//创建一个UITextField对象，及设置其位置及大小</div><div class=\"line\">//输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容</div><div class=\"line\">searchTextField.clearButtonMode = UITextFieldViewModeAlways;</div><div class=\"line\">text.clearsOnBeginEditing = YES;//再次编辑就清空</div><div class=\"line\">searchTextField.contentVerticalAlignment=UIControlContentVerticalAlignmentCenter;//设置其输入内容竖直居中</div><div class=\"line\"></div><div class=\"line\">UIImageView* imgV=[[UIImageViewalloc]initWithImage:[UIImageimageNamed:@&quot;search_ico&quot;]];</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftView=imgV;//设置输入框内左边的图标</div><div class=\"line\"></div><div class=\"line\">[self.tf11setClearButtonMode:UITextFieldViewModeWhileEditing];//右侧删除按钮</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftViewMode=UITextFieldViewModeAlways;</div><div class=\"line\"></div><div class=\"line\">searchTextField.placeholder=@&quot;请输入关键字&quot;;//默认显示的字</div><div class=\"line\"></div><div class=\"line\">searchTextField.secureTextEntry=YES;//设置成密码格式</div><div class=\"line\"></div><div class=\"line\">searchTextField.keyboardType=UIKeyboardTypeDefault;//设置键盘类型为默认的</div><div class=\"line\"></div><div class=\"line\">searchTextField.returnKeyType=UIReturnKeyDefault;//返回键的类型</div><div class=\"line\">/*</div><div class=\"line\">typedef enum &#123;</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyDefault, 默认 灰色按钮，标有Return</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyGo,      标有Go的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyJoin,标有Join的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyNext,标有Next的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyRoute,标有Route的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeySearch,标有Search的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeySend,标有Send的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyYahoo,标有Yahoo的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyYahoo,标有Yahoo的蓝色按钮</div><div class=\"line\"></div><div class=\"line\">    UIReturnKeyEmergencyCall, 紧急呼叫按钮</div><div class=\"line\"></div><div class=\"line\">&#125; UIReturnKeyType;</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">searchTextField.delegate=self;//设置委托</div><div class=\"line\"></div><div class=\"line\">textFied.adjustsFontSizeToFitWidth = YES;//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动，与下边的配合使用</div><div class=\"line\"></div><div class=\"line\">text.minimumFontSize = 20;//设置自动缩小显示的最小字体大小</div><div class=\"line\"></div><div class=\"line\">text.autocapitalizationType = UITextAutocapitalizationTypeNone;//首字母是否大写</div><div class=\"line\">text.enablesReturnKeyAutomatically = YES;//输入框没有字的时候return变成灰色</div></pre></td></tr></table></figure>\n<h4 id=\"光标显示位置调整\"><a href=\"#光标显示位置调整\" class=\"headerlink\" title=\"光标显示位置调整\"></a>光标显示位置调整</h4><p>设置leftView，同是设置以下两个方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">searchTextField.leftView=imgV;//设置输入框内左边的图标</div><div class=\"line\"></div><div class=\"line\">searchTextField.leftViewMode=UITextFieldViewModeAlways;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设置textfiled的边框的颜色和样式\"><a href=\"#设置textfiled的边框的颜色和样式\" class=\"headerlink\" title=\"设置textfiled的边框的颜色和样式\"></a>设置textfiled的边框的颜色和样式</h4><p>尽量使用layer的属性来设置</p>\n<h4 id=\"设置光标颜色\"><a href=\"#设置光标颜色\" class=\"headerlink\" title=\"设置光标颜色\"></a>设置光标颜色</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置光标颜色1</div><div class=\"line\">self.tintColor = [UIColor redColor];</div></pre></td></tr></table></figure>\n<h4 id=\"设置占位文字颜色\"><a href=\"#设置占位文字颜色\" class=\"headerlink\" title=\"设置占位文字颜色\"></a>设置占位文字颜色</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 设置光标的颜色2</div><div class=\"line\"></div><div class=\"line\">UIColor *color = [UIColor whiteColor];  </div><div class=\"line\">    _userName.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@&quot;用户名&quot; attributes:@&#123;NSForegroundColorAttributeName: color&#125;];</div></pre></td></tr></table></figure>\n<h3 id=\"各种小技巧\"><a href=\"#各种小技巧\" class=\"headerlink\" title=\"各种小技巧\"></a>各种小技巧</h3><h4 id=\"监听删除\"><a href=\"#监听删除\" class=\"headerlink\" title=\"监听删除\"></a>监听删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)textField:(UITextField*)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string&#123;</div><div class=\"line\"></div><div class=\"line\">   NSString*match =nil;;</div><div class=\"line\">   if(textField ==_userTextField)&#123;</div><div class=\"line\">        match =@&quot;^([0-9])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        match =@&quot;^([0-9a-zA-Z]|[\\\\s|-])&#123;0,&#125;$&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">   if(textField ==self.userTextField) &#123;</div><div class=\"line\">       if(range.length==1) &#123;</div><div class=\"line\">           self.pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">            [selfcheckInputValid];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">在这个方法里边拿到range，如果length为0说明在正向输入，如果为1说明在删除字符</div></pre></td></tr></table></figure>\n<h4 id=\"密文变明文光标错位\"><a href=\"#密文变明文光标错位\" class=\"headerlink\" title=\"密文变明文光标错位\"></a>密文变明文光标错位</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">思路：删除内容，然后重新赋值</div><div class=\"line\"></div><div class=\"line\">- (void)pwdShowBtnClick:(UIButton*)btn&#123;</div><div class=\"line\">    btn.selected= !(btn.selected);</div><div class=\"line\">   _pwdTextField.secureTextEntry= !(btn.selected);</div><div class=\"line\">   NSString*pwd =_pwdTextField.text;</div><div class=\"line\">   _pwdTextField.text=@&quot;&quot;;</div><div class=\"line\">//    [_pwdTextField resignFirstResponder];</div><div class=\"line\">   _pwdTextField.text= pwd;</div><div class=\"line\">    [_pwdTextFieldbecomeFirstResponder];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"各种收起键盘\"><a href=\"#各种收起键盘\" class=\"headerlink\" title=\"各种收起键盘\"></a>各种收起键盘</h4><ul>\n<li>点击背景view的任何地方</li>\n<li>点击return</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self.textField resignFirstResponder];</div><div class=\"line\"></div><div class=\"line\">[self.view endEditing:YES];//最彻底的办法</div><div class=\"line\"></div><div class=\"line\">-(BOOL)textFieldShouldReturn:(UITextField *)textField</div><div class=\"line\">&#123;</div><div class=\"line\">    [textField resignFirstResponder];</div><div class=\"line\">    returnYES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"虚拟键盘挡住textfield\"><a href=\"#虚拟键盘挡住textfield\" class=\"headerlink\" title=\"虚拟键盘挡住textfield\"></a>虚拟键盘挡住textfield</h4><ul>\n<li>设置inputAccessoryView，在这个上边添加另外一个textfield</li>\n<li>监听键盘弹出事件，此时将firstresponder设置为该textfield</li>\n</ul>\n<h4 id=\"给数字键盘添加取消或者其他按钮\"><a href=\"#给数字键盘添加取消或者其他按钮\" class=\"headerlink\" title=\"给数字键盘添加取消或者其他按钮\"></a>给数字键盘添加取消或者其他按钮</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\">- (UITextField *)textField &#123;</div><div class=\"line\">    if (!_textField) &#123;</div><div class=\"line\">        _textField = [[UITextField alloc] init];</div><div class=\"line\">        _textField.frame = CGRectMake(100, 100, 200, 50);</div><div class=\"line\">        _textField.keyboardType = UIKeyboardTypeNumberPad;</div><div class=\"line\">        _textField.backgroundColor = [UIColor blueColor];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _textField;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShowOnDelay:) name:UIKeyboardWillShowNotification object:nil];</div><div class=\"line\"> self.littlecancleButton.backgroundColor = [UIColor clearColor];//这句主要是为了提前加载button，如果在键盘的通知中添加button</div><div class=\"line\"> ，就会自动加上动画</div><div class=\"line\">    [self.view addSubview:self.textField];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)windowDidShow:(NSNotification *)noti &#123;</div><div class=\"line\">    NSLog(@&quot;------&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)keyboardWillShowOnDelay:(NSNotification *)noti &#123;</div><div class=\"line\"></div><div class=\"line\">    UIWindow *keyboardWindow = nil;</div><div class=\"line\">    </div><div class=\"line\">    for (UIWindow *testWindow in [[UIApplication sharedApplication] windows]) &#123;</div><div class=\"line\">        if ([NSStringFromClass([testWindow class]) isEqualToString:@&quot;UIRemoteKeyboardWindow&quot;]) &#123;</div><div class=\"line\">            keyboardWindow = testWindow;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    if (!keyboardWindow) return;</div><div class=\"line\">    </div><div class=\"line\">    [keyboardWindow addSubview:self.littlecancleButton];</div><div class=\"line\">    [UIView animateWithDuration:0.1 animations:^&#123;</div><div class=\"line\">        self.littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);</div><div class=\"line\">    &#125;];</div><div class=\"line\">   </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)littlecancleButton &#123;</div><div class=\"line\">    if (!_littlecancleButton) &#123;</div><div class=\"line\">        _littlecancleButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_littlecancleButton setTitle:@&quot;取消&quot; forState:UIControlStateNormal];</div><div class=\"line\">        _littlecancleButton.titleLabel.font = [UIFont systemFontOfSize:20];</div><div class=\"line\">        [_littlecancleButton sizeToFit];</div><div class=\"line\">        [_littlecancleButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];</div><div class=\"line\">        _littlecancleButton.frame = CGRectMake(0, [UIScreen mainScreen].bounds.size.height + 216 - 53, [UIScreen mainScreen].bounds.size.width * 0.3333, 53);</div><div class=\"line\">        [_littlecancleButton addTarget:self action:@selector(cancleBtnClick) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    return _littlecancleButton;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)cancleBtnClick &#123;</div><div class=\"line\">    NSLog(@&quot;1111111&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"虚拟键盘遮挡提示弹框\"><a href=\"#虚拟键盘遮挡提示弹框\" class=\"headerlink\" title=\"虚拟键盘遮挡提示弹框\"></a>虚拟键盘遮挡提示弹框</h4><p>解决思路同添加取消按钮，就是将提示框添加到键盘的window上</p>\n<h4 id=\"textfield随着键盘移动\"><a href=\"#textfield随着键盘移动\" class=\"headerlink\" title=\"textfield随着键盘移动\"></a>textfield随着键盘移动</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">   </div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillChangeFrameNotification object:nil];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.textField];</div><div class=\"line\">    </div><div class=\"line\">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap)];</div><div class=\"line\">    [self.view addGestureRecognizer:tap];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)tap &#123;</div><div class=\"line\">    [self.view endEditing:YES];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)keyboardWillShow:(NSNotification *)noti &#123;</div><div class=\"line\">    double duration = [noti.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];</div><div class=\"line\">    </div><div class=\"line\">    CGFloat keyboardY = [noti.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y;</div><div class=\"line\">    CGFloat ty = keyboardY - kScreenH;</div><div class=\"line\">    </div><div class=\"line\">    [UIView animateWithDuration:duration animations:^&#123;</div><div class=\"line\">        self.textField.transform = CGAffineTransformMakeTranslation(0, ty);</div><div class=\"line\">    &#125;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"配合使用正则表达式\"><a href=\"#配合使用正则表达式\" class=\"headerlink\" title=\"配合使用正则表达式\"></a>配合使用正则表达式</h3><ul>\n<li>校验是否为有效手机号<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否为有效手机号的判断</div><div class=\"line\">- (NSString *)valiMobile:(NSString *)mobile&#123;</div><div class=\"line\">if (mobile.length &lt; 11)</div><div class=\"line\">&#123;</div><div class=\"line\">return @&quot;请填写有效的手机号&quot;;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">/**</div><div class=\"line\">* 移动号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CM_NUM = @&quot;^((13[4-9])|(147)|(15[0-2,7-9])|(178)|(18[2-4,7-8]))\\\\d&#123;8&#125;|(1705)\\\\d&#123;7&#125;$&quot;;</div><div class=\"line\">/**</div><div class=\"line\">* 联通号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CU_NUM = @&quot;^((13[0-2])|(145)|(15[5-6])|(176)|(18[5,6]))\\\\d&#123;8&#125;|(1709)\\\\d&#123;7&#125;$&quot;;</div><div class=\"line\">/**</div><div class=\"line\">* 电信号段正则表达式</div><div class=\"line\">*/</div><div class=\"line\">NSString *CT_NUM = @&quot;^((133)|(153)|(177)|(18[0,1,9]))\\\\d&#123;8&#125;$&quot;;</div><div class=\"line\">NSPredicate *pred1 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM_NUM];</div><div class=\"line\">BOOL isMatch1 = [pred1 evaluateWithObject:mobile];</div><div class=\"line\">NSPredicate *pred2 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU_NUM];</div><div class=\"line\">BOOL isMatch2 = [pred2 evaluateWithObject:mobile];</div><div class=\"line\">NSPredicate *pred3 = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT_NUM];</div><div class=\"line\">BOOL isMatch3 = [pred3 evaluateWithObject:mobile];</div><div class=\"line\"></div><div class=\"line\">if (isMatch1 || isMatch2 || isMatch3) &#123;</div><div class=\"line\">return nil;</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">return @&quot;请填写有效的手机号&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return nil;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"事件与响应者链","date":"2014-07-21T02:43:38.000Z","_content":"","source":"_posts/2014/事件与响应者链.md","raw":"---\ntitle: 事件与响应者链\ndate: 2014-07-21 10:43:38\ntags:\n---\n","slug":"2014/事件与响应者链","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pm9001xsauay3y30rl2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS设计模式","date":"2014-11-18T07:20:59.000Z","_content":">设计模式的功能是在软件设计当中是解决一些重复的公共问题。他们是一些模板来帮助你更容易的书写代码和复用你的代码。他们还可能帮助你创建低耦合的代码，你可以很轻松的修改和替换其中的组件。\n<!--more-->\n## MVC\n现在可能更流行的是MVVM，首先，你要保证在你的项目中任何一个类都有一个控制器，一个模型，一个视图，一个类中的函数不能有两种作用\n\n## Singleton – 单例模式\n单例设计模式确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。\n\n在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。\n\n推荐写法，拦截alloc和copy方法\n\n```\nstatic  MySingleton  *shareSingleton ＝ nil;\n\n+( instancetype ) sharedSingleton  {\n\n   static  dispatch_once  onceToken;\n\n   dispatch_once ( &onceToken, ^ {\n\n   shareSingleton  =  [[super allocWithZone:NULL] init] ;\n\n} );\n\n    return sharedSingleton;\n\n}\n\n+(id) allocWithZone:(struct _NSZone *)zone {\n\n   return [Singleton shareInstance] ; \n\n}\n\n-(id) copyWithZone:(struct _NSZone *)zone {\n\n   return [Singleton shareInstance] ;\n\n}\n\n```\n\n## Observer – 观察者模式\n在观察者模式中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。\n\n它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。\n\n如果你想要一直使用 MVC 模式（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。\n\nCocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。\n\n### 通知 Notifications\n#### 实现原理\n\n\n#### 注意\n- 通知是同步操作，所以再通知的调用方法中做太多的事情是肯定会有问题的，有太多的通知也是有问题的\n\n\n### KVO\n\n#### KVO实现原理\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/9770095.jpg)\n- KVO是基于runtime机制实现的\n- 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制\n- 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person\n- 每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法\n- 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。\n- 补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类\n- KVO和通知一样，都是同步操作，所以使用的时候要注意\n\n\n\n\n#### 手动触发KVO\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    // “手动触发self.now的KVO”，必写。\n    [self willChangeValueForKey:@\"now\"];\n\n    // “手动触发self.now的KVO”，必写。\n    [self didChangeValueForKey:@\"now\"];\n}\n```\n","source":"_posts/2014/iOS设计模式.md","raw":"---\ntitle: iOS设计模式\ndate: 2014-11-18 15:20:59\ntags:\n- iOS基础知识\ncategories: iOS\n---\n>设计模式的功能是在软件设计当中是解决一些重复的公共问题。他们是一些模板来帮助你更容易的书写代码和复用你的代码。他们还可能帮助你创建低耦合的代码，你可以很轻松的修改和替换其中的组件。\n<!--more-->\n## MVC\n现在可能更流行的是MVVM，首先，你要保证在你的项目中任何一个类都有一个控制器，一个模型，一个视图，一个类中的函数不能有两种作用\n\n## Singleton – 单例模式\n单例设计模式确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。\n\n在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。\n\n推荐写法，拦截alloc和copy方法\n\n```\nstatic  MySingleton  *shareSingleton ＝ nil;\n\n+( instancetype ) sharedSingleton  {\n\n   static  dispatch_once  onceToken;\n\n   dispatch_once ( &onceToken, ^ {\n\n   shareSingleton  =  [[super allocWithZone:NULL] init] ;\n\n} );\n\n    return sharedSingleton;\n\n}\n\n+(id) allocWithZone:(struct _NSZone *)zone {\n\n   return [Singleton shareInstance] ; \n\n}\n\n-(id) copyWithZone:(struct _NSZone *)zone {\n\n   return [Singleton shareInstance] ;\n\n}\n\n```\n\n## Observer – 观察者模式\n在观察者模式中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。\n\n它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。\n\n如果你想要一直使用 MVC 模式（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。\n\nCocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。\n\n### 通知 Notifications\n#### 实现原理\n\n\n#### 注意\n- 通知是同步操作，所以再通知的调用方法中做太多的事情是肯定会有问题的，有太多的通知也是有问题的\n\n\n### KVO\n\n#### KVO实现原理\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/9770095.jpg)\n- KVO是基于runtime机制实现的\n- 当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制\n- 如果原类为Person，那么生成的派生类名为NSKVONotifying_Person\n- 每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法\n- 键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。\n- 补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类\n- KVO和通知一样，都是同步操作，所以使用的时候要注意\n\n\n\n\n#### 手动触发KVO\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n\n    // “手动触发self.now的KVO”，必写。\n    [self willChangeValueForKey:@\"now\"];\n\n    // “手动触发self.now的KVO”，必写。\n    [self didChangeValueForKey:@\"now\"];\n}\n```\n","slug":"2014/iOS设计模式","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmb0020saua9ui4jufx","content":"<blockquote>\n<p>设计模式的功能是在软件设计当中是解决一些重复的公共问题。他们是一些模板来帮助你更容易的书写代码和复用你的代码。他们还可能帮助你创建低耦合的代码，你可以很轻松的修改和替换其中的组件。<br><a id=\"more\"></a></p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>现在可能更流行的是MVVM，首先，你要保证在你的项目中任何一个类都有一个控制器，一个模型，一个视图，一个类中的函数不能有两种作用</p>\n</blockquote>\n<h2 id=\"Singleton-–-单例模式\"><a href=\"#Singleton-–-单例模式\" class=\"headerlink\" title=\"Singleton – 单例模式\"></a>Singleton – 单例模式</h2><p>单例设计模式确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。</p>\n<p>在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。</p>\n<p>推荐写法，拦截alloc和copy方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">static  MySingleton  *shareSingleton ＝ nil;</div><div class=\"line\"></div><div class=\"line\">+( instancetype ) sharedSingleton  &#123;</div><div class=\"line\"></div><div class=\"line\">   static  dispatch_once  onceToken;</div><div class=\"line\"></div><div class=\"line\">   dispatch_once ( &amp;onceToken, ^ &#123;</div><div class=\"line\"></div><div class=\"line\">   shareSingleton  =  [[super allocWithZone:NULL] init] ;</div><div class=\"line\"></div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">    return sharedSingleton;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(id) allocWithZone:(struct _NSZone *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">   return [Singleton shareInstance] ; </div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id) copyWithZone:(struct _NSZone *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">   return [Singleton shareInstance] ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Observer-–-观察者模式\"><a href=\"#Observer-–-观察者模式\" class=\"headerlink\" title=\"Observer – 观察者模式\"></a>Observer – 观察者模式</h2><p>在观察者模式中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>\n<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>\n<p>如果你想要一直使用 MVC 模式（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>\n<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>\n<h3 id=\"通知-Notifications\"><a href=\"#通知-Notifications\" class=\"headerlink\" title=\"通知 Notifications\"></a>通知 Notifications</h3><h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>通知是同步操作，所以再通知的调用方法中做太多的事情是肯定会有问题的，有太多的通知也是有问题的</li>\n</ul>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><h4 id=\"KVO实现原理\"><a href=\"#KVO实现原理\" class=\"headerlink\" title=\"KVO实现原理\"></a>KVO实现原理</h4><p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/9770095.jpg\" alt=\"\"></p>\n<ul>\n<li>KVO是基于runtime机制实现的</li>\n<li>当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制</li>\n<li>如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</li>\n<li>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</li>\n<li>键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</li>\n<li>补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</li>\n<li>KVO和通知一样，都是同步操作，所以使用的时候要注意</li>\n</ul>\n<h4 id=\"手动触发KVO\"><a href=\"#手动触发KVO\" class=\"headerlink\" title=\"手动触发KVO\"></a>手动触发KVO</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    // “手动触发self.now的KVO”，必写。</div><div class=\"line\">    [self willChangeValueForKey:@&quot;now&quot;];</div><div class=\"line\"></div><div class=\"line\">    // “手动触发self.now的KVO”，必写。</div><div class=\"line\">    [self didChangeValueForKey:@&quot;now&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>设计模式的功能是在软件设计当中是解决一些重复的公共问题。他们是一些模板来帮助你更容易的书写代码和复用你的代码。他们还可能帮助你创建低耦合的代码，你可以很轻松的修改和替换其中的组件。<br>","more":"</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><p>现在可能更流行的是MVVM，首先，你要保证在你的项目中任何一个类都有一个控制器，一个模型，一个视图，一个类中的函数不能有两种作用</p>\n</blockquote>\n<h2 id=\"Singleton-–-单例模式\"><a href=\"#Singleton-–-单例模式\" class=\"headerlink\" title=\"Singleton – 单例模式\"></a>Singleton – 单例模式</h2><p>单例设计模式确切的说就是一个类只有一个实例，有一个全局的接口来访问这个实例。当第一次载入的时候，它通常使用延时加载的方法创建单一实例。</p>\n<p>在一些情况下，一个类只有一个实例是有意义的。例如，这里没有必要有多个登录实例，除非你一次想写入多个日志文件。或者，一个全局的配置类文件：它可以很容易的很安全的执行一个公共资源，这样的一个配置文件，要比同时修改多个配置类文件好很多。</p>\n<p>推荐写法，拦截alloc和copy方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">static  MySingleton  *shareSingleton ＝ nil;</div><div class=\"line\"></div><div class=\"line\">+( instancetype ) sharedSingleton  &#123;</div><div class=\"line\"></div><div class=\"line\">   static  dispatch_once  onceToken;</div><div class=\"line\"></div><div class=\"line\">   dispatch_once ( &amp;onceToken, ^ &#123;</div><div class=\"line\"></div><div class=\"line\">   shareSingleton  =  [[super allocWithZone:NULL] init] ;</div><div class=\"line\"></div><div class=\"line\">&#125; );</div><div class=\"line\"></div><div class=\"line\">    return sharedSingleton;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(id) allocWithZone:(struct _NSZone *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">   return [Singleton shareInstance] ; </div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(id) copyWithZone:(struct _NSZone *)zone &#123;</div><div class=\"line\"></div><div class=\"line\">   return [Singleton shareInstance] ;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Observer-–-观察者模式\"><a href=\"#Observer-–-观察者模式\" class=\"headerlink\" title=\"Observer – 观察者模式\"></a>Observer – 观察者模式</h2><p>在观察者模式中，当状态发生改变的时候，一个对象会通知另一个对象。这个对象不需要知道另一个对象发生了什么改变─因此非常鼓励这种分离式的设计。这种模式经常用于，当一个属性发生改变时通知跟它相关的对象。</p>\n<p>它通常需要一个观察者(observer)注册跟踪另外一个对象的状态。当状态发生改变的时候，所有的观察对象都会被通知改变。苹果的推送通知服务就是一个这样的例子。</p>\n<p>如果你想要一直使用 MVC 模式（你确实需要），你如果想在模型和视图之间，不直接相互引用的情况下还要有通信。这时候就要用到观察者模式了。</p>\n<p>Cocoa 有两个常用的方法来执行观察者模式：Notifications 和 Key-Value Observing (KVO)。</p>\n<h3 id=\"通知-Notifications\"><a href=\"#通知-Notifications\" class=\"headerlink\" title=\"通知 Notifications\"></a>通知 Notifications</h3><h4 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h4><h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li>通知是同步操作，所以再通知的调用方法中做太多的事情是肯定会有问题的，有太多的通知也是有问题的</li>\n</ul>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><h4 id=\"KVO实现原理\"><a href=\"#KVO实现原理\" class=\"headerlink\" title=\"KVO实现原理\"></a>KVO实现原理</h4><p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/9770095.jpg\" alt=\"\"></p>\n<ul>\n<li>KVO是基于runtime机制实现的</li>\n<li>当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制</li>\n<li>如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</li>\n<li>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</li>\n<li>键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</li>\n<li>补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</li>\n<li>KVO和通知一样，都是同步操作，所以使用的时候要注意</li>\n</ul>\n<h4 id=\"手动触发KVO\"><a href=\"#手动触发KVO\" class=\"headerlink\" title=\"手动触发KVO\"></a>手动触发KVO</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    // “手动触发self.now的KVO”，必写。</div><div class=\"line\">    [self willChangeValueForKey:@&quot;now&quot;];</div><div class=\"line\"></div><div class=\"line\">    // “手动触发self.now的KVO”，必写。</div><div class=\"line\">    [self didChangeValueForKey:@&quot;now&quot;];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"计算机网络概述--TCP/IP","date":"2014-07-18T03:20:01.000Z","_content":"计算机基础\n<!--more-->\n>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”\n\n术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/10977221.jpg)\n","source":"_posts/2014/计算机网络概述.md","raw":"---\ntitle: 计算机网络概述--TCP/IP\ndate: 2014-07-18 11:20:01\ntags:\n- 计算机基础\ncategories: 基础\n---\n计算机基础\n<!--more-->\n>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”\n\n术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。\n\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/10977221.jpg)\n","slug":"2014/计算机网络概述","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmc0023sauaqwebjkf5","content":"<p>计算机基础<br><a id=\"more\"></a></p>\n<blockquote>\n<p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>\n</blockquote>\n<p>术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</p>\n<p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/10977221.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>计算机基础<br>","more":"</p>\n<blockquote>\n<p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>\n</blockquote>\n<p>术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。</p>\n<p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-18/10977221.jpg\" alt=\"\"></p>"},{"title":"Block使用总结","date":"2015-05-02T11:17:41.000Z","_content":"\nblock用来保存一段代码，在需要的时候回调，是对闭包的实现\n<!--more-->\n\n所以，切勿将过程代码当做block的实际实现，切记切记！！！\n## block的声明\n```\n//变量\nvoid (^myBlock)();\nint (^myBlock1)(int, int);\n\n//属性1\ntypydef void(^Myblock)();//这样Myblock就代表一个block类型了\n@property (nonatomic, copy) Myblock myblock; \n\n//属性2\n@property (nonatomic, copy) void(^myBlock)(int);//这样仍然是一个block，而且名字就是myBlock\n\n//参数\n- (void) modifyUserInfoWithNickName:(NSString *) nickName\n                           userLogo:(NSString *) userLogo\n                                sex:(NSNumber *) sex\n                           location:(NSString *) location\n                            succeed:(void(^)())successBlock\n                               fail:(void(^)(NSError *error))errorBlock;\n                               //这个时候的格式就变成了(返回+(^)(参数))名字\n                               \n也可以这样\n\ntypedef void(^FXSuccessBlock)(id result);\ntypedef void(^FXFailBlock)(NSError *error);\n\n- (void)onlyGetLoginUserInfo:(FXSuccessBlock)successHandler\n                 failHandler:(FXFailBlock)failHandler;\n```\nblock声明的格式：`返回值 + block名字 + 参数`\n\n## block实现\nblock实现的格式：`^(参数){}`\n\n注意block实现是要加上变量名字的\n```\nself.loginBlock = ^(BOOL complete) {\n  NSLog(@\"登录成功\");\n};\n```\n或者有种偷巧的写法，就是利用set方法\n```\n [self setLoginSucBlock:^(BOOL complete) {\n      NSLog(@\"登录成功\");  \n  }];\n```\n\n## Block对外部变量的管理\n### 基本数据类型\n#### 1、局部变量\n局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。\n```\nint base = 100;\nlong (^sum)(int, int) = ^ long (int a, int b) {\n     return base + a + b;\n};\nbase = 0;\nPRintf(\"%ld\\n\",sum(1,2));\n// 这里输出是103，而不是3, 因为块内base为拷贝的常量 100\n}\n```\n//进入block的是值，而不是地址，因为这个变量是定义在栈内存中的，随时可能被释放，所以我要将它的值copy进来，防止我使用的时候取不到\n#### 2、STATIC修饰符的全局变量\n因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。\n\n加入一个变量定义在函数之外，那么这个变量是全局变量。\n\n```\nstatic int a = 10;\n    \nint(^sum)(int) =^(int b) {\n    return a + b;\n};\n\na = 0;\n\nNSLog(@\"----%d\", sum(2));//2\n```\n//进入block的是地址而不是值，因为static修饰的变量在内存中存在于静态变量区，是不会被回收或者释放的，即使释放了，也会在爱disk中有备份，当我们使用的时候再创建然后赋值给我就好了，所以不用担心被销毁，所以用地址就好了\n\n#### 3.__block修饰的变量\n被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。\n\n```\n __block int a = 10;\n    \nint(^sum)(int) =^(int b) {\n    return a + b;\n};\n\na = 0;\n\nNSLog(@\"----%d\", sum(2));//2\n//进入block的是地址而不是值，这个道理与static是一致的\n```\n\n注意：如果我们用NSString来验证对象的block的内存管理是没有意义的，因为，某几种情况下NSString对象是存放在常量区的，相当于int这种变量\n\n`补充：`\n```\nNSString *name = @\"han\";\nNSLog(\"%p\", name);//打印的是@\"han\"的地址\nNSLog(\"%p\", &name);//打印的是name这个指针的地址\n```\n### 对象\n对象一定是存在于堆上的，所以决定要不要拷贝指针的关键在于引用的指针\n```\n@implementation ViewController\nUIView *view;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    view = [[UIView alloc] init];\n\n    void(^stackBlock)() = ^() {\n        NSLog(@\"&&&&&%p\", &view);\n    };\n    \n    NSLog(@\"****%p\", &view);\n    \n    stackBlock();\n}\n@end\n//2016-07-11 20:47:36.908 block[1906:517460] ****0x1000d1208\n//2016-07-11 20:47:36.909 block[1906:517460] &&&&&0x1000d1208\n\n```\n现在是一个全局变量来引用UIView，我们发现指针直接就是原来的地址，并没有发生变化，\n\n```\n@implementation ViewController\n\nvoid(^globalBlock)();\nint a;\n//UIView *view;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n     UIView *view = [[UIView alloc] init];\n\n    void(^stackBlock)() = ^() {\n        NSLog(@\"&&&&&%p\", &view);\n    };\n    \n    NSLog(@\"****%p\", &view);\n    \n    stackBlock();\n}\n\n//2016-07-11 21:00:51.055 block[1916:519453] ****0x16fd69f28\n//2016-07-11 21:00:51.056 block[1916:519453] &&&&&0x13563a480\n```\n很明显是两个指针\n\n那如果是一个成员变量会是什么效果呢？经过验证也是同一个指针。\n一个指针和两个指针有啥区别呢？答案就是，如果是两个指针的话，那么即使你外边的指针释放掉，这个对象也是释放不掉的，如果这个block不释放的话，所以如果这个block是一个全局的block这个对象也就没有释放的可能了。\n解决的方案就是，传入一个弱引用的指针，这样起码这个被引用的对象是不会因为block而不能释放了。\n从这个角度来理解，为什么会存在堆，栈，全局block，因为如果我引用了某个变量，而这个变量是在栈上的，那么不能因为被block引用而不释放这个变量，所以解决方案就是直接copy一份这个变量的值进来block结构体，用一个指针去引用，而如果引用了一个全局的变量，那么就不存在释放不掉的问题了，那么就不用再复制一份了。\n\n>一个block值创建的时候是在全局区的\n- 如果这个时候给我引用了一个全局的变量，那么我仍然在全局\n- 如果这个时候给我引用一个局部变量，那么这个block就会被移动到栈上，这里要注意的是成员变量与局部变量同等对待，因为它毕竟不在全局变量区，但是捕获成员变量的时候，因为这个变量是不会被轻易释放的，所以不会copy这个指针\n- 这个时候如果你在ARC情况下对这个block做一个赋值操作，如果之前这个block在栈上，那么一个strong引用操作之后这个block就被移动到堆上了\n\n\n//todo\nautorelease关键字起作用在arc下，需要这个对象是一个autorelease对象，默认情况下，UIView不是这样的对象，其他的是这样的对象，所以\n```\n@autorelease {\n  UIView *view = [UIView alloc] init];//内存会一直增加，不会释放的，以为UIView不会被释放，如果这个换成UIImage或者其他的，那就没有问题\n}\n```\n\n","source":"_posts/2015/Block使用总结.md","raw":"---\ntitle: Block使用总结\ndate: 2015-05-2 19:17:41\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\nblock用来保存一段代码，在需要的时候回调，是对闭包的实现\n<!--more-->\n\n所以，切勿将过程代码当做block的实际实现，切记切记！！！\n## block的声明\n```\n//变量\nvoid (^myBlock)();\nint (^myBlock1)(int, int);\n\n//属性1\ntypydef void(^Myblock)();//这样Myblock就代表一个block类型了\n@property (nonatomic, copy) Myblock myblock; \n\n//属性2\n@property (nonatomic, copy) void(^myBlock)(int);//这样仍然是一个block，而且名字就是myBlock\n\n//参数\n- (void) modifyUserInfoWithNickName:(NSString *) nickName\n                           userLogo:(NSString *) userLogo\n                                sex:(NSNumber *) sex\n                           location:(NSString *) location\n                            succeed:(void(^)())successBlock\n                               fail:(void(^)(NSError *error))errorBlock;\n                               //这个时候的格式就变成了(返回+(^)(参数))名字\n                               \n也可以这样\n\ntypedef void(^FXSuccessBlock)(id result);\ntypedef void(^FXFailBlock)(NSError *error);\n\n- (void)onlyGetLoginUserInfo:(FXSuccessBlock)successHandler\n                 failHandler:(FXFailBlock)failHandler;\n```\nblock声明的格式：`返回值 + block名字 + 参数`\n\n## block实现\nblock实现的格式：`^(参数){}`\n\n注意block实现是要加上变量名字的\n```\nself.loginBlock = ^(BOOL complete) {\n  NSLog(@\"登录成功\");\n};\n```\n或者有种偷巧的写法，就是利用set方法\n```\n [self setLoginSucBlock:^(BOOL complete) {\n      NSLog(@\"登录成功\");  \n  }];\n```\n\n## Block对外部变量的管理\n### 基本数据类型\n#### 1、局部变量\n局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。\n```\nint base = 100;\nlong (^sum)(int, int) = ^ long (int a, int b) {\n     return base + a + b;\n};\nbase = 0;\nPRintf(\"%ld\\n\",sum(1,2));\n// 这里输出是103，而不是3, 因为块内base为拷贝的常量 100\n}\n```\n//进入block的是值，而不是地址，因为这个变量是定义在栈内存中的，随时可能被释放，所以我要将它的值copy进来，防止我使用的时候取不到\n#### 2、STATIC修饰符的全局变量\n因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。\n\n加入一个变量定义在函数之外，那么这个变量是全局变量。\n\n```\nstatic int a = 10;\n    \nint(^sum)(int) =^(int b) {\n    return a + b;\n};\n\na = 0;\n\nNSLog(@\"----%d\", sum(2));//2\n```\n//进入block的是地址而不是值，因为static修饰的变量在内存中存在于静态变量区，是不会被回收或者释放的，即使释放了，也会在爱disk中有备份，当我们使用的时候再创建然后赋值给我就好了，所以不用担心被销毁，所以用地址就好了\n\n#### 3.__block修饰的变量\n被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。\n\n```\n __block int a = 10;\n    \nint(^sum)(int) =^(int b) {\n    return a + b;\n};\n\na = 0;\n\nNSLog(@\"----%d\", sum(2));//2\n//进入block的是地址而不是值，这个道理与static是一致的\n```\n\n注意：如果我们用NSString来验证对象的block的内存管理是没有意义的，因为，某几种情况下NSString对象是存放在常量区的，相当于int这种变量\n\n`补充：`\n```\nNSString *name = @\"han\";\nNSLog(\"%p\", name);//打印的是@\"han\"的地址\nNSLog(\"%p\", &name);//打印的是name这个指针的地址\n```\n### 对象\n对象一定是存在于堆上的，所以决定要不要拷贝指针的关键在于引用的指针\n```\n@implementation ViewController\nUIView *view;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    view = [[UIView alloc] init];\n\n    void(^stackBlock)() = ^() {\n        NSLog(@\"&&&&&%p\", &view);\n    };\n    \n    NSLog(@\"****%p\", &view);\n    \n    stackBlock();\n}\n@end\n//2016-07-11 20:47:36.908 block[1906:517460] ****0x1000d1208\n//2016-07-11 20:47:36.909 block[1906:517460] &&&&&0x1000d1208\n\n```\n现在是一个全局变量来引用UIView，我们发现指针直接就是原来的地址，并没有发生变化，\n\n```\n@implementation ViewController\n\nvoid(^globalBlock)();\nint a;\n//UIView *view;\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n     UIView *view = [[UIView alloc] init];\n\n    void(^stackBlock)() = ^() {\n        NSLog(@\"&&&&&%p\", &view);\n    };\n    \n    NSLog(@\"****%p\", &view);\n    \n    stackBlock();\n}\n\n//2016-07-11 21:00:51.055 block[1916:519453] ****0x16fd69f28\n//2016-07-11 21:00:51.056 block[1916:519453] &&&&&0x13563a480\n```\n很明显是两个指针\n\n那如果是一个成员变量会是什么效果呢？经过验证也是同一个指针。\n一个指针和两个指针有啥区别呢？答案就是，如果是两个指针的话，那么即使你外边的指针释放掉，这个对象也是释放不掉的，如果这个block不释放的话，所以如果这个block是一个全局的block这个对象也就没有释放的可能了。\n解决的方案就是，传入一个弱引用的指针，这样起码这个被引用的对象是不会因为block而不能释放了。\n从这个角度来理解，为什么会存在堆，栈，全局block，因为如果我引用了某个变量，而这个变量是在栈上的，那么不能因为被block引用而不释放这个变量，所以解决方案就是直接copy一份这个变量的值进来block结构体，用一个指针去引用，而如果引用了一个全局的变量，那么就不存在释放不掉的问题了，那么就不用再复制一份了。\n\n>一个block值创建的时候是在全局区的\n- 如果这个时候给我引用了一个全局的变量，那么我仍然在全局\n- 如果这个时候给我引用一个局部变量，那么这个block就会被移动到栈上，这里要注意的是成员变量与局部变量同等对待，因为它毕竟不在全局变量区，但是捕获成员变量的时候，因为这个变量是不会被轻易释放的，所以不会copy这个指针\n- 这个时候如果你在ARC情况下对这个block做一个赋值操作，如果之前这个block在栈上，那么一个strong引用操作之后这个block就被移动到堆上了\n\n\n//todo\nautorelease关键字起作用在arc下，需要这个对象是一个autorelease对象，默认情况下，UIView不是这样的对象，其他的是这样的对象，所以\n```\n@autorelease {\n  UIView *view = [UIView alloc] init];//内存会一直增加，不会释放的，以为UIView不会被释放，如果这个换成UIImage或者其他的，那就没有问题\n}\n```\n\n","slug":"2015/Block使用总结","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pme0027sauarqlwgubi","content":"<p>block用来保存一段代码，在需要的时候回调，是对闭包的实现<br><a id=\"more\"></a></p>\n<p>所以，切勿将过程代码当做block的实际实现，切记切记！！！</p>\n<h2 id=\"block的声明\"><a href=\"#block的声明\" class=\"headerlink\" title=\"block的声明\"></a>block的声明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//变量</div><div class=\"line\">void (^myBlock)();</div><div class=\"line\">int (^myBlock1)(int, int);</div><div class=\"line\"></div><div class=\"line\">//属性1</div><div class=\"line\">typydef void(^Myblock)();//这样Myblock就代表一个block类型了</div><div class=\"line\">@property (nonatomic, copy) Myblock myblock; </div><div class=\"line\"></div><div class=\"line\">//属性2</div><div class=\"line\">@property (nonatomic, copy) void(^myBlock)(int);//这样仍然是一个block，而且名字就是myBlock</div><div class=\"line\"></div><div class=\"line\">//参数</div><div class=\"line\">- (void) modifyUserInfoWithNickName:(NSString *) nickName</div><div class=\"line\">                           userLogo:(NSString *) userLogo</div><div class=\"line\">                                sex:(NSNumber *) sex</div><div class=\"line\">                           location:(NSString *) location</div><div class=\"line\">                            succeed:(void(^)())successBlock</div><div class=\"line\">                               fail:(void(^)(NSError *error))errorBlock;</div><div class=\"line\">                               //这个时候的格式就变成了(返回+(^)(参数))名字</div><div class=\"line\">                               </div><div class=\"line\">也可以这样</div><div class=\"line\"></div><div class=\"line\">typedef void(^FXSuccessBlock)(id result);</div><div class=\"line\">typedef void(^FXFailBlock)(NSError *error);</div><div class=\"line\"></div><div class=\"line\">- (void)onlyGetLoginUserInfo:(FXSuccessBlock)successHandler</div><div class=\"line\">                 failHandler:(FXFailBlock)failHandler;</div></pre></td></tr></table></figure>\n<p>block声明的格式：<code>返回值 + block名字 + 参数</code></p>\n<h2 id=\"block实现\"><a href=\"#block实现\" class=\"headerlink\" title=\"block实现\"></a>block实现</h2><p>block实现的格式：<code>^(参数){}</code></p>\n<p>注意block实现是要加上变量名字的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.loginBlock = ^(BOOL complete) &#123;</div><div class=\"line\">  NSLog(@&quot;登录成功&quot;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>或者有种偷巧的写法，就是利用set方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self setLoginSucBlock:^(BOOL complete) &#123;</div><div class=\"line\">     NSLog(@&quot;登录成功&quot;);  </div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"Block对外部变量的管理\"><a href=\"#Block对外部变量的管理\" class=\"headerlink\" title=\"Block对外部变量的管理\"></a>Block对外部变量的管理</h2><h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><h4 id=\"1、局部变量\"><a href=\"#1、局部变量\" class=\"headerlink\" title=\"1、局部变量\"></a>1、局部变量</h4><p>局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int base = 100;</div><div class=\"line\">long (^sum)(int, int) = ^ long (int a, int b) &#123;</div><div class=\"line\">     return base + a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\">base = 0;</div><div class=\"line\">PRintf(&quot;%ld\\n&quot;,sum(1,2));</div><div class=\"line\">// 这里输出是103，而不是3, 因为块内base为拷贝的常量 100</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>//进入block的是值，而不是地址，因为这个变量是定义在栈内存中的，随时可能被释放，所以我要将它的值copy进来，防止我使用的时候取不到</p>\n<h4 id=\"2、STATIC修饰符的全局变量\"><a href=\"#2、STATIC修饰符的全局变量\" class=\"headerlink\" title=\"2、STATIC修饰符的全局变量\"></a>2、STATIC修饰符的全局变量</h4><p>因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。</p>\n<p>加入一个变量定义在函数之外，那么这个变量是全局变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int a = 10;</div><div class=\"line\">    </div><div class=\"line\">int(^sum)(int) =^(int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">a = 0;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;----%d&quot;, sum(2));//2</div></pre></td></tr></table></figure>\n<p>//进入block的是地址而不是值，因为static修饰的变量在内存中存在于静态变量区，是不会被回收或者释放的，即使释放了，也会在爱disk中有备份，当我们使用的时候再创建然后赋值给我就好了，所以不用担心被销毁，所以用地址就好了</p>\n<h4 id=\"3-block修饰的变量\"><a href=\"#3-block修饰的变量\" class=\"headerlink\" title=\"3.__block修饰的变量\"></a>3.__block修饰的变量</h4><p>被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __block int a = 10;</div><div class=\"line\">    </div><div class=\"line\">int(^sum)(int) =^(int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">a = 0;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;----%d&quot;, sum(2));//2</div><div class=\"line\">//进入block的是地址而不是值，这个道理与static是一致的</div></pre></td></tr></table></figure>\n<p>注意：如果我们用NSString来验证对象的block的内存管理是没有意义的，因为，某几种情况下NSString对象是存放在常量区的，相当于int这种变量</p>\n<p><code>补充：</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *name = @&quot;han&quot;;</div><div class=\"line\">NSLog(&quot;%p&quot;, name);//打印的是@&quot;han&quot;的地址</div><div class=\"line\">NSLog(&quot;%p&quot;, &amp;name);//打印的是name这个指针的地址</div></pre></td></tr></table></figure></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象一定是存在于堆上的，所以决定要不要拷贝指针的关键在于引用的指针<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\">UIView *view;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    view = [[UIView alloc] init];</div><div class=\"line\"></div><div class=\"line\">    void(^stackBlock)() = ^() &#123;</div><div class=\"line\">        NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;****%p&quot;, &amp;view);</div><div class=\"line\">    </div><div class=\"line\">    stackBlock();</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//2016-07-11 20:47:36.908 block[1906:517460] ****0x1000d1208</div><div class=\"line\">//2016-07-11 20:47:36.909 block[1906:517460] &amp;&amp;&amp;&amp;&amp;0x1000d1208</div></pre></td></tr></table></figure></p>\n<p>现在是一个全局变量来引用UIView，我们发现指针直接就是原来的地址，并没有发生变化，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">void(^globalBlock)();</div><div class=\"line\">int a;</div><div class=\"line\">//UIView *view;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">     UIView *view = [[UIView alloc] init];</div><div class=\"line\"></div><div class=\"line\">    void(^stackBlock)() = ^() &#123;</div><div class=\"line\">        NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;****%p&quot;, &amp;view);</div><div class=\"line\">    </div><div class=\"line\">    stackBlock();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//2016-07-11 21:00:51.055 block[1916:519453] ****0x16fd69f28</div><div class=\"line\">//2016-07-11 21:00:51.056 block[1916:519453] &amp;&amp;&amp;&amp;&amp;0x13563a480</div></pre></td></tr></table></figure>\n<p>很明显是两个指针</p>\n<p>那如果是一个成员变量会是什么效果呢？经过验证也是同一个指针。<br>一个指针和两个指针有啥区别呢？答案就是，如果是两个指针的话，那么即使你外边的指针释放掉，这个对象也是释放不掉的，如果这个block不释放的话，所以如果这个block是一个全局的block这个对象也就没有释放的可能了。<br>解决的方案就是，传入一个弱引用的指针，这样起码这个被引用的对象是不会因为block而不能释放了。<br>从这个角度来理解，为什么会存在堆，栈，全局block，因为如果我引用了某个变量，而这个变量是在栈上的，那么不能因为被block引用而不释放这个变量，所以解决方案就是直接copy一份这个变量的值进来block结构体，用一个指针去引用，而如果引用了一个全局的变量，那么就不存在释放不掉的问题了，那么就不用再复制一份了。</p>\n<blockquote>\n<p>一个block值创建的时候是在全局区的</p>\n<ul>\n<li>如果这个时候给我引用了一个全局的变量，那么我仍然在全局</li>\n<li>如果这个时候给我引用一个局部变量，那么这个block就会被移动到栈上，这里要注意的是成员变量与局部变量同等对待，因为它毕竟不在全局变量区，但是捕获成员变量的时候，因为这个变量是不会被轻易释放的，所以不会copy这个指针</li>\n<li>这个时候如果你在ARC情况下对这个block做一个赋值操作，如果之前这个block在栈上，那么一个strong引用操作之后这个block就被移动到堆上了</li>\n</ul>\n</blockquote>\n<p>//todo<br>autorelease关键字起作用在arc下，需要这个对象是一个autorelease对象，默认情况下，UIView不是这样的对象，其他的是这样的对象，所以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@autorelease &#123;</div><div class=\"line\">  UIView *view = [UIView alloc] init];//内存会一直增加，不会释放的，以为UIView不会被释放，如果这个换成UIImage或者其他的，那就没有问题</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>block用来保存一段代码，在需要的时候回调，是对闭包的实现<br>","more":"</p>\n<p>所以，切勿将过程代码当做block的实际实现，切记切记！！！</p>\n<h2 id=\"block的声明\"><a href=\"#block的声明\" class=\"headerlink\" title=\"block的声明\"></a>block的声明</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//变量</div><div class=\"line\">void (^myBlock)();</div><div class=\"line\">int (^myBlock1)(int, int);</div><div class=\"line\"></div><div class=\"line\">//属性1</div><div class=\"line\">typydef void(^Myblock)();//这样Myblock就代表一个block类型了</div><div class=\"line\">@property (nonatomic, copy) Myblock myblock; </div><div class=\"line\"></div><div class=\"line\">//属性2</div><div class=\"line\">@property (nonatomic, copy) void(^myBlock)(int);//这样仍然是一个block，而且名字就是myBlock</div><div class=\"line\"></div><div class=\"line\">//参数</div><div class=\"line\">- (void) modifyUserInfoWithNickName:(NSString *) nickName</div><div class=\"line\">                           userLogo:(NSString *) userLogo</div><div class=\"line\">                                sex:(NSNumber *) sex</div><div class=\"line\">                           location:(NSString *) location</div><div class=\"line\">                            succeed:(void(^)())successBlock</div><div class=\"line\">                               fail:(void(^)(NSError *error))errorBlock;</div><div class=\"line\">                               //这个时候的格式就变成了(返回+(^)(参数))名字</div><div class=\"line\">                               </div><div class=\"line\">也可以这样</div><div class=\"line\"></div><div class=\"line\">typedef void(^FXSuccessBlock)(id result);</div><div class=\"line\">typedef void(^FXFailBlock)(NSError *error);</div><div class=\"line\"></div><div class=\"line\">- (void)onlyGetLoginUserInfo:(FXSuccessBlock)successHandler</div><div class=\"line\">                 failHandler:(FXFailBlock)failHandler;</div></pre></td></tr></table></figure>\n<p>block声明的格式：<code>返回值 + block名字 + 参数</code></p>\n<h2 id=\"block实现\"><a href=\"#block实现\" class=\"headerlink\" title=\"block实现\"></a>block实现</h2><p>block实现的格式：<code>^(参数){}</code></p>\n<p>注意block实现是要加上变量名字的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.loginBlock = ^(BOOL complete) &#123;</div><div class=\"line\">  NSLog(@&quot;登录成功&quot;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>或者有种偷巧的写法，就是利用set方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[self setLoginSucBlock:^(BOOL complete) &#123;</div><div class=\"line\">     NSLog(@&quot;登录成功&quot;);  </div><div class=\"line\"> &#125;];</div></pre></td></tr></table></figure></p>\n<h2 id=\"Block对外部变量的管理\"><a href=\"#Block对外部变量的管理\" class=\"headerlink\" title=\"Block对外部变量的管理\"></a>Block对外部变量的管理</h2><h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><h4 id=\"1、局部变量\"><a href=\"#1、局部变量\" class=\"headerlink\" title=\"1、局部变量\"></a>1、局部变量</h4><p>局部自动变量，在Block中只读。Block定义时copy变量的值，在Block中作为常量使用，所以即使变量的值在Block外改变，也不影响他在Block中的值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">int base = 100;</div><div class=\"line\">long (^sum)(int, int) = ^ long (int a, int b) &#123;</div><div class=\"line\">     return base + a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\">base = 0;</div><div class=\"line\">PRintf(&quot;%ld\\n&quot;,sum(1,2));</div><div class=\"line\">// 这里输出是103，而不是3, 因为块内base为拷贝的常量 100</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>//进入block的是值，而不是地址，因为这个变量是定义在栈内存中的，随时可能被释放，所以我要将它的值copy进来，防止我使用的时候取不到</p>\n<h4 id=\"2、STATIC修饰符的全局变量\"><a href=\"#2、STATIC修饰符的全局变量\" class=\"headerlink\" title=\"2、STATIC修饰符的全局变量\"></a>2、STATIC修饰符的全局变量</h4><p>因为全局变量或静态变量在内存中的地址是固定的，Block在读取该变量值的时候是直接从其所在内存读出，获取到的是最新值，而不是在定义时copy的常量。</p>\n<p>加入一个变量定义在函数之外，那么这个变量是全局变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int a = 10;</div><div class=\"line\">    </div><div class=\"line\">int(^sum)(int) =^(int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">a = 0;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;----%d&quot;, sum(2));//2</div></pre></td></tr></table></figure>\n<p>//进入block的是地址而不是值，因为static修饰的变量在内存中存在于静态变量区，是不会被回收或者释放的，即使释放了，也会在爱disk中有备份，当我们使用的时候再创建然后赋值给我就好了，所以不用担心被销毁，所以用地址就好了</p>\n<h4 id=\"3-block修饰的变量\"><a href=\"#3-block修饰的变量\" class=\"headerlink\" title=\"3.__block修饰的变量\"></a>3.__block修饰的变量</h4><p>被__block修饰的变量称作Block变量。 基本类型的Block变量等效于全局变量、或静态变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> __block int a = 10;</div><div class=\"line\">    </div><div class=\"line\">int(^sum)(int) =^(int b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">a = 0;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;----%d&quot;, sum(2));//2</div><div class=\"line\">//进入block的是地址而不是值，这个道理与static是一致的</div></pre></td></tr></table></figure>\n<p>注意：如果我们用NSString来验证对象的block的内存管理是没有意义的，因为，某几种情况下NSString对象是存放在常量区的，相当于int这种变量</p>\n<p><code>补充：</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *name = @&quot;han&quot;;</div><div class=\"line\">NSLog(&quot;%p&quot;, name);//打印的是@&quot;han&quot;的地址</div><div class=\"line\">NSLog(&quot;%p&quot;, &amp;name);//打印的是name这个指针的地址</div></pre></td></tr></table></figure></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>对象一定是存在于堆上的，所以决定要不要拷贝指针的关键在于引用的指针<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\">UIView *view;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    view = [[UIView alloc] init];</div><div class=\"line\"></div><div class=\"line\">    void(^stackBlock)() = ^() &#123;</div><div class=\"line\">        NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;****%p&quot;, &amp;view);</div><div class=\"line\">    </div><div class=\"line\">    stackBlock();</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">//2016-07-11 20:47:36.908 block[1906:517460] ****0x1000d1208</div><div class=\"line\">//2016-07-11 20:47:36.909 block[1906:517460] &amp;&amp;&amp;&amp;&amp;0x1000d1208</div></pre></td></tr></table></figure></p>\n<p>现在是一个全局变量来引用UIView，我们发现指针直接就是原来的地址，并没有发生变化，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">void(^globalBlock)();</div><div class=\"line\">int a;</div><div class=\"line\">//UIView *view;</div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">     UIView *view = [[UIView alloc] init];</div><div class=\"line\"></div><div class=\"line\">    void(^stackBlock)() = ^() &#123;</div><div class=\"line\">        NSLog(@&quot;&amp;&amp;&amp;&amp;&amp;%p&quot;, &amp;view);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;****%p&quot;, &amp;view);</div><div class=\"line\">    </div><div class=\"line\">    stackBlock();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//2016-07-11 21:00:51.055 block[1916:519453] ****0x16fd69f28</div><div class=\"line\">//2016-07-11 21:00:51.056 block[1916:519453] &amp;&amp;&amp;&amp;&amp;0x13563a480</div></pre></td></tr></table></figure>\n<p>很明显是两个指针</p>\n<p>那如果是一个成员变量会是什么效果呢？经过验证也是同一个指针。<br>一个指针和两个指针有啥区别呢？答案就是，如果是两个指针的话，那么即使你外边的指针释放掉，这个对象也是释放不掉的，如果这个block不释放的话，所以如果这个block是一个全局的block这个对象也就没有释放的可能了。<br>解决的方案就是，传入一个弱引用的指针，这样起码这个被引用的对象是不会因为block而不能释放了。<br>从这个角度来理解，为什么会存在堆，栈，全局block，因为如果我引用了某个变量，而这个变量是在栈上的，那么不能因为被block引用而不释放这个变量，所以解决方案就是直接copy一份这个变量的值进来block结构体，用一个指针去引用，而如果引用了一个全局的变量，那么就不存在释放不掉的问题了，那么就不用再复制一份了。</p>\n<blockquote>\n<p>一个block值创建的时候是在全局区的</p>\n<ul>\n<li>如果这个时候给我引用了一个全局的变量，那么我仍然在全局</li>\n<li>如果这个时候给我引用一个局部变量，那么这个block就会被移动到栈上，这里要注意的是成员变量与局部变量同等对待，因为它毕竟不在全局变量区，但是捕获成员变量的时候，因为这个变量是不会被轻易释放的，所以不会copy这个指针</li>\n<li>这个时候如果你在ARC情况下对这个block做一个赋值操作，如果之前这个block在栈上，那么一个strong引用操作之后这个block就被移动到堆上了</li>\n</ul>\n</blockquote>\n<p>//todo<br>autorelease关键字起作用在arc下，需要这个对象是一个autorelease对象，默认情况下，UIView不是这样的对象，其他的是这样的对象，所以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@autorelease &#123;</div><div class=\"line\">  UIView *view = [UIView alloc] init];//内存会一直增加，不会释放的，以为UIView不会被释放，如果这个换成UIImage或者其他的，那就没有问题</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"Git使用总结","date":"2015-04-10T14:52:41.000Z","_content":"\n\n### 1.配置：\n**1.设置你的名字与邮箱（可与 git 帐号无关）：**\n\n`git config --global user.name \"Your Name\"`\n`git config --global user.email your@email.com`\n\n缓存一段时间的 git 帐号密码（timeout 单位：秒）：\n\n`git config --global credential.helper \"cache --timeout=3600\"`\n\n**2.克隆、签出仓库：**\n`git clone <url>`\n\n服务器一般会给出两种连接方式\n- 一种是SSH:需要SSH加密\n- 一种是HTTP:直接可以用\n\n<!--more-->\n以上边的地址为例：\n`git clone http://10.16.1.16/iOS/gitintro.git`\n这样它默认会将文件以gitintro为名，建立在当前文件路径下\n自定义：\n`git clone http://10.16.1.16/iOS/gitintro.git mygit`\n这样写它会将文件夹的名字从gitintro改为mygit\n\n**另外：**如果该项目使用了，`git submodule`子模块 技术，那么还需要增加另外两步操作：\n- `git submodule init`\n- `git submodule update`\n\n或者一步到位\n`git clone --recursive http://10.16.1.16/iOS/gitintro.git mygit`\n\n3.自建仓库\n只要是一个文件夹，然后进行git初始化就可以\n利用命令行将当前目录切换到你要做仓库的那个文件夹，\n`cd xxx`\n然后初始化仓库\n`git init`\n\n**3.查看远程服务器：**\n`git remote -v`\n\n进阶：\n关联远程服务器：\n`git reomte add <origin> <git-repo-url>`\n\n查看配置信息，包括 remote、分支关联、本地配置等：\n`cat .git/config`\n\n\n### 2. 添加、删除、本地提交\n添加新文件，确认文件修改：\n`git add <file-path>`\n\n取消添加新文件：\n`git reset <file-path>`\n\n从 git 删除文件（不再在 repo 里管理了）：\n`git rm <file-path>`\n\n查看本地未确认的修改（代码、内容变更）：\n`git diff`\n\n查看本地已确认（但未提交）的修改：\n`git diff --cached`\n\n查看本地修改的文件状态：\n`git status`\n\n本地提交（提交上述 add\\rm 确认的修改、操作），生成一个版本：\n`git commit -m \"short commit message\"`\n\n追加到上一次本地提交：\n`git commit --amend`\n\n查看提交记录：\n`git log`\n\n简化版\n`git reflog`\n\n查看提交的详细修改记录：\n`git log -p`\n\n查看提交修改的文件信息：\n`git log --stat`\n\n其它：\n让当前修改 AFK 一下，好干点别的事情：`git stash`\n事情做完，把 AFK 前的修改找回来：`git stash pop`\n\n\n### 3. 撤消\n撤销一个文件的修改：\n`git checkout -- <file-path>`\n\n撤销当前目录的所有修改：\n`git checkout -- .`\n\n删除某个文件\n`git rm xxxx`\n### 4.版本回退\n回退到任意版本，需要拿到commit id\n`git reset --hard 3628164`\n回退到上一个版本\n `git reset --hard HEAD^`\n 回退到上100个版本\n `git reset --hard HEAD~100`\n\n**但是这样简单的操作只能是把本地的工作空间的内容进行回退，那么如果我想要让远程库也回退怎么办呢？**\n\n回想一下原理，当你对这个分支进行pull的时候\n- 它会去版本库去检查有没有冲突\n- 如果没有那么它直接会覆盖工作空间\n- 如果有冲突它才会提示你解决冲突\n\n那么现在，如果我已经到了第五个 commit，但是我想要回到第3个commit的状态，\n`git reset --hard 87b6a3b`\n你想要把这个状态更新到远程，先要commit，你会发现你commit是无效的，因为你这个commit已经存在了，一摸一样，所以你是不能commit的，现在要自己制造一些修改，然后再commit，就可以了。\n\n**所以远程版本回退的根本是制造冲突，然后提交冲突**\n\n**那么如果是这个文件已经删除了那么这个时候怎么办呢？**\n答案是：\n- 本地进行版本回退`git reset --hard 76824`\n- 打开这个又恢复的文件，然后修改一些东西\n- 执行 `add commit`\n- 然后执行pull，最新的修改从远程拉回来，这个时候它会报冲突\n\n它说，这个冲突是修改和删除的冲突，也就是说，一个版本库中它已经被删除了，可是在另外一个版本库中它是被修改的，现在你就要解决冲突，怎么解决呢？原来的冲突最多是这个文件中的代码不一致了，这个时候找你打开代码，删删剪剪就好了，可是现在文件直接没有了咋弄？\n再次git pull\n它说你可以用git add/rm xxx来决定你是保留冲突中的哪一方\n\n\n### 5. 分支\n创建分支（基于当前分支）：\n`git branch <new-branch>`\n\n基于某个分支创建分支：\n`git branch <new-branch> <base-branch>`\n\n查看本地分支：\n`git branch`\n\n切换分支：\n`git checkout <branch>`\n\n创建新分支并立即切过去：\n`git checkout -b <new-branch> [base-branch]`\n\n合并一个分支到当前分支（删除该分支后不保留commit纪录）：\n`git merge <other-branch>`\n\n合并分支且删除该分支后保留commit纪录\n`git merge --no-ff -m\"xxx\" <other-branch> `\n\n回滚一个分支的合并：\n`git revert -m (1|2) <merge-commit>`\n参考： http://pms.kugou.com/zentao/doc-view-171.html\n\nrebase 把分支的 commit 在基础分支上重放（与 merge 的区别很重要，请只在本地分支 rebase！！！）：\n`git rebase <base-branch>`\n\n安全删除（已经合并过的）本地分支：\n`git branch -d <branch>`\n\n强行删除本地分支（请先 -d，如果 -d 失败，检查无误后才 -D）：\n`git branch -D <branch>`\n\n\n### 6. 跟服务器同步：\n查看远程分支：\n`git branch -r`\n\n签出服务器分支工作（会创建本地与服务器分支关联）：\n`git checkout <remote-branch-name>`\n或\n`git checkout -b <local-branch-name> origin/<remote-branch-name>`\n\n（已存在的）本地分支关联到服务器分支：\n`git branch -u origin/<remote-branch> <local-branch>`\n或：\n`git branch --set-upstream-to=origin/<remote-branch> <local-branch>`\n\n获取服务器（所有的）更新，并合并当前远程分支的更新：\n`git pull`\n\n使用 rebase 的方式 pull，可能会少产生一条 merge 虚 commit：\n`git pull --rebase`\n\n获取某个远程分支的更新（并且合并到当前分支！！）：\n`git pull origin <branch>`\n\n仅拉取服务器更新，但不合并或 rebase：\n`git fetch [origin [<remote-branch-name>]]`\n\nrebase 当前分支已经 fetch 到本地的服务器更新：\n`git rebase`\n\n----------------\n**push**\npush新建的本地分支并且建立连接\n`git push --set-upstream origin <local-branch>`\n`git push origin <local-branch>`\n`git push -u origin <local-branch>`\n\n删除服务器远程分支：\n`git push origin :<remote-branch>`\n或 git 1.7 以后：\n`git push origin --delete <remote-branch>`\n\npush该分支的内容更新，前提是已经有默认的对应的分支，如果没有就会报错\n`git push`\n![Alt text](./1443163940619.png)\n\n但是这种方式不需要提前关联，因为你已经指明了，我打算把我这个分支推送给谁：\n`git push origin <branch>`\n\n清除已被删除远程分支的本地残余：\n`git remote prune origin`\n\n### 7.fork源码之后与源码保持同步\n\n1.切换到要保持同步的分支\n\n2.添加一个别名，指向ngqa项目的位置 \n`git remote add ngqa https://github.com/howe/ngqa.git`\n\n3.pull一下它下边的某个分支，一定要确定一下这个分支是不是有内容`git pull ngqa master`\n\n4.然后在sourcetree解决一下冲突，一般是点一下最下边的那个红色选框\n\n5.然后`git push`\n\n6.如果出现如下问题\n>  \"please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch\n\n解决方案：\n>1-press \"i\"\n2-write your merge message\n3-press \"esc\"\n4-write \":wq\" then press enter\n\n### 8.配置SSH\n- 查看git用户名\n`git config user.name`\n- 查看git邮箱\n`git config user.email`\n- 修改git用户名和邮箱\n`git config --global user.name \"username\"`\n`git config --global user.email \"email\"`\n- 查看是否已经有了ssh密钥：\n`cd ~/.ssh`\n- 生成SSH\n`ssh-keygen -t rsa -C \"你的邮箱\"`\n- 查看SSH\n`cat ~/.ssh/id_rsa.pub`\n将下面出现的这些个东西都拷贝到你的SSH面板中\n\n\n### 9.问题集锦\n- 如果你明明已经有了权限但是还是不能clone代码，那可能是服务器设置了DNS解析，你需要更改本机的DNS解析地址和服务器一致\n- 冲突解决\n\n","source":"_posts/2015/Git使用总结.md","raw":"---\ntitle: Git使用总结\ndate: 2015-04-10 22:52:41\ntags:\n- 工具\ncategories: 基础\n---\n\n\n### 1.配置：\n**1.设置你的名字与邮箱（可与 git 帐号无关）：**\n\n`git config --global user.name \"Your Name\"`\n`git config --global user.email your@email.com`\n\n缓存一段时间的 git 帐号密码（timeout 单位：秒）：\n\n`git config --global credential.helper \"cache --timeout=3600\"`\n\n**2.克隆、签出仓库：**\n`git clone <url>`\n\n服务器一般会给出两种连接方式\n- 一种是SSH:需要SSH加密\n- 一种是HTTP:直接可以用\n\n<!--more-->\n以上边的地址为例：\n`git clone http://10.16.1.16/iOS/gitintro.git`\n这样它默认会将文件以gitintro为名，建立在当前文件路径下\n自定义：\n`git clone http://10.16.1.16/iOS/gitintro.git mygit`\n这样写它会将文件夹的名字从gitintro改为mygit\n\n**另外：**如果该项目使用了，`git submodule`子模块 技术，那么还需要增加另外两步操作：\n- `git submodule init`\n- `git submodule update`\n\n或者一步到位\n`git clone --recursive http://10.16.1.16/iOS/gitintro.git mygit`\n\n3.自建仓库\n只要是一个文件夹，然后进行git初始化就可以\n利用命令行将当前目录切换到你要做仓库的那个文件夹，\n`cd xxx`\n然后初始化仓库\n`git init`\n\n**3.查看远程服务器：**\n`git remote -v`\n\n进阶：\n关联远程服务器：\n`git reomte add <origin> <git-repo-url>`\n\n查看配置信息，包括 remote、分支关联、本地配置等：\n`cat .git/config`\n\n\n### 2. 添加、删除、本地提交\n添加新文件，确认文件修改：\n`git add <file-path>`\n\n取消添加新文件：\n`git reset <file-path>`\n\n从 git 删除文件（不再在 repo 里管理了）：\n`git rm <file-path>`\n\n查看本地未确认的修改（代码、内容变更）：\n`git diff`\n\n查看本地已确认（但未提交）的修改：\n`git diff --cached`\n\n查看本地修改的文件状态：\n`git status`\n\n本地提交（提交上述 add\\rm 确认的修改、操作），生成一个版本：\n`git commit -m \"short commit message\"`\n\n追加到上一次本地提交：\n`git commit --amend`\n\n查看提交记录：\n`git log`\n\n简化版\n`git reflog`\n\n查看提交的详细修改记录：\n`git log -p`\n\n查看提交修改的文件信息：\n`git log --stat`\n\n其它：\n让当前修改 AFK 一下，好干点别的事情：`git stash`\n事情做完，把 AFK 前的修改找回来：`git stash pop`\n\n\n### 3. 撤消\n撤销一个文件的修改：\n`git checkout -- <file-path>`\n\n撤销当前目录的所有修改：\n`git checkout -- .`\n\n删除某个文件\n`git rm xxxx`\n### 4.版本回退\n回退到任意版本，需要拿到commit id\n`git reset --hard 3628164`\n回退到上一个版本\n `git reset --hard HEAD^`\n 回退到上100个版本\n `git reset --hard HEAD~100`\n\n**但是这样简单的操作只能是把本地的工作空间的内容进行回退，那么如果我想要让远程库也回退怎么办呢？**\n\n回想一下原理，当你对这个分支进行pull的时候\n- 它会去版本库去检查有没有冲突\n- 如果没有那么它直接会覆盖工作空间\n- 如果有冲突它才会提示你解决冲突\n\n那么现在，如果我已经到了第五个 commit，但是我想要回到第3个commit的状态，\n`git reset --hard 87b6a3b`\n你想要把这个状态更新到远程，先要commit，你会发现你commit是无效的，因为你这个commit已经存在了，一摸一样，所以你是不能commit的，现在要自己制造一些修改，然后再commit，就可以了。\n\n**所以远程版本回退的根本是制造冲突，然后提交冲突**\n\n**那么如果是这个文件已经删除了那么这个时候怎么办呢？**\n答案是：\n- 本地进行版本回退`git reset --hard 76824`\n- 打开这个又恢复的文件，然后修改一些东西\n- 执行 `add commit`\n- 然后执行pull，最新的修改从远程拉回来，这个时候它会报冲突\n\n它说，这个冲突是修改和删除的冲突，也就是说，一个版本库中它已经被删除了，可是在另外一个版本库中它是被修改的，现在你就要解决冲突，怎么解决呢？原来的冲突最多是这个文件中的代码不一致了，这个时候找你打开代码，删删剪剪就好了，可是现在文件直接没有了咋弄？\n再次git pull\n它说你可以用git add/rm xxx来决定你是保留冲突中的哪一方\n\n\n### 5. 分支\n创建分支（基于当前分支）：\n`git branch <new-branch>`\n\n基于某个分支创建分支：\n`git branch <new-branch> <base-branch>`\n\n查看本地分支：\n`git branch`\n\n切换分支：\n`git checkout <branch>`\n\n创建新分支并立即切过去：\n`git checkout -b <new-branch> [base-branch]`\n\n合并一个分支到当前分支（删除该分支后不保留commit纪录）：\n`git merge <other-branch>`\n\n合并分支且删除该分支后保留commit纪录\n`git merge --no-ff -m\"xxx\" <other-branch> `\n\n回滚一个分支的合并：\n`git revert -m (1|2) <merge-commit>`\n参考： http://pms.kugou.com/zentao/doc-view-171.html\n\nrebase 把分支的 commit 在基础分支上重放（与 merge 的区别很重要，请只在本地分支 rebase！！！）：\n`git rebase <base-branch>`\n\n安全删除（已经合并过的）本地分支：\n`git branch -d <branch>`\n\n强行删除本地分支（请先 -d，如果 -d 失败，检查无误后才 -D）：\n`git branch -D <branch>`\n\n\n### 6. 跟服务器同步：\n查看远程分支：\n`git branch -r`\n\n签出服务器分支工作（会创建本地与服务器分支关联）：\n`git checkout <remote-branch-name>`\n或\n`git checkout -b <local-branch-name> origin/<remote-branch-name>`\n\n（已存在的）本地分支关联到服务器分支：\n`git branch -u origin/<remote-branch> <local-branch>`\n或：\n`git branch --set-upstream-to=origin/<remote-branch> <local-branch>`\n\n获取服务器（所有的）更新，并合并当前远程分支的更新：\n`git pull`\n\n使用 rebase 的方式 pull，可能会少产生一条 merge 虚 commit：\n`git pull --rebase`\n\n获取某个远程分支的更新（并且合并到当前分支！！）：\n`git pull origin <branch>`\n\n仅拉取服务器更新，但不合并或 rebase：\n`git fetch [origin [<remote-branch-name>]]`\n\nrebase 当前分支已经 fetch 到本地的服务器更新：\n`git rebase`\n\n----------------\n**push**\npush新建的本地分支并且建立连接\n`git push --set-upstream origin <local-branch>`\n`git push origin <local-branch>`\n`git push -u origin <local-branch>`\n\n删除服务器远程分支：\n`git push origin :<remote-branch>`\n或 git 1.7 以后：\n`git push origin --delete <remote-branch>`\n\npush该分支的内容更新，前提是已经有默认的对应的分支，如果没有就会报错\n`git push`\n![Alt text](./1443163940619.png)\n\n但是这种方式不需要提前关联，因为你已经指明了，我打算把我这个分支推送给谁：\n`git push origin <branch>`\n\n清除已被删除远程分支的本地残余：\n`git remote prune origin`\n\n### 7.fork源码之后与源码保持同步\n\n1.切换到要保持同步的分支\n\n2.添加一个别名，指向ngqa项目的位置 \n`git remote add ngqa https://github.com/howe/ngqa.git`\n\n3.pull一下它下边的某个分支，一定要确定一下这个分支是不是有内容`git pull ngqa master`\n\n4.然后在sourcetree解决一下冲突，一般是点一下最下边的那个红色选框\n\n5.然后`git push`\n\n6.如果出现如下问题\n>  \"please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch\n\n解决方案：\n>1-press \"i\"\n2-write your merge message\n3-press \"esc\"\n4-write \":wq\" then press enter\n\n### 8.配置SSH\n- 查看git用户名\n`git config user.name`\n- 查看git邮箱\n`git config user.email`\n- 修改git用户名和邮箱\n`git config --global user.name \"username\"`\n`git config --global user.email \"email\"`\n- 查看是否已经有了ssh密钥：\n`cd ~/.ssh`\n- 生成SSH\n`ssh-keygen -t rsa -C \"你的邮箱\"`\n- 查看SSH\n`cat ~/.ssh/id_rsa.pub`\n将下面出现的这些个东西都拷贝到你的SSH面板中\n\n\n### 9.问题集锦\n- 如果你明明已经有了权限但是还是不能clone代码，那可能是服务器设置了DNS解析，你需要更改本机的DNS解析地址和服务器一致\n- 冲突解决\n\n","slug":"2015/Git使用总结","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmh002asaua7bh3myow","content":"<h3 id=\"1-配置：\"><a href=\"#1-配置：\" class=\"headerlink\" title=\"1.配置：\"></a>1.配置：</h3><p><strong>1.设置你的名字与邮箱（可与 git 帐号无关）：</strong></p>\n<p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email your@email.com</code></p>\n<p>缓存一段时间的 git 帐号密码（timeout 单位：秒）：</p>\n<p><code>git config --global credential.helper &quot;cache --timeout=3600&quot;</code></p>\n<p><strong>2.克隆、签出仓库：</strong><br><code>git clone &lt;url&gt;</code></p>\n<p>服务器一般会给出两种连接方式</p>\n<ul>\n<li>一种是SSH:需要SSH加密</li>\n<li>一种是HTTP:直接可以用</li>\n</ul>\n<a id=\"more\"></a>\n<p>以上边的地址为例：<br><code>git clone http://10.16.1.16/iOS/gitintro.git</code><br>这样它默认会将文件以gitintro为名，建立在当前文件路径下<br>自定义：<br><code>git clone http://10.16.1.16/iOS/gitintro.git mygit</code><br>这样写它会将文件夹的名字从gitintro改为mygit</p>\n<p><strong>另外：</strong>如果该项目使用了，<code>git submodule</code>子模块 技术，那么还需要增加另外两步操作：</p>\n<ul>\n<li><code>git submodule init</code></li>\n<li><code>git submodule update</code></li>\n</ul>\n<p>或者一步到位<br><code>git clone --recursive http://10.16.1.16/iOS/gitintro.git mygit</code></p>\n<p>3.自建仓库<br>只要是一个文件夹，然后进行git初始化就可以<br>利用命令行将当前目录切换到你要做仓库的那个文件夹，<br><code>cd xxx</code><br>然后初始化仓库<br><code>git init</code></p>\n<p><strong>3.查看远程服务器：</strong><br><code>git remote -v</code></p>\n<p>进阶：<br>关联远程服务器：<br><code>git reomte add &lt;origin&gt; &lt;git-repo-url&gt;</code></p>\n<p>查看配置信息，包括 remote、分支关联、本地配置等：<br><code>cat .git/config</code></p>\n<h3 id=\"2-添加、删除、本地提交\"><a href=\"#2-添加、删除、本地提交\" class=\"headerlink\" title=\"2. 添加、删除、本地提交\"></a>2. 添加、删除、本地提交</h3><p>添加新文件，确认文件修改：<br><code>git add &lt;file-path&gt;</code></p>\n<p>取消添加新文件：<br><code>git reset &lt;file-path&gt;</code></p>\n<p>从 git 删除文件（不再在 repo 里管理了）：<br><code>git rm &lt;file-path&gt;</code></p>\n<p>查看本地未确认的修改（代码、内容变更）：<br><code>git diff</code></p>\n<p>查看本地已确认（但未提交）的修改：<br><code>git diff --cached</code></p>\n<p>查看本地修改的文件状态：<br><code>git status</code></p>\n<p>本地提交（提交上述 add\\rm 确认的修改、操作），生成一个版本：<br><code>git commit -m &quot;short commit message&quot;</code></p>\n<p>追加到上一次本地提交：<br><code>git commit --amend</code></p>\n<p>查看提交记录：<br><code>git log</code></p>\n<p>简化版<br><code>git reflog</code></p>\n<p>查看提交的详细修改记录：<br><code>git log -p</code></p>\n<p>查看提交修改的文件信息：<br><code>git log --stat</code></p>\n<p>其它：<br>让当前修改 AFK 一下，好干点别的事情：<code>git stash</code><br>事情做完，把 AFK 前的修改找回来：<code>git stash pop</code></p>\n<h3 id=\"3-撤消\"><a href=\"#3-撤消\" class=\"headerlink\" title=\"3. 撤消\"></a>3. 撤消</h3><p>撤销一个文件的修改：<br><code>git checkout -- &lt;file-path&gt;</code></p>\n<p>撤销当前目录的所有修改：<br><code>git checkout -- .</code></p>\n<p>删除某个文件<br><code>git rm xxxx</code></p>\n<h3 id=\"4-版本回退\"><a href=\"#4-版本回退\" class=\"headerlink\" title=\"4.版本回退\"></a>4.版本回退</h3><p>回退到任意版本，需要拿到commit id<br><code>git reset --hard 3628164</code><br>回退到上一个版本<br> <code>git reset --hard HEAD^</code><br> 回退到上100个版本<br> <code>git reset --hard HEAD~100</code></p>\n<p><strong>但是这样简单的操作只能是把本地的工作空间的内容进行回退，那么如果我想要让远程库也回退怎么办呢？</strong></p>\n<p>回想一下原理，当你对这个分支进行pull的时候</p>\n<ul>\n<li>它会去版本库去检查有没有冲突</li>\n<li>如果没有那么它直接会覆盖工作空间</li>\n<li>如果有冲突它才会提示你解决冲突</li>\n</ul>\n<p>那么现在，如果我已经到了第五个 commit，但是我想要回到第3个commit的状态，<br><code>git reset --hard 87b6a3b</code><br>你想要把这个状态更新到远程，先要commit，你会发现你commit是无效的，因为你这个commit已经存在了，一摸一样，所以你是不能commit的，现在要自己制造一些修改，然后再commit，就可以了。</p>\n<p><strong>所以远程版本回退的根本是制造冲突，然后提交冲突</strong></p>\n<p><strong>那么如果是这个文件已经删除了那么这个时候怎么办呢？</strong><br>答案是：</p>\n<ul>\n<li>本地进行版本回退<code>git reset --hard 76824</code></li>\n<li>打开这个又恢复的文件，然后修改一些东西</li>\n<li>执行 <code>add commit</code></li>\n<li>然后执行pull，最新的修改从远程拉回来，这个时候它会报冲突</li>\n</ul>\n<p>它说，这个冲突是修改和删除的冲突，也就是说，一个版本库中它已经被删除了，可是在另外一个版本库中它是被修改的，现在你就要解决冲突，怎么解决呢？原来的冲突最多是这个文件中的代码不一致了，这个时候找你打开代码，删删剪剪就好了，可是现在文件直接没有了咋弄？<br>再次git pull<br>它说你可以用git add/rm xxx来决定你是保留冲突中的哪一方</p>\n<h3 id=\"5-分支\"><a href=\"#5-分支\" class=\"headerlink\" title=\"5. 分支\"></a>5. 分支</h3><p>创建分支（基于当前分支）：<br><code>git branch &lt;new-branch&gt;</code></p>\n<p>基于某个分支创建分支：<br><code>git branch &lt;new-branch&gt; &lt;base-branch&gt;</code></p>\n<p>查看本地分支：<br><code>git branch</code></p>\n<p>切换分支：<br><code>git checkout &lt;branch&gt;</code></p>\n<p>创建新分支并立即切过去：<br><code>git checkout -b &lt;new-branch&gt; [base-branch]</code></p>\n<p>合并一个分支到当前分支（删除该分支后不保留commit纪录）：<br><code>git merge &lt;other-branch&gt;</code></p>\n<p>合并分支且删除该分支后保留commit纪录<br><code>git merge --no-ff -m&quot;xxx&quot; &lt;other-branch&gt;</code></p>\n<p>回滚一个分支的合并：<br><code>git revert -m (1|2) &lt;merge-commit&gt;</code><br>参考： <a href=\"http://pms.kugou.com/zentao/doc-view-171.html\" target=\"_blank\" rel=\"external\">http://pms.kugou.com/zentao/doc-view-171.html</a></p>\n<p>rebase 把分支的 commit 在基础分支上重放（与 merge 的区别很重要，请只在本地分支 rebase！！！）：<br><code>git rebase &lt;base-branch&gt;</code></p>\n<p>安全删除（已经合并过的）本地分支：<br><code>git branch -d &lt;branch&gt;</code></p>\n<p>强行删除本地分支（请先 -d，如果 -d 失败，检查无误后才 -D）：<br><code>git branch -D &lt;branch&gt;</code></p>\n<h3 id=\"6-跟服务器同步：\"><a href=\"#6-跟服务器同步：\" class=\"headerlink\" title=\"6. 跟服务器同步：\"></a>6. 跟服务器同步：</h3><p>查看远程分支：<br><code>git branch -r</code></p>\n<p>签出服务器分支工作（会创建本地与服务器分支关联）：<br><code>git checkout &lt;remote-branch-name&gt;</code><br>或<br><code>git checkout -b &lt;local-branch-name&gt; origin/&lt;remote-branch-name&gt;</code></p>\n<p>（已存在的）本地分支关联到服务器分支：<br><code>git branch -u origin/&lt;remote-branch&gt; &lt;local-branch&gt;</code><br>或：<br><code>git branch --set-upstream-to=origin/&lt;remote-branch&gt; &lt;local-branch&gt;</code></p>\n<p>获取服务器（所有的）更新，并合并当前远程分支的更新：<br><code>git pull</code></p>\n<p>使用 rebase 的方式 pull，可能会少产生一条 merge 虚 commit：<br><code>git pull --rebase</code></p>\n<p>获取某个远程分支的更新（并且合并到当前分支！！）：<br><code>git pull origin &lt;branch&gt;</code></p>\n<p>仅拉取服务器更新，但不合并或 rebase：<br><code>git fetch [origin [&lt;remote-branch-name&gt;]]</code></p>\n<p>rebase 当前分支已经 fetch 到本地的服务器更新：<br><code>git rebase</code></p>\n<hr>\n<p><strong>push</strong><br>push新建的本地分支并且建立连接<br><code>git push --set-upstream origin &lt;local-branch&gt;</code><br><code>git push origin &lt;local-branch&gt;</code><br><code>git push -u origin &lt;local-branch&gt;</code></p>\n<p>删除服务器远程分支：<br><code>git push origin :&lt;remote-branch&gt;</code><br>或 git 1.7 以后：<br><code>git push origin --delete &lt;remote-branch&gt;</code></p>\n<p>push该分支的内容更新，前提是已经有默认的对应的分支，如果没有就会报错<br><code>git push</code><br><img src=\"./1443163940619.png\" alt=\"Alt text\"></p>\n<p>但是这种方式不需要提前关联，因为你已经指明了，我打算把我这个分支推送给谁：<br><code>git push origin &lt;branch&gt;</code></p>\n<p>清除已被删除远程分支的本地残余：<br><code>git remote prune origin</code></p>\n<h3 id=\"7-fork源码之后与源码保持同步\"><a href=\"#7-fork源码之后与源码保持同步\" class=\"headerlink\" title=\"7.fork源码之后与源码保持同步\"></a>7.fork源码之后与源码保持同步</h3><p>1.切换到要保持同步的分支</p>\n<p>2.添加一个别名，指向ngqa项目的位置<br><code>git remote add ngqa https://github.com/howe/ngqa.git</code></p>\n<p>3.pull一下它下边的某个分支，一定要确定一下这个分支是不是有内容<code>git pull ngqa master</code></p>\n<p>4.然后在sourcetree解决一下冲突，一般是点一下最下边的那个红色选框</p>\n<p>5.然后<code>git push</code></p>\n<p>6.如果出现如下问题</p>\n<blockquote>\n<p> “please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch</p>\n</blockquote>\n<p>解决方案：</p>\n<blockquote>\n<p>1-press “i”<br>2-write your merge message<br>3-press “esc”<br>4-write “:wq” then press enter</p>\n</blockquote>\n<h3 id=\"8-配置SSH\"><a href=\"#8-配置SSH\" class=\"headerlink\" title=\"8.配置SSH\"></a>8.配置SSH</h3><ul>\n<li>查看git用户名<br><code>git config user.name</code></li>\n<li>查看git邮箱<br><code>git config user.email</code></li>\n<li>修改git用户名和邮箱<br><code>git config --global user.name &quot;username&quot;</code><br><code>git config --global user.email &quot;email&quot;</code></li>\n<li>查看是否已经有了ssh密钥：<br><code>cd ~/.ssh</code></li>\n<li>生成SSH<br><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code></li>\n<li>查看SSH<br><code>cat ~/.ssh/id_rsa.pub</code><br>将下面出现的这些个东西都拷贝到你的SSH面板中</li>\n</ul>\n<h3 id=\"9-问题集锦\"><a href=\"#9-问题集锦\" class=\"headerlink\" title=\"9.问题集锦\"></a>9.问题集锦</h3><ul>\n<li>如果你明明已经有了权限但是还是不能clone代码，那可能是服务器设置了DNS解析，你需要更改本机的DNS解析地址和服务器一致</li>\n<li>冲突解决</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-配置：\"><a href=\"#1-配置：\" class=\"headerlink\" title=\"1.配置：\"></a>1.配置：</h3><p><strong>1.设置你的名字与邮箱（可与 git 帐号无关）：</strong></p>\n<p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email your@email.com</code></p>\n<p>缓存一段时间的 git 帐号密码（timeout 单位：秒）：</p>\n<p><code>git config --global credential.helper &quot;cache --timeout=3600&quot;</code></p>\n<p><strong>2.克隆、签出仓库：</strong><br><code>git clone &lt;url&gt;</code></p>\n<p>服务器一般会给出两种连接方式</p>\n<ul>\n<li>一种是SSH:需要SSH加密</li>\n<li>一种是HTTP:直接可以用</li>\n</ul>","more":"<p>以上边的地址为例：<br><code>git clone http://10.16.1.16/iOS/gitintro.git</code><br>这样它默认会将文件以gitintro为名，建立在当前文件路径下<br>自定义：<br><code>git clone http://10.16.1.16/iOS/gitintro.git mygit</code><br>这样写它会将文件夹的名字从gitintro改为mygit</p>\n<p><strong>另外：</strong>如果该项目使用了，<code>git submodule</code>子模块 技术，那么还需要增加另外两步操作：</p>\n<ul>\n<li><code>git submodule init</code></li>\n<li><code>git submodule update</code></li>\n</ul>\n<p>或者一步到位<br><code>git clone --recursive http://10.16.1.16/iOS/gitintro.git mygit</code></p>\n<p>3.自建仓库<br>只要是一个文件夹，然后进行git初始化就可以<br>利用命令行将当前目录切换到你要做仓库的那个文件夹，<br><code>cd xxx</code><br>然后初始化仓库<br><code>git init</code></p>\n<p><strong>3.查看远程服务器：</strong><br><code>git remote -v</code></p>\n<p>进阶：<br>关联远程服务器：<br><code>git reomte add &lt;origin&gt; &lt;git-repo-url&gt;</code></p>\n<p>查看配置信息，包括 remote、分支关联、本地配置等：<br><code>cat .git/config</code></p>\n<h3 id=\"2-添加、删除、本地提交\"><a href=\"#2-添加、删除、本地提交\" class=\"headerlink\" title=\"2. 添加、删除、本地提交\"></a>2. 添加、删除、本地提交</h3><p>添加新文件，确认文件修改：<br><code>git add &lt;file-path&gt;</code></p>\n<p>取消添加新文件：<br><code>git reset &lt;file-path&gt;</code></p>\n<p>从 git 删除文件（不再在 repo 里管理了）：<br><code>git rm &lt;file-path&gt;</code></p>\n<p>查看本地未确认的修改（代码、内容变更）：<br><code>git diff</code></p>\n<p>查看本地已确认（但未提交）的修改：<br><code>git diff --cached</code></p>\n<p>查看本地修改的文件状态：<br><code>git status</code></p>\n<p>本地提交（提交上述 add\\rm 确认的修改、操作），生成一个版本：<br><code>git commit -m &quot;short commit message&quot;</code></p>\n<p>追加到上一次本地提交：<br><code>git commit --amend</code></p>\n<p>查看提交记录：<br><code>git log</code></p>\n<p>简化版<br><code>git reflog</code></p>\n<p>查看提交的详细修改记录：<br><code>git log -p</code></p>\n<p>查看提交修改的文件信息：<br><code>git log --stat</code></p>\n<p>其它：<br>让当前修改 AFK 一下，好干点别的事情：<code>git stash</code><br>事情做完，把 AFK 前的修改找回来：<code>git stash pop</code></p>\n<h3 id=\"3-撤消\"><a href=\"#3-撤消\" class=\"headerlink\" title=\"3. 撤消\"></a>3. 撤消</h3><p>撤销一个文件的修改：<br><code>git checkout -- &lt;file-path&gt;</code></p>\n<p>撤销当前目录的所有修改：<br><code>git checkout -- .</code></p>\n<p>删除某个文件<br><code>git rm xxxx</code></p>\n<h3 id=\"4-版本回退\"><a href=\"#4-版本回退\" class=\"headerlink\" title=\"4.版本回退\"></a>4.版本回退</h3><p>回退到任意版本，需要拿到commit id<br><code>git reset --hard 3628164</code><br>回退到上一个版本<br> <code>git reset --hard HEAD^</code><br> 回退到上100个版本<br> <code>git reset --hard HEAD~100</code></p>\n<p><strong>但是这样简单的操作只能是把本地的工作空间的内容进行回退，那么如果我想要让远程库也回退怎么办呢？</strong></p>\n<p>回想一下原理，当你对这个分支进行pull的时候</p>\n<ul>\n<li>它会去版本库去检查有没有冲突</li>\n<li>如果没有那么它直接会覆盖工作空间</li>\n<li>如果有冲突它才会提示你解决冲突</li>\n</ul>\n<p>那么现在，如果我已经到了第五个 commit，但是我想要回到第3个commit的状态，<br><code>git reset --hard 87b6a3b</code><br>你想要把这个状态更新到远程，先要commit，你会发现你commit是无效的，因为你这个commit已经存在了，一摸一样，所以你是不能commit的，现在要自己制造一些修改，然后再commit，就可以了。</p>\n<p><strong>所以远程版本回退的根本是制造冲突，然后提交冲突</strong></p>\n<p><strong>那么如果是这个文件已经删除了那么这个时候怎么办呢？</strong><br>答案是：</p>\n<ul>\n<li>本地进行版本回退<code>git reset --hard 76824</code></li>\n<li>打开这个又恢复的文件，然后修改一些东西</li>\n<li>执行 <code>add commit</code></li>\n<li>然后执行pull，最新的修改从远程拉回来，这个时候它会报冲突</li>\n</ul>\n<p>它说，这个冲突是修改和删除的冲突，也就是说，一个版本库中它已经被删除了，可是在另外一个版本库中它是被修改的，现在你就要解决冲突，怎么解决呢？原来的冲突最多是这个文件中的代码不一致了，这个时候找你打开代码，删删剪剪就好了，可是现在文件直接没有了咋弄？<br>再次git pull<br>它说你可以用git add/rm xxx来决定你是保留冲突中的哪一方</p>\n<h3 id=\"5-分支\"><a href=\"#5-分支\" class=\"headerlink\" title=\"5. 分支\"></a>5. 分支</h3><p>创建分支（基于当前分支）：<br><code>git branch &lt;new-branch&gt;</code></p>\n<p>基于某个分支创建分支：<br><code>git branch &lt;new-branch&gt; &lt;base-branch&gt;</code></p>\n<p>查看本地分支：<br><code>git branch</code></p>\n<p>切换分支：<br><code>git checkout &lt;branch&gt;</code></p>\n<p>创建新分支并立即切过去：<br><code>git checkout -b &lt;new-branch&gt; [base-branch]</code></p>\n<p>合并一个分支到当前分支（删除该分支后不保留commit纪录）：<br><code>git merge &lt;other-branch&gt;</code></p>\n<p>合并分支且删除该分支后保留commit纪录<br><code>git merge --no-ff -m&quot;xxx&quot; &lt;other-branch&gt;</code></p>\n<p>回滚一个分支的合并：<br><code>git revert -m (1|2) &lt;merge-commit&gt;</code><br>参考： <a href=\"http://pms.kugou.com/zentao/doc-view-171.html\" target=\"_blank\" rel=\"external\">http://pms.kugou.com/zentao/doc-view-171.html</a></p>\n<p>rebase 把分支的 commit 在基础分支上重放（与 merge 的区别很重要，请只在本地分支 rebase！！！）：<br><code>git rebase &lt;base-branch&gt;</code></p>\n<p>安全删除（已经合并过的）本地分支：<br><code>git branch -d &lt;branch&gt;</code></p>\n<p>强行删除本地分支（请先 -d，如果 -d 失败，检查无误后才 -D）：<br><code>git branch -D &lt;branch&gt;</code></p>\n<h3 id=\"6-跟服务器同步：\"><a href=\"#6-跟服务器同步：\" class=\"headerlink\" title=\"6. 跟服务器同步：\"></a>6. 跟服务器同步：</h3><p>查看远程分支：<br><code>git branch -r</code></p>\n<p>签出服务器分支工作（会创建本地与服务器分支关联）：<br><code>git checkout &lt;remote-branch-name&gt;</code><br>或<br><code>git checkout -b &lt;local-branch-name&gt; origin/&lt;remote-branch-name&gt;</code></p>\n<p>（已存在的）本地分支关联到服务器分支：<br><code>git branch -u origin/&lt;remote-branch&gt; &lt;local-branch&gt;</code><br>或：<br><code>git branch --set-upstream-to=origin/&lt;remote-branch&gt; &lt;local-branch&gt;</code></p>\n<p>获取服务器（所有的）更新，并合并当前远程分支的更新：<br><code>git pull</code></p>\n<p>使用 rebase 的方式 pull，可能会少产生一条 merge 虚 commit：<br><code>git pull --rebase</code></p>\n<p>获取某个远程分支的更新（并且合并到当前分支！！）：<br><code>git pull origin &lt;branch&gt;</code></p>\n<p>仅拉取服务器更新，但不合并或 rebase：<br><code>git fetch [origin [&lt;remote-branch-name&gt;]]</code></p>\n<p>rebase 当前分支已经 fetch 到本地的服务器更新：<br><code>git rebase</code></p>\n<hr>\n<p><strong>push</strong><br>push新建的本地分支并且建立连接<br><code>git push --set-upstream origin &lt;local-branch&gt;</code><br><code>git push origin &lt;local-branch&gt;</code><br><code>git push -u origin &lt;local-branch&gt;</code></p>\n<p>删除服务器远程分支：<br><code>git push origin :&lt;remote-branch&gt;</code><br>或 git 1.7 以后：<br><code>git push origin --delete &lt;remote-branch&gt;</code></p>\n<p>push该分支的内容更新，前提是已经有默认的对应的分支，如果没有就会报错<br><code>git push</code><br><img src=\"./1443163940619.png\" alt=\"Alt text\"></p>\n<p>但是这种方式不需要提前关联，因为你已经指明了，我打算把我这个分支推送给谁：<br><code>git push origin &lt;branch&gt;</code></p>\n<p>清除已被删除远程分支的本地残余：<br><code>git remote prune origin</code></p>\n<h3 id=\"7-fork源码之后与源码保持同步\"><a href=\"#7-fork源码之后与源码保持同步\" class=\"headerlink\" title=\"7.fork源码之后与源码保持同步\"></a>7.fork源码之后与源码保持同步</h3><p>1.切换到要保持同步的分支</p>\n<p>2.添加一个别名，指向ngqa项目的位置<br><code>git remote add ngqa https://github.com/howe/ngqa.git</code></p>\n<p>3.pull一下它下边的某个分支，一定要确定一下这个分支是不是有内容<code>git pull ngqa master</code></p>\n<p>4.然后在sourcetree解决一下冲突，一般是点一下最下边的那个红色选框</p>\n<p>5.然后<code>git push</code></p>\n<p>6.如果出现如下问题</p>\n<blockquote>\n<p> “please enter a commit message to explain why this merge is necessary,especially if it merges an updated upstream into a topic branch</p>\n</blockquote>\n<p>解决方案：</p>\n<blockquote>\n<p>1-press “i”<br>2-write your merge message<br>3-press “esc”<br>4-write “:wq” then press enter</p>\n</blockquote>\n<h3 id=\"8-配置SSH\"><a href=\"#8-配置SSH\" class=\"headerlink\" title=\"8.配置SSH\"></a>8.配置SSH</h3><ul>\n<li>查看git用户名<br><code>git config user.name</code></li>\n<li>查看git邮箱<br><code>git config user.email</code></li>\n<li>修改git用户名和邮箱<br><code>git config --global user.name &quot;username&quot;</code><br><code>git config --global user.email &quot;email&quot;</code></li>\n<li>查看是否已经有了ssh密钥：<br><code>cd ~/.ssh</code></li>\n<li>生成SSH<br><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code></li>\n<li>查看SSH<br><code>cat ~/.ssh/id_rsa.pub</code><br>将下面出现的这些个东西都拷贝到你的SSH面板中</li>\n</ul>\n<h3 id=\"9-问题集锦\"><a href=\"#9-问题集锦\" class=\"headerlink\" title=\"9.问题集锦\"></a>9.问题集锦</h3><ul>\n<li>如果你明明已经有了权限但是还是不能clone代码，那可能是服务器设置了DNS解析，你需要更改本机的DNS解析地址和服务器一致</li>\n<li>冲突解决</li>\n</ul>"},{"title":"Hexo 配置/使用教程","date":"2015-03-09T02:39:20.000Z","_content":"\n### hexo安装\n>前提已经安装了node.js和git\n\n- `npm install hexo --no-optional`\n- `hexo init myBlog`//创建hexo的文件夹\n- `cd myBlog`\n- `npm install`\n- `hexo server`//打开对应的链接可看到效果 \n\n <!--more--> \n### git配置\n\n- 创建git仓库`name/name.github.io`\n- 添加信息到配置文件`_config.yml`\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:xizhengmeng/xizhengmeng.github.io.git\n  branch: master\n```\n\n- 安装插件`npm install hexo-deployer-git --save`\n\n>如果要访问这个网站直接`xizhengmeng.github.io`就好了\n\n### 使用\n- 进入博客所在的文件夹，比如我说的是~/myBlog\n- `hexo clean`\n- `hexo g`//生成\n- `hexo d`//推送到github服务器\n- `hexo new \"fileName\"`创建新的文件，在_post文件中\n- `hexo new page fileName`创建一个文件夹，然后在其中创建一个index.md文件，比如标签云页面，或者分类页面\n\n\n### 绑定域名\n- 申请域名，直接搜索`hexo和github，域名和github绑定的问题`\n- 生成CNAME文件，并添加到source文件夹下，与post同级目录\n- 更改配置文件--——config.yml`url: www.hanson647.com`\n\n### 主题安装\n- 进入Hexo文件的根目录`cd Hexo`\n- 拉取主题文件，并在本地创建对应的文件`git clone https://github.com/kathyqian/crisp-ghost-theme.git themes/gost`\n- 更改配置文件的主题为该主题\n```\ntheme: yilia\n```\n- 重新部署\n\n>主题更新`git pull`\n\n>使用了yelee主题，主题使用说明`http://moxfive.coding.me/yelee/`\n\n### 搜索功能配置\n- 安装插件`npm install --save hexo-generator-search`\n- 设置主题配置文件\n```\nsearch: \n  on: true\n  onload: true\n```\n- 设置hexo配置文件\n```\nsearch:\n  path: search.xml\n  field: post\n```\n- 重新生成\n\n最后你会在publick文件中看到一个search.xml文件，最后你会在你的网站中看到你的搜索框\n\n#### 注意\n在工程的_config文件中，要将url对应的字段设置为/，否则你会发现搜索会自动加上一个前置的url，这样就又错乱了\n\n### 添加标签以及标签云页面\n- 创建tags页面`hexo new page tags`\n- 直接在文章中的tags关键字后边添加对应的标签就好\n```\ntags:\n- 工具\n```\n- 编辑刚才创建的tags页面，将其类型更改为tags\n```\ntitle: tags\ndate: \ntype: \"tags\"\n```\n- 在主题配置文件中，将tags添加到menu中\n```\nmenu:\n  home: /\n  archives: /archives\n  tags: /tags\n```\n### 创建关于页面\n`hexo new page about`\n\n\n### 容易出现的问题\n#### hexo d\n- `Error: ssh_exchange_identification: read: Connection reset by peer`\n说明是网关的问题，我是解决了一下网络解决的，一开始连接的是京东的guest网络，出现该问题，切换为access解决\n\n#### md文件格式\n标题中#号要与后边的标题留出间隙，也就是一个空格，否则hexo渲染是不认的\n\n### 参考链接\n- next主题设置<http://theme-next.iissnan.com>\n- hexo官网<https://hexo.io/zh-cn/>\n","source":"_posts/2015/Hexo-配置教程.md","raw":"---\ntitle: Hexo 配置/使用教程\ndate: 2015-03-09 10:39:20\ntags:\n- 工具\ncategories: 基础\n\n---\n\n### hexo安装\n>前提已经安装了node.js和git\n\n- `npm install hexo --no-optional`\n- `hexo init myBlog`//创建hexo的文件夹\n- `cd myBlog`\n- `npm install`\n- `hexo server`//打开对应的链接可看到效果 \n\n <!--more--> \n### git配置\n\n- 创建git仓库`name/name.github.io`\n- 添加信息到配置文件`_config.yml`\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:xizhengmeng/xizhengmeng.github.io.git\n  branch: master\n```\n\n- 安装插件`npm install hexo-deployer-git --save`\n\n>如果要访问这个网站直接`xizhengmeng.github.io`就好了\n\n### 使用\n- 进入博客所在的文件夹，比如我说的是~/myBlog\n- `hexo clean`\n- `hexo g`//生成\n- `hexo d`//推送到github服务器\n- `hexo new \"fileName\"`创建新的文件，在_post文件中\n- `hexo new page fileName`创建一个文件夹，然后在其中创建一个index.md文件，比如标签云页面，或者分类页面\n\n\n### 绑定域名\n- 申请域名，直接搜索`hexo和github，域名和github绑定的问题`\n- 生成CNAME文件，并添加到source文件夹下，与post同级目录\n- 更改配置文件--——config.yml`url: www.hanson647.com`\n\n### 主题安装\n- 进入Hexo文件的根目录`cd Hexo`\n- 拉取主题文件，并在本地创建对应的文件`git clone https://github.com/kathyqian/crisp-ghost-theme.git themes/gost`\n- 更改配置文件的主题为该主题\n```\ntheme: yilia\n```\n- 重新部署\n\n>主题更新`git pull`\n\n>使用了yelee主题，主题使用说明`http://moxfive.coding.me/yelee/`\n\n### 搜索功能配置\n- 安装插件`npm install --save hexo-generator-search`\n- 设置主题配置文件\n```\nsearch: \n  on: true\n  onload: true\n```\n- 设置hexo配置文件\n```\nsearch:\n  path: search.xml\n  field: post\n```\n- 重新生成\n\n最后你会在publick文件中看到一个search.xml文件，最后你会在你的网站中看到你的搜索框\n\n#### 注意\n在工程的_config文件中，要将url对应的字段设置为/，否则你会发现搜索会自动加上一个前置的url，这样就又错乱了\n\n### 添加标签以及标签云页面\n- 创建tags页面`hexo new page tags`\n- 直接在文章中的tags关键字后边添加对应的标签就好\n```\ntags:\n- 工具\n```\n- 编辑刚才创建的tags页面，将其类型更改为tags\n```\ntitle: tags\ndate: \ntype: \"tags\"\n```\n- 在主题配置文件中，将tags添加到menu中\n```\nmenu:\n  home: /\n  archives: /archives\n  tags: /tags\n```\n### 创建关于页面\n`hexo new page about`\n\n\n### 容易出现的问题\n#### hexo d\n- `Error: ssh_exchange_identification: read: Connection reset by peer`\n说明是网关的问题，我是解决了一下网络解决的，一开始连接的是京东的guest网络，出现该问题，切换为access解决\n\n#### md文件格式\n标题中#号要与后边的标题留出间隙，也就是一个空格，否则hexo渲染是不认的\n\n### 参考链接\n- next主题设置<http://theme-next.iissnan.com>\n- hexo官网<https://hexo.io/zh-cn/>\n","slug":"2015/Hexo-配置教程","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmi002esaua54x38q7m","content":"<h3 id=\"hexo安装\"><a href=\"#hexo安装\" class=\"headerlink\" title=\"hexo安装\"></a>hexo安装</h3><blockquote>\n<p>前提已经安装了node.js和git</p>\n</blockquote>\n<ul>\n<li><code>npm install hexo --no-optional</code></li>\n<li><code>hexo init myBlog</code>//创建hexo的文件夹</li>\n<li><code>cd myBlog</code></li>\n<li><code>npm install</code></li>\n<li><p><code>hexo server</code>//打开对应的链接可看到效果 </p>\n<a id=\"more\"></a> \n<h3 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h3></li>\n<li><p>创建git仓库<code>name/name.github.io</code></p>\n</li>\n<li>添加信息到配置文件<code>_config.yml</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:xizhengmeng/xizhengmeng.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<ul>\n<li>安装插件<code>npm install hexo-deployer-git --save</code></li>\n</ul>\n<blockquote>\n<p>如果要访问这个网站直接<code>xizhengmeng.github.io</code>就好了</p>\n</blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>进入博客所在的文件夹，比如我说的是~/myBlog</li>\n<li><code>hexo clean</code></li>\n<li><code>hexo g</code>//生成</li>\n<li><code>hexo d</code>//推送到github服务器</li>\n<li><code>hexo new &quot;fileName&quot;</code>创建新的文件，在_post文件中</li>\n<li><code>hexo new page fileName</code>创建一个文件夹，然后在其中创建一个index.md文件，比如标签云页面，或者分类页面</li>\n</ul>\n<h3 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h3><ul>\n<li>申请域名，直接搜索<code>hexo和github，域名和github绑定的问题</code></li>\n<li>生成CNAME文件，并添加到source文件夹下，与post同级目录</li>\n<li>更改配置文件–——config.yml<code>url: www.hanson647.com</code></li>\n</ul>\n<h3 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h3><ul>\n<li>进入Hexo文件的根目录<code>cd Hexo</code></li>\n<li>拉取主题文件，并在本地创建对应的文件<code>git clone https://github.com/kathyqian/crisp-ghost-theme.git themes/gost</code></li>\n<li><p>更改配置文件的主题为该主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: yilia</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新部署</p>\n</li>\n</ul>\n<blockquote>\n<p>主题更新<code>git pull</code></p>\n<p>使用了yelee主题，主题使用说明<code>http://moxfive.coding.me/yelee/</code></p>\n</blockquote>\n<h3 id=\"搜索功能配置\"><a href=\"#搜索功能配置\" class=\"headerlink\" title=\"搜索功能配置\"></a>搜索功能配置</h3><ul>\n<li>安装插件<code>npm install --save hexo-generator-search</code></li>\n<li><p>设置主题配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">search: </div><div class=\"line\">  on: true</div><div class=\"line\">  onload: true</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置hexo配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">search:</div><div class=\"line\">  path: search.xml</div><div class=\"line\">  field: post</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新生成</p>\n</li>\n</ul>\n<p>最后你会在publick文件中看到一个search.xml文件，最后你会在你的网站中看到你的搜索框</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在工程的_config文件中，要将url对应的字段设置为/，否则你会发现搜索会自动加上一个前置的url，这样就又错乱了</p>\n<h3 id=\"添加标签以及标签云页面\"><a href=\"#添加标签以及标签云页面\" class=\"headerlink\" title=\"添加标签以及标签云页面\"></a>添加标签以及标签云页面</h3><ul>\n<li>创建tags页面<code>hexo new page tags</code></li>\n<li><p>直接在文章中的tags关键字后边添加对应的标签就好</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">tags:</div><div class=\"line\">- 工具</div></pre></td></tr></table></figure>\n</li>\n<li><p>编辑刚才创建的tags页面，将其类型更改为tags</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: tags</div><div class=\"line\">date: </div><div class=\"line\">type: &quot;tags&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在主题配置文件中，将tags添加到menu中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  archives: /archives</div><div class=\"line\">  tags: /tags</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"创建关于页面\"><a href=\"#创建关于页面\" class=\"headerlink\" title=\"创建关于页面\"></a>创建关于页面</h3><p><code>hexo new page about</code></p>\n<h3 id=\"容易出现的问题\"><a href=\"#容易出现的问题\" class=\"headerlink\" title=\"容易出现的问题\"></a>容易出现的问题</h3><h4 id=\"hexo-d\"><a href=\"#hexo-d\" class=\"headerlink\" title=\"hexo d\"></a>hexo d</h4><ul>\n<li><code>Error: ssh_exchange_identification: read: Connection reset by peer</code><br>说明是网关的问题，我是解决了一下网络解决的，一开始连接的是京东的guest网络，出现该问题，切换为access解决</li>\n</ul>\n<h4 id=\"md文件格式\"><a href=\"#md文件格式\" class=\"headerlink\" title=\"md文件格式\"></a>md文件格式</h4><p>标题中#号要与后边的标题留出间隙，也就是一个空格，否则hexo渲染是不认的</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li>next主题设置<a href=\"http://theme-next.iissnan.com\" target=\"_blank\" rel=\"external\">http://theme-next.iissnan.com</a></li>\n<li>hexo官网<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"hexo安装\"><a href=\"#hexo安装\" class=\"headerlink\" title=\"hexo安装\"></a>hexo安装</h3><blockquote>\n<p>前提已经安装了node.js和git</p>\n</blockquote>\n<ul>\n<li><code>npm install hexo --no-optional</code></li>\n<li><code>hexo init myBlog</code>//创建hexo的文件夹</li>\n<li><code>cd myBlog</code></li>\n<li><code>npm install</code></li>\n<li><p><code>hexo server</code>//打开对应的链接可看到效果 </p>","more":"<h3 id=\"git配置\"><a href=\"#git配置\" class=\"headerlink\" title=\"git配置\"></a>git配置</h3></li>\n<li><p>创建git仓库<code>name/name.github.io</code></p>\n</li>\n<li>添加信息到配置文件<code>_config.yml</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:xizhengmeng/xizhengmeng.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<ul>\n<li>安装插件<code>npm install hexo-deployer-git --save</code></li>\n</ul>\n<blockquote>\n<p>如果要访问这个网站直接<code>xizhengmeng.github.io</code>就好了</p>\n</blockquote>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ul>\n<li>进入博客所在的文件夹，比如我说的是~/myBlog</li>\n<li><code>hexo clean</code></li>\n<li><code>hexo g</code>//生成</li>\n<li><code>hexo d</code>//推送到github服务器</li>\n<li><code>hexo new &quot;fileName&quot;</code>创建新的文件，在_post文件中</li>\n<li><code>hexo new page fileName</code>创建一个文件夹，然后在其中创建一个index.md文件，比如标签云页面，或者分类页面</li>\n</ul>\n<h3 id=\"绑定域名\"><a href=\"#绑定域名\" class=\"headerlink\" title=\"绑定域名\"></a>绑定域名</h3><ul>\n<li>申请域名，直接搜索<code>hexo和github，域名和github绑定的问题</code></li>\n<li>生成CNAME文件，并添加到source文件夹下，与post同级目录</li>\n<li>更改配置文件–——config.yml<code>url: www.hanson647.com</code></li>\n</ul>\n<h3 id=\"主题安装\"><a href=\"#主题安装\" class=\"headerlink\" title=\"主题安装\"></a>主题安装</h3><ul>\n<li>进入Hexo文件的根目录<code>cd Hexo</code></li>\n<li>拉取主题文件，并在本地创建对应的文件<code>git clone https://github.com/kathyqian/crisp-ghost-theme.git themes/gost</code></li>\n<li><p>更改配置文件的主题为该主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">theme: yilia</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新部署</p>\n</li>\n</ul>\n<blockquote>\n<p>主题更新<code>git pull</code></p>\n<p>使用了yelee主题，主题使用说明<code>http://moxfive.coding.me/yelee/</code></p>\n</blockquote>\n<h3 id=\"搜索功能配置\"><a href=\"#搜索功能配置\" class=\"headerlink\" title=\"搜索功能配置\"></a>搜索功能配置</h3><ul>\n<li>安装插件<code>npm install --save hexo-generator-search</code></li>\n<li><p>设置主题配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">search: </div><div class=\"line\">  on: true</div><div class=\"line\">  onload: true</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置hexo配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">search:</div><div class=\"line\">  path: search.xml</div><div class=\"line\">  field: post</div></pre></td></tr></table></figure>\n</li>\n<li><p>重新生成</p>\n</li>\n</ul>\n<p>最后你会在publick文件中看到一个search.xml文件，最后你会在你的网站中看到你的搜索框</p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>在工程的_config文件中，要将url对应的字段设置为/，否则你会发现搜索会自动加上一个前置的url，这样就又错乱了</p>\n<h3 id=\"添加标签以及标签云页面\"><a href=\"#添加标签以及标签云页面\" class=\"headerlink\" title=\"添加标签以及标签云页面\"></a>添加标签以及标签云页面</h3><ul>\n<li>创建tags页面<code>hexo new page tags</code></li>\n<li><p>直接在文章中的tags关键字后边添加对应的标签就好</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">tags:</div><div class=\"line\">- 工具</div></pre></td></tr></table></figure>\n</li>\n<li><p>编辑刚才创建的tags页面，将其类型更改为tags</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">title: tags</div><div class=\"line\">date: </div><div class=\"line\">type: &quot;tags&quot;</div></pre></td></tr></table></figure>\n</li>\n<li><p>在主题配置文件中，将tags添加到menu中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  archives: /archives</div><div class=\"line\">  tags: /tags</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"创建关于页面\"><a href=\"#创建关于页面\" class=\"headerlink\" title=\"创建关于页面\"></a>创建关于页面</h3><p><code>hexo new page about</code></p>\n<h3 id=\"容易出现的问题\"><a href=\"#容易出现的问题\" class=\"headerlink\" title=\"容易出现的问题\"></a>容易出现的问题</h3><h4 id=\"hexo-d\"><a href=\"#hexo-d\" class=\"headerlink\" title=\"hexo d\"></a>hexo d</h4><ul>\n<li><code>Error: ssh_exchange_identification: read: Connection reset by peer</code><br>说明是网关的问题，我是解决了一下网络解决的，一开始连接的是京东的guest网络，出现该问题，切换为access解决</li>\n</ul>\n<h4 id=\"md文件格式\"><a href=\"#md文件格式\" class=\"headerlink\" title=\"md文件格式\"></a>md文件格式</h4><p>标题中#号要与后边的标题留出间隙，也就是一个空格，否则hexo渲染是不认的</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li>next主题设置<a href=\"http://theme-next.iissnan.com\" target=\"_blank\" rel=\"external\">http://theme-next.iissnan.com</a></li>\n<li>hexo官网<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"external\">https://hexo.io/zh-cn/</a></li>\n</ul>"},{"title":"OC中的各种变量","date":"2015-06-10T10:00:10.000Z","_content":"\n首先看一下几个概念分类：\n- 成员变量\n- 属性\n- 局部变量\n- 全局变量\n- 静态变量 = 全局变量 + static声明的局部变量\n<!--more-->\n\n>首先声明：\n- 全局变量和静态变量都存在于全局内存区，在app生命周期内只初始化一次\n- 局部变量存在于栈内存区\n- 这里所讨论的是变量，而不是变量的值，这里两个概念`int a = 10`，a是变量，而10是它的值，这是两个概念\n- 地位内存是全局变量区，高位内存是堆或者栈`0x108eae338`9位， `0x7fff56d52ad4`12位\n\n## 成员变量var\n>定义：变量存活周期跟你定义的该类实体对象一样；作用域是整个实体对象；可以在h文件中声明或者在m文件中@implementation上面添加的\n\n```\n@interface CustomView1()\n{\n\tUIView *_backView1;\n}\n@property (nonatomic, strong) UIView *backView;\n@end\n```\n上边的两种写法都是对的，都代表是一个类的成员变量，只不过@property关键字做的事情比较多，上边类名称+()叫做extension，类扩展，如果有括号内加上名字叫做category，是分类。成员变量声明周期与类的对象相同。\n我们可以通过将一个对象赋值给成员变量来提升他的生命周期。\n\n## 属性\n@property关键字标识的变量\n\n## 全局变量\n>全局变量指的是存在于全局内存区，这个app声明周期只初始化一次，在所有的文件中不允许重名，下面的情况均属于全局变量\n.m文件中\n```\nint a;\n\n@interface CustomView1()\n\n@end\nint b;\n@implementation CustomView1\nint c;\nCustomView *_backView;\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n        [self initSubViews];\n    }\n    return self;\n}\n\n@end\n\n```\n>说明：a，b，c均为全局变量\n\n.h文件中\n```\nint d;\n@interface CustomView1\n\n@end\n```\n>说明：主要不是在interface关键字与end关键字之间都是全局变量，如果其他文件中有这个名字的变量，那么编译时不能够通过的\n\n全局变量可以提供全部的外界访问，无论你定义在h文件或者是m文件中，并且无需引入头文件，但是我们需要再重新再定义一下这个变量，否则编译器是不会通过的，他怎么知道你有这个变量呢，你说是吧，所以我们可以像下边这样来使用\n\n```\n#import \"ViewController.h\"\n#import \"CustomView1.h\"\n\ntypedef void(^MyBlcok)();\nNSString * const waha = @\"lalala\";\n\n@interface ViewController ()\n\n@property (nonatomic, copy) MyBlcok myBlock;\n@property (nonatomic, strong) UIView *backView;\n\n@end\n\n\n#import \"AppDelegate.h\"\n\n@interface AppDelegate ()\n\n@end\n\n@implementation AppDelegate\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n    extern NSString *waha;\n\n    NSLog(@\"appdelegate***%@---%p\", waha, &waha);\n    return YES;\n}\n```\n>我们需要再重新定义一下这个变量，否则编译器是通不过的，不过要将这变量变为全局才可以，其实也就是改变一下它的内存位置，将其从栈移动到全局内存中去\n\n### static + 全局变量\n这种方式的话这个全局变量就会变成这个类所私有的，声明周期与该类相同，允许重名\n\n\n### iOS中使用全局变量的方法\n- 静态变量\n- 单例\n- 在某个现成的单例中增加属性例如:appdelegate\n\n## 局部变量\n除了全局变量剩下的都是局部变量，内存是在栈上的，如果用关键字static来修饰局部变量那么它就变成了一个静态变量，内存也到了全局变量区，只是生命周期发生了改变，但是作用域并没有发生变化。\n\n- 如果用extern来修饰局部变量，那么它就会直接内存区变为全局区，生命周期和app一样了。如果后边再有其他的同名全局变量，编译器不会报错，但是后边生命的那个不会生效的，不过值还是允许改的。可以打印来验证一下，无论你在后边声明多少个该同名变量，他们的地址总是一样的。\n\n## 常量与const关键字\n顾名思义，常量就是不能被修改的变量，说到这里我就有一个疑问，这个跟宏有啥区别？\n- const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。\n- 编译时刻:宏是预编译（编译之前处理），const是编译阶段。\n- 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。\n- 宏的好处:宏能定义一些函数，方法。 const不能。\n- 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。\n- 注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存\n\n我们确实可以选择使用宏来定义一个常量，然后给很多地方使用，当我需要改变这个变量的时候，我只要改变这个宏后边的值就可以了，使用的场景比如：\n- 项目中的url\n- 项目中的屏幕尺寸\n- 项目中的某些特定颜色和尺寸\n\n有些地方宏会体现出它的优势，比如一些代码块的替换，具体来说，比如屏幕的尺寸的获取，比如weakSelf的定义，但是使用常量的情况使用宏是有些问题的，就是因为宏是没有类型判断的，那么如果某个CGFloat的值，我们使用了宏，那么编译阶段就不会警告任何错误，哪怕你定义了一个NSString类型的宏，然后你又把它当做了CGFloat来使用，所以对于某些值得定义，我们要使用类型常量，而不用宏来定义，比如：\n- 动画时间\n- 按钮尺寸\n- 文字尺寸\n- 等等\n\n具体来讲又可能分为三种情况：\n- 全部文件都使用\n- 只给自己使用\n\n我们先来看看给自己使用的常量的定义：\n\n```\n#import \"key1.h\"\n\nstatic const NSTimeInterval kAnimationDuration = 0.2;\n\n@interface key1()\n\n@end\n\n@implementation key1\n\n@end\n```\n要点有两个：\n- 要用static和const同时来声明\n- 声明在关键字之外\n\n声明在关键字之外那么就是全局变量，又因为是给自己用的，所以要加上static做限制，而const是为了防止这个变量在后边被修改\n\n再来看一下全局使用的常量，此类常量需要放在`全局符号表`,下面我们来看一下给全局使用的常量是如何来定义的：\n```\n//In the header file\nextern NSString *const EOCStringConst;//这样的const的位置意味着这个指针是一个常量\n\n//In the implementation file\nNSString *const EOCStringConstant = @\"VALUE\";\n```\n>这种常量一般在头文件中声明，然后在实现文件中定义，注意const的位置，不允许更改指针的指向，另外编译器看到extern关键字，就明白在全局符号表中将会有一个名字叫EOCStringConstant的符号了，\n\n## static和extern\n>static作用：\n- 修饰局部变量\n  - 延长局部变量的生命周期\n  - 局部变量只会生成一份内存，初始化一次\n  - 改变局部变量的作用域\n- 修饰全局变量\n  - 只能在本文件访问，修改全局变量的作用域，生命周期不变\n  - 避免重复定义全局变量\n\n>extern\n- 作用：获取全局变量的值，不能用来定义变量\n- 工作原理：现在当前文件查找有木有全局变量，没有的话才去其他文件查找\n\n\n## static和const\nstatic与const作用:声明一个只读的静态变量\n\n## extern与const联合使用\n- 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。\n\n    - 原因:static与const组合：在每个文件都需要定义一份静态全局变量。\n    - extern与const组合:只需要定义一份全局变量，多个文件共享。\n\n- 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。\n\n```\nGlobeConst.h\n\n/*******************************首页****************************/\nextern NSString * const nameKey = @\"name\";\n/*******************************首页****************************/\n\nGlobeConst.m\n\n#import <Foundation/Foundation.h>\n/*******************************首页****************************/\nNSString * const nameKey = @\"name\";\n/*******************************首页****************************/\n```\n我们现在来理解一下上面的代码，其实应该反过来看，首先我们在.m文件中声明并且对nameKey进行了赋值，所以我们在.h文件中才可以通过extern来取到nameKey的值，并且使用，其实我们完全可以在其他地方进行nameKey的取值，比如另外一个不相关的.m文件，只不过这样做会比较繁琐，需要重新声明这个变量，所以我们统一将这些个静态变量以extern的方式声明出来，放在.h文件中，让其他的文件调用，注意，这里是不能进行赋值操作的\n>这里做一个辨析：全局变量并不是因为你用extern关键字，全局变量是由你变量声明的位置所决定的，而extern其实是一个取值的操作，同时告诉编译器这个变量无论声明在哪里，我知道这个全局变量是存在的，放心的使用就好，但是如果真的这个全局变量是不存在的，比如说你把它声明定义在了某个函数内部，那么这个时候肯定报错了\n>另外我们使用`extern NSString *name = @\"名字\"`这种写法是没有意义的，因为extern是取值操作，这样写编译器也会报错的\n\n关于extern关键字总结如下：\n- 1. Declaration can be done any number of times but definition only once.\n- 2. “extern” keyword is used to extend the visibility of variables/functions().\n- 3. Since functions are visible through out the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant.\n- 4. When extern is used with a variable, it’s only declared not defined.\n- 5. As an exception, when an extern variable is declared with initialization, it is taken as definition of the variable as well.\n\n## __weak 与 __strong \n当我们定义一个变量的时候\n```\nUIView *view;\nview = [UIView alloc] init];\n```\n其实这个view前边默认有一个关键字，那就是__strong，这是因为这个关键字，所以我们的=赋值的时候，是一个强引用，所以alloc创建出来的对象是不会被释放的，又因为view这个变量被定义在栈上，所以当代码执行到一个函数结束的时候，这个view变量会被释放，这样alloc出来的对象就失去了强引用，这部分内存也将被系统所回收。\n\n现在我们来理解一下block的赋值操作，我们知道，当一个block被创建的时候，假如没有捕获变量，那么这个block是定义在全局的，对全局block做一个强引用的赋值操作是不会改变它的存储位置的，如果这个block捕获了一个栈上的变量，那么这个block就会被移动到栈上，这个时候如果我们对这个block做了一个强引用的赋值操作，这个block就被移动到了堆上。内存管理策略就变成了是否有强指针引用\n\n## 使用常量替换宏定义\n使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。\n```\nstatic CGFloat const kLogoImageWidth = 100; //logo宽度\nstatic CGFloat const kLogoImageHeight = 100; //logo宽度static CGFloat const kLogoImageY = 110;\nstatic CGFloat const kBtnHeight = 40;\nstatic CGFloat const kPadding = 30;\nstatic CGFloat const kWeixinTopPadding = 15;\nstatic CGFloat const kWeiboLoginBottom = 230;\n#define kScaleSpace(designSpace) ((designSpace)(SCREEN_HEIGHT/667.0)) //根据iphone6 的设计稿计算缩放高度\n```\n\n替换完成之后代码的编译速度确实上去了，现在编译快了。希望对正在为编译速度慢感到困惑的您有所帮助\n\n>补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式：\n\n```\nUserInfoModelConstants.h\n\nextern NSString *const USER_AGE_KEY ;\nextern NSString *const USER_TELPHONE_KEY ;\nextern NSString *const USER_ADDRESS_KEY ;\nextern NSString *const USER_BRIEF_KEY ;\n\nUserInfoModelConstants.m\n\nNSString *const BKUSER_AGE_KEY = @\"XXXXX.userAge\";\nNSString *const BKUSER_TELPHONE_KEY = @\"XXXXX.telphoneNO\";\nNSString *const BKUSER_ADDRESS_KEY = @\"XXXXX.address\";\nNSString *const BKUSER_BRIEF_KEY = @\"XXXXX.brief\";\n```\n在需要使用共享常量的文件中引入UserInfoModelConstants.h即可。\n\n\n","source":"_posts/2015/OC中的各种变量.md","raw":"---\ntitle: OC中的各种变量\ndate: 2015-06-10 18:00:10\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\n首先看一下几个概念分类：\n- 成员变量\n- 属性\n- 局部变量\n- 全局变量\n- 静态变量 = 全局变量 + static声明的局部变量\n<!--more-->\n\n>首先声明：\n- 全局变量和静态变量都存在于全局内存区，在app生命周期内只初始化一次\n- 局部变量存在于栈内存区\n- 这里所讨论的是变量，而不是变量的值，这里两个概念`int a = 10`，a是变量，而10是它的值，这是两个概念\n- 地位内存是全局变量区，高位内存是堆或者栈`0x108eae338`9位， `0x7fff56d52ad4`12位\n\n## 成员变量var\n>定义：变量存活周期跟你定义的该类实体对象一样；作用域是整个实体对象；可以在h文件中声明或者在m文件中@implementation上面添加的\n\n```\n@interface CustomView1()\n{\n\tUIView *_backView1;\n}\n@property (nonatomic, strong) UIView *backView;\n@end\n```\n上边的两种写法都是对的，都代表是一个类的成员变量，只不过@property关键字做的事情比较多，上边类名称+()叫做extension，类扩展，如果有括号内加上名字叫做category，是分类。成员变量声明周期与类的对象相同。\n我们可以通过将一个对象赋值给成员变量来提升他的生命周期。\n\n## 属性\n@property关键字标识的变量\n\n## 全局变量\n>全局变量指的是存在于全局内存区，这个app声明周期只初始化一次，在所有的文件中不允许重名，下面的情况均属于全局变量\n.m文件中\n```\nint a;\n\n@interface CustomView1()\n\n@end\nint b;\n@implementation CustomView1\nint c;\nCustomView *_backView;\n\n- (instancetype)initWithFrame:(CGRect)frame {\n    if (self = [super initWithFrame:frame]) {\n        [self initSubViews];\n    }\n    return self;\n}\n\n@end\n\n```\n>说明：a，b，c均为全局变量\n\n.h文件中\n```\nint d;\n@interface CustomView1\n\n@end\n```\n>说明：主要不是在interface关键字与end关键字之间都是全局变量，如果其他文件中有这个名字的变量，那么编译时不能够通过的\n\n全局变量可以提供全部的外界访问，无论你定义在h文件或者是m文件中，并且无需引入头文件，但是我们需要再重新再定义一下这个变量，否则编译器是不会通过的，他怎么知道你有这个变量呢，你说是吧，所以我们可以像下边这样来使用\n\n```\n#import \"ViewController.h\"\n#import \"CustomView1.h\"\n\ntypedef void(^MyBlcok)();\nNSString * const waha = @\"lalala\";\n\n@interface ViewController ()\n\n@property (nonatomic, copy) MyBlcok myBlock;\n@property (nonatomic, strong) UIView *backView;\n\n@end\n\n\n#import \"AppDelegate.h\"\n\n@interface AppDelegate ()\n\n@end\n\n@implementation AppDelegate\n\n\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    // Override point for customization after application launch.\n    extern NSString *waha;\n\n    NSLog(@\"appdelegate***%@---%p\", waha, &waha);\n    return YES;\n}\n```\n>我们需要再重新定义一下这个变量，否则编译器是通不过的，不过要将这变量变为全局才可以，其实也就是改变一下它的内存位置，将其从栈移动到全局内存中去\n\n### static + 全局变量\n这种方式的话这个全局变量就会变成这个类所私有的，声明周期与该类相同，允许重名\n\n\n### iOS中使用全局变量的方法\n- 静态变量\n- 单例\n- 在某个现成的单例中增加属性例如:appdelegate\n\n## 局部变量\n除了全局变量剩下的都是局部变量，内存是在栈上的，如果用关键字static来修饰局部变量那么它就变成了一个静态变量，内存也到了全局变量区，只是生命周期发生了改变，但是作用域并没有发生变化。\n\n- 如果用extern来修饰局部变量，那么它就会直接内存区变为全局区，生命周期和app一样了。如果后边再有其他的同名全局变量，编译器不会报错，但是后边生命的那个不会生效的，不过值还是允许改的。可以打印来验证一下，无论你在后边声明多少个该同名变量，他们的地址总是一样的。\n\n## 常量与const关键字\n顾名思义，常量就是不能被修改的变量，说到这里我就有一个疑问，这个跟宏有啥区别？\n- const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。\n- 编译时刻:宏是预编译（编译之前处理），const是编译阶段。\n- 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。\n- 宏的好处:宏能定义一些函数，方法。 const不能。\n- 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。\n- 注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存\n\n我们确实可以选择使用宏来定义一个常量，然后给很多地方使用，当我需要改变这个变量的时候，我只要改变这个宏后边的值就可以了，使用的场景比如：\n- 项目中的url\n- 项目中的屏幕尺寸\n- 项目中的某些特定颜色和尺寸\n\n有些地方宏会体现出它的优势，比如一些代码块的替换，具体来说，比如屏幕的尺寸的获取，比如weakSelf的定义，但是使用常量的情况使用宏是有些问题的，就是因为宏是没有类型判断的，那么如果某个CGFloat的值，我们使用了宏，那么编译阶段就不会警告任何错误，哪怕你定义了一个NSString类型的宏，然后你又把它当做了CGFloat来使用，所以对于某些值得定义，我们要使用类型常量，而不用宏来定义，比如：\n- 动画时间\n- 按钮尺寸\n- 文字尺寸\n- 等等\n\n具体来讲又可能分为三种情况：\n- 全部文件都使用\n- 只给自己使用\n\n我们先来看看给自己使用的常量的定义：\n\n```\n#import \"key1.h\"\n\nstatic const NSTimeInterval kAnimationDuration = 0.2;\n\n@interface key1()\n\n@end\n\n@implementation key1\n\n@end\n```\n要点有两个：\n- 要用static和const同时来声明\n- 声明在关键字之外\n\n声明在关键字之外那么就是全局变量，又因为是给自己用的，所以要加上static做限制，而const是为了防止这个变量在后边被修改\n\n再来看一下全局使用的常量，此类常量需要放在`全局符号表`,下面我们来看一下给全局使用的常量是如何来定义的：\n```\n//In the header file\nextern NSString *const EOCStringConst;//这样的const的位置意味着这个指针是一个常量\n\n//In the implementation file\nNSString *const EOCStringConstant = @\"VALUE\";\n```\n>这种常量一般在头文件中声明，然后在实现文件中定义，注意const的位置，不允许更改指针的指向，另外编译器看到extern关键字，就明白在全局符号表中将会有一个名字叫EOCStringConstant的符号了，\n\n## static和extern\n>static作用：\n- 修饰局部变量\n  - 延长局部变量的生命周期\n  - 局部变量只会生成一份内存，初始化一次\n  - 改变局部变量的作用域\n- 修饰全局变量\n  - 只能在本文件访问，修改全局变量的作用域，生命周期不变\n  - 避免重复定义全局变量\n\n>extern\n- 作用：获取全局变量的值，不能用来定义变量\n- 工作原理：现在当前文件查找有木有全局变量，没有的话才去其他文件查找\n\n\n## static和const\nstatic与const作用:声明一个只读的静态变量\n\n## extern与const联合使用\n- 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。\n\n    - 原因:static与const组合：在每个文件都需要定义一份静态全局变量。\n    - extern与const组合:只需要定义一份全局变量，多个文件共享。\n\n- 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。\n\n```\nGlobeConst.h\n\n/*******************************首页****************************/\nextern NSString * const nameKey = @\"name\";\n/*******************************首页****************************/\n\nGlobeConst.m\n\n#import <Foundation/Foundation.h>\n/*******************************首页****************************/\nNSString * const nameKey = @\"name\";\n/*******************************首页****************************/\n```\n我们现在来理解一下上面的代码，其实应该反过来看，首先我们在.m文件中声明并且对nameKey进行了赋值，所以我们在.h文件中才可以通过extern来取到nameKey的值，并且使用，其实我们完全可以在其他地方进行nameKey的取值，比如另外一个不相关的.m文件，只不过这样做会比较繁琐，需要重新声明这个变量，所以我们统一将这些个静态变量以extern的方式声明出来，放在.h文件中，让其他的文件调用，注意，这里是不能进行赋值操作的\n>这里做一个辨析：全局变量并不是因为你用extern关键字，全局变量是由你变量声明的位置所决定的，而extern其实是一个取值的操作，同时告诉编译器这个变量无论声明在哪里，我知道这个全局变量是存在的，放心的使用就好，但是如果真的这个全局变量是不存在的，比如说你把它声明定义在了某个函数内部，那么这个时候肯定报错了\n>另外我们使用`extern NSString *name = @\"名字\"`这种写法是没有意义的，因为extern是取值操作，这样写编译器也会报错的\n\n关于extern关键字总结如下：\n- 1. Declaration can be done any number of times but definition only once.\n- 2. “extern” keyword is used to extend the visibility of variables/functions().\n- 3. Since functions are visible through out the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant.\n- 4. When extern is used with a variable, it’s only declared not defined.\n- 5. As an exception, when an extern variable is declared with initialization, it is taken as definition of the variable as well.\n\n## __weak 与 __strong \n当我们定义一个变量的时候\n```\nUIView *view;\nview = [UIView alloc] init];\n```\n其实这个view前边默认有一个关键字，那就是__strong，这是因为这个关键字，所以我们的=赋值的时候，是一个强引用，所以alloc创建出来的对象是不会被释放的，又因为view这个变量被定义在栈上，所以当代码执行到一个函数结束的时候，这个view变量会被释放，这样alloc出来的对象就失去了强引用，这部分内存也将被系统所回收。\n\n现在我们来理解一下block的赋值操作，我们知道，当一个block被创建的时候，假如没有捕获变量，那么这个block是定义在全局的，对全局block做一个强引用的赋值操作是不会改变它的存储位置的，如果这个block捕获了一个栈上的变量，那么这个block就会被移动到栈上，这个时候如果我们对这个block做了一个强引用的赋值操作，这个block就被移动到了堆上。内存管理策略就变成了是否有强指针引用\n\n## 使用常量替换宏定义\n使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。\n```\nstatic CGFloat const kLogoImageWidth = 100; //logo宽度\nstatic CGFloat const kLogoImageHeight = 100; //logo宽度static CGFloat const kLogoImageY = 110;\nstatic CGFloat const kBtnHeight = 40;\nstatic CGFloat const kPadding = 30;\nstatic CGFloat const kWeixinTopPadding = 15;\nstatic CGFloat const kWeiboLoginBottom = 230;\n#define kScaleSpace(designSpace) ((designSpace)(SCREEN_HEIGHT/667.0)) //根据iphone6 的设计稿计算缩放高度\n```\n\n替换完成之后代码的编译速度确实上去了，现在编译快了。希望对正在为编译速度慢感到困惑的您有所帮助\n\n>补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式：\n\n```\nUserInfoModelConstants.h\n\nextern NSString *const USER_AGE_KEY ;\nextern NSString *const USER_TELPHONE_KEY ;\nextern NSString *const USER_ADDRESS_KEY ;\nextern NSString *const USER_BRIEF_KEY ;\n\nUserInfoModelConstants.m\n\nNSString *const BKUSER_AGE_KEY = @\"XXXXX.userAge\";\nNSString *const BKUSER_TELPHONE_KEY = @\"XXXXX.telphoneNO\";\nNSString *const BKUSER_ADDRESS_KEY = @\"XXXXX.address\";\nNSString *const BKUSER_BRIEF_KEY = @\"XXXXX.brief\";\n```\n在需要使用共享常量的文件中引入UserInfoModelConstants.h即可。\n\n\n","slug":"2015/OC中的各种变量","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmj002gsaua4skkkxt4","content":"<p>首先看一下几个概念分类：</p>\n<ul>\n<li>成员变量</li>\n<li>属性</li>\n<li>局部变量</li>\n<li>全局变量</li>\n<li>静态变量 = 全局变量 + static声明的局部变量<a id=\"more\"></a>\n</li>\n</ul>\n<blockquote>\n<p>首先声明：</p>\n<ul>\n<li>全局变量和静态变量都存在于全局内存区，在app生命周期内只初始化一次</li>\n<li>局部变量存在于栈内存区</li>\n<li>这里所讨论的是变量，而不是变量的值，这里两个概念<code>int a = 10</code>，a是变量，而10是它的值，这是两个概念</li>\n<li>地位内存是全局变量区，高位内存是堆或者栈<code>0x108eae338</code>9位， <code>0x7fff56d52ad4</code>12位</li>\n</ul>\n</blockquote>\n<h2 id=\"成员变量var\"><a href=\"#成员变量var\" class=\"headerlink\" title=\"成员变量var\"></a>成员变量var</h2><blockquote>\n<p>定义：变量存活周期跟你定义的该类实体对象一样；作用域是整个实体对象；可以在h文件中声明或者在m文件中@implementation上面添加的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface CustomView1()</div><div class=\"line\">&#123;</div><div class=\"line\">\tUIView *_backView1;</div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic, strong) UIView *backView;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>上边的两种写法都是对的，都代表是一个类的成员变量，只不过@property关键字做的事情比较多，上边类名称+()叫做extension，类扩展，如果有括号内加上名字叫做category，是分类。成员变量声明周期与类的对象相同。<br>我们可以通过将一个对象赋值给成员变量来提升他的生命周期。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>@property关键字标识的变量</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><blockquote>\n<p>全局变量指的是存在于全局内存区，这个app声明周期只初始化一次，在所有的文件中不允许重名，下面的情况均属于全局变量<br>.m文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a;</div><div class=\"line\"></div><div class=\"line\">@interface CustomView1()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">int b;</div><div class=\"line\">@implementation CustomView1</div><div class=\"line\">int c;</div><div class=\"line\">CustomView *_backView;</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</div><div class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">        [self initSubViews];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>说明：a，b，c均为全局变量</p>\n</blockquote>\n<p>.h文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int d;</div><div class=\"line\">@interface CustomView1</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>说明：主要不是在interface关键字与end关键字之间都是全局变量，如果其他文件中有这个名字的变量，那么编译时不能够通过的</p>\n</blockquote>\n<p>全局变量可以提供全部的外界访问，无论你定义在h文件或者是m文件中，并且无需引入头文件，但是我们需要再重新再定义一下这个变量，否则编译器是不会通过的，他怎么知道你有这个变量呢，你说是吧，所以我们可以像下边这样来使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\">#import &quot;CustomView1.h&quot;</div><div class=\"line\"></div><div class=\"line\">typedef void(^MyBlcok)();</div><div class=\"line\">NSString * const waha = @&quot;lalala&quot;;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) MyBlcok myBlock;</div><div class=\"line\">@property (nonatomic, strong) UIView *backView;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;AppDelegate.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface AppDelegate ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation AppDelegate</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class=\"line\">    // Override point for customization after application launch.</div><div class=\"line\">    extern NSString *waha;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;appdelegate***%@---%p&quot;, waha, &amp;waha);</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>我们需要再重新定义一下这个变量，否则编译器是通不过的，不过要将这变量变为全局才可以，其实也就是改变一下它的内存位置，将其从栈移动到全局内存中去</p>\n</blockquote>\n<h3 id=\"static-全局变量\"><a href=\"#static-全局变量\" class=\"headerlink\" title=\"static + 全局变量\"></a>static + 全局变量</h3><p>这种方式的话这个全局变量就会变成这个类所私有的，声明周期与该类相同，允许重名</p>\n<h3 id=\"iOS中使用全局变量的方法\"><a href=\"#iOS中使用全局变量的方法\" class=\"headerlink\" title=\"iOS中使用全局变量的方法\"></a>iOS中使用全局变量的方法</h3><ul>\n<li>静态变量</li>\n<li>单例</li>\n<li>在某个现成的单例中增加属性例如:appdelegate</li>\n</ul>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>除了全局变量剩下的都是局部变量，内存是在栈上的，如果用关键字static来修饰局部变量那么它就变成了一个静态变量，内存也到了全局变量区，只是生命周期发生了改变，但是作用域并没有发生变化。</p>\n<ul>\n<li>如果用extern来修饰局部变量，那么它就会直接内存区变为全局区，生命周期和app一样了。如果后边再有其他的同名全局变量，编译器不会报错，但是后边生命的那个不会生效的，不过值还是允许改的。可以打印来验证一下，无论你在后边声明多少个该同名变量，他们的地址总是一样的。</li>\n</ul>\n<h2 id=\"常量与const关键字\"><a href=\"#常量与const关键字\" class=\"headerlink\" title=\"常量与const关键字\"></a>常量与const关键字</h2><p>顾名思义，常量就是不能被修改的变量，说到这里我就有一个疑问，这个跟宏有啥区别？</p>\n<ul>\n<li>const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</li>\n<li>编译时刻:宏是预编译（编译之前处理），const是编译阶段。</li>\n<li>编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>\n<li>宏的好处:宏能定义一些函数，方法。 const不能。</li>\n<li>宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>\n<li>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存</li>\n</ul>\n<p>我们确实可以选择使用宏来定义一个常量，然后给很多地方使用，当我需要改变这个变量的时候，我只要改变这个宏后边的值就可以了，使用的场景比如：</p>\n<ul>\n<li>项目中的url</li>\n<li>项目中的屏幕尺寸</li>\n<li>项目中的某些特定颜色和尺寸</li>\n</ul>\n<p>有些地方宏会体现出它的优势，比如一些代码块的替换，具体来说，比如屏幕的尺寸的获取，比如weakSelf的定义，但是使用常量的情况使用宏是有些问题的，就是因为宏是没有类型判断的，那么如果某个CGFloat的值，我们使用了宏，那么编译阶段就不会警告任何错误，哪怕你定义了一个NSString类型的宏，然后你又把它当做了CGFloat来使用，所以对于某些值得定义，我们要使用类型常量，而不用宏来定义，比如：</p>\n<ul>\n<li>动画时间</li>\n<li>按钮尺寸</li>\n<li>文字尺寸</li>\n<li>等等</li>\n</ul>\n<p>具体来讲又可能分为三种情况：</p>\n<ul>\n<li>全部文件都使用</li>\n<li>只给自己使用</li>\n</ul>\n<p>我们先来看看给自己使用的常量的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;key1.h&quot;</div><div class=\"line\"></div><div class=\"line\">static const NSTimeInterval kAnimationDuration = 0.2;</div><div class=\"line\"></div><div class=\"line\">@interface key1()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation key1</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>要点有两个：</p>\n<ul>\n<li>要用static和const同时来声明</li>\n<li>声明在关键字之外</li>\n</ul>\n<p>声明在关键字之外那么就是全局变量，又因为是给自己用的，所以要加上static做限制，而const是为了防止这个变量在后边被修改</p>\n<p>再来看一下全局使用的常量，此类常量需要放在<code>全局符号表</code>,下面我们来看一下给全局使用的常量是如何来定义的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//In the header file</div><div class=\"line\">extern NSString *const EOCStringConst;//这样的const的位置意味着这个指针是一个常量</div><div class=\"line\"></div><div class=\"line\">//In the implementation file</div><div class=\"line\">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这种常量一般在头文件中声明，然后在实现文件中定义，注意const的位置，不允许更改指针的指向，另外编译器看到extern关键字，就明白在全局符号表中将会有一个名字叫EOCStringConstant的符号了，</p>\n</blockquote>\n<h2 id=\"static和extern\"><a href=\"#static和extern\" class=\"headerlink\" title=\"static和extern\"></a>static和extern</h2><blockquote>\n<p>static作用：</p>\n<ul>\n<li>修饰局部变量<ul>\n<li>延长局部变量的生命周期</li>\n<li>局部变量只会生成一份内存，初始化一次</li>\n<li>改变局部变量的作用域</li>\n</ul>\n</li>\n<li>修饰全局变量<ul>\n<li>只能在本文件访问，修改全局变量的作用域，生命周期不变</li>\n<li>避免重复定义全局变量</li>\n</ul>\n</li>\n</ul>\n<p>extern</p>\n<ul>\n<li>作用：获取全局变量的值，不能用来定义变量</li>\n<li>工作原理：现在当前文件查找有木有全局变量，没有的话才去其他文件查找</li>\n</ul>\n</blockquote>\n<h2 id=\"static和const\"><a href=\"#static和const\" class=\"headerlink\" title=\"static和const\"></a>static和const</h2><p>static与const作用:声明一个只读的静态变量</p>\n<h2 id=\"extern与const联合使用\"><a href=\"#extern与const联合使用\" class=\"headerlink\" title=\"extern与const联合使用\"></a>extern与const联合使用</h2><ul>\n<li><p>开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。</p>\n<ul>\n<li>原因:static与const组合：在每个文件都需要定义一份静态全局变量。</li>\n<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>\n</ul>\n</li>\n<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">GlobeConst.h</div><div class=\"line\"></div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\">extern NSString * const nameKey = @&quot;name&quot;;</div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\"></div><div class=\"line\">GlobeConst.m</div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\">NSString * const nameKey = @&quot;name&quot;;</div><div class=\"line\">/*******************************首页****************************/</div></pre></td></tr></table></figure>\n<p>我们现在来理解一下上面的代码，其实应该反过来看，首先我们在.m文件中声明并且对nameKey进行了赋值，所以我们在.h文件中才可以通过extern来取到nameKey的值，并且使用，其实我们完全可以在其他地方进行nameKey的取值，比如另外一个不相关的.m文件，只不过这样做会比较繁琐，需要重新声明这个变量，所以我们统一将这些个静态变量以extern的方式声明出来，放在.h文件中，让其他的文件调用，注意，这里是不能进行赋值操作的</p>\n<blockquote>\n<p>这里做一个辨析：全局变量并不是因为你用extern关键字，全局变量是由你变量声明的位置所决定的，而extern其实是一个取值的操作，同时告诉编译器这个变量无论声明在哪里，我知道这个全局变量是存在的，放心的使用就好，但是如果真的这个全局变量是不存在的，比如说你把它声明定义在了某个函数内部，那么这个时候肯定报错了<br>另外我们使用<code>extern NSString *name = @&quot;名字&quot;</code>这种写法是没有意义的，因为extern是取值操作，这样写编译器也会报错的</p>\n</blockquote>\n<p>关于extern关键字总结如下：</p>\n<ul>\n<li><ol>\n<li>Declaration can be done any number of times but definition only once.</li>\n</ol>\n</li>\n<li><ol>\n<li>“extern” keyword is used to extend the visibility of variables/functions().</li>\n</ol>\n</li>\n<li><ol>\n<li>Since functions are visible through out the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant.</li>\n</ol>\n</li>\n<li><ol>\n<li>When extern is used with a variable, it’s only declared not defined.</li>\n</ol>\n</li>\n<li><ol>\n<li>As an exception, when an extern variable is declared with initialization, it is taken as definition of the variable as well.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"weak-与-strong\"><a href=\"#weak-与-strong\" class=\"headerlink\" title=\"weak 与 strong\"></a><strong>weak 与 </strong>strong</h2><p>当我们定义一个变量的时候<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *view;</div><div class=\"line\">view = [UIView alloc] init];</div></pre></td></tr></table></figure></p>\n<p>其实这个view前边默认有一个关键字，那就是__strong，这是因为这个关键字，所以我们的=赋值的时候，是一个强引用，所以alloc创建出来的对象是不会被释放的，又因为view这个变量被定义在栈上，所以当代码执行到一个函数结束的时候，这个view变量会被释放，这样alloc出来的对象就失去了强引用，这部分内存也将被系统所回收。</p>\n<p>现在我们来理解一下block的赋值操作，我们知道，当一个block被创建的时候，假如没有捕获变量，那么这个block是定义在全局的，对全局block做一个强引用的赋值操作是不会改变它的存储位置的，如果这个block捕获了一个栈上的变量，那么这个block就会被移动到栈上，这个时候如果我们对这个block做了一个强引用的赋值操作，这个block就被移动到了堆上。内存管理策略就变成了是否有强指针引用</p>\n<h2 id=\"使用常量替换宏定义\"><a href=\"#使用常量替换宏定义\" class=\"headerlink\" title=\"使用常量替换宏定义\"></a>使用常量替换宏定义</h2><p>使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CGFloat const kLogoImageWidth = 100; //logo宽度</div><div class=\"line\">static CGFloat const kLogoImageHeight = 100; //logo宽度static CGFloat const kLogoImageY = 110;</div><div class=\"line\">static CGFloat const kBtnHeight = 40;</div><div class=\"line\">static CGFloat const kPadding = 30;</div><div class=\"line\">static CGFloat const kWeixinTopPadding = 15;</div><div class=\"line\">static CGFloat const kWeiboLoginBottom = 230;</div><div class=\"line\">#define kScaleSpace(designSpace) ((designSpace)(SCREEN_HEIGHT/667.0)) //根据iphone6 的设计稿计算缩放高度</div></pre></td></tr></table></figure></p>\n<p>替换完成之后代码的编译速度确实上去了，现在编译快了。希望对正在为编译速度慢感到困惑的您有所帮助</p>\n<blockquote>\n<p>补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserInfoModelConstants.h</div><div class=\"line\"></div><div class=\"line\">extern NSString *const USER_AGE_KEY ;</div><div class=\"line\">extern NSString *const USER_TELPHONE_KEY ;</div><div class=\"line\">extern NSString *const USER_ADDRESS_KEY ;</div><div class=\"line\">extern NSString *const USER_BRIEF_KEY ;</div><div class=\"line\"></div><div class=\"line\">UserInfoModelConstants.m</div><div class=\"line\"></div><div class=\"line\">NSString *const BKUSER_AGE_KEY = @&quot;XXXXX.userAge&quot;;</div><div class=\"line\">NSString *const BKUSER_TELPHONE_KEY = @&quot;XXXXX.telphoneNO&quot;;</div><div class=\"line\">NSString *const BKUSER_ADDRESS_KEY = @&quot;XXXXX.address&quot;;</div><div class=\"line\">NSString *const BKUSER_BRIEF_KEY = @&quot;XXXXX.brief&quot;;</div></pre></td></tr></table></figure>\n<p>在需要使用共享常量的文件中引入UserInfoModelConstants.h即可。</p>\n","site":{"data":{}},"excerpt":"<p>首先看一下几个概念分类：</p>\n<ul>\n<li>成员变量</li>\n<li>属性</li>\n<li>局部变量</li>\n<li>全局变量</li>\n<li>静态变量 = 全局变量 + static声明的局部变量","more":"</li>\n</ul>\n<blockquote>\n<p>首先声明：</p>\n<ul>\n<li>全局变量和静态变量都存在于全局内存区，在app生命周期内只初始化一次</li>\n<li>局部变量存在于栈内存区</li>\n<li>这里所讨论的是变量，而不是变量的值，这里两个概念<code>int a = 10</code>，a是变量，而10是它的值，这是两个概念</li>\n<li>地位内存是全局变量区，高位内存是堆或者栈<code>0x108eae338</code>9位， <code>0x7fff56d52ad4</code>12位</li>\n</ul>\n</blockquote>\n<h2 id=\"成员变量var\"><a href=\"#成员变量var\" class=\"headerlink\" title=\"成员变量var\"></a>成员变量var</h2><blockquote>\n<p>定义：变量存活周期跟你定义的该类实体对象一样；作用域是整个实体对象；可以在h文件中声明或者在m文件中@implementation上面添加的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface CustomView1()</div><div class=\"line\">&#123;</div><div class=\"line\">\tUIView *_backView1;</div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic, strong) UIView *backView;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>上边的两种写法都是对的，都代表是一个类的成员变量，只不过@property关键字做的事情比较多，上边类名称+()叫做extension，类扩展，如果有括号内加上名字叫做category，是分类。成员变量声明周期与类的对象相同。<br>我们可以通过将一个对象赋值给成员变量来提升他的生命周期。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>@property关键字标识的变量</p>\n<h2 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h2><blockquote>\n<p>全局变量指的是存在于全局内存区，这个app声明周期只初始化一次，在所有的文件中不允许重名，下面的情况均属于全局变量<br>.m文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">int a;</div><div class=\"line\"></div><div class=\"line\">@interface CustomView1()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\">int b;</div><div class=\"line\">@implementation CustomView1</div><div class=\"line\">int c;</div><div class=\"line\">CustomView *_backView;</div><div class=\"line\"></div><div class=\"line\">- (instancetype)initWithFrame:(CGRect)frame &#123;</div><div class=\"line\">    if (self = [super initWithFrame:frame]) &#123;</div><div class=\"line\">        [self initSubViews];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>说明：a，b，c均为全局变量</p>\n</blockquote>\n<p>.h文件中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">int d;</div><div class=\"line\">@interface CustomView1</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>说明：主要不是在interface关键字与end关键字之间都是全局变量，如果其他文件中有这个名字的变量，那么编译时不能够通过的</p>\n</blockquote>\n<p>全局变量可以提供全部的外界访问，无论你定义在h文件或者是m文件中，并且无需引入头文件，但是我们需要再重新再定义一下这个变量，否则编译器是不会通过的，他怎么知道你有这个变量呢，你说是吧，所以我们可以像下边这样来使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;ViewController.h&quot;</div><div class=\"line\">#import &quot;CustomView1.h&quot;</div><div class=\"line\"></div><div class=\"line\">typedef void(^MyBlcok)();</div><div class=\"line\">NSString * const waha = @&quot;lalala&quot;;</div><div class=\"line\"></div><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@property (nonatomic, copy) MyBlcok myBlock;</div><div class=\"line\">@property (nonatomic, strong) UIView *backView;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;AppDelegate.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface AppDelegate ()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation AppDelegate</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class=\"line\">    // Override point for customization after application launch.</div><div class=\"line\">    extern NSString *waha;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;appdelegate***%@---%p&quot;, waha, &amp;waha);</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>我们需要再重新定义一下这个变量，否则编译器是通不过的，不过要将这变量变为全局才可以，其实也就是改变一下它的内存位置，将其从栈移动到全局内存中去</p>\n</blockquote>\n<h3 id=\"static-全局变量\"><a href=\"#static-全局变量\" class=\"headerlink\" title=\"static + 全局变量\"></a>static + 全局变量</h3><p>这种方式的话这个全局变量就会变成这个类所私有的，声明周期与该类相同，允许重名</p>\n<h3 id=\"iOS中使用全局变量的方法\"><a href=\"#iOS中使用全局变量的方法\" class=\"headerlink\" title=\"iOS中使用全局变量的方法\"></a>iOS中使用全局变量的方法</h3><ul>\n<li>静态变量</li>\n<li>单例</li>\n<li>在某个现成的单例中增加属性例如:appdelegate</li>\n</ul>\n<h2 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h2><p>除了全局变量剩下的都是局部变量，内存是在栈上的，如果用关键字static来修饰局部变量那么它就变成了一个静态变量，内存也到了全局变量区，只是生命周期发生了改变，但是作用域并没有发生变化。</p>\n<ul>\n<li>如果用extern来修饰局部变量，那么它就会直接内存区变为全局区，生命周期和app一样了。如果后边再有其他的同名全局变量，编译器不会报错，但是后边生命的那个不会生效的，不过值还是允许改的。可以打印来验证一下，无论你在后边声明多少个该同名变量，他们的地址总是一样的。</li>\n</ul>\n<h2 id=\"常量与const关键字\"><a href=\"#常量与const关键字\" class=\"headerlink\" title=\"常量与const关键字\"></a>常量与const关键字</h2><p>顾名思义，常量就是不能被修改的变量，说到这里我就有一个疑问，这个跟宏有啥区别？</p>\n<ul>\n<li>const简介：之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</li>\n<li>编译时刻:宏是预编译（编译之前处理），const是编译阶段。</li>\n<li>编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>\n<li>宏的好处:宏能定义一些函数，方法。 const不能。</li>\n<li>宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>\n<li>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存</li>\n</ul>\n<p>我们确实可以选择使用宏来定义一个常量，然后给很多地方使用，当我需要改变这个变量的时候，我只要改变这个宏后边的值就可以了，使用的场景比如：</p>\n<ul>\n<li>项目中的url</li>\n<li>项目中的屏幕尺寸</li>\n<li>项目中的某些特定颜色和尺寸</li>\n</ul>\n<p>有些地方宏会体现出它的优势，比如一些代码块的替换，具体来说，比如屏幕的尺寸的获取，比如weakSelf的定义，但是使用常量的情况使用宏是有些问题的，就是因为宏是没有类型判断的，那么如果某个CGFloat的值，我们使用了宏，那么编译阶段就不会警告任何错误，哪怕你定义了一个NSString类型的宏，然后你又把它当做了CGFloat来使用，所以对于某些值得定义，我们要使用类型常量，而不用宏来定义，比如：</p>\n<ul>\n<li>动画时间</li>\n<li>按钮尺寸</li>\n<li>文字尺寸</li>\n<li>等等</li>\n</ul>\n<p>具体来讲又可能分为三种情况：</p>\n<ul>\n<li>全部文件都使用</li>\n<li>只给自己使用</li>\n</ul>\n<p>我们先来看看给自己使用的常量的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;key1.h&quot;</div><div class=\"line\"></div><div class=\"line\">static const NSTimeInterval kAnimationDuration = 0.2;</div><div class=\"line\"></div><div class=\"line\">@interface key1()</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation key1</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>要点有两个：</p>\n<ul>\n<li>要用static和const同时来声明</li>\n<li>声明在关键字之外</li>\n</ul>\n<p>声明在关键字之外那么就是全局变量，又因为是给自己用的，所以要加上static做限制，而const是为了防止这个变量在后边被修改</p>\n<p>再来看一下全局使用的常量，此类常量需要放在<code>全局符号表</code>,下面我们来看一下给全局使用的常量是如何来定义的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//In the header file</div><div class=\"line\">extern NSString *const EOCStringConst;//这样的const的位置意味着这个指针是一个常量</div><div class=\"line\"></div><div class=\"line\">//In the implementation file</div><div class=\"line\">NSString *const EOCStringConstant = @&quot;VALUE&quot;;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这种常量一般在头文件中声明，然后在实现文件中定义，注意const的位置，不允许更改指针的指向，另外编译器看到extern关键字，就明白在全局符号表中将会有一个名字叫EOCStringConstant的符号了，</p>\n</blockquote>\n<h2 id=\"static和extern\"><a href=\"#static和extern\" class=\"headerlink\" title=\"static和extern\"></a>static和extern</h2><blockquote>\n<p>static作用：</p>\n<ul>\n<li>修饰局部变量<ul>\n<li>延长局部变量的生命周期</li>\n<li>局部变量只会生成一份内存，初始化一次</li>\n<li>改变局部变量的作用域</li>\n</ul>\n</li>\n<li>修饰全局变量<ul>\n<li>只能在本文件访问，修改全局变量的作用域，生命周期不变</li>\n<li>避免重复定义全局变量</li>\n</ul>\n</li>\n</ul>\n<p>extern</p>\n<ul>\n<li>作用：获取全局变量的值，不能用来定义变量</li>\n<li>工作原理：现在当前文件查找有木有全局变量，没有的话才去其他文件查找</li>\n</ul>\n</blockquote>\n<h2 id=\"static和const\"><a href=\"#static和const\" class=\"headerlink\" title=\"static和const\"></a>static和const</h2><p>static与const作用:声明一个只读的静态变量</p>\n<h2 id=\"extern与const联合使用\"><a href=\"#extern与const联合使用\" class=\"headerlink\" title=\"extern与const联合使用\"></a>extern与const联合使用</h2><ul>\n<li><p>开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。</p>\n<ul>\n<li>原因:static与const组合：在每个文件都需要定义一份静态全局变量。</li>\n<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>\n</ul>\n</li>\n<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">GlobeConst.h</div><div class=\"line\"></div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\">extern NSString * const nameKey = @&quot;name&quot;;</div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\"></div><div class=\"line\">GlobeConst.m</div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\">/*******************************首页****************************/</div><div class=\"line\">NSString * const nameKey = @&quot;name&quot;;</div><div class=\"line\">/*******************************首页****************************/</div></pre></td></tr></table></figure>\n<p>我们现在来理解一下上面的代码，其实应该反过来看，首先我们在.m文件中声明并且对nameKey进行了赋值，所以我们在.h文件中才可以通过extern来取到nameKey的值，并且使用，其实我们完全可以在其他地方进行nameKey的取值，比如另外一个不相关的.m文件，只不过这样做会比较繁琐，需要重新声明这个变量，所以我们统一将这些个静态变量以extern的方式声明出来，放在.h文件中，让其他的文件调用，注意，这里是不能进行赋值操作的</p>\n<blockquote>\n<p>这里做一个辨析：全局变量并不是因为你用extern关键字，全局变量是由你变量声明的位置所决定的，而extern其实是一个取值的操作，同时告诉编译器这个变量无论声明在哪里，我知道这个全局变量是存在的，放心的使用就好，但是如果真的这个全局变量是不存在的，比如说你把它声明定义在了某个函数内部，那么这个时候肯定报错了<br>另外我们使用<code>extern NSString *name = @&quot;名字&quot;</code>这种写法是没有意义的，因为extern是取值操作，这样写编译器也会报错的</p>\n</blockquote>\n<p>关于extern关键字总结如下：</p>\n<ul>\n<li><ol>\n<li>Declaration can be done any number of times but definition only once.</li>\n</ol>\n</li>\n<li><ol>\n<li>“extern” keyword is used to extend the visibility of variables/functions().</li>\n</ol>\n</li>\n<li><ol>\n<li>Since functions are visible through out the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant.</li>\n</ol>\n</li>\n<li><ol>\n<li>When extern is used with a variable, it’s only declared not defined.</li>\n</ol>\n</li>\n<li><ol>\n<li>As an exception, when an extern variable is declared with initialization, it is taken as definition of the variable as well.</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"weak-与-strong\"><a href=\"#weak-与-strong\" class=\"headerlink\" title=\"weak 与 strong\"></a><strong>weak 与 </strong>strong</h2><p>当我们定义一个变量的时候<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIView *view;</div><div class=\"line\">view = [UIView alloc] init];</div></pre></td></tr></table></figure></p>\n<p>其实这个view前边默认有一个关键字，那就是__strong，这是因为这个关键字，所以我们的=赋值的时候，是一个强引用，所以alloc创建出来的对象是不会被释放的，又因为view这个变量被定义在栈上，所以当代码执行到一个函数结束的时候，这个view变量会被释放，这样alloc出来的对象就失去了强引用，这部分内存也将被系统所回收。</p>\n<p>现在我们来理解一下block的赋值操作，我们知道，当一个block被创建的时候，假如没有捕获变量，那么这个block是定义在全局的，对全局block做一个强引用的赋值操作是不会改变它的存储位置的，如果这个block捕获了一个栈上的变量，那么这个block就会被移动到栈上，这个时候如果我们对这个block做了一个强引用的赋值操作，这个block就被移动到了堆上。内存管理策略就变成了是否有强指针引用</p>\n<h2 id=\"使用常量替换宏定义\"><a href=\"#使用常量替换宏定义\" class=\"headerlink\" title=\"使用常量替换宏定义\"></a>使用常量替换宏定义</h2><p>使用宏定义过多的话，随着工程越来越大，编译速度会越来越慢。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">static CGFloat const kLogoImageWidth = 100; //logo宽度</div><div class=\"line\">static CGFloat const kLogoImageHeight = 100; //logo宽度static CGFloat const kLogoImageY = 110;</div><div class=\"line\">static CGFloat const kBtnHeight = 40;</div><div class=\"line\">static CGFloat const kPadding = 30;</div><div class=\"line\">static CGFloat const kWeixinTopPadding = 15;</div><div class=\"line\">static CGFloat const kWeiboLoginBottom = 230;</div><div class=\"line\">#define kScaleSpace(designSpace) ((designSpace)(SCREEN_HEIGHT/667.0)) //根据iphone6 的设计稿计算缩放高度</div></pre></td></tr></table></figure></p>\n<p>替换完成之后代码的编译速度确实上去了，现在编译快了。希望对正在为编译速度慢感到困惑的您有所帮助</p>\n<blockquote>\n<p>补充说明：以上的类型常量替换宏的情况，只是适用于单个文件的情况。如果是多个文件共享的常量，苹果推荐的这样的方式：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">UserInfoModelConstants.h</div><div class=\"line\"></div><div class=\"line\">extern NSString *const USER_AGE_KEY ;</div><div class=\"line\">extern NSString *const USER_TELPHONE_KEY ;</div><div class=\"line\">extern NSString *const USER_ADDRESS_KEY ;</div><div class=\"line\">extern NSString *const USER_BRIEF_KEY ;</div><div class=\"line\"></div><div class=\"line\">UserInfoModelConstants.m</div><div class=\"line\"></div><div class=\"line\">NSString *const BKUSER_AGE_KEY = @&quot;XXXXX.userAge&quot;;</div><div class=\"line\">NSString *const BKUSER_TELPHONE_KEY = @&quot;XXXXX.telphoneNO&quot;;</div><div class=\"line\">NSString *const BKUSER_ADDRESS_KEY = @&quot;XXXXX.address&quot;;</div><div class=\"line\">NSString *const BKUSER_BRIEF_KEY = @&quot;XXXXX.brief&quot;;</div></pre></td></tr></table></figure>\n<p>在需要使用共享常量的文件中引入UserInfoModelConstants.h即可。</p>"},{"title":"Runloop概述","date":"2015-07-21T01:35:22.000Z","_content":"\n## 1.基本概念\n### 为什么需要runloop\n- 使程序一直活着\n- 决定程序何时应该处理哪些event\n- 调用解耦(message queue)\n- 节省CPU时间\n- 开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源\n\n### 与runloop相关的类\n- NSTimer\n- UIEvent\n- Autorelease\n- NSObjec-->NSDelayedPerforming\n- NSObjec-->NSThreadPerformAddition\n- CADisplayLink\n- CATransition\n- CAAnimation\n- dispatch_get_main_queue()\n- NSURLConnection\n\n### runloop与线程\n\n- 每条线程都有唯一的一个与之对应的RunLoop对象\n- 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建\n- RunLoop在第一次`获取时创建`，在线程结束时销毁\n- 一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件，比如说主线程。\n- 线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从苹果公开的源码中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式\n\n### 获取runloop\n>Foundation\n```\n[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象\n[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象\n```\n\n>Core Foundation\n```\nCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象\nCFRunLoopGetMain(); // 获得主线程的RunLoop对象\n```\n\n### runloop基本结构\n`NSRunLoop继承自NSObject`\n![](http://i1.piimg.com/567571/d478dc563d0af5b8.png)\n- runloop与Thread一一对应，但是并不是一个thread只能有一runloop，我们可以给runloop嵌套runloop\n\n#### CFRunLoopMode\n- CFRunLoopModeRef代表RunLoop的运行模式\n    - 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer\n    - 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode\n    - 如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入\n    - 这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响\n\n![](http://i1.piimg.com/567571/83261feb726f1627.png)\n\n>系统默认注册了5个Mode:(前两个跟最后一个常用)\n- kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行\n- UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\n- UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用\n- GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到\n- kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mod\n![](http://i1.piimg.com/567571/8d1aff60c4248ca3.png)\n#### CFRunLoopSource\n- CFRunLoopSourceRef是事件源（输入源）\n- 按照官方文档的分类\n    - Port-Based Sources (基于端口,跟其他线程交互,通过内核发布的消息)\n    - Custom Input Sources (自定义)\n    - Cocoa Perform Selector Sources (performSelector…方法)\n- 按照函数调用栈的分类\n    - Source0：非基于Port的\n    - Source1：基于Port的\n\nSource0: event事件，只含有回调，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop。\nSource1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。\n\n#### CFRunLoopTimer\n本质就是一个timer\n```\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;//该方法定义在RunLoop中，不过是NSObject的分类；\n+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//这个类方法定义在DisPlayLink中\n- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;//这也是DisPlayLink中的方法\n```\n- CFRunLoopTimerRef是基于时间的触发器\n- 基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响\n- GCD的定时器不受RunLoop的Mode影响\n#### CFRunLoopObserver\n- CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变\n- 可以监听的时间点有以下几个\n\n![](http://img8.a.pcs.baidu.com/rest/2.0/pcs/thumbnail?method=generate&path=%2Fimages%2FSnip20160721_13.png&app_id=246327&width=1600&height=1600)\n\n\n\n## 应用\n- CADisplayLink\n- NSTimer\n- ImageView显示\n- PerformSelector\n- 常驻线程\n- 自动释放池\n- NSURLConnection的执行过程\n- AFNetWorking中是如何使用RunLoop的?\n\n### 深入理解Perform Selector\n```\n- (void)tryPerformSelectorOnMianThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self performSelector:@selector(perform1) withObject:nil];\n    });\n}\n\n- (void)mainThreadMethod{\n\nNSLog(@\"execute %s\",__func__);\n\n// print: execute -[ViewController mainThreadMethod]\n}\n```\n\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\n});\n}\n- (void)backGroundThread{\n\nNSLog(@\"%u\",[NSThread isMainThread]);\n\nNSLog(@\"execute %s\",__FUNCTION__);\n\n}\n```\n这样我们在ViewDidLoad中调用tryPerformSelectorOnMianThread,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];\n上边的performselector在子线程中依然可以执行，因为它不依赖于timer，不需要启动runloop，但是下边的做法就不行。\n\n和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行\n\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\n});\n}\n- (void)backGroundThread{\n\nNSLog(@\"%u\",[NSThread isMainThread]);\n\nNSLog(@\"execute %s\",__FUNCTION__);\n\n}\n```\n同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？\n这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个Timer的source，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\nNSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n[runLoop run];\n\n});\n}\n```\n这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。\n小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop\n\n### Perform Selector after\n当某个事件触发了某段代码执行的时候，是要在一个runloop中执行完毕的，如果这个线程有runloop的话，这样如果在一个主线程有一大段代码要执行，那么就会阻碍这个线程，或者更准确来讲是让这个runloop不能去处理用户事件和刷新屏幕，那该怎么办呢？\n答案就是这个方法`- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay`我们可以把一个大段的方法执行切分成几份，然后用该方法连接，每次执行这个方法，就会进入到下一个runloop才会执行，而每个runloop的执行，用户事件的处理和屏幕刷新是在代码执行前边的，所以这样就有机会中断代码的执行，就像是下边这样\n```\n@property (nonatomic, strong) UIButton *btn1;\n@property (nonatomic, strong) UIButton *btn2;\n@property (nonatomic, assign) BOOL next;\n\n@end\n\nint b = 0;\n\n@implementation ViewController\n\n- (UIButton *)btn1 {\n    if (!_btn1) {\n        _btn1 = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn1 setTitle:@\"点我1\" forState:UIControlStateNormal];\n        [_btn1 sizeToFit];\n        [_btn1 addTarget:self action:@selector(click1) forControlEvents:UIControlEventTouchUpInside];\n        [_btn1 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n    }\n    return _btn1;\n}\n\n- (UIButton *)btn2 {\n    if (!_btn2) {\n        _btn2 = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn2 setTitle:@\"点我2\" forState:UIControlStateNormal];\n        [_btn2 sizeToFit];\n        [_btn2 addTarget:self action:@selector(click2) forControlEvents:UIControlEventTouchUpInside];\n        [_btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n    }\n    return _btn2;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.btn1];\n    [self.view addSubview:self.btn2];\n    \n    self.btn1.frame = CGRectMake(10, 30, 50, 20);\n    self.btn2.frame = CGRectMake(100, 30, 50, 20);\n}\n\n- (void)click1 {\n    \n    for (int i = 0; i < 3000; i++) {\n        NSLog(@\"%d\", i);\n    }\n[self performSelector:@selector(perform1) withObject:nil afterDelay:0.005];\n\n}\n\n- (void)perform1 {\n    for (int i = 3000; i < 6000; i++) {\n        NSLog(@\"%d\", i);\n    }\n    [self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];\n\n}\n\n- (void)perform4 {\n    if (!_next) return;\n    for (int i = 6000; i < 9000; i++) {\n        NSLog(@\"%d\", i);\n    }\n    [self performSelector:@selector(perform5) withObject:nil afterDelay:0.005];\n}\n\n- (void)perform5 {\n    if (!_next) return;\n    for (int i = 600; i < 900; i++) {\n        NSLog(@\"%d\", i);\n    }\n}\n\n- (void)click2 {\n    _next = NO;\n}\n\n```\n实验证明，只有after方法有这样的魔力。\n>总结:当我们创建了一个timer事件的时候，这个时候这个事件就会被放到下一个runloop中执行，如果这个线程中根本就没有起runloop，那么也就不存在下一个runloop，这个事件也就永远不会被执行了。\n\n### CADisplayLink\n用法和timer一样，放在子线程的话记得自己创建runloop\n```\n dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            // Track FPS using display link\n            _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkTick)];\n    //        [_displayLink setPaused:YES];\n            [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];\n            [[NSRunLoop currentRunLoop] run];\n        });\n```\n\n### Timer\n```\n@interface ViewController ()\n@property (nonatomic, strong) UIScrollView *scrollView;\n@property (nonatomic, assign) NSInteger count;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.scrollView];\n \n    NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(printfString) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode兼容,timer就都可以跑了\n}\n\n- (UIScrollView *)scrollView {\n    if (!_scrollView) {\n        _scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, kScreenW, 200)];\n        _scrollView.backgroundColor = [UIColor redColor];\n        _scrollView.contentSize = CGSizeMake(kScreenW * 2, 0);\n    }\n    return _scrollView;\n}\n\n- (void)printfString {\n    self.count ++;\n    NSLog(@\"%ld\", self.count);\n}\n```\n这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n    NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n\n    [myTimer fire];\n\n});\n```\n这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:\n```\nNSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n    [runLoop run];\n```\n这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。\n### ImageView\n\n需求:当用户在拖拽时(UI交互时)不显示图片,拖拽完成时显示图片\n\n方法1 监听UIScrollerView滚动 (通过UIScrollViewDelegate监听,此处不再举例)\n\n方法2 RunLoop 设置运行模式\n\n```\n// 只在NSDefaultRunLoopMode模式下显示图片\n    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"placeholder\"] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];\n```\n比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片\n\n### 一直活着的后台线程\n现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:\n```\n@interface ViewController ()\n\n@property(nonatomic,strong) NSThread *myThread;\n\n@end\n\n@implementation ViewController\n\n- (void)alwaysLiveBackGoundThread{\n\nNSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@\"etund\"];\nself.myThread = thread;\n[self.myThread start];\n\n}\n- (void)myThreadRun{\n\nNSLog(@\"my thread run\");\n\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\n    NSLog(@\"%@\",self.myThread);\n    [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];\n}\n- (void)doBackGroundThreadWork{\n\n    NSLog(@\"do some work %s\",__FUNCTION__);\n\n}\n@end\n```\n这个方法中，我们利用一个强引用来获取了后天线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡):\n```\n- (void)myThreadRun{\n\n[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n[[NSRunLoop currentRunLoop] run]\n\n  NSLog(@\"my thread run\");\n\n}\n```\n这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。\n小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在\n\n### NSURLConnection的执行过程\n在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:\n![](006.png)\n从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:\n```\nwhile (!_isEndRequest)\n{\n    NSLog(@\"entered run loop\");\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n}\n\nNSLog(@\"main finished，task be removed\");\n\n- (void)connectionDidFinishLoading:(NSURLConnection *)connection\n{\n\n  _isEndRequest = YES;\n\n}\n```\n这里我们就可以解决下面这些疑问了:<br/>\n\n- 为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。\n- 如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。\n- 既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环。\n\n\n### AFNetWorking中是如何使用RunLoop的?\n在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。\n为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item\n```\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n@autoreleasepool {\n    [[NSThread currentThread] setName:@\"AFNetworking\"];\n    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    [runLoop run];\n}\n\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。\n```\n- (void)start {\n[self.lock lock];\nif ([self isCancelled]) {\n    [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n} else if ([self isReady]) {\n    self.state = AFOperationExecutingState;\n    [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n}\n[self.lock unlock];\n}\n```\n### GCD定时器的实现\n```\n- (void)gcdTimer{\n\n// get the queue\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\n// creat timer\nself.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n// config the timer (starting time，interval)\n// set begining time\ndispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));\n// set the interval\nuint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);\n\ndispatch_source_set_timer(self.timer, start, interver, 0.0);\n\ndispatch_source_set_event_handler(self.timer, ^{\n\n    // the tarsk needed to be processed async\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n\n        for (int i = 0; i < 100000; i++) {\n            NSLog(@\"gcdTimer\");\n        }\n    });\n});\ndispatch_resume(self.timer);\n\n}\n```\n\n\n\n\n\n\n## 谈谈你对Run Loop的理解\n\n- RunLoop是多线程的一个很重要的机制，就是一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程会通过do-while死循环让程序持续等待下一个任务不退出。通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。非主线程通常来说就是为了执行某个任务而创建的，执行完就会归还资源，因此默认不开启RunLoop\n- 实质上，对于子线程的runloop是默认不存在的，因为苹果采用了懒加载的方式，如果没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询当前线程的RunLoop，也不会创建、加载\n- 当然如果子线程处理完某个任务后不退出，需要继续等待接受事件，需要启动的时候也可以手动启动，比如说添加定时器的时候就要手动开始RunLoop\n如何处理事件\n\n- 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n- 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n- 网络请求：最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLConnection是iOS7中新增的接口。当网络开始传输时，NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket线程是处理底层socket连接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接受底层socket的事件，并添加到上层的Delegate\n\n应用\n\n- 滑动与图片刷新：当tableView的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程回去加载图片，加载完成后主线程会设置cell的图片，但是会造成卡顿。可以设置图片的任务在CFRunloopDefaultMode下进行，当滚动tableView的时候，Runloop切换到UITrackingRunLoopMode，不去设置图片，而是而是当停止的时候，再去设置图片。（在viewDidLoad中调用self.imageView performSelector@selector(setImage) withObject:...afterDelay:...inModes@[NSDefayltRunLoopMode]）\n\n- 常驻子线程，保持子线程一直处理事件 为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出\n\n\n## RunLoop处理的几种事件\n>static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();\n\n他对这六类事件有如下解释\n\n1.Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。\n\n2.Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。\n\n3.Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。\n\n4.Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。CADisplayLink也是这里触发\n\n5.Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。\n[self performSelector:@selector(perform1) withObject:nil];是走source0的\n\n6.Source1事件：处理系统内核的mach_msg事件。\n\n验证方法是，打断点，lldb上边的调用栈\n\n### 总结\n如果我们想要打断一个方法的执行，一个办法就是用`[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];`来连接方法的执行，这里延迟时间设置为0有时是无效的，我们可以给一个很小的时间，\n","source":"_posts/2015/Runloop概述.md","raw":"---\ntitle: Runloop概述\ndate: 2015-07-21 09:35:22\ntags:\n- iOS进阶\ncategories: iOS\n---\n\n## 1.基本概念\n### 为什么需要runloop\n- 使程序一直活着\n- 决定程序何时应该处理哪些event\n- 调用解耦(message queue)\n- 节省CPU时间\n- 开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源\n\n### 与runloop相关的类\n- NSTimer\n- UIEvent\n- Autorelease\n- NSObjec-->NSDelayedPerforming\n- NSObjec-->NSThreadPerformAddition\n- CADisplayLink\n- CATransition\n- CAAnimation\n- dispatch_get_main_queue()\n- NSURLConnection\n\n### runloop与线程\n\n- 每条线程都有唯一的一个与之对应的RunLoop对象\n- 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建\n- RunLoop在第一次`获取时创建`，在线程结束时销毁\n- 一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件，比如说主线程。\n- 线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从苹果公开的源码中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式\n\n### 获取runloop\n>Foundation\n```\n[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象\n[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象\n```\n\n>Core Foundation\n```\nCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象\nCFRunLoopGetMain(); // 获得主线程的RunLoop对象\n```\n\n### runloop基本结构\n`NSRunLoop继承自NSObject`\n![](http://i1.piimg.com/567571/d478dc563d0af5b8.png)\n- runloop与Thread一一对应，但是并不是一个thread只能有一runloop，我们可以给runloop嵌套runloop\n\n#### CFRunLoopMode\n- CFRunLoopModeRef代表RunLoop的运行模式\n    - 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer\n    - 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode\n    - 如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入\n    - 这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响\n\n![](http://i1.piimg.com/567571/83261feb726f1627.png)\n\n>系统默认注册了5个Mode:(前两个跟最后一个常用)\n- kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行\n- UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响\n- UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用\n- GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到\n- kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mod\n![](http://i1.piimg.com/567571/8d1aff60c4248ca3.png)\n#### CFRunLoopSource\n- CFRunLoopSourceRef是事件源（输入源）\n- 按照官方文档的分类\n    - Port-Based Sources (基于端口,跟其他线程交互,通过内核发布的消息)\n    - Custom Input Sources (自定义)\n    - Cocoa Perform Selector Sources (performSelector…方法)\n- 按照函数调用栈的分类\n    - Source0：非基于Port的\n    - Source1：基于Port的\n\nSource0: event事件，只含有回调，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop。\nSource1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。\n\n#### CFRunLoopTimer\n本质就是一个timer\n```\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;//该方法定义在RunLoop中，不过是NSObject的分类；\n+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//这个类方法定义在DisPlayLink中\n- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;//这也是DisPlayLink中的方法\n```\n- CFRunLoopTimerRef是基于时间的触发器\n- 基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响\n- GCD的定时器不受RunLoop的Mode影响\n#### CFRunLoopObserver\n- CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变\n- 可以监听的时间点有以下几个\n\n![](http://img8.a.pcs.baidu.com/rest/2.0/pcs/thumbnail?method=generate&path=%2Fimages%2FSnip20160721_13.png&app_id=246327&width=1600&height=1600)\n\n\n\n## 应用\n- CADisplayLink\n- NSTimer\n- ImageView显示\n- PerformSelector\n- 常驻线程\n- 自动释放池\n- NSURLConnection的执行过程\n- AFNetWorking中是如何使用RunLoop的?\n\n### 深入理解Perform Selector\n```\n- (void)tryPerformSelectorOnMianThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n        [self performSelector:@selector(perform1) withObject:nil];\n    });\n}\n\n- (void)mainThreadMethod{\n\nNSLog(@\"execute %s\",__func__);\n\n// print: execute -[ViewController mainThreadMethod]\n}\n```\n\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\n});\n}\n- (void)backGroundThread{\n\nNSLog(@\"%u\",[NSThread isMainThread]);\n\nNSLog(@\"execute %s\",__FUNCTION__);\n\n}\n```\n这样我们在ViewDidLoad中调用tryPerformSelectorOnMianThread,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];\n上边的performselector在子线程中依然可以执行，因为它不依赖于timer，不需要启动runloop，但是下边的做法就不行。\n\n和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行\n\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\n});\n}\n- (void)backGroundThread{\n\nNSLog(@\"%u\",[NSThread isMainThread]);\n\nNSLog(@\"execute %s\",__FUNCTION__);\n\n}\n```\n同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？\n这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个Timer的source，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:\n```\n- (void)tryPerformSelectorOnBackGroundThread{\n\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];\n\nNSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n[runLoop run];\n\n});\n}\n```\n这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。\n小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop\n\n### Perform Selector after\n当某个事件触发了某段代码执行的时候，是要在一个runloop中执行完毕的，如果这个线程有runloop的话，这样如果在一个主线程有一大段代码要执行，那么就会阻碍这个线程，或者更准确来讲是让这个runloop不能去处理用户事件和刷新屏幕，那该怎么办呢？\n答案就是这个方法`- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay`我们可以把一个大段的方法执行切分成几份，然后用该方法连接，每次执行这个方法，就会进入到下一个runloop才会执行，而每个runloop的执行，用户事件的处理和屏幕刷新是在代码执行前边的，所以这样就有机会中断代码的执行，就像是下边这样\n```\n@property (nonatomic, strong) UIButton *btn1;\n@property (nonatomic, strong) UIButton *btn2;\n@property (nonatomic, assign) BOOL next;\n\n@end\n\nint b = 0;\n\n@implementation ViewController\n\n- (UIButton *)btn1 {\n    if (!_btn1) {\n        _btn1 = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn1 setTitle:@\"点我1\" forState:UIControlStateNormal];\n        [_btn1 sizeToFit];\n        [_btn1 addTarget:self action:@selector(click1) forControlEvents:UIControlEventTouchUpInside];\n        [_btn1 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n    }\n    return _btn1;\n}\n\n- (UIButton *)btn2 {\n    if (!_btn2) {\n        _btn2 = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn2 setTitle:@\"点我2\" forState:UIControlStateNormal];\n        [_btn2 sizeToFit];\n        [_btn2 addTarget:self action:@selector(click2) forControlEvents:UIControlEventTouchUpInside];\n        [_btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n    }\n    return _btn2;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.btn1];\n    [self.view addSubview:self.btn2];\n    \n    self.btn1.frame = CGRectMake(10, 30, 50, 20);\n    self.btn2.frame = CGRectMake(100, 30, 50, 20);\n}\n\n- (void)click1 {\n    \n    for (int i = 0; i < 3000; i++) {\n        NSLog(@\"%d\", i);\n    }\n[self performSelector:@selector(perform1) withObject:nil afterDelay:0.005];\n\n}\n\n- (void)perform1 {\n    for (int i = 3000; i < 6000; i++) {\n        NSLog(@\"%d\", i);\n    }\n    [self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];\n\n}\n\n- (void)perform4 {\n    if (!_next) return;\n    for (int i = 6000; i < 9000; i++) {\n        NSLog(@\"%d\", i);\n    }\n    [self performSelector:@selector(perform5) withObject:nil afterDelay:0.005];\n}\n\n- (void)perform5 {\n    if (!_next) return;\n    for (int i = 600; i < 900; i++) {\n        NSLog(@\"%d\", i);\n    }\n}\n\n- (void)click2 {\n    _next = NO;\n}\n\n```\n实验证明，只有after方法有这样的魔力。\n>总结:当我们创建了一个timer事件的时候，这个时候这个事件就会被放到下一个runloop中执行，如果这个线程中根本就没有起runloop，那么也就不存在下一个runloop，这个事件也就永远不会被执行了。\n\n### CADisplayLink\n用法和timer一样，放在子线程的话记得自己创建runloop\n```\n dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            // Track FPS using display link\n            _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkTick)];\n    //        [_displayLink setPaused:YES];\n            [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];\n            [[NSRunLoop currentRunLoop] run];\n        });\n```\n\n### Timer\n```\n@interface ViewController ()\n@property (nonatomic, strong) UIScrollView *scrollView;\n@property (nonatomic, assign) NSInteger count;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.scrollView];\n \n    NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(printfString) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode兼容,timer就都可以跑了\n}\n\n- (UIScrollView *)scrollView {\n    if (!_scrollView) {\n        _scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, kScreenW, 200)];\n        _scrollView.backgroundColor = [UIColor redColor];\n        _scrollView.contentSize = CGSizeMake(kScreenW * 2, 0);\n    }\n    return _scrollView;\n}\n\n- (void)printfString {\n    self.count ++;\n    NSLog(@\"%ld\", self.count);\n}\n```\n这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?\n```\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n\n    NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];\n\n    [myTimer fire];\n\n});\n```\n这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:\n```\nNSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n    [runLoop run];\n```\n这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。\n### ImageView\n\n需求:当用户在拖拽时(UI交互时)不显示图片,拖拽完成时显示图片\n\n方法1 监听UIScrollerView滚动 (通过UIScrollViewDelegate监听,此处不再举例)\n\n方法2 RunLoop 设置运行模式\n\n```\n// 只在NSDefaultRunLoopMode模式下显示图片\n    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"placeholder\"] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];\n```\n比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片\n\n### 一直活着的后台线程\n现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:\n```\n@interface ViewController ()\n\n@property(nonatomic,strong) NSThread *myThread;\n\n@end\n\n@implementation ViewController\n\n- (void)alwaysLiveBackGoundThread{\n\nNSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@\"etund\"];\nself.myThread = thread;\n[self.myThread start];\n\n}\n- (void)myThreadRun{\n\nNSLog(@\"my thread run\");\n\n}\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{\n\n    NSLog(@\"%@\",self.myThread);\n    [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];\n}\n- (void)doBackGroundThreadWork{\n\n    NSLog(@\"do some work %s\",__FUNCTION__);\n\n}\n@end\n```\n这个方法中，我们利用一个强引用来获取了后天线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡):\n```\n- (void)myThreadRun{\n\n[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n[[NSRunLoop currentRunLoop] run]\n\n  NSLog(@\"my thread run\");\n\n}\n```\n这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。\n小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在\n\n### NSURLConnection的执行过程\n在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:\n![](006.png)\n从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:\n```\nwhile (!_isEndRequest)\n{\n    NSLog(@\"entered run loop\");\n    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n}\n\nNSLog(@\"main finished，task be removed\");\n\n- (void)connectionDidFinishLoading:(NSURLConnection *)connection\n{\n\n  _isEndRequest = YES;\n\n}\n```\n这里我们就可以解决下面这些疑问了:<br/>\n\n- 为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。\n- 如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。\n- 既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环。\n\n\n### AFNetWorking中是如何使用RunLoop的?\n在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。\n为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item\n```\n+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n@autoreleasepool {\n    [[NSThread currentThread] setName:@\"AFNetworking\"];\n    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    [runLoop run];\n}\n\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n    return _networkRequestThread;\n}\n```\n这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。\n```\n- (void)start {\n[self.lock lock];\nif ([self isCancelled]) {\n    [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n} else if ([self isReady]) {\n    self.state = AFOperationExecutingState;\n    [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];\n}\n[self.lock unlock];\n}\n```\n### GCD定时器的实现\n```\n- (void)gcdTimer{\n\n// get the queue\ndispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n\n// creat timer\nself.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n// config the timer (starting time，interval)\n// set begining time\ndispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));\n// set the interval\nuint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);\n\ndispatch_source_set_timer(self.timer, start, interver, 0.0);\n\ndispatch_source_set_event_handler(self.timer, ^{\n\n    // the tarsk needed to be processed async\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n\n        for (int i = 0; i < 100000; i++) {\n            NSLog(@\"gcdTimer\");\n        }\n    });\n});\ndispatch_resume(self.timer);\n\n}\n```\n\n\n\n\n\n\n## 谈谈你对Run Loop的理解\n\n- RunLoop是多线程的一个很重要的机制，就是一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程会通过do-while死循环让程序持续等待下一个任务不退出。通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。非主线程通常来说就是为了执行某个任务而创建的，执行完就会归还资源，因此默认不开启RunLoop\n- 实质上，对于子线程的runloop是默认不存在的，因为苹果采用了懒加载的方式，如果没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询当前线程的RunLoop，也不会创建、加载\n- 当然如果子线程处理完某个任务后不退出，需要继续等待接受事件，需要启动的时候也可以手动启动，比如说添加定时器的时候就要手动开始RunLoop\n如何处理事件\n\n- 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n- 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n- 网络请求：最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLConnection是iOS7中新增的接口。当网络开始传输时，NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket线程是处理底层socket连接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接受底层socket的事件，并添加到上层的Delegate\n\n应用\n\n- 滑动与图片刷新：当tableView的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程回去加载图片，加载完成后主线程会设置cell的图片，但是会造成卡顿。可以设置图片的任务在CFRunloopDefaultMode下进行，当滚动tableView的时候，Runloop切换到UITrackingRunLoopMode，不去设置图片，而是而是当停止的时候，再去设置图片。（在viewDidLoad中调用self.imageView performSelector@selector(setImage) withObject:...afterDelay:...inModes@[NSDefayltRunLoopMode]）\n\n- 常驻子线程，保持子线程一直处理事件 为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出\n\n\n## RunLoop处理的几种事件\n>static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();\nstatic void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();\nstatic void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();\n\n他对这六类事件有如下解释\n\n1.Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。\n\n2.Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。\n\n3.Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。\n\n4.Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。CADisplayLink也是这里触发\n\n5.Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。\n[self performSelector:@selector(perform1) withObject:nil];是走source0的\n\n6.Source1事件：处理系统内核的mach_msg事件。\n\n验证方法是，打断点，lldb上边的调用栈\n\n### 总结\n如果我们想要打断一个方法的执行，一个办法就是用`[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];`来连接方法的执行，这里延迟时间设置为0有时是无效的，我们可以给一个很小的时间，\n","slug":"2015/Runloop概述","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pml002ksaua6kmwxih8","content":"<h2 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1.基本概念\"></a>1.基本概念</h2><h3 id=\"为什么需要runloop\"><a href=\"#为什么需要runloop\" class=\"headerlink\" title=\"为什么需要runloop\"></a>为什么需要runloop</h3><ul>\n<li>使程序一直活着</li>\n<li>决定程序何时应该处理哪些event</li>\n<li>调用解耦(message queue)</li>\n<li>节省CPU时间</li>\n<li>开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源</li>\n</ul>\n<h3 id=\"与runloop相关的类\"><a href=\"#与runloop相关的类\" class=\"headerlink\" title=\"与runloop相关的类\"></a>与runloop相关的类</h3><ul>\n<li>NSTimer</li>\n<li>UIEvent</li>\n<li>Autorelease</li>\n<li>NSObjec–&gt;NSDelayedPerforming</li>\n<li>NSObjec–&gt;NSThreadPerformAddition</li>\n<li>CADisplayLink</li>\n<li>CATransition</li>\n<li>CAAnimation</li>\n<li>dispatch_get_main_queue()</li>\n<li>NSURLConnection</li>\n</ul>\n<h3 id=\"runloop与线程\"><a href=\"#runloop与线程\" class=\"headerlink\" title=\"runloop与线程\"></a>runloop与线程</h3><ul>\n<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>\n<li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li>\n<li>RunLoop在第一次<code>获取时创建</code>，在线程结束时销毁</li>\n<li>一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件，比如说主线程。</li>\n<li>线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从苹果公开的源码中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式</li>\n</ul>\n<h3 id=\"获取runloop\"><a href=\"#获取runloop\" class=\"headerlink\" title=\"获取runloop\"></a>获取runloop</h3><blockquote>\n<p>Foundation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</div><div class=\"line\">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</div></pre></td></tr></table></figure></p>\n<p>Core Foundation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</div><div class=\"line\">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"runloop基本结构\"><a href=\"#runloop基本结构\" class=\"headerlink\" title=\"runloop基本结构\"></a>runloop基本结构</h3><p><code>NSRunLoop继承自NSObject</code><br><img src=\"http://i1.piimg.com/567571/d478dc563d0af5b8.png\" alt=\"\"></p>\n<ul>\n<li>runloop与Thread一一对应，但是并不是一个thread只能有一runloop，我们可以给runloop嵌套runloop</li>\n</ul>\n<h4 id=\"CFRunLoopMode\"><a href=\"#CFRunLoopMode\" class=\"headerlink\" title=\"CFRunLoopMode\"></a>CFRunLoopMode</h4><ul>\n<li>CFRunLoopModeRef代表RunLoop的运行模式<ul>\n<li>一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer</li>\n<li>每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode</li>\n<li>如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入</li>\n<li>这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://i1.piimg.com/567571/83261feb726f1627.png\" alt=\"\"></p>\n<blockquote>\n<p>系统默认注册了5个Mode:(前两个跟最后一个常用)</p>\n<ul>\n<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>\n<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mod<br><img src=\"http://i1.piimg.com/567571/8d1aff60c4248ca3.png\" alt=\"\"><h4 id=\"CFRunLoopSource\"><a href=\"#CFRunLoopSource\" class=\"headerlink\" title=\"CFRunLoopSource\"></a>CFRunLoopSource</h4></li>\n<li>CFRunLoopSourceRef是事件源（输入源）</li>\n<li>按照官方文档的分类<ul>\n<li>Port-Based Sources (基于端口,跟其他线程交互,通过内核发布的消息)</li>\n<li>Custom Input Sources (自定义)</li>\n<li>Cocoa Perform Selector Sources (performSelector…方法)</li>\n</ul>\n</li>\n<li>按照函数调用栈的分类<ul>\n<li>Source0：非基于Port的</li>\n<li>Source1：基于Port的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>Source0: event事件，只含有回调，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop。<br>Source1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。</p>\n<h4 id=\"CFRunLoopTimer\"><a href=\"#CFRunLoopTimer\" class=\"headerlink\" title=\"CFRunLoopTimer\"></a>CFRunLoopTimer</h4><p>本质就是一个timer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div><div class=\"line\">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div><div class=\"line\">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;//该方法定义在RunLoop中，不过是NSObject的分类；</div><div class=\"line\">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//这个类方法定义在DisPlayLink中</div><div class=\"line\">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;//这也是DisPlayLink中的方法</div></pre></td></tr></table></figure></p>\n<ul>\n<li>CFRunLoopTimerRef是基于时间的触发器</li>\n<li>基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响</li>\n<li>GCD的定时器不受RunLoop的Mode影响<h4 id=\"CFRunLoopObserver\"><a href=\"#CFRunLoopObserver\" class=\"headerlink\" title=\"CFRunLoopObserver\"></a>CFRunLoopObserver</h4></li>\n<li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</li>\n<li>可以监听的时间点有以下几个</li>\n</ul>\n<p><img src=\"http://img8.a.pcs.baidu.com/rest/2.0/pcs/thumbnail?method=generate&amp;path=%2Fimages%2FSnip20160721_13.png&amp;app_id=246327&amp;width=1600&amp;height=1600\" alt=\"\"></p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li>CADisplayLink</li>\n<li>NSTimer</li>\n<li>ImageView显示</li>\n<li>PerformSelector</li>\n<li>常驻线程</li>\n<li>自动释放池</li>\n<li>NSURLConnection的执行过程</li>\n<li>AFNetWorking中是如何使用RunLoop的?</li>\n</ul>\n<h3 id=\"深入理解Perform-Selector\"><a href=\"#深入理解Perform-Selector\" class=\"headerlink\" title=\"深入理解Perform Selector\"></a>深入理解Perform Selector</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnMianThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">        [self performSelector:@selector(perform1) withObject:nil];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mainThreadMethod&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">// print: execute -[ViewController mainThreadMethod]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)backGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;%u&quot;,[NSThread isMainThread]);</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样我们在ViewDidLoad中调用tryPerformSelectorOnMianThread,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];<br>上边的performselector在子线程中依然可以执行，因为它不依赖于timer，不需要启动runloop，但是下边的做法就不行。</p>\n<p>和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)backGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;%u&quot;,[NSThread isMainThread]);</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？<br>这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个Timer的source，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">[runLoop run];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。<br>小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop</p>\n<h3 id=\"Perform-Selector-after\"><a href=\"#Perform-Selector-after\" class=\"headerlink\" title=\"Perform Selector after\"></a>Perform Selector after</h3><p>当某个事件触发了某段代码执行的时候，是要在一个runloop中执行完毕的，如果这个线程有runloop的话，这样如果在一个主线程有一大段代码要执行，那么就会阻碍这个线程，或者更准确来讲是让这个runloop不能去处理用户事件和刷新屏幕，那该怎么办呢？<br>答案就是这个方法<code>- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>我们可以把一个大段的方法执行切分成几份，然后用该方法连接，每次执行这个方法，就会进入到下一个runloop才会执行，而每个runloop的执行，用户事件的处理和屏幕刷新是在代码执行前边的，所以这样就有机会中断代码的执行，就像是下边这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) UIButton *btn1;</div><div class=\"line\">@property (nonatomic, strong) UIButton *btn2;</div><div class=\"line\">@property (nonatomic, assign) BOOL next;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">int b = 0;</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn1 &#123;</div><div class=\"line\">    if (!_btn1) &#123;</div><div class=\"line\">        _btn1 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn1 setTitle:@&quot;点我1&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn1 sizeToFit];</div><div class=\"line\">        [_btn1 addTarget:self action:@selector(click1) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">        [_btn1 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn2 &#123;</div><div class=\"line\">    if (!_btn2) &#123;</div><div class=\"line\">        _btn2 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn2 setTitle:@&quot;点我2&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn2 sizeToFit];</div><div class=\"line\">        [_btn2 addTarget:self action:@selector(click2) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">        [_btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.btn1];</div><div class=\"line\">    [self.view addSubview:self.btn2];</div><div class=\"line\">    </div><div class=\"line\">    self.btn1.frame = CGRectMake(10, 30, 50, 20);</div><div class=\"line\">    self.btn2.frame = CGRectMake(100, 30, 50, 20);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)click1 &#123;</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; 3000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">[self performSelector:@selector(perform1) withObject:nil afterDelay:0.005];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform1 &#123;</div><div class=\"line\">    for (int i = 3000; i &lt; 6000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform4 &#123;</div><div class=\"line\">    if (!_next) return;</div><div class=\"line\">    for (int i = 6000; i &lt; 9000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self performSelector:@selector(perform5) withObject:nil afterDelay:0.005];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform5 &#123;</div><div class=\"line\">    if (!_next) return;</div><div class=\"line\">    for (int i = 600; i &lt; 900; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)click2 &#123;</div><div class=\"line\">    _next = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实验证明，只有after方法有这样的魔力。</p>\n<blockquote>\n<p>总结:当我们创建了一个timer事件的时候，这个时候这个事件就会被放到下一个runloop中执行，如果这个线程中根本就没有起runloop，那么也就不存在下一个runloop，这个事件也就永远不会被执行了。</p>\n</blockquote>\n<h3 id=\"CADisplayLink\"><a href=\"#CADisplayLink\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h3><p>用法和timer一样，放在子线程的话记得自己创建runloop<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">           // Track FPS using display link</div><div class=\"line\">           _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkTick)];</div><div class=\"line\">   //        [_displayLink setPaused:YES];</div><div class=\"line\">           [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class=\"line\">           [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">       &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic, strong) UIScrollView *scrollView;</div><div class=\"line\">@property (nonatomic, assign) NSInteger count;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.scrollView];</div><div class=\"line\"> </div><div class=\"line\">    NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(printfString) userInfo:nil repeats:YES];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode兼容,timer就都可以跑了</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIScrollView *)scrollView &#123;</div><div class=\"line\">    if (!_scrollView) &#123;</div><div class=\"line\">        _scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, kScreenW, 200)];</div><div class=\"line\">        _scrollView.backgroundColor = [UIColor redColor];</div><div class=\"line\">        _scrollView.contentSize = CGSizeMake(kScreenW * 2, 0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _scrollView;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)printfString &#123;</div><div class=\"line\">    self.count ++;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;, self.count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">    NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</div><div class=\"line\"></div><div class=\"line\">    [myTimer fire];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">    [runLoop run];</div></pre></td></tr></table></figure></p>\n<p>这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。</p>\n<h3 id=\"ImageView\"><a href=\"#ImageView\" class=\"headerlink\" title=\"ImageView\"></a>ImageView</h3><p>需求:当用户在拖拽时(UI交互时)不显示图片,拖拽完成时显示图片</p>\n<p>方法1 监听UIScrollerView滚动 (通过UIScrollViewDelegate监听,此处不再举例)</p>\n<p>方法2 RunLoop 设置运行模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只在NSDefaultRunLoopMode模式下显示图片</div><div class=\"line\">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>\n<p>比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片</p>\n<h3 id=\"一直活着的后台线程\"><a href=\"#一直活着的后台线程\" class=\"headerlink\" title=\"一直活着的后台线程\"></a>一直活着的后台线程</h3><p>现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic,strong) NSThread *myThread;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)alwaysLiveBackGoundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@&quot;etund&quot;];</div><div class=\"line\">self.myThread = thread;</div><div class=\"line\">[self.myThread start];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)myThreadRun&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;my thread run&quot;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@&quot;,self.myThread);</div><div class=\"line\">    [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)doBackGroundThreadWork&#123;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;do some work %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>这个方法中，我们利用一个强引用来获取了后天线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)myThreadRun&#123;</div><div class=\"line\"></div><div class=\"line\">[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">[[NSRunLoop currentRunLoop] run]</div><div class=\"line\"></div><div class=\"line\">  NSLog(@&quot;my thread run&quot;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。<br>小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在</p>\n<h3 id=\"NSURLConnection的执行过程\"><a href=\"#NSURLConnection的执行过程\" class=\"headerlink\" title=\"NSURLConnection的执行过程\"></a>NSURLConnection的执行过程</h3><p>在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:<br><img src=\"006.png\" alt=\"\"><br>从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (!_isEndRequest)</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;entered run loop&quot;);</div><div class=\"line\">    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;main finished，task be removed&quot;);</div><div class=\"line\"></div><div class=\"line\">- (void)connectionDidFinishLoading:(NSURLConnection *)connection</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">  _isEndRequest = YES;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们就可以解决下面这些疑问了:<br></p>\n<ul>\n<li>为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。</li>\n<li>如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。</li>\n<li>既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环。</li>\n</ul>\n<h3 id=\"AFNetWorking中是如何使用RunLoop的\"><a href=\"#AFNetWorking中是如何使用RunLoop的\" class=\"headerlink\" title=\"AFNetWorking中是如何使用RunLoop的?\"></a>AFNetWorking中是如何使用RunLoop的?</h3><p>在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。<br>为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</div><div class=\"line\">@autoreleasepool &#123;</div><div class=\"line\">    [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</div><div class=\"line\">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    [runLoop run];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSThread *)networkRequestThread &#123;</div><div class=\"line\">    static NSThread *_networkRequestThread = nil;</div><div class=\"line\">    static dispatch_once_t oncePredicate;</div><div class=\"line\">    dispatch_once(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)start &#123;</div><div class=\"line\">[self.lock lock];</div><div class=\"line\">if ([self isCancelled]) &#123;</div><div class=\"line\">    [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class=\"line\">&#125; else if ([self isReady]) &#123;</div><div class=\"line\">    self.state = AFOperationExecutingState;</div><div class=\"line\">    [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class=\"line\">&#125;</div><div class=\"line\">[self.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"GCD定时器的实现\"><a href=\"#GCD定时器的实现\" class=\"headerlink\" title=\"GCD定时器的实现\"></a>GCD定时器的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)gcdTimer&#123;</div><div class=\"line\"></div><div class=\"line\">// get the queue</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\"></div><div class=\"line\">// creat timer</div><div class=\"line\">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">// config the timer (starting time，interval)</div><div class=\"line\">// set begining time</div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class=\"line\">// set the interval</div><div class=\"line\">uint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class=\"line\"></div><div class=\"line\">dispatch_source_set_timer(self.timer, start, interver, 0.0);</div><div class=\"line\"></div><div class=\"line\">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class=\"line\"></div><div class=\"line\">    // the tarsk needed to be processed async</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">            NSLog(@&quot;gcdTimer&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_resume(self.timer);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"谈谈你对Run-Loop的理解\"><a href=\"#谈谈你对Run-Loop的理解\" class=\"headerlink\" title=\"谈谈你对Run Loop的理解\"></a>谈谈你对Run Loop的理解</h2><ul>\n<li>RunLoop是多线程的一个很重要的机制，就是一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程会通过do-while死循环让程序持续等待下一个任务不退出。通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。非主线程通常来说就是为了执行某个任务而创建的，执行完就会归还资源，因此默认不开启RunLoop</li>\n<li>实质上，对于子线程的runloop是默认不存在的，因为苹果采用了懒加载的方式，如果没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询当前线程的RunLoop，也不会创建、加载</li>\n<li><p>当然如果子线程处理完某个任务后不退出，需要继续等待接受事件，需要启动的时候也可以手动启动，比如说添加定时器的时候就要手动开始RunLoop<br>如何处理事件</p>\n</li>\n<li><p>界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n</li>\n<li><p>手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</li>\n<li><p>网络请求：最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLConnection是iOS7中新增的接口。当网络开始传输时，NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket线程是处理底层socket连接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接受底层socket的事件，并添加到上层的Delegate</p>\n</li>\n</ul>\n<p>应用</p>\n<ul>\n<li><p>滑动与图片刷新：当tableView的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程回去加载图片，加载完成后主线程会设置cell的图片，但是会造成卡顿。可以设置图片的任务在CFRunloopDefaultMode下进行，当滚动tableView的时候，Runloop切换到UITrackingRunLoopMode，不去设置图片，而是而是当停止的时候，再去设置图片。（在viewDidLoad中调用self.imageView performSelector@selector(setImage) withObject:…afterDelay:…inModes@[NSDefayltRunLoopMode]）</p>\n</li>\n<li><p>常驻子线程，保持子线程一直处理事件 为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出</p>\n</li>\n</ul>\n<h2 id=\"RunLoop处理的几种事件\"><a href=\"#RunLoop处理的几种事件\" class=\"headerlink\" title=\"RunLoop处理的几种事件\"></a>RunLoop处理的几种事件</h2><blockquote>\n<p>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong>();<br>static void <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong>();</p>\n</blockquote>\n<p>他对这六类事件有如下解释</p>\n<p>1.Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。</p>\n<p>2.Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。</p>\n<p>3.Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。</p>\n<p>4.Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。CADisplayLink也是这里触发</p>\n<p>5.Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。<br>[self performSelector:@selector(perform1) withObject:nil];是走source0的</p>\n<p>6.Source1事件：处理系统内核的mach_msg事件。</p>\n<p>验证方法是，打断点，lldb上边的调用栈</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果我们想要打断一个方法的执行，一个办法就是用<code>[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</code>来连接方法的执行，这里延迟时间设置为0有时是无效的，我们可以给一个很小的时间，</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1.基本概念\"></a>1.基本概念</h2><h3 id=\"为什么需要runloop\"><a href=\"#为什么需要runloop\" class=\"headerlink\" title=\"为什么需要runloop\"></a>为什么需要runloop</h3><ul>\n<li>使程序一直活着</li>\n<li>决定程序何时应该处理哪些event</li>\n<li>调用解耦(message queue)</li>\n<li>节省CPU时间</li>\n<li>开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源</li>\n</ul>\n<h3 id=\"与runloop相关的类\"><a href=\"#与runloop相关的类\" class=\"headerlink\" title=\"与runloop相关的类\"></a>与runloop相关的类</h3><ul>\n<li>NSTimer</li>\n<li>UIEvent</li>\n<li>Autorelease</li>\n<li>NSObjec–&gt;NSDelayedPerforming</li>\n<li>NSObjec–&gt;NSThreadPerformAddition</li>\n<li>CADisplayLink</li>\n<li>CATransition</li>\n<li>CAAnimation</li>\n<li>dispatch_get_main_queue()</li>\n<li>NSURLConnection</li>\n</ul>\n<h3 id=\"runloop与线程\"><a href=\"#runloop与线程\" class=\"headerlink\" title=\"runloop与线程\"></a>runloop与线程</h3><ul>\n<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>\n<li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li>\n<li>RunLoop在第一次<code>获取时创建</code>，在线程结束时销毁</li>\n<li>一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件，比如说主线程。</li>\n<li>线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从苹果公开的源码中看出来)，其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式</li>\n</ul>\n<h3 id=\"获取runloop\"><a href=\"#获取runloop\" class=\"headerlink\" title=\"获取runloop\"></a>获取runloop</h3><blockquote>\n<p>Foundation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</div><div class=\"line\">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</div></pre></td></tr></table></figure></p>\n<p>Core Foundation<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</div><div class=\"line\">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"runloop基本结构\"><a href=\"#runloop基本结构\" class=\"headerlink\" title=\"runloop基本结构\"></a>runloop基本结构</h3><p><code>NSRunLoop继承自NSObject</code><br><img src=\"http://i1.piimg.com/567571/d478dc563d0af5b8.png\" alt=\"\"></p>\n<ul>\n<li>runloop与Thread一一对应，但是并不是一个thread只能有一runloop，我们可以给runloop嵌套runloop</li>\n</ul>\n<h4 id=\"CFRunLoopMode\"><a href=\"#CFRunLoopMode\" class=\"headerlink\" title=\"CFRunLoopMode\"></a>CFRunLoopMode</h4><ul>\n<li>CFRunLoopModeRef代表RunLoop的运行模式<ul>\n<li>一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source/Timer/Observer</li>\n<li>每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode</li>\n<li>如果需要切换Mode，只能退出Loop，再重新指定一个Mode进入</li>\n<li>这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://i1.piimg.com/567571/83261feb726f1627.png\" alt=\"\"></p>\n<blockquote>\n<p>系统默认注册了5个Mode:(前两个跟最后一个常用)</p>\n<ul>\n<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>\n<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>\n<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mod<br><img src=\"http://i1.piimg.com/567571/8d1aff60c4248ca3.png\" alt=\"\"><h4 id=\"CFRunLoopSource\"><a href=\"#CFRunLoopSource\" class=\"headerlink\" title=\"CFRunLoopSource\"></a>CFRunLoopSource</h4></li>\n<li>CFRunLoopSourceRef是事件源（输入源）</li>\n<li>按照官方文档的分类<ul>\n<li>Port-Based Sources (基于端口,跟其他线程交互,通过内核发布的消息)</li>\n<li>Custom Input Sources (自定义)</li>\n<li>Cocoa Perform Selector Sources (performSelector…方法)</li>\n</ul>\n</li>\n<li>按照函数调用栈的分类<ul>\n<li>Source0：非基于Port的</li>\n<li>Source1：基于Port的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>Source0: event事件，只含有回调，需要先调用CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop。<br>Source1: 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。</p>\n<h4 id=\"CFRunLoopTimer\"><a href=\"#CFRunLoopTimer\" class=\"headerlink\" title=\"CFRunLoopTimer\"></a>CFRunLoopTimer</h4><p>本质就是一个timer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div><div class=\"line\">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</div><div class=\"line\">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;//该方法定义在RunLoop中，不过是NSObject的分类；</div><div class=\"line\">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;//这个类方法定义在DisPlayLink中</div><div class=\"line\">- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode;//这也是DisPlayLink中的方法</div></pre></td></tr></table></figure></p>\n<ul>\n<li>CFRunLoopTimerRef是基于时间的触发器</li>\n<li>基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响</li>\n<li>GCD的定时器不受RunLoop的Mode影响<h4 id=\"CFRunLoopObserver\"><a href=\"#CFRunLoopObserver\" class=\"headerlink\" title=\"CFRunLoopObserver\"></a>CFRunLoopObserver</h4></li>\n<li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</li>\n<li>可以监听的时间点有以下几个</li>\n</ul>\n<p><img src=\"http://img8.a.pcs.baidu.com/rest/2.0/pcs/thumbnail?method=generate&amp;path=%2Fimages%2FSnip20160721_13.png&amp;app_id=246327&amp;width=1600&amp;height=1600\" alt=\"\"></p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li>CADisplayLink</li>\n<li>NSTimer</li>\n<li>ImageView显示</li>\n<li>PerformSelector</li>\n<li>常驻线程</li>\n<li>自动释放池</li>\n<li>NSURLConnection的执行过程</li>\n<li>AFNetWorking中是如何使用RunLoop的?</li>\n</ul>\n<h3 id=\"深入理解Perform-Selector\"><a href=\"#深入理解Perform-Selector\" class=\"headerlink\" title=\"深入理解Perform Selector\"></a>深入理解Perform Selector</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnMianThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">        [self performSelector:@selector(perform1) withObject:nil];</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)mainThreadMethod&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__func__);</div><div class=\"line\"></div><div class=\"line\">// print: execute -[ViewController mainThreadMethod]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)backGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;%u&quot;,[NSThread isMainThread]);</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样我们在ViewDidLoad中调用tryPerformSelectorOnMianThread,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];<br>上边的performselector在子线程中依然可以执行，因为它不依赖于timer，不需要启动runloop，但是下边的做法就不行。</p>\n<p>和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)backGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;%u&quot;,[NSThread isMainThread]);</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;execute %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样的，我们调用tryPerformSelectorOnBackGroundThread这个方法，我们会发现，下面的backGroundThread不会被调用，这是什么原因呢？<br>这是因为，在调用performSelector:onThread: withObject: waitUntilDone的时候，系统会给我们创建一个Timer的source，加到对应的RunLoop上去，然而这个时候我们没有RunLoop,如果我们加上RunLoop:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)tryPerformSelectorOnBackGroundThread&#123;</div><div class=\"line\"></div><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</div><div class=\"line\"></div><div class=\"line\">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">[runLoop run];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这时就会发现我们的方法正常被调用了。那么为什么主线程中的perfom selector却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。<br>小结:当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop</p>\n<h3 id=\"Perform-Selector-after\"><a href=\"#Perform-Selector-after\" class=\"headerlink\" title=\"Perform Selector after\"></a>Perform Selector after</h3><p>当某个事件触发了某段代码执行的时候，是要在一个runloop中执行完毕的，如果这个线程有runloop的话，这样如果在一个主线程有一大段代码要执行，那么就会阻碍这个线程，或者更准确来讲是让这个runloop不能去处理用户事件和刷新屏幕，那该怎么办呢？<br>答案就是这个方法<code>- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay</code>我们可以把一个大段的方法执行切分成几份，然后用该方法连接，每次执行这个方法，就会进入到下一个runloop才会执行，而每个runloop的执行，用户事件的处理和屏幕刷新是在代码执行前边的，所以这样就有机会中断代码的执行，就像是下边这样<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) UIButton *btn1;</div><div class=\"line\">@property (nonatomic, strong) UIButton *btn2;</div><div class=\"line\">@property (nonatomic, assign) BOOL next;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">int b = 0;</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn1 &#123;</div><div class=\"line\">    if (!_btn1) &#123;</div><div class=\"line\">        _btn1 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn1 setTitle:@&quot;点我1&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn1 sizeToFit];</div><div class=\"line\">        [_btn1 addTarget:self action:@selector(click1) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">        [_btn1 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn2 &#123;</div><div class=\"line\">    if (!_btn2) &#123;</div><div class=\"line\">        _btn2 = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn2 setTitle:@&quot;点我2&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn2 sizeToFit];</div><div class=\"line\">        [_btn2 addTarget:self action:@selector(click2) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">        [_btn2 setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.btn1];</div><div class=\"line\">    [self.view addSubview:self.btn2];</div><div class=\"line\">    </div><div class=\"line\">    self.btn1.frame = CGRectMake(10, 30, 50, 20);</div><div class=\"line\">    self.btn2.frame = CGRectMake(100, 30, 50, 20);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)click1 &#123;</div><div class=\"line\">    </div><div class=\"line\">    for (int i = 0; i &lt; 3000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">[self performSelector:@selector(perform1) withObject:nil afterDelay:0.005];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform1 &#123;</div><div class=\"line\">    for (int i = 3000; i &lt; 6000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform4 &#123;</div><div class=\"line\">    if (!_next) return;</div><div class=\"line\">    for (int i = 6000; i &lt; 9000; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">    [self performSelector:@selector(perform5) withObject:nil afterDelay:0.005];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)perform5 &#123;</div><div class=\"line\">    if (!_next) return;</div><div class=\"line\">    for (int i = 600; i &lt; 900; i++) &#123;</div><div class=\"line\">        NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)click2 &#123;</div><div class=\"line\">    _next = NO;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实验证明，只有after方法有这样的魔力。</p>\n<blockquote>\n<p>总结:当我们创建了一个timer事件的时候，这个时候这个事件就会被放到下一个runloop中执行，如果这个线程中根本就没有起runloop，那么也就不存在下一个runloop，这个事件也就永远不会被执行了。</p>\n</blockquote>\n<h3 id=\"CADisplayLink\"><a href=\"#CADisplayLink\" class=\"headerlink\" title=\"CADisplayLink\"></a>CADisplayLink</h3><p>用法和timer一样，放在子线程的话记得自己创建runloop<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">           // Track FPS using display link</div><div class=\"line\">           _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkTick)];</div><div class=\"line\">   //        [_displayLink setPaused:YES];</div><div class=\"line\">           [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</div><div class=\"line\">           [[NSRunLoop currentRunLoop] run];</div><div class=\"line\">       &#125;);</div></pre></td></tr></table></figure></p>\n<h3 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">@property (nonatomic, strong) UIScrollView *scrollView;</div><div class=\"line\">@property (nonatomic, assign) NSInteger count;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.scrollView];</div><div class=\"line\"> </div><div class=\"line\">    NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(printfString) userInfo:nil repeats:YES];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode兼容,timer就都可以跑了</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIScrollView *)scrollView &#123;</div><div class=\"line\">    if (!_scrollView) &#123;</div><div class=\"line\">        _scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, kScreenW, 200)];</div><div class=\"line\">        _scrollView.backgroundColor = [UIColor redColor];</div><div class=\"line\">        _scrollView.contentSize = CGSizeMake(kScreenW * 2, 0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _scrollView;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)printfString &#123;</div><div class=\"line\">    self.count ++;</div><div class=\"line\">    NSLog(@&quot;%ld&quot;, self.count);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">    NSTimer *myTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</div><div class=\"line\"></div><div class=\"line\">    [myTimer fire];</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的,既然需要注册到RunLoop,那么我们就需要有一个RunLoop,我们在后台线程中加入如下的代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">    [runLoop run];</div></pre></td></tr></table></figure></p>\n<p>这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做tolerance,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个CADisplayLink,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在最后会给予说明。</p>\n<h3 id=\"ImageView\"><a href=\"#ImageView\" class=\"headerlink\" title=\"ImageView\"></a>ImageView</h3><p>需求:当用户在拖拽时(UI交互时)不显示图片,拖拽完成时显示图片</p>\n<p>方法1 监听UIScrollerView滚动 (通过UIScrollViewDelegate监听,此处不再举例)</p>\n<p>方法2 RunLoop 设置运行模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只在NSDefaultRunLoopMode模式下显示图片</div><div class=\"line\">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>\n<p>比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片</p>\n<h3 id=\"一直活着的后台线程\"><a href=\"#一直活着的后台线程\" class=\"headerlink\" title=\"一直活着的后台线程\"></a>一直活着的后台线程</h3><p>现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic,strong) NSThread *myThread;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (void)alwaysLiveBackGoundThread&#123;</div><div class=\"line\"></div><div class=\"line\">NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(myThreadRun) object:@&quot;etund&quot;];</div><div class=\"line\">self.myThread = thread;</div><div class=\"line\">[self.myThread start];</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)myThreadRun&#123;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;my thread run&quot;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;%@&quot;,self.myThread);</div><div class=\"line\">    [self performSelector:@selector(doBackGroundThreadWork) onThread:self.myThread withObject:nil waitUntilDone:NO];</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)doBackGroundThreadWork&#123;</div><div class=\"line\"></div><div class=\"line\">    NSLog(@&quot;do some work %s&quot;,__FUNCTION__);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>这个方法中，我们利用一个强引用来获取了后天线程中的thread,然后在点击屏幕的时候，在这个线程上执行doBackGroundThreadWork这个方法，此时我们可以看到，在touchesBegin方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:新建状态、就绪状态、运行状态、阻塞状态、死亡状态，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(有工作的强烈愿望而不死亡):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)myThreadRun&#123;</div><div class=\"line\"></div><div class=\"line\">[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">[[NSRunLoop currentRunLoop] run]</div><div class=\"line\"></div><div class=\"line\">  NSLog(@&quot;my thread run&quot;);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。<br>小结:正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在</p>\n<h3 id=\"NSURLConnection的执行过程\"><a href=\"#NSURLConnection的执行过程\" class=\"headerlink\" title=\"NSURLConnection的执行过程\"></a>NSURLConnection的执行过程</h3><p>在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了[connection start]之后，这个Delegate会不停的收到事件的回调。实际上，start这个函数的内部会获取CurrentRunloop，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:<br><img src=\"006.png\" alt=\"\"><br>从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(唤醒)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (!_isEndRequest)</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;entered run loop&quot;);</div><div class=\"line\">    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">NSLog(@&quot;main finished，task be removed&quot;);</div><div class=\"line\"></div><div class=\"line\">- (void)connectionDidFinishLoading:(NSURLConnection *)connection</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">  _isEndRequest = YES;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们就可以解决下面这些疑问了:<br></p>\n<ul>\n<li>为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。</li>\n<li>如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。</li>\n<li>既然[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调唤醒了这个线程，让它在这里循环。</li>\n</ul>\n<h3 id=\"AFNetWorking中是如何使用RunLoop的\"><a href=\"#AFNetWorking中是如何使用RunLoop的\" class=\"headerlink\" title=\"AFNetWorking中是如何使用RunLoop的?\"></a>AFNetWorking中是如何使用RunLoop的?</h3><p>在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。<br>为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加item<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</div><div class=\"line\">@autoreleasepool &#123;</div><div class=\"line\">    [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</div><div class=\"line\">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class=\"line\">    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</div><div class=\"line\">    [runLoop run];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+ (NSThread *)networkRequestThread &#123;</div><div class=\"line\">    static NSThread *_networkRequestThread = nil;</div><div class=\"line\">    static dispatch_once_t oncePredicate;</div><div class=\"line\">    dispatch_once(&amp;oncePredicate, ^&#123;</div><div class=\"line\">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</div><div class=\"line\">        [_networkRequestThread start];</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return _networkRequestThread;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里这个NSMachPort的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:[NSObject performSelector:onThread:..]来将这个任务扔给后台线程的RunLoop中来执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)start &#123;</div><div class=\"line\">[self.lock lock];</div><div class=\"line\">if ([self isCancelled]) &#123;</div><div class=\"line\">    [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class=\"line\">&#125; else if ([self isReady]) &#123;</div><div class=\"line\">    self.state = AFOperationExecutingState;</div><div class=\"line\">    [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</div><div class=\"line\">&#125;</div><div class=\"line\">[self.lock unlock];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"GCD定时器的实现\"><a href=\"#GCD定时器的实现\" class=\"headerlink\" title=\"GCD定时器的实现\"></a>GCD定时器的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)gcdTimer&#123;</div><div class=\"line\"></div><div class=\"line\">// get the queue</div><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class=\"line\"></div><div class=\"line\">// creat timer</div><div class=\"line\">self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class=\"line\">// config the timer (starting time，interval)</div><div class=\"line\">// set begining time</div><div class=\"line\">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));</div><div class=\"line\">// set the interval</div><div class=\"line\">uint64_t interver = (uint64_t)(1.0 * NSEC_PER_SEC);</div><div class=\"line\"></div><div class=\"line\">dispatch_source_set_timer(self.timer, start, interver, 0.0);</div><div class=\"line\"></div><div class=\"line\">dispatch_source_set_event_handler(self.timer, ^&#123;</div><div class=\"line\"></div><div class=\"line\">    // the tarsk needed to be processed async</div><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; 100000; i++) &#123;</div><div class=\"line\">            NSLog(@&quot;gcdTimer&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">dispatch_resume(self.timer);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"谈谈你对Run-Loop的理解\"><a href=\"#谈谈你对Run-Loop的理解\" class=\"headerlink\" title=\"谈谈你对Run Loop的理解\"></a>谈谈你对Run Loop的理解</h2><ul>\n<li>RunLoop是多线程的一个很重要的机制，就是一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程会通过do-while死循环让程序持续等待下一个任务不退出。通过mach_msg()让runloop没事时进入trap状态，节省CPU资源。非主线程通常来说就是为了执行某个任务而创建的，执行完就会归还资源，因此默认不开启RunLoop</li>\n<li>实质上，对于子线程的runloop是默认不存在的，因为苹果采用了懒加载的方式，如果没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询当前线程的RunLoop，也不会创建、加载</li>\n<li><p>当然如果子线程处理完某个任务后不退出，需要继续等待接受事件，需要启动的时候也可以手动启动，比如说添加定时器的时候就要手动开始RunLoop<br>如何处理事件</p>\n</li>\n<li><p>界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n</li>\n<li><p>手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</li>\n<li><p>网络请求：最底层是CFSocket层，然后是CFNetwork将其封装，然后是NSURLConnection对CFNetwork进行面向对象的封装，NSURLConnection是iOS7中新增的接口。当网络开始传输时，NSURLConnection创建了两个新线程：com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket线程是处理底层socket连接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接受底层socket的事件，并添加到上层的Delegate</p>\n</li>\n</ul>\n<p>应用</p>\n<ul>\n<li><p>滑动与图片刷新：当tableView的cell上有需要从网络获取的图片的时候，滚动tableView，异步线程回去加载图片，加载完成后主线程会设置cell的图片，但是会造成卡顿。可以设置图片的任务在CFRunloopDefaultMode下进行，当滚动tableView的时候，Runloop切换到UITrackingRunLoopMode，不去设置图片，而是而是当停止的时候，再去设置图片。（在viewDidLoad中调用self.imageView performSelector@selector(setImage) withObject:…afterDelay:…inModes@[NSDefayltRunLoopMode]）</p>\n</li>\n<li><p>常驻子线程，保持子线程一直处理事件 为了保证线程长期运转，可以在子线程中加入RunLoop，并且给Runloop设置item，防止Runloop自动退出</p>\n</li>\n</ul>\n<h2 id=\"RunLoop处理的几种事件\"><a href=\"#RunLoop处理的几种事件\" class=\"headerlink\" title=\"RunLoop处理的几种事件\"></a>RunLoop处理的几种事件</h2><blockquote>\n<p>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong>();<br>static void <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong>();<br>static void <strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong>();</p>\n</blockquote>\n<p>他对这六类事件有如下解释</p>\n<p>1.Observer事件，runloop中状态变化时进行通知。（微信卡顿监控就是利用这个事件通知来记录下最近一次main runloop活动时间，在另一个check线程中用定时器检测当前时间距离最后一次活动时间过久来判断在主线程中的处理逻辑耗时和卡主线程）。这里还需要特别注意，CAAnimation是由RunloopObserver触发回调来重绘，接下来会讲到。</p>\n<p>2.Block事件，非延迟的NSObject PerformSelector立即调用，dispatch_after立即调用，block回调。</p>\n<p>3.Main_Dispatch_Queue事件：GCD中dispatch到main queue的block会被dispatch到main loop执行。</p>\n<p>4.Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。CADisplayLink也是这里触发</p>\n<p>5.Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。<br>[self performSelector:@selector(perform1) withObject:nil];是走source0的</p>\n<p>6.Source1事件：处理系统内核的mach_msg事件。</p>\n<p>验证方法是，打断点，lldb上边的调用栈</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>如果我们想要打断一个方法的执行，一个办法就是用<code>[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</code>来连接方法的执行，这里延迟时间设置为0有时是无效的，我们可以给一个很小的时间，</p>\n"},{"title":"category内部实现原理","date":"2015-12-15T07:28:20.000Z","_content":"见过的比较好的一篇讲述category实现的博客，在此做个记录\n<!--more-->\n\n转载自：<http://tech.meituan.com/DiveIntoCategory.html>\n\n无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。\n\n简介\n\n本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。\n本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：\n\n- 初入宝地-category简介\n- 连类比事-category和extension\n- 挑灯细览-category真面目\n- 追本溯源-category如何加载\n- 旁枝末叶-category和+load方法\n- 触类旁通-category和方法覆盖\n- 更上一层-category和关联对象\n\n##  1、初入宝地-category简介\n\ncategory是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1\n\n- 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。\n- 声明私有方法\n\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\n- 模拟多继承\n- 把framework的私有方法公开\n\nObjective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。\n\n## 2、连类比事-category和extension\n\nextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）\n\n但是category则完全不一样，它是在运行期决议的。\n就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。\n\n##  3、挑灯细览-category真面目\n\n我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了\n1)、类的名字（name）\n2)、类（cls）\n3)、category中所有给类添加的实例方法的列表（instanceMethods）\n4)、category中所有添加的类方法的列表（classMethods）\n5)、category实现的所有协议的列表（protocols）\n6)、category中添加的所有属性（instanceProperties）\n\n```\ntypedef struct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n} category_t;\n```\n\n\n\n\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\nok，我们先去写一个category看一下category到底为何物：\n```\nMyClass.h：\n\n\n#import <Foundation/Foundation.h>\n\n@interface MyClass : NSObject\n\n- (void)printName;\n\n@end\n\n@interface MyClass(MyAddition)\n\n@property(nonatomic, copy) NSString *name;\n\n- (void)printName;\n\n@end\n\n\n\n\n\nMyClass.m：\n\n\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyClass\");\n}\n\n@end\n\n@implementation MyClass(MyAddition)\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyAddition\");\n}\n\n@end\n```\n\n\n\n\n我们使用clang的命令去看看category到底会变成什么：\n\n\nclang -rewrite-objc MyClass.m\n\n\n\n\n\n好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：\n\n```\nstatic struct /*_method_list_t*/ {\nunsigned int entsize;  // sizeof(struct _objc_method)\nunsigned int method_count;\nstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_objc_method),\n1,\n{{(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName}}\n};\n\nstatic struct /*_prop_list_t*/ {\nunsigned int entsize;  // sizeof(struct _prop_t)\nunsigned int count_of_properties;\nstruct _prop_t prop_list[1];\n} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_prop_t),\n1,\n{{\"name\",\"T@\\\"NSString\\\",C,N\"}}\n};\n\nextern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;\n\nstatic struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n\"MyClass\",\n0, // &OBJC_CLASS_$_MyClass,\n(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,\n0,\n0,\n(const struct _prop_list_t *)&_OBJC_$_PROP_LIST_MyClass_$_MyAddition,\n};\nstatic void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) {\n_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &OBJC_CLASS_$_MyClass;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n(void *)&OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,\n};\nstatic struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n&_OBJC_$_CATEGORY_MyClass_$_MyAddition,\n};\n```\n\n\n我们可以看到，\n1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。\n2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。\n3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。\n到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。\n\n4、追本溯源-category如何加载\n\n我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。\n想了解更多dyld地同学可以移步这里（3）。\n\n对于OC运行时，入口方法如下（在objc-os.mm文件中）：\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n\n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    lock_init();\n    exception_init();\n\n    // Register for unmap first, in case some +load unmaps something\n    _dyld_register_func_for_remove_image(&unmap_image);\n    dyld_register_image_state_change_handler(dyld_image_state_bound,\n                                            1/*batch*/, &map_images);\n    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n}\n```\n\n\n\n\ncategory被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：\n\n```\n// Discover categories.\n    for (EACH_HEADER) {\n        category_t **catlist =\n            _getObjc2CategoryList(hi, &count);\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            class_t *cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = NULL;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                \"missing weak-linked target class\",\n                                cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category.\n            // First, register the category with its target class.\n            // Then, rebuild the class's method lists (etc) if\n            // the class is realized.\n            BOOL classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols\n                ||  cat->instanceProperties)\n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (isRealized(cls)) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\",\n                                getName(cls), cat->name,\n                                classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols\n                /* ||  cat->classProperties */)\n            {\n                addUnattachedCategoryForClass(cat, cls->isa, hi);\n                if (isRealized(cls->isa)) {\n                    remethodizeClass(cls->isa);\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\",\n                                getName(cls), cat->name);\n                }\n            }\n        }\n    }\n\n```\n\n\n\n首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。\n略去PrintConnecting这个用于log的东西，这段代码很容易理解：\n1)、把category的实例方法、协议以及属性添加到类上\n2)、把category的类方法和协议添加到类的metaclass上\n\n值得注意的是，在代码中有一小段注释 / || cat->classProperties /，看来苹果有过给类添加属性的计划啊。\nok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：\n在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。\n\n```\nstatic void remethodizeClass(class_t *cls)\n{\n    category_list *cats;\n    BOOL isMeta;\n\n    rwlock_assert_writing(&runtimeLock);\n\n    isMeta = isMetaClass(cls);\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls))) {\n        chained_property_list *newproperties;\n        const protocol_list_t **newprotos;\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\",\n                        getName(cls), isMeta ? \"(meta)\" : \"\");\n        }\n\n        // Update methods, properties, protocols\n\n        BOOL vtableAffected = NO;\n        attachCategoryMethods(cls, cats, &vtableAffected);\n\n        newproperties = buildPropertyList(NULL, cats, isMeta);\n        if (newproperties) {\n            newproperties->next = cls->data()->properties;\n            cls->data()->properties = newproperties;\n        }\n\n        newprotos = buildProtocolList(cats, NULL, cls->data()->protocols);\n        if (cls->data()->protocols  &&  cls->data()->protocols != newprotos) {\n            _free_internal(cls->data()->protocols);\n        }\n        cls->data()->protocols = newprotos;\n\n        _free_internal(cats);\n\n        // Update method caches and vtables\n        flushCaches(cls);\n        if (vtableAffected) flushVtables(cls);\n    }\n}\n\n```\n\n\n\n而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：\n\n```\nstatic void\nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n\n\n\n\nattachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：\n\n```\nfor (uint32_t m = 0;\n            (scanForCustomRR || scanForCustomAWZ)  &&  m < mlist->count;\n            m++)\n        {\n            SEL sel = method_list_nth(mlist, m)->name;\n            if (scanForCustomRR  &&  isRRSelector(sel)) {\n                cls->setHasCustomRR();\n                scanForCustomRR = false;\n            } else if (scanForCustomAWZ  &&  isAWZSelector(sel)) {\n                cls->setHasCustomAWZ();\n                scanForCustomAWZ = false;\n            }\n        }\n\n        // Fill method list array\n        newLists[newCount++] = mlist;\n    .\n    .\n    .\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n```\n\n\n\n\n需要注意的有两点：\n1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA\n2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。\n\n## 5、旁枝末叶-category和+load方法\n\n我们知道，在类和category中都可以有+load方法，那么有两个问题：\n1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？\n2)、这么些个+load方法，调用顺序是咋样的呢？\n鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：\n\n我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。\n在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:\n\n运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：\n```\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n```\n所以，对于上面两个问题，答案是很明显的：\n1)、可以调用，因为附加category到类的工作会先于+load方法的执行\n2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。\n目前的编译顺序是这样的：\n\n我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：\n```\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n```\n虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。\n这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。\n\n### 6、触类旁通-category和方法覆盖\n\n鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:\n怎么调用到原来类中被category覆盖掉的方法？\n对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：\n\n```\nClass currentClass = [MyClass class];\nMyClass *my = [[MyClass alloc] init];\n\nif (currentClass) {\n    unsigned int methodCount;\n    Method *methodList = class_copyMethodList(currentClass, &methodCount);\n    IMP lastImp = NULL;\n    SEL lastSel = NULL;\n    for (NSInteger i = 0; i < methodCount; i++) {\n        Method method = methodList[i];\n        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))\n                                        encoding:NSUTF8StringEncoding];\n        if ([@\"printName\" isEqualToString:methodName]) {\n            lastImp = method_getImplementation(method);\n            lastSel = method_getName(method);\n        }\n    }\n    typedef void (*fn)(id,SEL);\n\n    if (lastImp != NULL) {\n        fn f = (fn)lastImp;\n        f(my,lastSel);\n    }\n    free(methodList);\n}\n```\n\n\n\n\n## 7、更上一层-category和关联对象\n\n如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。\n```\nMyClass+Category1.h:\n\n\n#import \"MyClass.h\"\n\n@interface MyClass (Category1)\n\n@property(nonatomic,copy) NSString *name;\n\n@end\n\n\n\n\n\nMyClass+Category1.m:\n\n\n#import \"MyClass+Category1.h\"\n#import <objc/runtime.h>\n\n@implementation MyClass (Category1)\n\n+ (void)load\n{\n    NSLog(@\"%@\",@\"load in Category1\");\n}\n\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self,\n                            \"name\",\n                            name,\n                            OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)name\n{\n    NSString *nameObject = objc_getAssociatedObject(self, \"name\");\n    return nameObject;\n}\n\n@end\n```\n\n\n\n\n但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？\n我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：\n```\n\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        if (new_value) {\n            // break any existing association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n```\n\n\n\n\n我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：\n\n```\nclass AssociationsManager {\n    static OSSpinLock _lock;\n    static AssociationsHashMap *_map;              // associative references:  object pointer -> PtrPtrHashMap.\npublic:\n    AssociationsManager()  { OSSpinLockLock(&_lock); }\n    ~AssociationsManager()  { OSSpinLockUnlock(&_lock); }\n\n    AssociationsHashMap &associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};\n```\n\n\n\n\nAssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n而在对象的销毁逻辑里面，见objc-runtime-new.mm:\n\n```\nvoid *objc_destructInstance(id obj)\n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n\n```\n\n\n\n嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n\n后记\n\n正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。\n本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。\n","source":"_posts/2015/category内部实现原理.md","raw":"---\ntitle: category内部实现原理\ndate: 2015-12-15 15:28:20\ntags:\n- iOS进阶\ncategories: iOS\n---\n见过的比较好的一篇讲述category实现的博客，在此做个记录\n<!--more-->\n\n转载自：<http://tech.meituan.com/DiveIntoCategory.html>\n\n无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。\n\n简介\n\n本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。\n本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：\n\n- 初入宝地-category简介\n- 连类比事-category和extension\n- 挑灯细览-category真面目\n- 追本溯源-category如何加载\n- 旁枝末叶-category和+load方法\n- 触类旁通-category和方法覆盖\n- 更上一层-category和关联对象\n\n##  1、初入宝地-category简介\n\ncategory是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1\n\n- 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。\n- 声明私有方法\n\n不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：\n\n- 模拟多继承\n- 把framework的私有方法公开\n\nObjective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。\n\n## 2、连类比事-category和extension\n\nextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）\n\n但是category则完全不一样，它是在运行期决议的。\n就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。\n\n##  3、挑灯细览-category真面目\n\n我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了\n1)、类的名字（name）\n2)、类（cls）\n3)、category中所有给类添加的实例方法的列表（instanceMethods）\n4)、category中所有添加的类方法的列表（classMethods）\n5)、category实现的所有协议的列表（protocols）\n6)、category中添加的所有属性（instanceProperties）\n\n```\ntypedef struct category_t {\n    const char *name;\n    classref_t cls;\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n} category_t;\n```\n\n\n\n\n从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。\nok，我们先去写一个category看一下category到底为何物：\n```\nMyClass.h：\n\n\n#import <Foundation/Foundation.h>\n\n@interface MyClass : NSObject\n\n- (void)printName;\n\n@end\n\n@interface MyClass(MyAddition)\n\n@property(nonatomic, copy) NSString *name;\n\n- (void)printName;\n\n@end\n\n\n\n\n\nMyClass.m：\n\n\n#import \"MyClass.h\"\n\n@implementation MyClass\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyClass\");\n}\n\n@end\n\n@implementation MyClass(MyAddition)\n\n- (void)printName\n{\n    NSLog(@\"%@\",@\"MyAddition\");\n}\n\n@end\n```\n\n\n\n\n我们使用clang的命令去看看category到底会变成什么：\n\n\nclang -rewrite-objc MyClass.m\n\n\n\n\n\n好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：\n\n```\nstatic struct /*_method_list_t*/ {\nunsigned int entsize;  // sizeof(struct _objc_method)\nunsigned int method_count;\nstruct _objc_method method_list[1];\n} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_objc_method),\n1,\n{{(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName}}\n};\n\nstatic struct /*_prop_list_t*/ {\nunsigned int entsize;  // sizeof(struct _prop_t)\nunsigned int count_of_properties;\nstruct _prop_t prop_list[1];\n} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = {\nsizeof(_prop_t),\n1,\n{{\"name\",\"T@\\\"NSString\\\",C,N\"}}\n};\n\nextern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;\n\nstatic struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =\n{\n\"MyClass\",\n0, // &OBJC_CLASS_$_MyClass,\n(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,\n0,\n0,\n(const struct _prop_list_t *)&_OBJC_$_PROP_LIST_MyClass_$_MyAddition,\n};\nstatic void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) {\n_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &OBJC_CLASS_$_MyClass;\n}\n#pragma section(\".objc_inithooks$B\", long, read, write)\n__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = {\n(void *)&OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,\n};\nstatic struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = {\n&OBJC_CLASS_$_MyClass,\n};\nstatic struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= {\n&_OBJC_$_CATEGORY_MyClass_$_MyAddition,\n};\n```\n\n\n我们可以看到，\n1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。\n2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。\n3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。\n到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。\n\n4、追本溯源-category如何加载\n\n我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。\n想了解更多dyld地同学可以移步这里（3）。\n\n对于OC运行时，入口方法如下（在objc-os.mm文件中）：\n\n```\nvoid _objc_init(void)\n{\n    static bool initialized = false;\n    if (initialized) return;\n    initialized = true;\n\n    // fixme defer initialization until an objc-using image is found?\n    environ_init();\n    tls_init();\n    lock_init();\n    exception_init();\n\n    // Register for unmap first, in case some +load unmaps something\n    _dyld_register_func_for_remove_image(&unmap_image);\n    dyld_register_image_state_change_handler(dyld_image_state_bound,\n                                            1/*batch*/, &map_images);\n    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &load_images);\n}\n```\n\n\n\n\ncategory被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：\n\n```\n// Discover categories.\n    for (EACH_HEADER) {\n        category_t **catlist =\n            _getObjc2CategoryList(hi, &count);\n        for (i = 0; i < count; i++) {\n            category_t *cat = catlist[i];\n            class_t *cls = remapClass(cat->cls);\n\n            if (!cls) {\n                // Category's target class is missing (probably weak-linked).\n                // Disavow any knowledge of this category.\n                catlist[i] = NULL;\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \"\n                                \"missing weak-linked target class\",\n                                cat->name, cat);\n                }\n                continue;\n            }\n\n            // Process this category.\n            // First, register the category with its target class.\n            // Then, rebuild the class's method lists (etc) if\n            // the class is realized.\n            BOOL classExists = NO;\n            if (cat->instanceMethods ||  cat->protocols\n                ||  cat->instanceProperties)\n            {\n                addUnattachedCategoryForClass(cat, cls, hi);\n                if (isRealized(cls)) {\n                    remethodizeClass(cls);\n                    classExists = YES;\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category -%s(%s) %s\",\n                                getName(cls), cat->name,\n                                classExists ? \"on existing class\" : \"\");\n                }\n            }\n\n            if (cat->classMethods  ||  cat->protocols\n                /* ||  cat->classProperties */)\n            {\n                addUnattachedCategoryForClass(cat, cls->isa, hi);\n                if (isRealized(cls->isa)) {\n                    remethodizeClass(cls->isa);\n                }\n                if (PrintConnecting) {\n                    _objc_inform(\"CLASS: found category +%s(%s)\",\n                                getName(cls), cat->name);\n                }\n            }\n        }\n    }\n\n```\n\n\n\n首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。\n略去PrintConnecting这个用于log的东西，这段代码很容易理解：\n1)、把category的实例方法、协议以及属性添加到类上\n2)、把category的类方法和协议添加到类的metaclass上\n\n值得注意的是，在代码中有一小段注释 / || cat->classProperties /，看来苹果有过给类添加属性的计划啊。\nok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：\n在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。\n\n```\nstatic void remethodizeClass(class_t *cls)\n{\n    category_list *cats;\n    BOOL isMeta;\n\n    rwlock_assert_writing(&runtimeLock);\n\n    isMeta = isMetaClass(cls);\n\n    // Re-methodizing: check for more categories\n    if ((cats = unattachedCategoriesForClass(cls))) {\n        chained_property_list *newproperties;\n        const protocol_list_t **newprotos;\n\n        if (PrintConnecting) {\n            _objc_inform(\"CLASS: attaching categories to class '%s' %s\",\n                        getName(cls), isMeta ? \"(meta)\" : \"\");\n        }\n\n        // Update methods, properties, protocols\n\n        BOOL vtableAffected = NO;\n        attachCategoryMethods(cls, cats, &vtableAffected);\n\n        newproperties = buildPropertyList(NULL, cats, isMeta);\n        if (newproperties) {\n            newproperties->next = cls->data()->properties;\n            cls->data()->properties = newproperties;\n        }\n\n        newprotos = buildProtocolList(cats, NULL, cls->data()->protocols);\n        if (cls->data()->protocols  &&  cls->data()->protocols != newprotos) {\n            _free_internal(cls->data()->protocols);\n        }\n        cls->data()->protocols = newprotos;\n\n        _free_internal(cats);\n\n        // Update method caches and vtables\n        flushCaches(cls);\n        if (vtableAffected) flushVtables(cls);\n    }\n}\n\n```\n\n\n\n而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：\n\n```\nstatic void\nattachCategoryMethods(class_t *cls, category_list *cats,\n                      BOOL *inoutVtablesAffected)\n{\n    if (!cats) return;\n    if (PrintReplacedMethods) printReplacements(cls, cats);\n\n    BOOL isMeta = isMetaClass(cls);\n    method_list_t **mlists = (method_list_t **)\n        _malloc_internal(cats->count * sizeof(*mlists));\n\n    // Count backwards through cats to get newest categories first\n    int mcount = 0;\n    int i = cats->count;\n    BOOL fromBundle = NO;\n    while (i--) {\n        method_list_t *mlist = cat_method_list(cats->list[i].cat, isMeta);\n        if (mlist) {\n            mlists[mcount++] = mlist;\n            fromBundle |= cats->list[i].fromBundle;\n        }\n    }\n\n    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);\n\n    _free_internal(mlists);\n\n}\n```\n\n\n\n\nattachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：\n\n```\nfor (uint32_t m = 0;\n            (scanForCustomRR || scanForCustomAWZ)  &&  m < mlist->count;\n            m++)\n        {\n            SEL sel = method_list_nth(mlist, m)->name;\n            if (scanForCustomRR  &&  isRRSelector(sel)) {\n                cls->setHasCustomRR();\n                scanForCustomRR = false;\n            } else if (scanForCustomAWZ  &&  isAWZSelector(sel)) {\n                cls->setHasCustomAWZ();\n                scanForCustomAWZ = false;\n            }\n        }\n\n        // Fill method list array\n        newLists[newCount++] = mlist;\n    .\n    .\n    .\n\n    // Copy old methods to the method list array\n    for (i = 0; i < oldCount; i++) {\n        newLists[newCount++] = oldLists[i];\n    }\n```\n\n\n\n\n需要注意的有两点：\n1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA\n2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。\n\n## 5、旁枝末叶-category和+load方法\n\n我们知道，在类和category中都可以有+load方法，那么有两个问题：\n1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？\n2)、这么些个+load方法，调用顺序是咋样的呢？\n鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：\n\n我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。\n在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:\n\n运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：\n```\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n```\n所以，对于上面两个问题，答案是很明显的：\n1)、可以调用，因为附加category到类的工作会先于+load方法的执行\n2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。\n目前的编译顺序是这样的：\n\n我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：\n```\nobjc[1187]: REPLACED: -[MyClass printName] by category Category2\nobjc[1187]: REPLACED: -[MyClass printName] by category Category1\n.\n.\n.\nobjc[1187]: LOAD: class 'MyClass' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +load\nobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +load\nobjc[1187]: LOAD: +[MyClass load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category2) load]\n.\n.\n.\nobjc[1187]: LOAD: +[MyClass(Category1) load]\n```\n虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。\n这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。\n\n### 6、触类旁通-category和方法覆盖\n\n鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:\n怎么调用到原来类中被category覆盖掉的方法？\n对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：\n\n```\nClass currentClass = [MyClass class];\nMyClass *my = [[MyClass alloc] init];\n\nif (currentClass) {\n    unsigned int methodCount;\n    Method *methodList = class_copyMethodList(currentClass, &methodCount);\n    IMP lastImp = NULL;\n    SEL lastSel = NULL;\n    for (NSInteger i = 0; i < methodCount; i++) {\n        Method method = methodList[i];\n        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))\n                                        encoding:NSUTF8StringEncoding];\n        if ([@\"printName\" isEqualToString:methodName]) {\n            lastImp = method_getImplementation(method);\n            lastSel = method_getName(method);\n        }\n    }\n    typedef void (*fn)(id,SEL);\n\n    if (lastImp != NULL) {\n        fn f = (fn)lastImp;\n        f(my,lastSel);\n    }\n    free(methodList);\n}\n```\n\n\n\n\n## 7、更上一层-category和关联对象\n\n如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。\n```\nMyClass+Category1.h:\n\n\n#import \"MyClass.h\"\n\n@interface MyClass (Category1)\n\n@property(nonatomic,copy) NSString *name;\n\n@end\n\n\n\n\n\nMyClass+Category1.m:\n\n\n#import \"MyClass+Category1.h\"\n#import <objc/runtime.h>\n\n@implementation MyClass (Category1)\n\n+ (void)load\n{\n    NSLog(@\"%@\",@\"load in Category1\");\n}\n\n- (void)setName:(NSString *)name\n{\n    objc_setAssociatedObject(self,\n                            \"name\",\n                            name,\n                            OBJC_ASSOCIATION_COPY);\n}\n\n- (NSString*)name\n{\n    NSString *nameObject = objc_getAssociatedObject(self, \"name\");\n    return nameObject;\n}\n\n@end\n```\n\n\n\n\n但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？\n我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：\n```\n\nvoid _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {\n    // retain the new value (if any) outside the lock.\n    ObjcAssociation old_association(0, nil);\n    id new_value = value ? acquireValue(value, policy) : nil;\n    {\n        AssociationsManager manager;\n        AssociationsHashMap &associations(manager.associations());\n        disguised_ptr_t disguised_object = DISGUISE(object);\n        if (new_value) {\n            // break any existing association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i != associations.end()) {\n                // secondary table exists\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    j->second = ObjcAssociation(policy, new_value);\n                } else {\n                    (*refs)[key] = ObjcAssociation(policy, new_value);\n                }\n            } else {\n                // create the new association (first time).\n                ObjectAssociationMap *refs = new ObjectAssociationMap;\n                associations[disguised_object] = refs;\n                (*refs)[key] = ObjcAssociation(policy, new_value);\n                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));\n            }\n        } else {\n            // setting the association to nil breaks the association.\n            AssociationsHashMap::iterator i = associations.find(disguised_object);\n            if (i !=  associations.end()) {\n                ObjectAssociationMap *refs = i->second;\n                ObjectAssociationMap::iterator j = refs->find(key);\n                if (j != refs->end()) {\n                    old_association = j->second;\n                    refs->erase(j);\n                }\n            }\n        }\n    }\n    // release the old value (outside of the lock).\n    if (old_association.hasValue()) ReleaseValue()(old_association);\n}\n```\n\n\n\n\n我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：\n\n```\nclass AssociationsManager {\n    static OSSpinLock _lock;\n    static AssociationsHashMap *_map;              // associative references:  object pointer -> PtrPtrHashMap.\npublic:\n    AssociationsManager()  { OSSpinLockLock(&_lock); }\n    ~AssociationsManager()  { OSSpinLockUnlock(&_lock); }\n\n    AssociationsHashMap &associations() {\n        if (_map == NULL)\n            _map = new AssociationsHashMap();\n        return *_map;\n    }\n};\n```\n\n\n\n\nAssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。\n而在对象的销毁逻辑里面，见objc-runtime-new.mm:\n\n```\nvoid *objc_destructInstance(id obj)\n{\n    if (obj) {\n        Class isa_gen = _object_getClass(obj);\n        class_t *isa = newcls(isa_gen);\n\n        // Read all of the flags at once for performance.\n        bool cxx = hasCxxStructors(isa);\n        bool assoc = !UseGC && _class_instancesHaveAssociatedObjects(isa_gen);\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n\n        if (!UseGC) objc_clear_deallocating(obj);\n    }\n\n    return obj;\n}\n\n```\n\n\n\n嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。\n\n后记\n\n正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。\n本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。\n","slug":"2015/category内部实现原理","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmm002msaualra0a8td","content":"<p>见过的比较好的一篇讲述category实现的博客，在此做个记录<br><a id=\"more\"></a></p>\n<p>转载自：<a href=\"http://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"external\">http://tech.meituan.com/DiveIntoCategory.html</a></p>\n<p>无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。</p>\n<p>简介</p>\n<p>本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。<br>本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：</p>\n<ul>\n<li>初入宝地-category简介</li>\n<li>连类比事-category和extension</li>\n<li>挑灯细览-category真面目</li>\n<li>追本溯源-category如何加载</li>\n<li>旁枝末叶-category和+load方法</li>\n<li>触类旁通-category和方法覆盖</li>\n<li>更上一层-category和关联对象</li>\n</ul>\n<h2 id=\"1、初入宝地-category简介\"><a href=\"#1、初入宝地-category简介\" class=\"headerlink\" title=\"1、初入宝地-category简介\"></a>1、初入宝地-category简介</h2><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1</p>\n<ul>\n<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li>\n<li>声明私有方法</li>\n</ul>\n<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>\n<ul>\n<li>模拟多继承</li>\n<li>把framework的私有方法公开</li>\n</ul>\n<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>\n<h2 id=\"2、连类比事-category和extension\"><a href=\"#2、连类比事-category和extension\" class=\"headerlink\" title=\"2、连类比事-category和extension\"></a>2、连类比事-category和extension</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）</p>\n<p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>\n<h2 id=\"3、挑灯细览-category真面目\"><a href=\"#3、挑灯细览-category真面目\" class=\"headerlink\" title=\"3、挑灯细览-category真面目\"></a>3、挑灯细览-category真面目</h2><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct category_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    struct method_list_t *instanceMethods;</div><div class=\"line\">    struct method_list_t *classMethods;</div><div class=\"line\">    struct protocol_list_t *protocols;</div><div class=\"line\">    struct property_list_t *instanceProperties;</div><div class=\"line\">&#125; category_t;</div></pre></td></tr></table></figure>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>ok，我们先去写一个category看一下category到底为何物：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyClass.h：</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface MyClass : NSObject</div><div class=\"line\"></div><div class=\"line\">- (void)printName;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface MyClass(MyAddition)</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic, copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">- (void)printName;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">MyClass.m：</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass</div><div class=\"line\"></div><div class=\"line\">- (void)printName</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass(MyAddition)</div><div class=\"line\"></div><div class=\"line\">- (void)printName</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>我们使用clang的命令去看看category到底会变成什么：</p>\n<p>clang -rewrite-objc MyClass.m</p>\n<p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">static struct /*_method_list_t*/ &#123;</div><div class=\"line\">unsigned int entsize;  // sizeof(struct _objc_method)</div><div class=\"line\">unsigned int method_count;</div><div class=\"line\">struct _objc_method method_list[1];</div><div class=\"line\">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">sizeof(_objc_method),</div><div class=\"line\">1,</div><div class=\"line\">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static struct /*_prop_list_t*/ &#123;</div><div class=\"line\">unsigned int entsize;  // sizeof(struct _prop_t)</div><div class=\"line\">unsigned int count_of_properties;</div><div class=\"line\">struct _prop_t prop_list[1];</div><div class=\"line\">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">sizeof(_prop_t),</div><div class=\"line\">1,</div><div class=\"line\">&#123;&#123;&quot;name&quot;,&quot;T@\\&quot;NSString\\&quot;,C,N&quot;&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;</div><div class=\"line\"></div><div class=\"line\">static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;MyClass&quot;,</div><div class=\"line\">0, // &amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</div><div class=\"line\">0,</div><div class=\"line\">0,</div><div class=\"line\">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div><div class=\"line\">static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;</div><div class=\"line\">_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</div><div class=\"line\">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</div><div class=\"line\">(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</div><div class=\"line\">&amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</div><div class=\"line\">&amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</div><div class=\"line\">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们可以看到，<br>1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。<br>2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。<br>3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL<em>CATEGORY$（当然，如果有多个category，会生成对应长度的数组^</em>^），用于运行期category的加载。<br>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。</p>\n<p>4、追本溯源-category如何加载</p>\n<p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。<br>想了解更多dyld地同学可以移步这里（3）。</p>\n<p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _objc_init(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    static bool initialized = false;</div><div class=\"line\">    if (initialized) return;</div><div class=\"line\">    initialized = true;</div><div class=\"line\"></div><div class=\"line\">    // fixme defer initialization until an objc-using image is found?</div><div class=\"line\">    environ_init();</div><div class=\"line\">    tls_init();</div><div class=\"line\">    lock_init();</div><div class=\"line\">    exception_init();</div><div class=\"line\"></div><div class=\"line\">    // Register for unmap first, in case some +load unmaps something</div><div class=\"line\">    _dyld_register_func_for_remove_image(&amp;unmap_image);</div><div class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_bound,</div><div class=\"line\">                                            1/*batch*/, &amp;map_images);</div><div class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Discover categories.</div><div class=\"line\">    for (EACH_HEADER) &#123;</div><div class=\"line\">        category_t **catlist =</div><div class=\"line\">            _getObjc2CategoryList(hi, &amp;count);</div><div class=\"line\">        for (i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">            category_t *cat = catlist[i];</div><div class=\"line\">            class_t *cls = remapClass(cat-&gt;cls);</div><div class=\"line\"></div><div class=\"line\">            if (!cls) &#123;</div><div class=\"line\">                // Category&apos;s target class is missing (probably weak-linked).</div><div class=\"line\">                // Disavow any knowledge of this category.</div><div class=\"line\">                catlist[i] = NULL;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot;</div><div class=\"line\">                                &quot;missing weak-linked target class&quot;,</div><div class=\"line\">                                cat-&gt;name, cat);</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Process this category.</div><div class=\"line\">            // First, register the category with its target class.</div><div class=\"line\">            // Then, rebuild the class&apos;s method lists (etc) if</div><div class=\"line\">            // the class is realized.</div><div class=\"line\">            BOOL classExists = NO;</div><div class=\"line\">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols</div><div class=\"line\">                ||  cat-&gt;instanceProperties)</div><div class=\"line\">            &#123;</div><div class=\"line\">                addUnattachedCategoryForClass(cat, cls, hi);</div><div class=\"line\">                if (isRealized(cls)) &#123;</div><div class=\"line\">                    remethodizeClass(cls);</div><div class=\"line\">                    classExists = YES;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</div><div class=\"line\">                                getName(cls), cat-&gt;name,</div><div class=\"line\">                                classExists ? &quot;on existing class&quot; : &quot;&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (cat-&gt;classMethods  ||  cat-&gt;protocols</div><div class=\"line\">                /* ||  cat-&gt;classProperties */)</div><div class=\"line\">            &#123;</div><div class=\"line\">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</div><div class=\"line\">                if (isRealized(cls-&gt;isa)) &#123;</div><div class=\"line\">                    remethodizeClass(cls-&gt;isa);</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</div><div class=\"line\">                                getName(cls), cat-&gt;name);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。<br>略去PrintConnecting这个用于log的东西，这段代码很容易理解：<br>1)、把category的实例方法、协议以及属性添加到类上<br>2)、把category的类方法和协议添加到类的metaclass上</p>\n<p>值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void remethodizeClass(class_t *cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    category_list *cats;</div><div class=\"line\">    BOOL isMeta;</div><div class=\"line\"></div><div class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</div><div class=\"line\"></div><div class=\"line\">    isMeta = isMetaClass(cls);</div><div class=\"line\"></div><div class=\"line\">    // Re-methodizing: check for more categories</div><div class=\"line\">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</div><div class=\"line\">        chained_property_list *newproperties;</div><div class=\"line\">        const protocol_list_t **newprotos;</div><div class=\"line\"></div><div class=\"line\">        if (PrintConnecting) &#123;</div><div class=\"line\">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</div><div class=\"line\">                        getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Update methods, properties, protocols</div><div class=\"line\"></div><div class=\"line\">        BOOL vtableAffected = NO;</div><div class=\"line\">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</div><div class=\"line\"></div><div class=\"line\">        newproperties = buildPropertyList(NULL, cats, isMeta);</div><div class=\"line\">        if (newproperties) &#123;</div><div class=\"line\">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</div><div class=\"line\">            cls-&gt;data()-&gt;properties = newproperties;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</div><div class=\"line\">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</div><div class=\"line\">            _free_internal(cls-&gt;data()-&gt;protocols);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cls-&gt;data()-&gt;protocols = newprotos;</div><div class=\"line\"></div><div class=\"line\">        _free_internal(cats);</div><div class=\"line\"></div><div class=\"line\">        // Update method caches and vtables</div><div class=\"line\">        flushCaches(cls);</div><div class=\"line\">        if (vtableAffected) flushVtables(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void</div><div class=\"line\">attachCategoryMethods(class_t *cls, category_list *cats,</div><div class=\"line\">                      BOOL *inoutVtablesAffected)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    BOOL isMeta = isMetaClass(cls);</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    BOOL fromBundle = NO;</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</div><div class=\"line\"></div><div class=\"line\">    _free_internal(mlists);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (uint32_t m = 0;</div><div class=\"line\">            (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</div><div class=\"line\">            m++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            SEL sel = method_list_nth(mlist, m)-&gt;name;</div><div class=\"line\">            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</div><div class=\"line\">                cls-&gt;setHasCustomRR();</div><div class=\"line\">                scanForCustomRR = false;</div><div class=\"line\">            &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</div><div class=\"line\">                cls-&gt;setHasCustomAWZ();</div><div class=\"line\">                scanForCustomAWZ = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Fill method list array</div><div class=\"line\">        newLists[newCount++] = mlist;</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\"></div><div class=\"line\">    // Copy old methods to the method list array</div><div class=\"line\">    for (i = 0; i &lt; oldCount; i++) &#123;</div><div class=\"line\">        newLists[newCount++] = oldLists[i];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>需要注意的有两点：<br>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA<br>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>\n<h2 id=\"5、旁枝末叶-category和-load方法\"><a href=\"#5、旁枝末叶-category和-load方法\" class=\"headerlink\" title=\"5、旁枝末叶-category和+load方法\"></a>5、旁枝末叶-category和+load方法</h2><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？<br>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：</p>\n<p>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:</p>\n<p>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category1</div><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category2</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: +[MyClass load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category1) load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category2) load]</div></pre></td></tr></table></figure></p>\n<p>所以，对于上面两个问题，答案是很明显的：<br>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。<br>目前的编译顺序是这样的：</p>\n<p>我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category2</div><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category1</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: +[MyClass load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category2) load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category1) load]</div></pre></td></tr></table></figure></p>\n<p>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。<br>这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p>\n<h3 id=\"6、触类旁通-category和方法覆盖\"><a href=\"#6、触类旁通-category和方法覆盖\" class=\"headerlink\" title=\"6、触类旁通-category和方法覆盖\"></a>6、触类旁通-category和方法覆盖</h3><p>鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:<br>怎么调用到原来类中被category覆盖掉的方法？<br>对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class currentClass = [MyClass class];</div><div class=\"line\">MyClass *my = [[MyClass alloc] init];</div><div class=\"line\"></div><div class=\"line\">if (currentClass) &#123;</div><div class=\"line\">    unsigned int methodCount;</div><div class=\"line\">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</div><div class=\"line\">    IMP lastImp = NULL;</div><div class=\"line\">    SEL lastSel = NULL;</div><div class=\"line\">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</div><div class=\"line\">        Method method = methodList[i];</div><div class=\"line\">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))</div><div class=\"line\">                                        encoding:NSUTF8StringEncoding];</div><div class=\"line\">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</div><div class=\"line\">            lastImp = method_getImplementation(method);</div><div class=\"line\">            lastSel = method_getName(method);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    typedef void (*fn)(id,SEL);</div><div class=\"line\"></div><div class=\"line\">    if (lastImp != NULL) &#123;</div><div class=\"line\">        fn f = (fn)lastImp;</div><div class=\"line\">        f(my,lastSel);</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(methodList);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"7、更上一层-category和关联对象\"><a href=\"#7、更上一层-category和关联对象\" class=\"headerlink\" title=\"7、更上一层-category和关联对象\"></a>7、更上一层-category和关联对象</h2><p>如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyClass+Category1.h:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface MyClass (Category1)</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic,copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">MyClass+Category1.m:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass+Category1.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass (Category1)</div><div class=\"line\"></div><div class=\"line\">+ (void)load</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setName:(NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self,</div><div class=\"line\">                            &quot;name&quot;,</div><div class=\"line\">                            name,</div><div class=\"line\">                            OBJC_ASSOCIATION_COPY);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSString*)name</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);</div><div class=\"line\">    return nameObject;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class=\"line\">    // retain the new value (if any) outside the lock.</div><div class=\"line\">    ObjcAssociation old_association(0, nil);</div><div class=\"line\">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class=\"line\">    &#123;</div><div class=\"line\">        AssociationsManager manager;</div><div class=\"line\">        AssociationsHashMap &amp;associations(manager.associations());</div><div class=\"line\">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class=\"line\">        if (new_value) &#123;</div><div class=\"line\">            // break any existing association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i != associations.end()) &#123;</div><div class=\"line\">                // secondary table exists</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // create the new association (first time).</div><div class=\"line\">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class=\"line\">                associations[disguised_object] = refs;</div><div class=\"line\">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // setting the association to nil breaks the association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i !=  associations.end()) &#123;</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    refs-&gt;erase(j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // release the old value (outside of the lock).</div><div class=\"line\">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class AssociationsManager &#123;</div><div class=\"line\">    static OSSpinLock _lock;</div><div class=\"line\">    static AssociationsHashMap *_map;              // associative references:  object pointer -&gt; PtrPtrHashMap.</div><div class=\"line\">public:</div><div class=\"line\">    AssociationsManager()  &#123; OSSpinLockLock(&amp;_lock); &#125;</div><div class=\"line\">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</div><div class=\"line\"></div><div class=\"line\">    AssociationsHashMap &amp;associations() &#123;</div><div class=\"line\">        if (_map == NULL)</div><div class=\"line\">            _map = new AssociationsHashMap();</div><div class=\"line\">        return *_map;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *objc_destructInstance(id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (obj) &#123;</div><div class=\"line\">        Class isa_gen = _object_getClass(obj);</div><div class=\"line\">        class_t *isa = newcls(isa_gen);</div><div class=\"line\"></div><div class=\"line\">        // Read all of the flags at once for performance.</div><div class=\"line\">        bool cxx = hasCxxStructors(isa);</div><div class=\"line\">        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</div><div class=\"line\"></div><div class=\"line\">        // This order is important.</div><div class=\"line\">        if (cxx) object_cxxDestruct(obj);</div><div class=\"line\">        if (assoc) _object_remove_assocations(obj);</div><div class=\"line\"></div><div class=\"line\">        if (!UseGC) objc_clear_deallocating(obj);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>\n<p>后记</p>\n<p>正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在<a href=\"http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。\" target=\"_blank\" rel=\"external\">http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。</a><br>本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。</p>\n","site":{"data":{}},"excerpt":"<p>见过的比较好的一篇讲述category实现的博客，在此做个记录<br>","more":"</p>\n<p>转载自：<a href=\"http://tech.meituan.com/DiveIntoCategory.html\" target=\"_blank\" rel=\"external\">http://tech.meituan.com/DiveIntoCategory.html</a></p>\n<p>无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。</p>\n<p>简介</p>\n<p>本文作者来自美团酒店旅游事业群iOS研发组。我们致力于创造价值、提升效率、追求卓越。欢迎大家加入我们（简历请发送到邮箱majia03@meituan.com）。<br>本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：</p>\n<ul>\n<li>初入宝地-category简介</li>\n<li>连类比事-category和extension</li>\n<li>挑灯细览-category真面目</li>\n<li>追本溯源-category如何加载</li>\n<li>旁枝末叶-category和+load方法</li>\n<li>触类旁通-category和方法覆盖</li>\n<li>更上一层-category和关联对象</li>\n</ul>\n<h2 id=\"1、初入宝地-category简介\"><a href=\"#1、初入宝地-category简介\" class=\"headerlink\" title=\"1、初入宝地-category简介\"></a>1、初入宝地-category简介</h2><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景1</p>\n<ul>\n<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li>\n<li>声明私有方法</li>\n</ul>\n<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>\n<ul>\n<li>模拟多继承</li>\n<li>把framework的私有方法公开</li>\n</ul>\n<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>\n<h2 id=\"2、连类比事-category和extension\"><a href=\"#2、连类比事-category和extension\" class=\"headerlink\" title=\"2、连类比事-category和extension\"></a>2、连类比事-category和extension</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见2）</p>\n<p>但是category则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>\n<h2 id=\"3、挑灯细览-category真面目\"><a href=\"#3、挑灯细览-category真面目\" class=\"headerlink\" title=\"3、挑灯细览-category真面目\"></a>3、挑灯细览-category真面目</h2><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct category_t &#123;</div><div class=\"line\">    const char *name;</div><div class=\"line\">    classref_t cls;</div><div class=\"line\">    struct method_list_t *instanceMethods;</div><div class=\"line\">    struct method_list_t *classMethods;</div><div class=\"line\">    struct protocol_list_t *protocols;</div><div class=\"line\">    struct property_list_t *instanceProperties;</div><div class=\"line\">&#125; category_t;</div></pre></td></tr></table></figure>\n<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>ok，我们先去写一个category看一下category到底为何物：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyClass.h：</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &lt;Foundation/Foundation.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface MyClass : NSObject</div><div class=\"line\"></div><div class=\"line\">- (void)printName;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@interface MyClass(MyAddition)</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic, copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">- (void)printName;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">MyClass.m：</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass</div><div class=\"line\"></div><div class=\"line\">- (void)printName</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass(MyAddition)</div><div class=\"line\"></div><div class=\"line\">- (void)printName</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>我们使用clang的命令去看看category到底会变成什么：</p>\n<p>clang -rewrite-objc MyClass.m</p>\n<p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">static struct /*_method_list_t*/ &#123;</div><div class=\"line\">unsigned int entsize;  // sizeof(struct _objc_method)</div><div class=\"line\">unsigned int method_count;</div><div class=\"line\">struct _objc_method method_list[1];</div><div class=\"line\">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">sizeof(_objc_method),</div><div class=\"line\">1,</div><div class=\"line\">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">static struct /*_prop_list_t*/ &#123;</div><div class=\"line\">unsigned int entsize;  // sizeof(struct _prop_t)</div><div class=\"line\">unsigned int count_of_properties;</div><div class=\"line\">struct _prop_t prop_list[1];</div><div class=\"line\">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</div><div class=\"line\">sizeof(_prop_t),</div><div class=\"line\">1,</div><div class=\"line\">&#123;&#123;&quot;name&quot;,&quot;T@\\&quot;NSString\\&quot;,C,N&quot;&#125;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;</div><div class=\"line\"></div><div class=\"line\">static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</div><div class=\"line\">&#123;</div><div class=\"line\">&quot;MyClass&quot;,</div><div class=\"line\">0, // &amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</div><div class=\"line\">0,</div><div class=\"line\">0,</div><div class=\"line\">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div><div class=\"line\">static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;</div><div class=\"line\">_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</div><div class=\"line\">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</div><div class=\"line\">(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</div><div class=\"line\">&amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</div><div class=\"line\">&amp;OBJC_CLASS_$_MyClass,</div><div class=\"line\">&#125;;</div><div class=\"line\">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</div><div class=\"line\">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>我们可以看到，<br>1)、首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。<br>2)、其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。<br>3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL<em>CATEGORY$（当然，如果有多个category，会生成对应长度的数组^</em>^），用于运行期category的加载。<br>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。</p>\n<p>4、追本溯源-category如何加载</p>\n<p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。<br>想了解更多dyld地同学可以移步这里（3）。</p>\n<p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">void _objc_init(void)</div><div class=\"line\">&#123;</div><div class=\"line\">    static bool initialized = false;</div><div class=\"line\">    if (initialized) return;</div><div class=\"line\">    initialized = true;</div><div class=\"line\"></div><div class=\"line\">    // fixme defer initialization until an objc-using image is found?</div><div class=\"line\">    environ_init();</div><div class=\"line\">    tls_init();</div><div class=\"line\">    lock_init();</div><div class=\"line\">    exception_init();</div><div class=\"line\"></div><div class=\"line\">    // Register for unmap first, in case some +load unmaps something</div><div class=\"line\">    _dyld_register_func_for_remove_image(&amp;unmap_image);</div><div class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_bound,</div><div class=\"line\">                                            1/*batch*/, &amp;map_images);</div><div class=\"line\">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Discover categories.</div><div class=\"line\">    for (EACH_HEADER) &#123;</div><div class=\"line\">        category_t **catlist =</div><div class=\"line\">            _getObjc2CategoryList(hi, &amp;count);</div><div class=\"line\">        for (i = 0; i &lt; count; i++) &#123;</div><div class=\"line\">            category_t *cat = catlist[i];</div><div class=\"line\">            class_t *cls = remapClass(cat-&gt;cls);</div><div class=\"line\"></div><div class=\"line\">            if (!cls) &#123;</div><div class=\"line\">                // Category&apos;s target class is missing (probably weak-linked).</div><div class=\"line\">                // Disavow any knowledge of this category.</div><div class=\"line\">                catlist[i] = NULL;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot;</div><div class=\"line\">                                &quot;missing weak-linked target class&quot;,</div><div class=\"line\">                                cat-&gt;name, cat);</div><div class=\"line\">                &#125;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Process this category.</div><div class=\"line\">            // First, register the category with its target class.</div><div class=\"line\">            // Then, rebuild the class&apos;s method lists (etc) if</div><div class=\"line\">            // the class is realized.</div><div class=\"line\">            BOOL classExists = NO;</div><div class=\"line\">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols</div><div class=\"line\">                ||  cat-&gt;instanceProperties)</div><div class=\"line\">            &#123;</div><div class=\"line\">                addUnattachedCategoryForClass(cat, cls, hi);</div><div class=\"line\">                if (isRealized(cls)) &#123;</div><div class=\"line\">                    remethodizeClass(cls);</div><div class=\"line\">                    classExists = YES;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</div><div class=\"line\">                                getName(cls), cat-&gt;name,</div><div class=\"line\">                                classExists ? &quot;on existing class&quot; : &quot;&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (cat-&gt;classMethods  ||  cat-&gt;protocols</div><div class=\"line\">                /* ||  cat-&gt;classProperties */)</div><div class=\"line\">            &#123;</div><div class=\"line\">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</div><div class=\"line\">                if (isRealized(cls-&gt;isa)) &#123;</div><div class=\"line\">                    remethodizeClass(cls-&gt;isa);</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (PrintConnecting) &#123;</div><div class=\"line\">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</div><div class=\"line\">                                getName(cls), cat-&gt;name);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。<br>略去PrintConnecting这个用于log的东西，这段代码很容易理解：<br>1)、把category的实例方法、协议以及属性添加到类上<br>2)、把category的类方法和协议添加到类的metaclass上</p>\n<p>值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void remethodizeClass(class_t *cls)</div><div class=\"line\">&#123;</div><div class=\"line\">    category_list *cats;</div><div class=\"line\">    BOOL isMeta;</div><div class=\"line\"></div><div class=\"line\">    rwlock_assert_writing(&amp;runtimeLock);</div><div class=\"line\"></div><div class=\"line\">    isMeta = isMetaClass(cls);</div><div class=\"line\"></div><div class=\"line\">    // Re-methodizing: check for more categories</div><div class=\"line\">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</div><div class=\"line\">        chained_property_list *newproperties;</div><div class=\"line\">        const protocol_list_t **newprotos;</div><div class=\"line\"></div><div class=\"line\">        if (PrintConnecting) &#123;</div><div class=\"line\">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</div><div class=\"line\">                        getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Update methods, properties, protocols</div><div class=\"line\"></div><div class=\"line\">        BOOL vtableAffected = NO;</div><div class=\"line\">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</div><div class=\"line\"></div><div class=\"line\">        newproperties = buildPropertyList(NULL, cats, isMeta);</div><div class=\"line\">        if (newproperties) &#123;</div><div class=\"line\">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</div><div class=\"line\">            cls-&gt;data()-&gt;properties = newproperties;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</div><div class=\"line\">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</div><div class=\"line\">            _free_internal(cls-&gt;data()-&gt;protocols);</div><div class=\"line\">        &#125;</div><div class=\"line\">        cls-&gt;data()-&gt;protocols = newprotos;</div><div class=\"line\"></div><div class=\"line\">        _free_internal(cats);</div><div class=\"line\"></div><div class=\"line\">        // Update method caches and vtables</div><div class=\"line\">        flushCaches(cls);</div><div class=\"line\">        if (vtableAffected) flushVtables(cls);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void</div><div class=\"line\">attachCategoryMethods(class_t *cls, category_list *cats,</div><div class=\"line\">                      BOOL *inoutVtablesAffected)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (!cats) return;</div><div class=\"line\">    if (PrintReplacedMethods) printReplacements(cls, cats);</div><div class=\"line\"></div><div class=\"line\">    BOOL isMeta = isMetaClass(cls);</div><div class=\"line\">    method_list_t **mlists = (method_list_t **)</div><div class=\"line\">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</div><div class=\"line\"></div><div class=\"line\">    // Count backwards through cats to get newest categories first</div><div class=\"line\">    int mcount = 0;</div><div class=\"line\">    int i = cats-&gt;count;</div><div class=\"line\">    BOOL fromBundle = NO;</div><div class=\"line\">    while (i--) &#123;</div><div class=\"line\">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</div><div class=\"line\">        if (mlist) &#123;</div><div class=\"line\">            mlists[mcount++] = mlist;</div><div class=\"line\">            fromBundle |= cats-&gt;list[i].fromBundle;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</div><div class=\"line\"></div><div class=\"line\">    _free_internal(mlists);</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (uint32_t m = 0;</div><div class=\"line\">            (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</div><div class=\"line\">            m++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            SEL sel = method_list_nth(mlist, m)-&gt;name;</div><div class=\"line\">            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</div><div class=\"line\">                cls-&gt;setHasCustomRR();</div><div class=\"line\">                scanForCustomRR = false;</div><div class=\"line\">            &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</div><div class=\"line\">                cls-&gt;setHasCustomAWZ();</div><div class=\"line\">                scanForCustomAWZ = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Fill method list array</div><div class=\"line\">        newLists[newCount++] = mlist;</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\">    .</div><div class=\"line\"></div><div class=\"line\">    // Copy old methods to the method list array</div><div class=\"line\">    for (i = 0; i &lt; oldCount; i++) &#123;</div><div class=\"line\">        newLists[newCount++] = oldLists[i];</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>需要注意的有两点：<br>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA<br>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>\n<h2 id=\"5、旁枝末叶-category和-load方法\"><a href=\"#5、旁枝末叶-category和-load方法\" class=\"headerlink\" title=\"5、旁枝末叶-category和+load方法\"></a>5、旁枝末叶-category和+load方法</h2><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？<br>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：</p>\n<p>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:</p>\n<p>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category1</div><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category2</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: +[MyClass load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category1) load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category2) load]</div></pre></td></tr></table></figure></p>\n<p>所以，对于上面两个问题，答案是很明显的：<br>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。<br>目前的编译顺序是这样的：</p>\n<p>我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category2</div><div class=\"line\">objc[1187]: REPLACED: -[MyClass printName] by category Category1</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</div><div class=\"line\">objc[1187]: LOAD: +[MyClass load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category2) load]</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">.</div><div class=\"line\">objc[1187]: LOAD: +[MyClass(Category1) load]</div></pre></td></tr></table></figure></p>\n<p>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。<br>这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p>\n<h3 id=\"6、触类旁通-category和方法覆盖\"><a href=\"#6、触类旁通-category和方法覆盖\" class=\"headerlink\" title=\"6、触类旁通-category和方法覆盖\"></a>6、触类旁通-category和方法覆盖</h3><p>鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:<br>怎么调用到原来类中被category覆盖掉的方法？<br>对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class currentClass = [MyClass class];</div><div class=\"line\">MyClass *my = [[MyClass alloc] init];</div><div class=\"line\"></div><div class=\"line\">if (currentClass) &#123;</div><div class=\"line\">    unsigned int methodCount;</div><div class=\"line\">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</div><div class=\"line\">    IMP lastImp = NULL;</div><div class=\"line\">    SEL lastSel = NULL;</div><div class=\"line\">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</div><div class=\"line\">        Method method = methodList[i];</div><div class=\"line\">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))</div><div class=\"line\">                                        encoding:NSUTF8StringEncoding];</div><div class=\"line\">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</div><div class=\"line\">            lastImp = method_getImplementation(method);</div><div class=\"line\">            lastSel = method_getName(method);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    typedef void (*fn)(id,SEL);</div><div class=\"line\"></div><div class=\"line\">    if (lastImp != NULL) &#123;</div><div class=\"line\">        fn f = (fn)lastImp;</div><div class=\"line\">        f(my,lastSel);</div><div class=\"line\">    &#125;</div><div class=\"line\">    free(methodList);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"7、更上一层-category和关联对象\"><a href=\"#7、更上一层-category和关联对象\" class=\"headerlink\" title=\"7、更上一层-category和关联对象\"></a>7、更上一层-category和关联对象</h2><p>如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">MyClass+Category1.h:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass.h&quot;</div><div class=\"line\"></div><div class=\"line\">@interface MyClass (Category1)</div><div class=\"line\"></div><div class=\"line\">@property(nonatomic,copy) NSString *name;</div><div class=\"line\"></div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">MyClass+Category1.m:</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import &quot;MyClass+Category1.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation MyClass (Category1)</div><div class=\"line\"></div><div class=\"line\">+ (void)load</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)setName:(NSString *)name</div><div class=\"line\">&#123;</div><div class=\"line\">    objc_setAssociatedObject(self,</div><div class=\"line\">                            &quot;name&quot;,</div><div class=\"line\">                            name,</div><div class=\"line\">                            OBJC_ASSOCIATION_COPY);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (NSString*)name</div><div class=\"line\">&#123;</div><div class=\"line\">    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);</div><div class=\"line\">    return nameObject;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</div><div class=\"line\">    // retain the new value (if any) outside the lock.</div><div class=\"line\">    ObjcAssociation old_association(0, nil);</div><div class=\"line\">    id new_value = value ? acquireValue(value, policy) : nil;</div><div class=\"line\">    &#123;</div><div class=\"line\">        AssociationsManager manager;</div><div class=\"line\">        AssociationsHashMap &amp;associations(manager.associations());</div><div class=\"line\">        disguised_ptr_t disguised_object = DISGUISE(object);</div><div class=\"line\">        if (new_value) &#123;</div><div class=\"line\">            // break any existing association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i != associations.end()) &#123;</div><div class=\"line\">                // secondary table exists</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // create the new association (first time).</div><div class=\"line\">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class=\"line\">                associations[disguised_object] = refs;</div><div class=\"line\">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class=\"line\">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // setting the association to nil breaks the association.</div><div class=\"line\">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class=\"line\">            if (i !=  associations.end()) &#123;</div><div class=\"line\">                ObjectAssociationMap *refs = i-&gt;second;</div><div class=\"line\">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class=\"line\">                if (j != refs-&gt;end()) &#123;</div><div class=\"line\">                    old_association = j-&gt;second;</div><div class=\"line\">                    refs-&gt;erase(j);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // release the old value (outside of the lock).</div><div class=\"line\">    if (old_association.hasValue()) ReleaseValue()(old_association);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class AssociationsManager &#123;</div><div class=\"line\">    static OSSpinLock _lock;</div><div class=\"line\">    static AssociationsHashMap *_map;              // associative references:  object pointer -&gt; PtrPtrHashMap.</div><div class=\"line\">public:</div><div class=\"line\">    AssociationsManager()  &#123; OSSpinLockLock(&amp;_lock); &#125;</div><div class=\"line\">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</div><div class=\"line\"></div><div class=\"line\">    AssociationsHashMap &amp;associations() &#123;</div><div class=\"line\">        if (_map == NULL)</div><div class=\"line\">            _map = new AssociationsHashMap();</div><div class=\"line\">        return *_map;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">void *objc_destructInstance(id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">    if (obj) &#123;</div><div class=\"line\">        Class isa_gen = _object_getClass(obj);</div><div class=\"line\">        class_t *isa = newcls(isa_gen);</div><div class=\"line\"></div><div class=\"line\">        // Read all of the flags at once for performance.</div><div class=\"line\">        bool cxx = hasCxxStructors(isa);</div><div class=\"line\">        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</div><div class=\"line\"></div><div class=\"line\">        // This order is important.</div><div class=\"line\">        if (cxx) object_cxxDestruct(obj);</div><div class=\"line\">        if (assoc) _object_remove_assocations(obj);</div><div class=\"line\"></div><div class=\"line\">        if (!UseGC) objc_clear_deallocating(obj);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>\n<p>后记</p>\n<p>正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在<a href=\"http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。\" target=\"_blank\" rel=\"external\">http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。</a><br>本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。</p>"},{"title":"iOS中的定时和延时","date":"2015-01-23T09:04:55.000Z","_content":"我们使用延时和定时可以使用以下方法：\n- NSTimer\n\n\n## NSTimer\n### 循环引用\n我们使用一个nstimer的时候，使用一个类方法来创建一个timer，返回一个timer指针，有时需要把tiemr加到runloop，有时系统自己来帮你做，你会发现，即使我并没有去强引用这个指针，timer只要在runloop中，timer就可以自然的回调，这是因为timer被runloop所引用，我们用控制器去引用这个timer，也只是增加了一个引用而已。\n\n```\n+(id)scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    id ret = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];\n    [block release];\n    return ret;\n}\n\n+(id)timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    id ret = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];\n    [block release];\n    return ret;\n}\n\n+(void)jdExecuteSimpleBlock:(NSTimer *)inTimer;\n{\n    if([inTimer userInfo])\n    {\n        void (^block)() = (void (^)())[inTimer userInfo];\n        block();\n    }\n}\n```\n这也是Block实现的tiemr不会被释放的原因。\n\n","source":"_posts/2015/iOS中的定时和延时.md","raw":"---\ntitle: iOS中的定时和延时\ndate: 2015-01-23 17:04:55\ntags:\n- iOS基础知识\ncategories: iOS\n---\n我们使用延时和定时可以使用以下方法：\n- NSTimer\n\n\n## NSTimer\n### 循环引用\n我们使用一个nstimer的时候，使用一个类方法来创建一个timer，返回一个timer指针，有时需要把tiemr加到runloop，有时系统自己来帮你做，你会发现，即使我并没有去强引用这个指针，timer只要在runloop中，timer就可以自然的回调，这是因为timer被runloop所引用，我们用控制器去引用这个timer，也只是增加了一个引用而已。\n\n```\n+(id)scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    id ret = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];\n    [block release];\n    return ret;\n}\n\n+(id)timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats\n{\n    void (^block)() = [inBlock copy];\n    id ret = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];\n    [block release];\n    return ret;\n}\n\n+(void)jdExecuteSimpleBlock:(NSTimer *)inTimer;\n{\n    if([inTimer userInfo])\n    {\n        void (^block)() = (void (^)())[inTimer userInfo];\n        block();\n    }\n}\n```\n这也是Block实现的tiemr不会被释放的原因。\n\n","slug":"2015/iOS中的定时和延时","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmo002psauasxmqd984","content":"<p>我们使用延时和定时可以使用以下方法：</p>\n<ul>\n<li>NSTimer</li>\n</ul>\n<h2 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h2><h3 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h3><p>我们使用一个nstimer的时候，使用一个类方法来创建一个timer，返回一个timer指针，有时需要把tiemr加到runloop，有时系统自己来帮你做，你会发现，即使我并没有去强引用这个指针，timer只要在runloop中，timer就可以自然的回调，这是因为timer被runloop所引用，我们用控制器去引用这个timer，也只是增加了一个引用而已。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(id)scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^block)() = [inBlock copy];</div><div class=\"line\">    id ret = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];</div><div class=\"line\">    [block release];</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(id)timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^block)() = [inBlock copy];</div><div class=\"line\">    id ret = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];</div><div class=\"line\">    [block release];</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)jdExecuteSimpleBlock:(NSTimer *)inTimer;</div><div class=\"line\">&#123;</div><div class=\"line\">    if([inTimer userInfo])</div><div class=\"line\">    &#123;</div><div class=\"line\">        void (^block)() = (void (^)())[inTimer userInfo];</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这也是Block实现的tiemr不会被释放的原因。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们使用延时和定时可以使用以下方法：</p>\n<ul>\n<li>NSTimer</li>\n</ul>\n<h2 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h2><h3 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h3><p>我们使用一个nstimer的时候，使用一个类方法来创建一个timer，返回一个timer指针，有时需要把tiemr加到runloop，有时系统自己来帮你做，你会发现，即使我并没有去强引用这个指针，timer只要在runloop中，timer就可以自然的回调，这是因为timer被runloop所引用，我们用控制器去引用这个timer，也只是增加了一个引用而已。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">+(id)scheduledTimerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^block)() = [inBlock copy];</div><div class=\"line\">    id ret = [self scheduledTimerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];</div><div class=\"line\">    [block release];</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(id)timerWithTimeInterval:(NSTimeInterval)inTimeInterval block:(void (^)())inBlock repeats:(BOOL)inRepeats</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^block)() = [inBlock copy];</div><div class=\"line\">    id ret = [self timerWithTimeInterval:inTimeInterval target:self selector:@selector(jdExecuteSimpleBlock:) userInfo:block repeats:inRepeats];</div><div class=\"line\">    [block release];</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">+(void)jdExecuteSimpleBlock:(NSTimer *)inTimer;</div><div class=\"line\">&#123;</div><div class=\"line\">    if([inTimer userInfo])</div><div class=\"line\">    &#123;</div><div class=\"line\">        void (^block)() = (void (^)())[inTimer userInfo];</div><div class=\"line\">        block();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这也是Block实现的tiemr不会被释放的原因。</p>\n"},{"title":"iOS中的屏幕旋转","date":"2015-04-12T10:04:08.000Z","_content":"\n### 总述\n- 旋转事件只传递给主window\n- 当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上\n<!--more-->\n- 屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转\n- 再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制\n\n### 详述\n#### 第一层设置\n![Alt text](./1444701872103.png)\n在这里选择是否支持横竖屏\n#### 第二层设置\n```\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {  \n    return UIInterfaceOrientationMaskAll;\n}\n```\n在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置\n\n#### 第三层设置\n在window的`根控制器`中实现这两个方法，来加以控制，是否允许旋转以及支持的方向\n```\n//是否允许旋转\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n//旋转的时候支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n#### 第四层设置\n在你要控制是否旋转的这个控制里边实现上边的这两个方法\n\n\n#### 小结\n>- 当屏幕旋转一次就会调用一次这个方法，来询问支持的方向\n>- 这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响\n>- 一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西\n>  - AppDelegate中的这个方法返回支持的方向\n>  - window的根控制器中是否允许旋转，以及支持的方向\n>  - **取交集**\n\n\n\n\n上边的的四层设置起作用的情况，我们要分三种情况来说\n>- 要控制的控制器间接依附最开始创建的window\n>\t- 该控制器是通过navigationcontroller管理的/直接添加childcontrollers\n>\t- present...\n>- 要控制的控制器依附于新创建的window\n\n##### 原始window\n>- 受到Appdelegate中的方法的影响\n>- 如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则\n>- 如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响\n\n##### 依附于新创建的window\n>- 不受到APPdelegate方法的影响\n>- 其它都一样，但是分析的起点就变成了当前window的根控制器\n\t- 比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了\n\n### demo\n#### 整体是支持横屏，但是某个界面禁止\n根据上边叙述，我们可以得到以下方案：\n- 通过present...来管理控制器\n\n> 在这个控制器中添加控制器代码，禁止旋转或者只支持竖着\n```\n  @implementation HSViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n}\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskPortrait;\n}\n\n@end\n```\n- 不通过present来管理界面\n> 通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向\n```\n - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    \n\n   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;\n    \n    if ([nav.topViewController isKindOfClass:[HSViewController class]]) {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n    \n    return UIInterfaceOrientationMaskAll;\n    \n}\n```\n\n#### 整体是支持竖屏，但是某个界面可以横屏\n这种需求，只能通过加判断代码来做到\n\n#### 控制通过webView加载的视频全屏时的横竖屏\nwebView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断\n```\n#import \"UIViewController+Extension.h\"\n\n@implementation UIViewController (Extension)\n\n#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏\n/**\n * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO\n *\n *  @return 返回是否\n */\n- (BOOL)shouldAutorotate {\n    //拿到当前主窗口的根控制器类型名称\n    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);\n    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转\n    if ([className isEqualToString:@\"UIViewController\"]) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n@end\n\n```\n","source":"_posts/2015/iOS中的屏幕旋转.md","raw":"---\ntitle: iOS中的屏幕旋转\ndate: 2015-04-12 18:04:08\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\n### 总述\n- 旋转事件只传递给主window\n- 当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上\n<!--more-->\n- 屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转\n- 再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制\n\n### 详述\n#### 第一层设置\n![Alt text](./1444701872103.png)\n在这里选择是否支持横竖屏\n#### 第二层设置\n```\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {  \n    return UIInterfaceOrientationMaskAll;\n}\n```\n在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置\n\n#### 第三层设置\n在window的`根控制器`中实现这两个方法，来加以控制，是否允许旋转以及支持的方向\n```\n//是否允许旋转\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n//旋转的时候支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n#### 第四层设置\n在你要控制是否旋转的这个控制里边实现上边的这两个方法\n\n\n#### 小结\n>- 当屏幕旋转一次就会调用一次这个方法，来询问支持的方向\n>- 这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响\n>- 一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西\n>  - AppDelegate中的这个方法返回支持的方向\n>  - window的根控制器中是否允许旋转，以及支持的方向\n>  - **取交集**\n\n\n\n\n上边的的四层设置起作用的情况，我们要分三种情况来说\n>- 要控制的控制器间接依附最开始创建的window\n>\t- 该控制器是通过navigationcontroller管理的/直接添加childcontrollers\n>\t- present...\n>- 要控制的控制器依附于新创建的window\n\n##### 原始window\n>- 受到Appdelegate中的方法的影响\n>- 如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则\n>- 如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响\n\n##### 依附于新创建的window\n>- 不受到APPdelegate方法的影响\n>- 其它都一样，但是分析的起点就变成了当前window的根控制器\n\t- 比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了\n\n### demo\n#### 整体是支持横屏，但是某个界面禁止\n根据上边叙述，我们可以得到以下方案：\n- 通过present...来管理控制器\n\n> 在这个控制器中添加控制器代码，禁止旋转或者只支持竖着\n```\n  @implementation HSViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n}\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskPortrait;\n}\n\n@end\n```\n- 不通过present来管理界面\n> 通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向\n```\n - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    \n\n   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;\n    \n    if ([nav.topViewController isKindOfClass:[HSViewController class]]) {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n    \n    return UIInterfaceOrientationMaskAll;\n    \n}\n```\n\n#### 整体是支持竖屏，但是某个界面可以横屏\n这种需求，只能通过加判断代码来做到\n\n#### 控制通过webView加载的视频全屏时的横竖屏\nwebView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断\n```\n#import \"UIViewController+Extension.h\"\n\n@implementation UIViewController (Extension)\n\n#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏\n/**\n * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO\n *\n *  @return 返回是否\n */\n- (BOOL)shouldAutorotate {\n    //拿到当前主窗口的根控制器类型名称\n    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);\n    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转\n    if ([className isEqualToString:@\"UIViewController\"]) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n@end\n\n```\n","slug":"2015/iOS中的屏幕旋转","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmp002ssauaagyz40x9","content":"<h3 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h3><ul>\n<li>旋转事件只传递给主window</li>\n<li>当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上<a id=\"more\"></a></li>\n<li>屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转</li>\n<li>再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制</li>\n</ul>\n<h3 id=\"详述\"><a href=\"#详述\" class=\"headerlink\" title=\"详述\"></a>详述</h3><h4 id=\"第一层设置\"><a href=\"#第一层设置\" class=\"headerlink\" title=\"第一层设置\"></a>第一层设置</h4><p><img src=\"./1444701872103.png\" alt=\"Alt text\"><br>在这里选择是否支持横竖屏</p>\n<h4 id=\"第二层设置\"><a href=\"#第二层设置\" class=\"headerlink\" title=\"第二层设置\"></a>第二层设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;  </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置</p>\n<h4 id=\"第三层设置\"><a href=\"#第三层设置\" class=\"headerlink\" title=\"第三层设置\"></a>第三层设置</h4><p>在window的<code>根控制器</code>中实现这两个方法，来加以控制，是否允许旋转以及支持的方向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否允许旋转</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\">//旋转的时候支持的方向</div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第四层设置\"><a href=\"#第四层设置\" class=\"headerlink\" title=\"第四层设置\"></a>第四层设置</h4><p>在你要控制是否旋转的这个控制里边实现上边的这两个方法</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><blockquote>\n<ul>\n<li>当屏幕旋转一次就会调用一次这个方法，来询问支持的方向</li>\n<li>这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响</li>\n<li>一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西<ul>\n<li>AppDelegate中的这个方法返回支持的方向</li>\n<li>window的根控制器中是否允许旋转，以及支持的方向</li>\n<li><strong>取交集</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>上边的的四层设置起作用的情况，我们要分三种情况来说</p>\n<blockquote>\n<ul>\n<li>要控制的控制器间接依附最开始创建的window<ul>\n<li>该控制器是通过navigationcontroller管理的/直接添加childcontrollers</li>\n<li>present…</li>\n</ul>\n</li>\n<li>要控制的控制器依附于新创建的window</li>\n</ul>\n</blockquote>\n<h5 id=\"原始window\"><a href=\"#原始window\" class=\"headerlink\" title=\"原始window\"></a>原始window</h5><blockquote>\n<ul>\n<li>受到Appdelegate中的方法的影响</li>\n<li>如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则</li>\n<li>如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响</li>\n</ul>\n</blockquote>\n<h5 id=\"依附于新创建的window\"><a href=\"#依附于新创建的window\" class=\"headerlink\" title=\"依附于新创建的window\"></a>依附于新创建的window</h5><blockquote>\n<ul>\n<li>不受到APPdelegate方法的影响</li>\n<li>其它都一样，但是分析的起点就变成了当前window的根控制器<ul>\n<li>比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><h4 id=\"整体是支持横屏，但是某个界面禁止\"><a href=\"#整体是支持横屏，但是某个界面禁止\" class=\"headerlink\" title=\"整体是支持横屏，但是某个界面禁止\"></a>整体是支持横屏，但是某个界面禁止</h4><p>根据上边叙述，我们可以得到以下方案：</p>\n<ul>\n<li>通过present…来管理控制器</li>\n</ul>\n<blockquote>\n<p>在这个控制器中添加控制器代码，禁止旋转或者只支持竖着<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  @implementation HSViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">   [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>不通过present来管理界面<blockquote>\n<p>通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;</div><div class=\"line\">    </div><div class=\"line\">    if ([nav.topViewController isKindOfClass:[HSViewController class]]) &#123;</div><div class=\"line\">        return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"整体是支持竖屏，但是某个界面可以横屏\"><a href=\"#整体是支持竖屏，但是某个界面可以横屏\" class=\"headerlink\" title=\"整体是支持竖屏，但是某个界面可以横屏\"></a>整体是支持竖屏，但是某个界面可以横屏</h4><p>这种需求，只能通过加判断代码来做到</p>\n<h4 id=\"控制通过webView加载的视频全屏时的横竖屏\"><a href=\"#控制通过webView加载的视频全屏时的横竖屏\" class=\"headerlink\" title=\"控制通过webView加载的视频全屏时的横竖屏\"></a>控制通过webView加载的视频全屏时的横竖屏</h4><p>webView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Extension.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Extension)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏</div><div class=\"line\">/**</div><div class=\"line\"> * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO</div><div class=\"line\"> *</div><div class=\"line\"> *  @return 返回是否</div><div class=\"line\"> */</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    //拿到当前主窗口的根控制器类型名称</div><div class=\"line\">    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);</div><div class=\"line\">    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转</div><div class=\"line\">    if ([className isEqualToString:@&quot;UIViewController&quot;]) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"总述\"><a href=\"#总述\" class=\"headerlink\" title=\"总述\"></a>总述</h3><ul>\n<li>旋转事件只传递给主window</li>\n<li>当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上","more":"</li>\n<li>屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转</li>\n<li>再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制</li>\n</ul>\n<h3 id=\"详述\"><a href=\"#详述\" class=\"headerlink\" title=\"详述\"></a>详述</h3><h4 id=\"第一层设置\"><a href=\"#第一层设置\" class=\"headerlink\" title=\"第一层设置\"></a>第一层设置</h4><p><img src=\"./1444701872103.png\" alt=\"Alt text\"><br>在这里选择是否支持横竖屏</p>\n<h4 id=\"第二层设置\"><a href=\"#第二层设置\" class=\"headerlink\" title=\"第二层设置\"></a>第二层设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;  </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置</p>\n<h4 id=\"第三层设置\"><a href=\"#第三层设置\" class=\"headerlink\" title=\"第三层设置\"></a>第三层设置</h4><p>在window的<code>根控制器</code>中实现这两个方法，来加以控制，是否允许旋转以及支持的方向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否允许旋转</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\">//旋转的时候支持的方向</div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第四层设置\"><a href=\"#第四层设置\" class=\"headerlink\" title=\"第四层设置\"></a>第四层设置</h4><p>在你要控制是否旋转的这个控制里边实现上边的这两个方法</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><blockquote>\n<ul>\n<li>当屏幕旋转一次就会调用一次这个方法，来询问支持的方向</li>\n<li>这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响</li>\n<li>一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西<ul>\n<li>AppDelegate中的这个方法返回支持的方向</li>\n<li>window的根控制器中是否允许旋转，以及支持的方向</li>\n<li><strong>取交集</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>上边的的四层设置起作用的情况，我们要分三种情况来说</p>\n<blockquote>\n<ul>\n<li>要控制的控制器间接依附最开始创建的window<ul>\n<li>该控制器是通过navigationcontroller管理的/直接添加childcontrollers</li>\n<li>present…</li>\n</ul>\n</li>\n<li>要控制的控制器依附于新创建的window</li>\n</ul>\n</blockquote>\n<h5 id=\"原始window\"><a href=\"#原始window\" class=\"headerlink\" title=\"原始window\"></a>原始window</h5><blockquote>\n<ul>\n<li>受到Appdelegate中的方法的影响</li>\n<li>如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则</li>\n<li>如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响</li>\n</ul>\n</blockquote>\n<h5 id=\"依附于新创建的window\"><a href=\"#依附于新创建的window\" class=\"headerlink\" title=\"依附于新创建的window\"></a>依附于新创建的window</h5><blockquote>\n<ul>\n<li>不受到APPdelegate方法的影响</li>\n<li>其它都一样，但是分析的起点就变成了当前window的根控制器<ul>\n<li>比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><h4 id=\"整体是支持横屏，但是某个界面禁止\"><a href=\"#整体是支持横屏，但是某个界面禁止\" class=\"headerlink\" title=\"整体是支持横屏，但是某个界面禁止\"></a>整体是支持横屏，但是某个界面禁止</h4><p>根据上边叙述，我们可以得到以下方案：</p>\n<ul>\n<li>通过present…来管理控制器</li>\n</ul>\n<blockquote>\n<p>在这个控制器中添加控制器代码，禁止旋转或者只支持竖着<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  @implementation HSViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">   [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>不通过present来管理界面<blockquote>\n<p>通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;</div><div class=\"line\">    </div><div class=\"line\">    if ([nav.topViewController isKindOfClass:[HSViewController class]]) &#123;</div><div class=\"line\">        return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"整体是支持竖屏，但是某个界面可以横屏\"><a href=\"#整体是支持竖屏，但是某个界面可以横屏\" class=\"headerlink\" title=\"整体是支持竖屏，但是某个界面可以横屏\"></a>整体是支持竖屏，但是某个界面可以横屏</h4><p>这种需求，只能通过加判断代码来做到</p>\n<h4 id=\"控制通过webView加载的视频全屏时的横竖屏\"><a href=\"#控制通过webView加载的视频全屏时的横竖屏\" class=\"headerlink\" title=\"控制通过webView加载的视频全屏时的横竖屏\"></a>控制通过webView加载的视频全屏时的横竖屏</h4><p>webView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Extension.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Extension)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏</div><div class=\"line\">/**</div><div class=\"line\"> * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO</div><div class=\"line\"> *</div><div class=\"line\"> *  @return 返回是否</div><div class=\"line\"> */</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    //拿到当前主窗口的根控制器类型名称</div><div class=\"line\">    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);</div><div class=\"line\">    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转</div><div class=\"line\">    if ([className isEqualToString:@&quot;UIViewController&quot;]) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>"},{"title":"iOS中的空值","date":"2015-02-15T07:02:55.000Z","_content":"nil和NULL和Nil和NSNull的区别\n<!--more-->\n## nil\n- nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。\n- 例如：\n```\nNSString *someString = nil;\nNSURL *someURL = nil;\nid someObject = nil;\n\n\nif (anotherObject == nil) // do something\n- 定义：\n?\n// objc.h\n#ifndef nil\n# if __has_feature(cxx_nullptr)\n#  define nil nullptr\n# else\n#  define nil __DARWIN_NULL\n# endif\n#endif\n\n\n// __DARWIN_NULL in _types.h\n\n\n#define __DARWIN_NULL ((void *)0)\n```\n\n## Nil\n\n- Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。\n- 例如：\n\n```\nClass someClass = Nil;\nClass anotherClass = [NSString class];\n```\n\n- 定义声明和 nil 是差不多的，值相同：\n```\n// objc.h\n#ifndef Nil\n# if __has_feature(cxx_nullptr)\n#  define Nil nullptr\n# else\n#  define Nil __DARWIN_NULL\n# endif\n#endif\n```\n## NULL\n\n- NULL 是任意的 C 指针空值。\n- 例如：\n```\nint *pointerToInt = NULL;\n\n- char *pointerToChar = NULL;\n- struct TreeNode *rootNode = NULL;\n- 定义：\n?\n// in stddef.h\n\n\n#define NULL ((void*)0)\n```\n\n## NSNull\n- NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。\n- 注意，这里NSNull是一个单例，也就是说同一个数组中，如果我们要删除这个空对象，那么只要调用一次removeobjec:方法就好了。\n- 例子说明：\n```\n// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。\nNSArray *array = [NSArray arrayWithObjects:@\"one\", @\"two\", nil];\n\n-\n\n// 错误的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:nil forKey:@\"someKey\"];\n-\n\n// 正确的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:[NSNull null] forKey:@\"someKey\"];\n```\n\n，对于像NSArray这样的类型，nil或NULL不能做为加到其中的Object，如果定义了一个NSArray，为其分配了内存，又想设置其中的内容为空，则可以用[NSNULL null返回的对对象来初始化NSArray中的内容，我的感觉有点像C语言中malloc一个内存空间，然后用memset初始化这段空间里的值为0。\n\n由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据：\n\"somevalue\":null ，通过JsonKit 这个第三方库解析出来的数据就成了\nsomevalue=\"\"; 这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：\n-[NSNulllength]:unrecognizedselectorsenttoinstance0x388a4a70 ，这个就是NSNull类型的对象，代表空对象。\n## NIL 或 NSNil\n\nObjC 不存在这两个符号！\n\n小结\n\n虽然 nil, Nil, NULL 的值相同，理解它们之间的书面意义才重要，让代码更加明确，增加可读性。\n","source":"_posts/2015/iOS中的空值.md","raw":"---\ntitle: iOS中的空值\ndate: 2015-02-15 15:02:55\ntags:\n- iOS基础知识\ncategories: iOS\n---\nnil和NULL和Nil和NSNull的区别\n<!--more-->\n## nil\n- nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。\n- 例如：\n```\nNSString *someString = nil;\nNSURL *someURL = nil;\nid someObject = nil;\n\n\nif (anotherObject == nil) // do something\n- 定义：\n?\n// objc.h\n#ifndef nil\n# if __has_feature(cxx_nullptr)\n#  define nil nullptr\n# else\n#  define nil __DARWIN_NULL\n# endif\n#endif\n\n\n// __DARWIN_NULL in _types.h\n\n\n#define __DARWIN_NULL ((void *)0)\n```\n\n## Nil\n\n- Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。\n- 例如：\n\n```\nClass someClass = Nil;\nClass anotherClass = [NSString class];\n```\n\n- 定义声明和 nil 是差不多的，值相同：\n```\n// objc.h\n#ifndef Nil\n# if __has_feature(cxx_nullptr)\n#  define Nil nullptr\n# else\n#  define Nil __DARWIN_NULL\n# endif\n#endif\n```\n## NULL\n\n- NULL 是任意的 C 指针空值。\n- 例如：\n```\nint *pointerToInt = NULL;\n\n- char *pointerToChar = NULL;\n- struct TreeNode *rootNode = NULL;\n- 定义：\n?\n// in stddef.h\n\n\n#define NULL ((void*)0)\n```\n\n## NSNull\n- NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。\n- 注意，这里NSNull是一个单例，也就是说同一个数组中，如果我们要删除这个空对象，那么只要调用一次removeobjec:方法就好了。\n- 例子说明：\n```\n// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。\nNSArray *array = [NSArray arrayWithObjects:@\"one\", @\"two\", nil];\n\n-\n\n// 错误的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:nil forKey:@\"someKey\"];\n-\n\n// 正确的使用\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:[NSNull null] forKey:@\"someKey\"];\n```\n\n，对于像NSArray这样的类型，nil或NULL不能做为加到其中的Object，如果定义了一个NSArray，为其分配了内存，又想设置其中的内容为空，则可以用[NSNULL null返回的对对象来初始化NSArray中的内容，我的感觉有点像C语言中malloc一个内存空间，然后用memset初始化这段空间里的值为0。\n\n由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据：\n\"somevalue\":null ，通过JsonKit 这个第三方库解析出来的数据就成了\nsomevalue=\"\"; 这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：\n-[NSNulllength]:unrecognizedselectorsenttoinstance0x388a4a70 ，这个就是NSNull类型的对象，代表空对象。\n## NIL 或 NSNil\n\nObjC 不存在这两个符号！\n\n小结\n\n虽然 nil, Nil, NULL 的值相同，理解它们之间的书面意义才重要，让代码更加明确，增加可读性。\n","slug":"2015/iOS中的空值","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmq002vsauaxjvk1iw9","content":"<p>nil和NULL和Nil和NSNull的区别<br><a id=\"more\"></a></p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><ul>\n<li>nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *someString = nil;</div><div class=\"line\">NSURL *someURL = nil;</div><div class=\"line\">id someObject = nil;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if (anotherObject == nil) // do something</div><div class=\"line\">- 定义：</div><div class=\"line\">?</div><div class=\"line\">// objc.h</div><div class=\"line\">#ifndef nil</div><div class=\"line\"># if __has_feature(cxx_nullptr)</div><div class=\"line\">#  define nil nullptr</div><div class=\"line\"># else</div><div class=\"line\">#  define nil __DARWIN_NULL</div><div class=\"line\"># endif</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// __DARWIN_NULL in _types.h</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define __DARWIN_NULL ((void *)0)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Nil\"><a href=\"#Nil\" class=\"headerlink\" title=\"Nil\"></a>Nil</h2><ul>\n<li>Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class someClass = Nil;</div><div class=\"line\">Class anotherClass = [NSString class];</div></pre></td></tr></table></figure>\n<ul>\n<li>定义声明和 nil 是差不多的，值相同：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// objc.h</div><div class=\"line\">#ifndef Nil</div><div class=\"line\"># if __has_feature(cxx_nullptr)</div><div class=\"line\">#  define Nil nullptr</div><div class=\"line\"># else</div><div class=\"line\">#  define Nil __DARWIN_NULL</div><div class=\"line\"># endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><ul>\n<li>NULL 是任意的 C 指针空值。</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *pointerToInt = NULL;</div><div class=\"line\"></div><div class=\"line\">- char *pointerToChar = NULL;</div><div class=\"line\">- struct TreeNode *rootNode = NULL;</div><div class=\"line\">- 定义：</div><div class=\"line\">?</div><div class=\"line\">// in stddef.h</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define NULL ((void*)0)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NSNull\"><a href=\"#NSNull\" class=\"headerlink\" title=\"NSNull\"></a>NSNull</h2><ul>\n<li>NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。</li>\n<li>注意，这里NSNull是一个单例，也就是说同一个数组中，如果我们要删除这个空对象，那么只要调用一次removeobjec:方法就好了。</li>\n<li>例子说明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。</div><div class=\"line\">NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, nil];</div><div class=\"line\"></div><div class=\"line\">-</div><div class=\"line\"></div><div class=\"line\">// 错误的使用</div><div class=\"line\">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class=\"line\">[dict setObject:nil forKey:@&quot;someKey&quot;];</div><div class=\"line\">-</div><div class=\"line\"></div><div class=\"line\">// 正确的使用</div><div class=\"line\">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class=\"line\">[dict setObject:[NSNull null] forKey:@&quot;someKey&quot;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>，对于像NSArray这样的类型，nil或NULL不能做为加到其中的Object，如果定义了一个NSArray，为其分配了内存，又想设置其中的内容为空，则可以用[NSNULL null返回的对对象来初始化NSArray中的内容，我的感觉有点像C语言中malloc一个内存空间，然后用memset初始化这段空间里的值为0。</p>\n<p>由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据：<br>“somevalue”:null ，通过JsonKit 这个第三方库解析出来的数据就成了<br>somevalue=””; 这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：<br>-[NSNulllength]:unrecognizedselectorsenttoinstance0x388a4a70 ，这个就是NSNull类型的对象，代表空对象。</p>\n<h2 id=\"NIL-或-NSNil\"><a href=\"#NIL-或-NSNil\" class=\"headerlink\" title=\"NIL 或 NSNil\"></a>NIL 或 NSNil</h2><p>ObjC 不存在这两个符号！</p>\n<p>小结</p>\n<p>虽然 nil, Nil, NULL 的值相同，理解它们之间的书面意义才重要，让代码更加明确，增加可读性。</p>\n","site":{"data":{}},"excerpt":"<p>nil和NULL和Nil和NSNull的区别<br>","more":"</p>\n<h2 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h2><ul>\n<li>nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString *someString = nil;</div><div class=\"line\">NSURL *someURL = nil;</div><div class=\"line\">id someObject = nil;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">if (anotherObject == nil) // do something</div><div class=\"line\">- 定义：</div><div class=\"line\">?</div><div class=\"line\">// objc.h</div><div class=\"line\">#ifndef nil</div><div class=\"line\"># if __has_feature(cxx_nullptr)</div><div class=\"line\">#  define nil nullptr</div><div class=\"line\"># else</div><div class=\"line\">#  define nil __DARWIN_NULL</div><div class=\"line\"># endif</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// __DARWIN_NULL in _types.h</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define __DARWIN_NULL ((void *)0)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Nil\"><a href=\"#Nil\" class=\"headerlink\" title=\"Nil\"></a>Nil</h2><ul>\n<li>Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。</li>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Class someClass = Nil;</div><div class=\"line\">Class anotherClass = [NSString class];</div></pre></td></tr></table></figure>\n<ul>\n<li>定义声明和 nil 是差不多的，值相同：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// objc.h</div><div class=\"line\">#ifndef Nil</div><div class=\"line\"># if __has_feature(cxx_nullptr)</div><div class=\"line\">#  define Nil nullptr</div><div class=\"line\"># else</div><div class=\"line\">#  define Nil __DARWIN_NULL</div><div class=\"line\"># endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><ul>\n<li>NULL 是任意的 C 指针空值。</li>\n<li>例如：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int *pointerToInt = NULL;</div><div class=\"line\"></div><div class=\"line\">- char *pointerToChar = NULL;</div><div class=\"line\">- struct TreeNode *rootNode = NULL;</div><div class=\"line\">- 定义：</div><div class=\"line\">?</div><div class=\"line\">// in stddef.h</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#define NULL ((void*)0)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"NSNull\"><a href=\"#NSNull\" class=\"headerlink\" title=\"NSNull\"></a>NSNull</h2><ul>\n<li>NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。</li>\n<li>注意，这里NSNull是一个单例，也就是说同一个数组中，如果我们要删除这个空对象，那么只要调用一次removeobjec:方法就好了。</li>\n<li>例子说明：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。</div><div class=\"line\">NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, nil];</div><div class=\"line\"></div><div class=\"line\">-</div><div class=\"line\"></div><div class=\"line\">// 错误的使用</div><div class=\"line\">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class=\"line\">[dict setObject:nil forKey:@&quot;someKey&quot;];</div><div class=\"line\">-</div><div class=\"line\"></div><div class=\"line\">// 正确的使用</div><div class=\"line\">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</div><div class=\"line\">[dict setObject:[NSNull null] forKey:@&quot;someKey&quot;];</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>，对于像NSArray这样的类型，nil或NULL不能做为加到其中的Object，如果定义了一个NSArray，为其分配了内存，又想设置其中的内容为空，则可以用[NSNULL null返回的对对象来初始化NSArray中的内容，我的感觉有点像C语言中malloc一个内存空间，然后用memset初始化这段空间里的值为0。</p>\n<p>由于服务器的数据库中有些字段为空，然后以Json形式返回给客户端时就会出现这样的数据：<br>“somevalue”:null ，通过JsonKit 这个第三方库解析出来的数据就成了<br>somevalue=””; 这个数据类型不是nil 也不是 String。 解析成对象之后，如果直接向这个对象发送消息（eg：length，count 等等）就会直接崩溃。提示错误为：<br>-[NSNulllength]:unrecognizedselectorsenttoinstance0x388a4a70 ，这个就是NSNull类型的对象，代表空对象。</p>\n<h2 id=\"NIL-或-NSNil\"><a href=\"#NIL-或-NSNil\" class=\"headerlink\" title=\"NIL 或 NSNil\"></a>NIL 或 NSNil</h2><p>ObjC 不存在这两个符号！</p>\n<p>小结</p>\n<p>虽然 nil, Nil, NULL 的值相同，理解它们之间的书面意义才重要，让代码更加明确，增加可读性。</p>"},{"title":"runtime概述","date":"2015-08-10T03:31:29.000Z","_content":"<!--more-->\n## runtime概述\n>**什么是runtime?**\nruntime直译就是运行时间,run(跑,运行) time(时间),网上大家都叫它运行时,它是一套比较底层的纯C语言API,属于一个C语言库,包含了很多底层的C语言API,它是OC的幕后工作者,我们平时写的OC代码,在运行过程时,都会转为runtime的C语言代码\n### 类与对象\n####Object\n```\ninterface NSObject <NSObject> {\n    Class isa  OBJC_ISA_AVAILABILITY;\n}\n```\n#### objc_method\n```\ntypedef struct objc_ method {\n    SEL method_name;\n    char *method_types;\n    IMP method_imp;\n};\n```\n\n#### objc_class\n```\nstruct objc_class {\n    Class isa;\n\n#if !__OBJC2__\n    Class super_class;                                        \n    const char *name;\n    long version;                          //类的版本信息，默认为0\n    long info;                             //类信息，供运行期使用的一些位标识\n    long instance_size;                    //该类的实例变量大小\n    struct objc_ivar_list *ivars;          //成员列表\n    struct objc_method_list **methodLists; //方法列表\n    struct objc_cache *cache;              //方法缓存\n    struct objc_protocol_list *protocols;  //协议链表\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n#### Method & SEL & IMP\n>- Method:`(typedef struct objc_method *Method)`在类定义中表示方法的类型，相当于SEL和IMP的映射\n>- SEL(selector):`typedef struct objc_selector *SEL`方法选择器，用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。\n>- IMP(implement):`typedef id (*IMP)(id, SEL, …)`方法的实现，这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。\n\n------\n>**注意**，SEL是由方法的名字，也就是字符串来生成的(包含参数)，也就是说，在不同的类中的方法，只要名字和参数相同，那么它的SEL也是相同的，SEL本质是一个Int类型的一个地址(用%p来表示)，地址中存放着方法的名字所有的SEL存储在一个NSSet中，所以SEL是唯一的，以hash实现搜索定位，效率高于NSArray，在方法的调用的时候，是通过数字的查找而非字符串的查找来进行方法定位的，当我定义一个类的时候，有声明或者实现，都会有对应的SEL以及Method对象存在，但是没有实现是IMP则为空，`SEL selector = NSSelectorFromString(@\"run\");`这个代码永远是正确的，但是`IMP ipmSel = [FXViewController methodForSelector:selector];`如果这个类没有这个实现，那么是会返回`(libobjc.A.dylib_objc_msgForward)`。\n>所以理论上来讲iOS不存在私有方法，因为我们可以通过运行时来调用任何存在的method，只不过这个方法没有在.h文件进行声明的话，在编译层面会进行一些禁止而已，这样也保障了运行的安全。\n```\nSEL selector = NSSelectorFromString(@\"run\");\nClass class = NSClassFromString(@\"FXViewController\");\nif ([class respondsToSelector:selector]) {\n    [class performSelector:selector withObject:nil];\n}\n```\n当我们在类中进行方法的声明或者实现的时候，底层会默认根据方法名，来注册这个方法，生成对应的SEL和Method，SEL会由一个NSSet来做一个统一的维护，另外Method对象会保存在对应的类的methodlist中，当我们在方法调用的时候，系统会快速的通过注册方法来拿到SEL，然后到对应的类的实现中去根据SEL查找Method，如果Method存在则直接跳转到IMP去调用其指向的函数。如果一个方法只有声明没有实现，那么这个类中是不会有Method对象存在的，可以用`class_copyMethodList`进行验证\n![Alt text](./1460617119227.png)\n这张图在加载类的时候创建，当发现有方法声明，或者方法实现，或者方法调用的时候，就会把对应的字符串进行一个注册，形成上边那样的一张表，这张表中的SEL是经过运算得到的，而不是查找。\n#### 运行时方法总结\n`通过名字获取SEL，通过SEL和Class获取IMP`\n```\n// 添加方法\nBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );\n// 获取实例方法\nMethod class_getInstanceMethod ( Class cls, SEL name );\n// 获取类方法\nMethod class_getClassMethod ( Class cls, SEL name );\n// 获取所有实例方法的数组，不能获取类方法\nMethod * class_copyMethodList ( Class cls, unsigned int *outCount );\n// 替代方法的实现，如果IMP不存在则默认调用class_addMethod方法\nIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );\n// 返回方法的具体实现\nIMP class_getMethodImplementation ( Class cls, SEL name );\nIMP class_getMethodImplementation_stret ( Class cls, SEL name );\n// 类实例是否响应指定的selector\nBOOL class_respondsToSelector ( Class cls, SEL sel );\n```\n\n#### 获取列表\n```\n unsigned int count;\n    //获取属性列表\n    objc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n\n    //获取方法列表\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n\n    //获取成员变量列表\n    Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    }\n\n    //获取协议列表\n    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n```\n\n### 方法的执行\n- 调用类的alloc方法，分配内存，初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力；\n- 当我们调用某个方法的时候，编译器会对这个方法调用进行转换\n\n```\n//1.利用msgSend函数\n\t[someone method];\n\t[someone performSelector:@selector(method)];\n\t---->objc_msgSend(someone, @selector(method));\n//2.利用转发函数\n\tNSinvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];\n[invocation invoke];\n\n```\n\n> `objc_msgSend`的作用:\n> - 它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型\n>-  然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。\n>-  最后，将方法实现的返回值作为该函数的返回值返回。\n\n\n#### 注意：\n当我们创建一个对象的时候，首先根据类的info来分配内存，然后初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力，当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。\n动态绑定为我们写代码提供了方便，却带来了性能的损耗，因为函数的调用通过地址可以直接确定，而方法需要通过函数的查找，但是方法的缓存一定程度上解决了这个问题。\n\n### 消息转发机制\n消息转发用到的方法(消息拦截用到的方法)\n\n```\n+ (BOOL)resolveClassMethod:(SEL)sel;\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n//后两个方法需要转发到其他的类处理\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/16603936.jpg)\n\n\n我们调用一个方法有两种形式\n```\n[object message];\n\n[object performSelector:@selector(method) withObject:nil];\n```\n第一种我们可以确定对象是否能够处理该方法，如果没有声明编译器会直接报错，不过也存在没有方法实现的风险，第二种方式就会直接编译通过，运行崩溃。\n规避的方法有两种\n- 第一就是在调用方法之前判断是否该方法实现\n```\nif ([self respondsToSelector:@selector(method)]) {\n    [self performSelector:@selector(method)];\n}\n```\n- 消息转发机制：通过这一机制，我们可以告诉对象如何处理未知的消息。\n>默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：\n\n```\n-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'\n```\n\n>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。\n>消息转发机制基本上分为三个步骤：\n- 动态方法解析\n- 备用接收者\n- 完整转发\n\n\n#### 动态方法解析\n对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。\n\n```\nvoid functionForMethod1(id self, SEL _cmd) {\n\n   NSLog(@\"%@, %p\", self, _cmd);\n\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    NSString *selectorString = NSStringFromSelector(sel);\n    if ([selectorString isEqualToString:@\"method1\"]) {\n        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, \"@:\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n不过这种方案更多的是为了实现@dynamic属性。\n#### 备用接收者\n\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector\n```\n\n如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。\n\n```\ninterface SUTRuntimeMethodHelper : NSObject\n- (void)method2;\nend\nimplementation SUTRuntimeMethodHelper\n- (void)method2 {\n    NSLog(@\"%@, %p\", self, _cmd);\n}\n@(02-Foundation)end\n#pragma mark -\n@interface SUTRuntimeMethod () {\n    SUTRuntimeMethodHelper *_helper;\n}\n@end\n@implementation SUTRuntimeMethod\n+ (instancetype)object {\n    return [[self alloc] init];\n}\n- (instancetype)init {\n    self = [super init];\n    if (self != nil) {\n        _helper = [[SUTRuntimeMethodHelper alloc] init];\n    }\n    return self;\n}\n- (void)test {\n    [self performSelector:@selector(method2)];\n}\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    NSLog(@\"forwardingTargetForSelector\");\n    NSString *selectorString = NSStringFromSelector(aSelector);\n    // 将消息转发给_helper来处理\n    if ([selectorString isEqualToString:@\"method2\"]) {\n        return _helper;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n```\n#### 完整转发\n如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n```\n>对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];\n    if (!signature) {\n        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {\n            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];\n        }\n    }\n    return signature;\n}\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {\n        [anInvocation invokeWithTarget:_helper];\n    }\n}\n```\n>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。\n\n### 动态方法添加\n首先调用一个不存在的方法\n```\n//隐式调用方法\n[target performSelector:@selector(resolveAdd:) withObject:@\"test\"];\n```\n然后，在target对象内部重写拦截调用的方法，动态添加方法。\n```\nvoid runAddMethod(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP \", string);\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n\n    //给本类动态添加一个方法\n    if ([NSStringFromSelector(sel) isEqualToString:@\"resolveAdd:\"]) {\n        class_addMethod(self, sel, (IMP)runAddMethod, \"v@:*\");\n    }\n    return YES;\n}\n```\n>其中class_addMethod的四个参数分别是：\n- Class cls 给哪个类添加方法，本例中是self\n- SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。\n- IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用- + (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。\n- \"v@:*\"方法的签名，代表有一个参数的方法\n\n###Method Swizzling\n为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。\n```\n#import <objc/runtime.h>\n@implementation UIViewController (Tracking)\n+ (void)load {\n        static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];         \n        // When swizzling a class method, use the following:\n                    // Class class = object_getClass((id)self);\n        SEL originalSelector = @selector(viewWillAppear:);\n                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        BOOL didAddMethod =\n                        class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n        if (didAddMethod) {\n                        class_replaceMethod(class,\n                swizzledSelector,\n                method_getImplementation(originalMethod),\n                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n#pragma mark - Method Swizzling\n- (void)xxx_viewWillAppear:(BOOL)animated {\n        [self xxx_viewWillAppear:animated];\n    NSLog(@\"viewWillAppear: %@\", self);\n}\n@end\n```\n#### 注意\n- Swizzling应该总是在+load中执行\n>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。\n\n- Swizzling应该总是在dispatch_once中执行\n>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践\n\n- 小心无限循环\n>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。\n\n### 对象关联\n现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。\n这种情况的一般解决办法就是继承。\n但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。\n这个时候，runtime的关联属性就发挥它的作用了。\n```\n//首先定义一个全局变量，用它的地址作为关联对象的key\nstatic char associatedObjectKey;\n//设置关联对象\nobjc_setAssociatedObject(target, &associatedObjectKey, @\"添加的字符串属性\", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象\nNSString *string = objc_getAssociatedObject(target, &associatedObjectKey);\nNSLog(@\"AssociatedObject = %@\", string);\n```\n>objc_setAssociatedObject的四个参数：\n- id object给谁设置关联对象。\n- const void *key关联对象唯一的key，获取时会用到。\n- id value关联对象。\n- objc_AssociationPolicy关联策略，有以下几种策略：\n>enum {\n    OBJC_ASSOCIATION_ASSIGN = 0,\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, \n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,\n    OBJC_ASSOCIATION_RETAIN = 01401,\n    OBJC_ASSOCIATION_COPY = 01403 \n};\n如果你熟悉OC，看名字应该知道这几种策略的意思了吧。\n\n\n`objc_getAssociatedObject`的两个参数。\n- id object获取谁的关联对象。\n- const void *key根据这个唯一的key获取关联对象。\n其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。\n```\n//添加关联对象\n- (void)addAssociatedObject:(id)object{\n    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n//获取关联对象\n- (id)getAssociatedObject{\n    return objc_getAssociatedObject(self, _cmd);\n}\n```\n注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。\n\n### 总结\n- 方法调用的本质就是通过instance/class+SEL来找到IMP，最终调用IMP的函数来执行调用的\n- 方法调用可以使用invoke的方法\n- 增加方法的是在某个类中增加Method，也就是增加SLE和IMP\n- 替换方法的是更改SLE与IMP的映射关系\n\n---------------------\n参考：\n[南峰子-runtime](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n[iOS-runtime理解-简书](http://www.jianshu.com/p/927c8384855a)\n\n","source":"_posts/2015/runtime概述.md","raw":"---\ntitle: runtime概述\ndate: 2015-08-10 11:31:29\ntags:\n- iOS进阶\ncategories: iOS\n---\n<!--more-->\n## runtime概述\n>**什么是runtime?**\nruntime直译就是运行时间,run(跑,运行) time(时间),网上大家都叫它运行时,它是一套比较底层的纯C语言API,属于一个C语言库,包含了很多底层的C语言API,它是OC的幕后工作者,我们平时写的OC代码,在运行过程时,都会转为runtime的C语言代码\n### 类与对象\n####Object\n```\ninterface NSObject <NSObject> {\n    Class isa  OBJC_ISA_AVAILABILITY;\n}\n```\n#### objc_method\n```\ntypedef struct objc_ method {\n    SEL method_name;\n    char *method_types;\n    IMP method_imp;\n};\n```\n\n#### objc_class\n```\nstruct objc_class {\n    Class isa;\n\n#if !__OBJC2__\n    Class super_class;                                        \n    const char *name;\n    long version;                          //类的版本信息，默认为0\n    long info;                             //类信息，供运行期使用的一些位标识\n    long instance_size;                    //该类的实例变量大小\n    struct objc_ivar_list *ivars;          //成员列表\n    struct objc_method_list **methodLists; //方法列表\n    struct objc_cache *cache;              //方法缓存\n    struct objc_protocol_list *protocols;  //协议链表\n#endif\n\n} OBJC2_UNAVAILABLE;\n```\n#### Method & SEL & IMP\n>- Method:`(typedef struct objc_method *Method)`在类定义中表示方法的类型，相当于SEL和IMP的映射\n>- SEL(selector):`typedef struct objc_selector *SEL`方法选择器，用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。\n>- IMP(implement):`typedef id (*IMP)(id, SEL, …)`方法的实现，这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。\n\n------\n>**注意**，SEL是由方法的名字，也就是字符串来生成的(包含参数)，也就是说，在不同的类中的方法，只要名字和参数相同，那么它的SEL也是相同的，SEL本质是一个Int类型的一个地址(用%p来表示)，地址中存放着方法的名字所有的SEL存储在一个NSSet中，所以SEL是唯一的，以hash实现搜索定位，效率高于NSArray，在方法的调用的时候，是通过数字的查找而非字符串的查找来进行方法定位的，当我定义一个类的时候，有声明或者实现，都会有对应的SEL以及Method对象存在，但是没有实现是IMP则为空，`SEL selector = NSSelectorFromString(@\"run\");`这个代码永远是正确的，但是`IMP ipmSel = [FXViewController methodForSelector:selector];`如果这个类没有这个实现，那么是会返回`(libobjc.A.dylib_objc_msgForward)`。\n>所以理论上来讲iOS不存在私有方法，因为我们可以通过运行时来调用任何存在的method，只不过这个方法没有在.h文件进行声明的话，在编译层面会进行一些禁止而已，这样也保障了运行的安全。\n```\nSEL selector = NSSelectorFromString(@\"run\");\nClass class = NSClassFromString(@\"FXViewController\");\nif ([class respondsToSelector:selector]) {\n    [class performSelector:selector withObject:nil];\n}\n```\n当我们在类中进行方法的声明或者实现的时候，底层会默认根据方法名，来注册这个方法，生成对应的SEL和Method，SEL会由一个NSSet来做一个统一的维护，另外Method对象会保存在对应的类的methodlist中，当我们在方法调用的时候，系统会快速的通过注册方法来拿到SEL，然后到对应的类的实现中去根据SEL查找Method，如果Method存在则直接跳转到IMP去调用其指向的函数。如果一个方法只有声明没有实现，那么这个类中是不会有Method对象存在的，可以用`class_copyMethodList`进行验证\n![Alt text](./1460617119227.png)\n这张图在加载类的时候创建，当发现有方法声明，或者方法实现，或者方法调用的时候，就会把对应的字符串进行一个注册，形成上边那样的一张表，这张表中的SEL是经过运算得到的，而不是查找。\n#### 运行时方法总结\n`通过名字获取SEL，通过SEL和Class获取IMP`\n```\n// 添加方法\nBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );\n// 获取实例方法\nMethod class_getInstanceMethod ( Class cls, SEL name );\n// 获取类方法\nMethod class_getClassMethod ( Class cls, SEL name );\n// 获取所有实例方法的数组，不能获取类方法\nMethod * class_copyMethodList ( Class cls, unsigned int *outCount );\n// 替代方法的实现，如果IMP不存在则默认调用class_addMethod方法\nIMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );\n// 返回方法的具体实现\nIMP class_getMethodImplementation ( Class cls, SEL name );\nIMP class_getMethodImplementation_stret ( Class cls, SEL name );\n// 类实例是否响应指定的selector\nBOOL class_respondsToSelector ( Class cls, SEL sel );\n```\n\n#### 获取列表\n```\n unsigned int count;\n    //获取属性列表\n    objc_property_t *propertyList = class_copyPropertyList([self class], &count);\n    for (unsigned int i=0; i<count; i++) {\n        const char *propertyName = property_getName(propertyList[i]);\n        NSLog(@\"property---->%@\", [NSString stringWithUTF8String:propertyName]);\n    }\n\n    //获取方法列表\n    Method *methodList = class_copyMethodList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Method method = methodList[i];\n        NSLog(@\"method---->%@\", NSStringFromSelector(method_getName(method)));\n    }\n\n    //获取成员变量列表\n    Ivar *ivarList = class_copyIvarList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Ivar myIvar = ivarList[i];\n        const char *ivarName = ivar_getName(myIvar);\n        NSLog(@\"Ivar---->%@\", [NSString stringWithUTF8String:ivarName]);\n    }\n\n    //获取协议列表\n    __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &count);\n    for (unsigned int i; i<count; i++) {\n        Protocol *myProtocal = protocolList[i];\n        const char *protocolName = protocol_getName(myProtocal);\n        NSLog(@\"protocol---->%@\", [NSString stringWithUTF8String:protocolName]);\n    }\n```\n\n### 方法的执行\n- 调用类的alloc方法，分配内存，初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力；\n- 当我们调用某个方法的时候，编译器会对这个方法调用进行转换\n\n```\n//1.利用msgSend函数\n\t[someone method];\n\t[someone performSelector:@selector(method)];\n\t---->objc_msgSend(someone, @selector(method));\n//2.利用转发函数\n\tNSinvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];\n[invocation invoke];\n\n```\n\n> `objc_msgSend`的作用:\n> - 它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型\n>-  然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。\n>-  最后，将方法实现的返回值作为该函数的返回值返回。\n\n\n#### 注意：\n当我们创建一个对象的时候，首先根据类的info来分配内存，然后初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力，当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。\n动态绑定为我们写代码提供了方便，却带来了性能的损耗，因为函数的调用通过地址可以直接确定，而方法需要通过函数的查找，但是方法的缓存一定程度上解决了这个问题。\n\n### 消息转发机制\n消息转发用到的方法(消息拦截用到的方法)\n\n```\n+ (BOOL)resolveClassMethod:(SEL)sel;\n+ (BOOL)resolveInstanceMethod:(SEL)sel;\n//后两个方法需要转发到其他的类处理\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/16603936.jpg)\n\n\n我们调用一个方法有两种形式\n```\n[object message];\n\n[object performSelector:@selector(method) withObject:nil];\n```\n第一种我们可以确定对象是否能够处理该方法，如果没有声明编译器会直接报错，不过也存在没有方法实现的风险，第二种方式就会直接编译通过，运行崩溃。\n规避的方法有两种\n- 第一就是在调用方法之前判断是否该方法实现\n```\nif ([self respondsToSelector:@selector(method)]) {\n    [self performSelector:@selector(method)];\n}\n```\n- 消息转发机制：通过这一机制，我们可以告诉对象如何处理未知的消息。\n>默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：\n\n```\n-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940\n\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'\n```\n\n>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。\n>消息转发机制基本上分为三个步骤：\n- 动态方法解析\n- 备用接收者\n- 完整转发\n\n\n#### 动态方法解析\n对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。\n\n```\nvoid functionForMethod1(id self, SEL _cmd) {\n\n   NSLog(@\"%@, %p\", self, _cmd);\n\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    NSString *selectorString = NSStringFromSelector(sel);\n    if ([selectorString isEqualToString:@\"method1\"]) {\n        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, \"@:\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n不过这种方案更多的是为了实现@dynamic属性。\n#### 备用接收者\n\n```\n- (id)forwardingTargetForSelector:(SEL)aSelector\n```\n\n如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。\n\n```\ninterface SUTRuntimeMethodHelper : NSObject\n- (void)method2;\nend\nimplementation SUTRuntimeMethodHelper\n- (void)method2 {\n    NSLog(@\"%@, %p\", self, _cmd);\n}\n@(02-Foundation)end\n#pragma mark -\n@interface SUTRuntimeMethod () {\n    SUTRuntimeMethodHelper *_helper;\n}\n@end\n@implementation SUTRuntimeMethod\n+ (instancetype)object {\n    return [[self alloc] init];\n}\n- (instancetype)init {\n    self = [super init];\n    if (self != nil) {\n        _helper = [[SUTRuntimeMethodHelper alloc] init];\n    }\n    return self;\n}\n- (void)test {\n    [self performSelector:@selector(method2)];\n}\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    NSLog(@\"forwardingTargetForSelector\");\n    NSString *selectorString = NSStringFromSelector(aSelector);\n    // 将消息转发给_helper来处理\n    if ([selectorString isEqualToString:@\"method2\"]) {\n        return _helper;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n```\n#### 完整转发\n如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法\n```\n- (void)forwardInvocation:(NSInvocation *)anInvocation\n```\n>对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];\n    if (!signature) {\n        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) {\n            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];\n        }\n    }\n    return signature;\n}\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) {\n        [anInvocation invokeWithTarget:_helper];\n    }\n}\n```\n>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。\n\n### 动态方法添加\n首先调用一个不存在的方法\n```\n//隐式调用方法\n[target performSelector:@selector(resolveAdd:) withObject:@\"test\"];\n```\n然后，在target对象内部重写拦截调用的方法，动态添加方法。\n```\nvoid runAddMethod(id self, SEL _cmd, NSString *string){\n    NSLog(@\"add C IMP \", string);\n}\n+ (BOOL)resolveInstanceMethod:(SEL)sel{\n\n    //给本类动态添加一个方法\n    if ([NSStringFromSelector(sel) isEqualToString:@\"resolveAdd:\"]) {\n        class_addMethod(self, sel, (IMP)runAddMethod, \"v@:*\");\n    }\n    return YES;\n}\n```\n>其中class_addMethod的四个参数分别是：\n- Class cls 给哪个类添加方法，本例中是self\n- SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。\n- IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用- + (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。\n- \"v@:*\"方法的签名，代表有一个参数的方法\n\n###Method Swizzling\n为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。\n```\n#import <objc/runtime.h>\n@implementation UIViewController (Tracking)\n+ (void)load {\n        static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class class = [self class];         \n        // When swizzling a class method, use the following:\n                    // Class class = object_getClass((id)self);\n        SEL originalSelector = @selector(viewWillAppear:);\n                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);\n        Method originalMethod = class_getInstanceMethod(class, originalSelector);\n                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n        BOOL didAddMethod =\n                        class_addMethod(class,\n                originalSelector,\n                method_getImplementation(swizzledMethod),\n                method_getTypeEncoding(swizzledMethod));\n        if (didAddMethod) {\n                        class_replaceMethod(class,\n                swizzledSelector,\n                method_getImplementation(originalMethod),\n                method_getTypeEncoding(originalMethod));\n        } else {\n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n#pragma mark - Method Swizzling\n- (void)xxx_viewWillAppear:(BOOL)animated {\n        [self xxx_viewWillAppear:animated];\n    NSLog(@\"viewWillAppear: %@\", self);\n}\n@end\n```\n#### 注意\n- Swizzling应该总是在+load中执行\n>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。\n\n- Swizzling应该总是在dispatch_once中执行\n>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践\n\n- 小心无限循环\n>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。\n\n### 对象关联\n现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。\n这种情况的一般解决办法就是继承。\n但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。\n这个时候，runtime的关联属性就发挥它的作用了。\n```\n//首先定义一个全局变量，用它的地址作为关联对象的key\nstatic char associatedObjectKey;\n//设置关联对象\nobjc_setAssociatedObject(target, &associatedObjectKey, @\"添加的字符串属性\", OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象\nNSString *string = objc_getAssociatedObject(target, &associatedObjectKey);\nNSLog(@\"AssociatedObject = %@\", string);\n```\n>objc_setAssociatedObject的四个参数：\n- id object给谁设置关联对象。\n- const void *key关联对象唯一的key，获取时会用到。\n- id value关联对象。\n- objc_AssociationPolicy关联策略，有以下几种策略：\n>enum {\n    OBJC_ASSOCIATION_ASSIGN = 0,\n    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, \n    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,\n    OBJC_ASSOCIATION_RETAIN = 01401,\n    OBJC_ASSOCIATION_COPY = 01403 \n};\n如果你熟悉OC，看名字应该知道这几种策略的意思了吧。\n\n\n`objc_getAssociatedObject`的两个参数。\n- id object获取谁的关联对象。\n- const void *key根据这个唯一的key获取关联对象。\n其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。\n```\n//添加关联对象\n- (void)addAssociatedObject:(id)object{\n    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n//获取关联对象\n- (id)getAssociatedObject{\n    return objc_getAssociatedObject(self, _cmd);\n}\n```\n注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。\n\n### 总结\n- 方法调用的本质就是通过instance/class+SEL来找到IMP，最终调用IMP的函数来执行调用的\n- 方法调用可以使用invoke的方法\n- 增加方法的是在某个类中增加Method，也就是增加SLE和IMP\n- 替换方法的是更改SLE与IMP的映射关系\n\n---------------------\n参考：\n[南峰子-runtime](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n[iOS-runtime理解-简书](http://www.jianshu.com/p/927c8384855a)\n\n","slug":"2015/runtime概述","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmr002ysauaf43p1cgu","content":"<a id=\"more\"></a>\n<h2 id=\"runtime概述\"><a href=\"#runtime概述\" class=\"headerlink\" title=\"runtime概述\"></a>runtime概述</h2><blockquote>\n<p><strong>什么是runtime?</strong><br>runtime直译就是运行时间,run(跑,运行) time(时间),网上大家都叫它运行时,它是一套比较底层的纯C语言API,属于一个C语言库,包含了很多底层的C语言API,它是OC的幕后工作者,我们平时写的OC代码,在运行过程时,都会转为runtime的C语言代码</p>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>####Object<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface NSObject &lt;NSObject&gt; &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"objc-method\"><a href=\"#objc-method\" class=\"headerlink\" title=\"objc_method\"></a>objc_method</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_ method &#123;</div><div class=\"line\">    SEL method_name;</div><div class=\"line\">    char *method_types;</div><div class=\"line\">    IMP method_imp;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa;</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class super_class;                                        </div><div class=\"line\">    const char *name;</div><div class=\"line\">    long version;                          //类的版本信息，默认为0</div><div class=\"line\">    long info;                             //类信息，供运行期使用的一些位标识</div><div class=\"line\">    long instance_size;                    //该类的实例变量大小</div><div class=\"line\">    struct objc_ivar_list *ivars;          //成员列表</div><div class=\"line\">    struct objc_method_list **methodLists; //方法列表</div><div class=\"line\">    struct objc_cache *cache;              //方法缓存</div><div class=\"line\">    struct objc_protocol_list *protocols;  //协议链表</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<h4 id=\"Method-amp-SEL-amp-IMP\"><a href=\"#Method-amp-SEL-amp-IMP\" class=\"headerlink\" title=\"Method &amp; SEL &amp; IMP\"></a>Method &amp; SEL &amp; IMP</h4><blockquote>\n<ul>\n<li>Method:<code>(typedef struct objc_method *Method)</code>在类定义中表示方法的类型，相当于SEL和IMP的映射</li>\n<li>SEL(selector):<code>typedef struct objc_selector *SEL</code>方法选择器，用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>\n<li>IMP(implement):<code>typedef id (*IMP)(id, SEL, …)</code>方法的实现，这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>注意</strong>，SEL是由方法的名字，也就是字符串来生成的(包含参数)，也就是说，在不同的类中的方法，只要名字和参数相同，那么它的SEL也是相同的，SEL本质是一个Int类型的一个地址(用%p来表示)，地址中存放着方法的名字所有的SEL存储在一个NSSet中，所以SEL是唯一的，以hash实现搜索定位，效率高于NSArray，在方法的调用的时候，是通过数字的查找而非字符串的查找来进行方法定位的，当我定义一个类的时候，有声明或者实现，都会有对应的SEL以及Method对象存在，但是没有实现是IMP则为空，<code>SEL selector = NSSelectorFromString(@&quot;run&quot;);</code>这个代码永远是正确的，但是<code>IMP ipmSel = [FXViewController methodForSelector:selector];</code>如果这个类没有这个实现，那么是会返回<code>(libobjc.A.dylib_objc_msgForward)</code>。<br>所以理论上来讲iOS不存在私有方法，因为我们可以通过运行时来调用任何存在的method，只不过这个方法没有在.h文件进行声明的话，在编译层面会进行一些禁止而已，这样也保障了运行的安全。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL selector = NSSelectorFromString(@&quot;run&quot;);</div><div class=\"line\">Class class = NSClassFromString(@&quot;FXViewController&quot;);</div><div class=\"line\">if ([class respondsToSelector:selector]) &#123;</div><div class=\"line\">    [class performSelector:selector withObject:nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>当我们在类中进行方法的声明或者实现的时候，底层会默认根据方法名，来注册这个方法，生成对应的SEL和Method，SEL会由一个NSSet来做一个统一的维护，另外Method对象会保存在对应的类的methodlist中，当我们在方法调用的时候，系统会快速的通过注册方法来拿到SEL，然后到对应的类的实现中去根据SEL查找Method，如果Method存在则直接跳转到IMP去调用其指向的函数。如果一个方法只有声明没有实现，那么这个类中是不会有Method对象存在的，可以用<code>class_copyMethodList</code>进行验证<br><img src=\"./1460617119227.png\" alt=\"Alt text\"><br>这张图在加载类的时候创建，当发现有方法声明，或者方法实现，或者方法调用的时候，就会把对应的字符串进行一个注册，形成上边那样的一张表，这张表中的SEL是经过运算得到的，而不是查找。</p>\n<h4 id=\"运行时方法总结\"><a href=\"#运行时方法总结\" class=\"headerlink\" title=\"运行时方法总结\"></a>运行时方法总结</h4><p><code>通过名字获取SEL，通过SEL和Class获取IMP</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 添加方法</div><div class=\"line\">BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );</div><div class=\"line\">// 获取实例方法</div><div class=\"line\">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class=\"line\">// 获取类方法</div><div class=\"line\">Method class_getClassMethod ( Class cls, SEL name );</div><div class=\"line\">// 获取所有实例方法的数组，不能获取类方法</div><div class=\"line\">Method * class_copyMethodList ( Class cls, unsigned int *outCount );</div><div class=\"line\">// 替代方法的实现，如果IMP不存在则默认调用class_addMethod方法</div><div class=\"line\">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );</div><div class=\"line\">// 返回方法的具体实现</div><div class=\"line\">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class=\"line\">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class=\"line\">// 类实例是否响应指定的selector</div><div class=\"line\">BOOL class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure></p>\n<h4 id=\"获取列表\"><a href=\"#获取列表\" class=\"headerlink\" title=\"获取列表\"></a>获取列表</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">unsigned int count;</div><div class=\"line\">   //获取属性列表</div><div class=\"line\">   objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">       const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">       NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取方法列表</div><div class=\"line\">   Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Method method = methodList[i];</div><div class=\"line\">       NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取成员变量列表</div><div class=\"line\">   Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Ivar myIvar = ivarList[i];</div><div class=\"line\">       const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">       NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取协议列表</div><div class=\"line\">   __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Protocol *myProtocal = protocolList[i];</div><div class=\"line\">       const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">       NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"方法的执行\"><a href=\"#方法的执行\" class=\"headerlink\" title=\"方法的执行\"></a>方法的执行</h3><ul>\n<li>调用类的alloc方法，分配内存，初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力；</li>\n<li>当我们调用某个方法的时候，编译器会对这个方法调用进行转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.利用msgSend函数</div><div class=\"line\">\t[someone method];</div><div class=\"line\">\t[someone performSelector:@selector(method)];</div><div class=\"line\">\t----&gt;objc_msgSend(someone, @selector(method));</div><div class=\"line\">//2.利用转发函数</div><div class=\"line\">\tNSinvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];</div><div class=\"line\">[invocation invoke];</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>objc_msgSend</code>的作用:</p>\n<ul>\n<li>它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型</li>\n<li>然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。</li>\n<li>最后，将方法实现的返回值作为该函数的返回值返回。</li>\n</ul>\n</blockquote>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>当我们创建一个对象的时候，首先根据类的info来分配内存，然后初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力，当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。<br>动态绑定为我们写代码提供了方便，却带来了性能的损耗，因为函数的调用通过地址可以直接确定，而方法需要通过函数的查找，但是方法的缓存一定程度上解决了这个问题。</p>\n<h3 id=\"消息转发机制\"><a href=\"#消息转发机制\" class=\"headerlink\" title=\"消息转发机制\"></a>消息转发机制</h3><p>消息转发用到的方法(消息拦截用到的方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (BOOL)resolveClassMethod:(SEL)sel;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel;</div><div class=\"line\">//后两个方法需要转发到其他的类处理</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector;</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/16603936.jpg\" alt=\"\"></p>\n<p>我们调用一个方法有两种形式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[object message];</div><div class=\"line\"></div><div class=\"line\">[object performSelector:@selector(method) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>第一种我们可以确定对象是否能够处理该方法，如果没有声明编译器会直接报错，不过也存在没有方法实现的风险，第二种方式就会直接编译通过，运行崩溃。<br>规避的方法有两种</p>\n<ul>\n<li><p>第一就是在调用方法之前判断是否该方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([self respondsToSelector:@selector(method)]) &#123;</div><div class=\"line\">    [self performSelector:@selector(method)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>消息转发机制：通过这一机制，我们可以告诉对象如何处理未知的消息。</p>\n<blockquote>\n<p>默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940</div><div class=\"line\"></div><div class=\"line\">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940&apos;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。<br>消息转发机制基本上分为三个步骤：</p>\n<ul>\n<li>动态方法解析</li>\n<li>备用接收者</li>\n<li>完整转发</li>\n</ul>\n</blockquote>\n<h4 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">void functionForMethod1(id self, SEL _cmd) &#123;</div><div class=\"line\"></div><div class=\"line\">   NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过这种方案更多的是为了实现@dynamic属性。</p>\n<h4 id=\"备用接收者\"><a href=\"#备用接收者\" class=\"headerlink\" title=\"备用接收者\"></a>备用接收者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>\n<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface SUTRuntimeMethodHelper : NSObject</div><div class=\"line\">- (void)method2;</div><div class=\"line\">end</div><div class=\"line\">implementation SUTRuntimeMethodHelper</div><div class=\"line\">- (void)method2 &#123;</div><div class=\"line\">    NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\">@(02-Foundation)end</div><div class=\"line\">#pragma mark -</div><div class=\"line\">@interface SUTRuntimeMethod () &#123;</div><div class=\"line\">    SUTRuntimeMethodHelper *_helper;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation SUTRuntimeMethod</div><div class=\"line\">+ (instancetype)object &#123;</div><div class=\"line\">    return [[self alloc] init];</div><div class=\"line\">&#125;</div><div class=\"line\">- (instancetype)init &#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self != nil) &#123;</div><div class=\"line\">        _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">    [self performSelector:@selector(method2)];</div><div class=\"line\">&#125;</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class=\"line\">    NSLog(@&quot;forwardingTargetForSelector&quot;);</div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class=\"line\">    // 将消息转发给_helper来处理</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method2&quot;]) &#123;</div><div class=\"line\">        return _helper;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"完整转发\"><a href=\"#完整转发\" class=\"headerlink\" title=\"完整转发\"></a>完整转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class=\"line\">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class=\"line\">    if (!signature) &#123;</div><div class=\"line\">        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class=\"line\">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return signature;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class=\"line\">    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class=\"line\">        [anInvocation invokeWithTarget:_helper];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>\n</blockquote>\n<h3 id=\"动态方法添加\"><a href=\"#动态方法添加\" class=\"headerlink\" title=\"动态方法添加\"></a>动态方法添加</h3><p>首先调用一个不存在的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用方法</div><div class=\"line\">[target performSelector:@selector(resolveAdd:) withObject:@&quot;test&quot;];</div></pre></td></tr></table></figure></p>\n<p>然后，在target对象内部重写拦截调用的方法，动态添加方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">void runAddMethod(id self, SEL _cmd, NSString *string)&#123;</div><div class=\"line\">    NSLog(@&quot;add C IMP &quot;, string);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\"></div><div class=\"line\">    //给本类动态添加一个方法</div><div class=\"line\">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;resolveAdd:&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>其中class_addMethod的四个参数分别是：</p>\n<ul>\n<li>Class cls 给哪个类添加方法，本例中是self</li>\n<li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。</li>\n<li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用- + (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li>\n<li>“v@:*”方法的签名，代表有一个参数的方法</li>\n</ul>\n</blockquote>\n<p>###Method Swizzling<br>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UIViewController (Tracking)</div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">        static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        Class class = [self class];         </div><div class=\"line\">        // When swizzling a class method, use the following:</div><div class=\"line\">                    // Class class = object_getClass((id)self);</div><div class=\"line\">        SEL originalSelector = @selector(viewWillAppear:);</div><div class=\"line\">                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">        BOOL didAddMethod =</div><div class=\"line\">                        class_addMethod(class,</div><div class=\"line\">                originalSelector,</div><div class=\"line\">                method_getImplementation(swizzledMethod),</div><div class=\"line\">                method_getTypeEncoding(swizzledMethod));</div><div class=\"line\">        if (didAddMethod) &#123;</div><div class=\"line\">                        class_replaceMethod(class,</div><div class=\"line\">                swizzledSelector,</div><div class=\"line\">                method_getImplementation(originalMethod),</div><div class=\"line\">                method_getTypeEncoding(originalMethod));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark - Method Swizzling</div><div class=\"line\">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class=\"line\">        [self xxx_viewWillAppear:animated];</div><div class=\"line\">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><p>Swizzling应该总是在+load中执行</p>\n<blockquote>\n<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>\n</blockquote>\n</li>\n<li><p>Swizzling应该总是在dispatch_once中执行</p>\n<blockquote>\n<p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践</p>\n</blockquote>\n</li>\n<li><p>小心无限循环</p>\n<blockquote>\n<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。<br>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。<br>这个时候，runtime的关联属性就发挥它的作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先定义一个全局变量，用它的地址作为关联对象的key</div><div class=\"line\">static char associatedObjectKey;</div><div class=\"line\">//设置关联对象</div><div class=\"line\">objc_setAssociatedObject(target, &amp;associatedObjectKey, @&quot;添加的字符串属性&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象</div><div class=\"line\">NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);</div><div class=\"line\">NSLog(@&quot;AssociatedObject = %@&quot;, string);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>objc_setAssociatedObject的四个参数：</p>\n<ul>\n<li>id object给谁设置关联对象。</li>\n<li>const void *key关联对象唯一的key，获取时会用到。</li>\n<li>id value关联对象。</li>\n<li>objc_AssociationPolicy关联策略，有以下几种策略：<br>enum {<br>  OBJC_ASSOCIATION_ASSIGN = 0,<br>  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,<br>  OBJC_ASSOCIATION_COPY_NONATOMIC = 3,<br>  OBJC_ASSOCIATION_RETAIN = 01401,<br>  OBJC_ASSOCIATION_COPY = 01403<br>};<br>如果你熟悉OC，看名字应该知道这几种策略的意思了吧。</li>\n</ul>\n</blockquote>\n<p><code>objc_getAssociatedObject</code>的两个参数。</p>\n<ul>\n<li>id object获取谁的关联对象。</li>\n<li>const void *key根据这个唯一的key获取关联对象。<br>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//添加关联对象</div><div class=\"line\">- (void)addAssociatedObject:(id)object&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">//获取关联对象</div><div class=\"line\">- (id)getAssociatedObject&#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>方法调用的本质就是通过instance/class+SEL来找到IMP，最终调用IMP的函数来执行调用的</li>\n<li>方法调用可以使用invoke的方法</li>\n<li>增加方法的是在某个类中增加Method，也就是增加SLE和IMP</li>\n<li>替换方法的是更改SLE与IMP的映射关系</li>\n</ul>\n<hr>\n<p>参考：<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\" target=\"_blank\" rel=\"external\">南峰子-runtime</a></p>\n<p><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"external\">iOS-runtime理解-简书</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"runtime概述\"><a href=\"#runtime概述\" class=\"headerlink\" title=\"runtime概述\"></a>runtime概述</h2><blockquote>\n<p><strong>什么是runtime?</strong><br>runtime直译就是运行时间,run(跑,运行) time(时间),网上大家都叫它运行时,它是一套比较底层的纯C语言API,属于一个C语言库,包含了很多底层的C语言API,它是OC的幕后工作者,我们平时写的OC代码,在运行过程时,都会转为runtime的C语言代码</p>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><p>####Object<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface NSObject &lt;NSObject&gt; &#123;</div><div class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"objc-method\"><a href=\"#objc-method\" class=\"headerlink\" title=\"objc_method\"></a>objc_method</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct objc_ method &#123;</div><div class=\"line\">    SEL method_name;</div><div class=\"line\">    char *method_types;</div><div class=\"line\">    IMP method_imp;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h4 id=\"objc-class\"><a href=\"#objc-class\" class=\"headerlink\" title=\"objc_class\"></a>objc_class</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct objc_class &#123;</div><div class=\"line\">    Class isa;</div><div class=\"line\"></div><div class=\"line\">#if !__OBJC2__</div><div class=\"line\">    Class super_class;                                        </div><div class=\"line\">    const char *name;</div><div class=\"line\">    long version;                          //类的版本信息，默认为0</div><div class=\"line\">    long info;                             //类信息，供运行期使用的一些位标识</div><div class=\"line\">    long instance_size;                    //该类的实例变量大小</div><div class=\"line\">    struct objc_ivar_list *ivars;          //成员列表</div><div class=\"line\">    struct objc_method_list **methodLists; //方法列表</div><div class=\"line\">    struct objc_cache *cache;              //方法缓存</div><div class=\"line\">    struct objc_protocol_list *protocols;  //协议链表</div><div class=\"line\">#endif</div><div class=\"line\"></div><div class=\"line\">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>\n<h4 id=\"Method-amp-SEL-amp-IMP\"><a href=\"#Method-amp-SEL-amp-IMP\" class=\"headerlink\" title=\"Method &amp; SEL &amp; IMP\"></a>Method &amp; SEL &amp; IMP</h4><blockquote>\n<ul>\n<li>Method:<code>(typedef struct objc_method *Method)</code>在类定义中表示方法的类型，相当于SEL和IMP的映射</li>\n<li>SEL(selector):<code>typedef struct objc_selector *SEL</code>方法选择器，用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>\n<li>IMP(implement):<code>typedef id (*IMP)(id, SEL, …)</code>方法的实现，这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p><strong>注意</strong>，SEL是由方法的名字，也就是字符串来生成的(包含参数)，也就是说，在不同的类中的方法，只要名字和参数相同，那么它的SEL也是相同的，SEL本质是一个Int类型的一个地址(用%p来表示)，地址中存放着方法的名字所有的SEL存储在一个NSSet中，所以SEL是唯一的，以hash实现搜索定位，效率高于NSArray，在方法的调用的时候，是通过数字的查找而非字符串的查找来进行方法定位的，当我定义一个类的时候，有声明或者实现，都会有对应的SEL以及Method对象存在，但是没有实现是IMP则为空，<code>SEL selector = NSSelectorFromString(@&quot;run&quot;);</code>这个代码永远是正确的，但是<code>IMP ipmSel = [FXViewController methodForSelector:selector];</code>如果这个类没有这个实现，那么是会返回<code>(libobjc.A.dylib_objc_msgForward)</code>。<br>所以理论上来讲iOS不存在私有方法，因为我们可以通过运行时来调用任何存在的method，只不过这个方法没有在.h文件进行声明的话，在编译层面会进行一些禁止而已，这样也保障了运行的安全。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">SEL selector = NSSelectorFromString(@&quot;run&quot;);</div><div class=\"line\">Class class = NSClassFromString(@&quot;FXViewController&quot;);</div><div class=\"line\">if ([class respondsToSelector:selector]) &#123;</div><div class=\"line\">    [class performSelector:selector withObject:nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>当我们在类中进行方法的声明或者实现的时候，底层会默认根据方法名，来注册这个方法，生成对应的SEL和Method，SEL会由一个NSSet来做一个统一的维护，另外Method对象会保存在对应的类的methodlist中，当我们在方法调用的时候，系统会快速的通过注册方法来拿到SEL，然后到对应的类的实现中去根据SEL查找Method，如果Method存在则直接跳转到IMP去调用其指向的函数。如果一个方法只有声明没有实现，那么这个类中是不会有Method对象存在的，可以用<code>class_copyMethodList</code>进行验证<br><img src=\"./1460617119227.png\" alt=\"Alt text\"><br>这张图在加载类的时候创建，当发现有方法声明，或者方法实现，或者方法调用的时候，就会把对应的字符串进行一个注册，形成上边那样的一张表，这张表中的SEL是经过运算得到的，而不是查找。</p>\n<h4 id=\"运行时方法总结\"><a href=\"#运行时方法总结\" class=\"headerlink\" title=\"运行时方法总结\"></a>运行时方法总结</h4><p><code>通过名字获取SEL，通过SEL和Class获取IMP</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 添加方法</div><div class=\"line\">BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );</div><div class=\"line\">// 获取实例方法</div><div class=\"line\">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class=\"line\">// 获取类方法</div><div class=\"line\">Method class_getClassMethod ( Class cls, SEL name );</div><div class=\"line\">// 获取所有实例方法的数组，不能获取类方法</div><div class=\"line\">Method * class_copyMethodList ( Class cls, unsigned int *outCount );</div><div class=\"line\">// 替代方法的实现，如果IMP不存在则默认调用class_addMethod方法</div><div class=\"line\">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );</div><div class=\"line\">// 返回方法的具体实现</div><div class=\"line\">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class=\"line\">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class=\"line\">// 类实例是否响应指定的selector</div><div class=\"line\">BOOL class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure></p>\n<h4 id=\"获取列表\"><a href=\"#获取列表\" class=\"headerlink\" title=\"获取列表\"></a>获取列表</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">unsigned int count;</div><div class=\"line\">   //获取属性列表</div><div class=\"line\">   objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i=0; i&lt;count; i++) &#123;</div><div class=\"line\">       const char *propertyName = property_getName(propertyList[i]);</div><div class=\"line\">       NSLog(@&quot;property----&gt;%@&quot;, [NSString stringWithUTF8String:propertyName]);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取方法列表</div><div class=\"line\">   Method *methodList = class_copyMethodList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Method method = methodList[i];</div><div class=\"line\">       NSLog(@&quot;method----&gt;%@&quot;, NSStringFromSelector(method_getName(method)));</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取成员变量列表</div><div class=\"line\">   Ivar *ivarList = class_copyIvarList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Ivar myIvar = ivarList[i];</div><div class=\"line\">       const char *ivarName = ivar_getName(myIvar);</div><div class=\"line\">       NSLog(@&quot;Ivar----&gt;%@&quot;, [NSString stringWithUTF8String:ivarName]);</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   //获取协议列表</div><div class=\"line\">   __unsafe_unretained Protocol **protocolList = class_copyProtocolList([self class], &amp;count);</div><div class=\"line\">   for (unsigned int i; i&lt;count; i++) &#123;</div><div class=\"line\">       Protocol *myProtocal = protocolList[i];</div><div class=\"line\">       const char *protocolName = protocol_getName(myProtocal);</div><div class=\"line\">       NSLog(@&quot;protocol----&gt;%@&quot;, [NSString stringWithUTF8String:protocolName]);</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<h3 id=\"方法的执行\"><a href=\"#方法的执行\" class=\"headerlink\" title=\"方法的执行\"></a>方法的执行</h3><ul>\n<li>调用类的alloc方法，分配内存，初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力；</li>\n<li>当我们调用某个方法的时候，编译器会对这个方法调用进行转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//1.利用msgSend函数</div><div class=\"line\">\t[someone method];</div><div class=\"line\">\t[someone performSelector:@selector(method)];</div><div class=\"line\">\t----&gt;objc_msgSend(someone, @selector(method));</div><div class=\"line\">//2.利用转发函数</div><div class=\"line\">\tNSinvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature];</div><div class=\"line\">[invocation invoke];</div></pre></td></tr></table></figure>\n<blockquote>\n<p><code>objc_msgSend</code>的作用:</p>\n<ul>\n<li>它首先找到 SEL 对应的方法实现 IMP。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型</li>\n<li>然后将消息接收者对象(指向消息接收者对象的指针)以及方法中指定的参数传递给方法实现 IMP。</li>\n<li>最后，将方法实现的返回值作为该函数的返回值返回。</li>\n</ul>\n</blockquote>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>当我们创建一个对象的时候，首先根据类的info来分配内存，然后初始化成员变量，其中isa指针也会被初始化，让这个对象有访问其类的能力，当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。<br>动态绑定为我们写代码提供了方便，却带来了性能的损耗，因为函数的调用通过地址可以直接确定，而方法需要通过函数的查找，但是方法的缓存一定程度上解决了这个问题。</p>\n<h3 id=\"消息转发机制\"><a href=\"#消息转发机制\" class=\"headerlink\" title=\"消息转发机制\"></a>消息转发机制</h3><p>消息转发用到的方法(消息拦截用到的方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (BOOL)resolveClassMethod:(SEL)sel;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel;</div><div class=\"line\">//后两个方法需要转发到其他的类处理</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector;</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div></pre></td></tr></table></figure>\n<p><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/16603936.jpg\" alt=\"\"></p>\n<p>我们调用一个方法有两种形式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[object message];</div><div class=\"line\"></div><div class=\"line\">[object performSelector:@selector(method) withObject:nil];</div></pre></td></tr></table></figure></p>\n<p>第一种我们可以确定对象是否能够处理该方法，如果没有声明编译器会直接报错，不过也存在没有方法实现的风险，第二种方式就会直接编译通过，运行崩溃。<br>规避的方法有两种</p>\n<ul>\n<li><p>第一就是在调用方法之前判断是否该方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if ([self respondsToSelector:@selector(method)]) &#123;</div><div class=\"line\">    [self performSelector:@selector(method)];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>消息转发机制：通过这一机制，我们可以告诉对象如何处理未知的消息。</p>\n<blockquote>\n<p>默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940</div><div class=\"line\"></div><div class=\"line\">*** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940&apos;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>这段异常信息实际上是由NSObject的”doesNotRecognizeSelector”方法抛出的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。<br>消息转发机制基本上分为三个步骤：</p>\n<ul>\n<li>动态方法解析</li>\n<li>备用接收者</li>\n<li>完整转发</li>\n</ul>\n</blockquote>\n<h4 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">void functionForMethod1(id self, SEL _cmd) &#123;</div><div class=\"line\"></div><div class=\"line\">   NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(sel);</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super resolveInstanceMethod:sel];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不过这种方案更多的是为了实现@dynamic属性。</p>\n<h4 id=\"备用接收者\"><a href=\"#备用接收者\" class=\"headerlink\" title=\"备用接收者\"></a>备用接收者</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>\n<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface SUTRuntimeMethodHelper : NSObject</div><div class=\"line\">- (void)method2;</div><div class=\"line\">end</div><div class=\"line\">implementation SUTRuntimeMethodHelper</div><div class=\"line\">- (void)method2 &#123;</div><div class=\"line\">    NSLog(@&quot;%@, %p&quot;, self, _cmd);</div><div class=\"line\">&#125;</div><div class=\"line\">@(02-Foundation)end</div><div class=\"line\">#pragma mark -</div><div class=\"line\">@interface SUTRuntimeMethod () &#123;</div><div class=\"line\">    SUTRuntimeMethodHelper *_helper;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div><div class=\"line\">@implementation SUTRuntimeMethod</div><div class=\"line\">+ (instancetype)object &#123;</div><div class=\"line\">    return [[self alloc] init];</div><div class=\"line\">&#125;</div><div class=\"line\">- (instancetype)init &#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self != nil) &#123;</div><div class=\"line\">        _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)test &#123;</div><div class=\"line\">    [self performSelector:@selector(method2)];</div><div class=\"line\">&#125;</div><div class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class=\"line\">    NSLog(@&quot;forwardingTargetForSelector&quot;);</div><div class=\"line\">    NSString *selectorString = NSStringFromSelector(aSelector);</div><div class=\"line\">    // 将消息转发给_helper来处理</div><div class=\"line\">    if ([selectorString isEqualToString:@&quot;method2&quot;]) &#123;</div><div class=\"line\">        return _helper;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return [super forwardingTargetForSelector:aSelector];</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h4 id=\"完整转发\"><a href=\"#完整转发\" class=\"headerlink\" title=\"完整转发\"></a>完整转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class=\"line\">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class=\"line\">    if (!signature) &#123;</div><div class=\"line\">        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class=\"line\">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return signature;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class=\"line\">    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class=\"line\">        [anInvocation invokeWithTarget:_helper];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>\n</blockquote>\n<h3 id=\"动态方法添加\"><a href=\"#动态方法添加\" class=\"headerlink\" title=\"动态方法添加\"></a>动态方法添加</h3><p>首先调用一个不存在的方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//隐式调用方法</div><div class=\"line\">[target performSelector:@selector(resolveAdd:) withObject:@&quot;test&quot;];</div></pre></td></tr></table></figure></p>\n<p>然后，在target对象内部重写拦截调用的方法，动态添加方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">void runAddMethod(id self, SEL _cmd, NSString *string)&#123;</div><div class=\"line\">    NSLog(@&quot;add C IMP &quot;, string);</div><div class=\"line\">&#125;</div><div class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class=\"line\"></div><div class=\"line\">    //给本类动态添加一个方法</div><div class=\"line\">    if ([NSStringFromSelector(sel) isEqualToString:@&quot;resolveAdd:&quot;]) &#123;</div><div class=\"line\">        class_addMethod(self, sel, (IMP)runAddMethod, &quot;v@:*&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>其中class_addMethod的四个参数分别是：</p>\n<ul>\n<li>Class cls 给哪个类添加方法，本例中是self</li>\n<li>SEL name 添加的方法，本例中是重写的拦截调用传进来的selector。</li>\n<li>IMP imp 方法的实现，C方法的方法实现可以直接获得。如果是OC方法，可以用- + (IMP)instanceMethodForSelector:(SEL)aSelector;获得方法的实现。</li>\n<li>“v@:*”方法的签名，代表有一个参数的方法</li>\n</ul>\n</blockquote>\n<p>###Method Swizzling<br>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\">@implementation UIViewController (Tracking)</div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">        static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        Class class = [self class];         </div><div class=\"line\">        // When swizzling a class method, use the following:</div><div class=\"line\">                    // Class class = object_getClass((id)self);</div><div class=\"line\">        SEL originalSelector = @selector(viewWillAppear:);</div><div class=\"line\">                    SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class=\"line\">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">                    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">        BOOL didAddMethod =</div><div class=\"line\">                        class_addMethod(class,</div><div class=\"line\">                originalSelector,</div><div class=\"line\">                method_getImplementation(swizzledMethod),</div><div class=\"line\">                method_getTypeEncoding(swizzledMethod));</div><div class=\"line\">        if (didAddMethod) &#123;</div><div class=\"line\">                        class_replaceMethod(class,</div><div class=\"line\">                swizzledSelector,</div><div class=\"line\">                method_getImplementation(originalMethod),</div><div class=\"line\">                method_getTypeEncoding(originalMethod));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\">#pragma mark - Method Swizzling</div><div class=\"line\">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class=\"line\">        [self xxx_viewWillAppear:animated];</div><div class=\"line\">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><ul>\n<li><p>Swizzling应该总是在+load中执行</p>\n<blockquote>\n<p>在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>\n</blockquote>\n</li>\n<li><p>Swizzling应该总是在dispatch_once中执行</p>\n<blockquote>\n<p>与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践</p>\n</blockquote>\n</li>\n<li><p>小心无限循环</p>\n<blockquote>\n<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>现在你准备用一个系统的类，但是系统的类并不能满足你的需求，你需要额外添加一个属性。<br>这种情况的一般解决办法就是继承。<br>但是，只增加一个属性，就去继承一个类，总是觉得太麻烦类。<br>这个时候，runtime的关联属性就发挥它的作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先定义一个全局变量，用它的地址作为关联对象的key</div><div class=\"line\">static char associatedObjectKey;</div><div class=\"line\">//设置关联对象</div><div class=\"line\">objc_setAssociatedObject(target, &amp;associatedObjectKey, @&quot;添加的字符串属性&quot;, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //获取关联对象</div><div class=\"line\">NSString *string = objc_getAssociatedObject(target, &amp;associatedObjectKey);</div><div class=\"line\">NSLog(@&quot;AssociatedObject = %@&quot;, string);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>objc_setAssociatedObject的四个参数：</p>\n<ul>\n<li>id object给谁设置关联对象。</li>\n<li>const void *key关联对象唯一的key，获取时会用到。</li>\n<li>id value关联对象。</li>\n<li>objc_AssociationPolicy关联策略，有以下几种策略：<br>enum {<br>  OBJC_ASSOCIATION_ASSIGN = 0,<br>  OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,<br>  OBJC_ASSOCIATION_COPY_NONATOMIC = 3,<br>  OBJC_ASSOCIATION_RETAIN = 01401,<br>  OBJC_ASSOCIATION_COPY = 01403<br>};<br>如果你熟悉OC，看名字应该知道这几种策略的意思了吧。</li>\n</ul>\n</blockquote>\n<p><code>objc_getAssociatedObject</code>的两个参数。</p>\n<ul>\n<li>id object获取谁的关联对象。</li>\n<li>const void *key根据这个唯一的key获取关联对象。<br>其实，你还可以把添加和获取关联对象的方法写在你需要用到这个功能的类的类别中，方便使用。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//添加关联对象</div><div class=\"line\">- (void)addAssociatedObject:(id)object&#123;</div><div class=\"line\">    objc_setAssociatedObject(self, @selector(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class=\"line\">&#125;</div><div class=\"line\">//获取关联对象</div><div class=\"line\">- (id)getAssociatedObject&#123;</div><div class=\"line\">    return objc_getAssociatedObject(self, _cmd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意：这里面我们把getAssociatedObject方法的地址作为唯一的key，_cmd代表当前调用方法的地址。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>方法调用的本质就是通过instance/class+SEL来找到IMP，最终调用IMP的函数来执行调用的</li>\n<li>方法调用可以使用invoke的方法</li>\n<li>增加方法的是在某个类中增加Method，也就是增加SLE和IMP</li>\n<li>替换方法的是更改SLE与IMP的映射关系</li>\n</ul>\n<hr>\n<p>参考：<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\" target=\"_blank\" rel=\"external\">南峰子-runtime</a></p>\n<p><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"external\">iOS-runtime理解-简书</a></p>"},{"title":"(转)视音频编解码技术零基础学习方法","date":"2015-07-17T12:06:07.000Z","_content":"\n原文地址<http://blog.csdn.net/leixiaohua1020/article/details/18893769>\n<!--more-->\n \n## 视频播放器原理\n视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。\n视频播放器的源代码详细解析（Media Player Classic - HC，Mplayer，FFplay，XBMC）可以参考系列文章：\nMedia Player Classic：Media Player Classic - HC源代码分析 1：整体结构[系列文章]\nMplayer：MPlayer源代码分析\nFFplay： FFplay源代码分析：整体流程图\nXBMC： XBMC源代码分析 1：整体结构以及编译方法[系列文章]\n在这里不细说了，仅简要说明一下视频播放器的原理。\n视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/69435586.jpg)\n\n解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。\n解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。\n解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。\n视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。\n接下来的几节我们将会列出主要的流媒体协议，封装格式，以及视音频编码标准。更详细的比较可以参考：\n视频参数（流媒体系统，封装格式，视频编码，音频编码，播放器）对比\n有关本文中涉及到的协议数据、封装格式数据、视频编码数据、音频编码数据、视频像素数据、音频采样数\n\n## 流媒体协议\n流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。\n主要流媒体协议一览\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/52205431.jpg)\nRTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。\nRTSP规范可参考：RTSP协议学习笔记\nRTSP+RTP系统中衡量服务质量可参考：网络视频传输的服务质量（QoS）\n上海IPTV码流分析结果可参考：IPTV视频码流分析\n因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。\n此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。\nRTMP我做的研究相对多一些：比如RTMP规范简单分析，或者RTMP流媒体播放过程\n相关工具的源代码分析：RTMPdump源代码分析 1： main()函数[系列文章]\nRTMP协议学习：RTMP流媒体技术零基础学习方法\n## 封装格式\n封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/78134537.jpg)\n由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。\n这些封装格式都有相关的文档，在这里就不一一例举了。\n我自己也做过辅助学习的小项目：\nTS封装格式分析器\nFLV封装格式分析器\n \n## 视频编码\n视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。\n视频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理\n注：视频编码技术在整个视音频技术中应该是最复杂的技术。如果没有基础的话，可以先买一些书看一下原理，比如说《现代电视原理》《数字电视广播原理与应用》（本科的课本）中的部分章节。\n\n由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/66098092.jpg)\n\n### 4.1 主流编码标准\nH.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。\n基于H.264标准的编码器还是很多的，究竟孰优孰劣？可参考：MSU出品的 H.264编码器比较（2011.5）\n在学习视频编码的时候，可能会用到各种编码器（实际上就是一个exe文件），他们常用的编码命令可以参考：各种视频编码器的命令行格式\n学习H.264最标准的源代码，就是其官方标准JM了。但是要注意，JM速度非常的慢，是无法用于实际的：H.264参考软件JM12.2RC代码详细流程\n实际中使用最多的就是x264了，性能强悍（超过了很多商业编码器），而且开源。其基本教程网上极多，不再赘述。编码时候可参考：x264编码指南——码率控制。编码后统计值的含义：X264输出的统计值的含义（X264 Stats Output）\nGoogle推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。有一篇写的很好的VP8的介绍文章：深入了解 VP8。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交，可参考文章：WebM(VP8) vs H.264\n此外，我国还推出了自己的国产标准AVS，性能也不错，但目前比H.264还是要稍微逊色一点。不过感觉我国在视频编解码领域还算比较先进的，可参考：视频编码国家标准AVS与H.264的比较（节选）\n近期又推出了AVS新一代的版本AVS+，具体的性能测试还没看过。不过据说AVS+得到了国家政策上非常强力的支持。\n### 4.2 下一代编码标准\n下一代的编解码标准就要数HEVC和VP9了。VP9是Google继VP8之后推出的新一代标准。VP9和HEVC相比，要稍微逊色一些。它们的对比可参考：（1）HEVC与VP9编码效率对比 （2）HEVC，VP9，x264性能对比\nHEVC在未来拥有很多大的优势，可参考：HEVC将会取代H.264的原因\n学习HEVC最标准的源代码，就是其官方标准HM了。其速度比H.264的官方标准代码又慢了一大截，使用可参考：HEVC学习—— HM的使用\n未来实际使用的HEVC开源编码器很有可能是x265，目前该项目还处于发展阶段，可参考：x265(HEVC编码器，基于x264)介绍。x265的使用可以参考：HEVC（H.265）标准的编码器（x265，DivX265）试用\n主流以及下一代编码标准之间的比较可以参考文章：视频编码方案之间的比较（HEVC，H.264，MPEG2等）\n此外，在码率一定的情况下，几种编码标准的比较可参考：限制码率的视频编码标准比较（包括MPEG-2，H.263， MPEG-4，以及 H.264）\n结果大致是这样的：\nHEVC > VP9 > H.264> VP8 > MPEG4 > H.263 > MPEG2。\n截了一些图，可以比较直观的了解各种编码标准：\nHEVC码流简析：HEVC码流简单分析\nH.264码流简析：H.264简单码流分析\nMPEG2码流简析：MPEG2简单码流分析\n以上简析使用的工具：视频码流分析工具\n我自己做的小工具：  H.264码流分析器\n\n## 音频编码\n音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。\n音频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理\n\n由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。\n这些编码标准之间的比较可以参考文章：音频编码方案之间音质比较（AAC，MP3，WMA等）\n结果大致是这样的：\nAAC+ > MP3PRO > AAC> RealAudio > WMA > MP3\nAAC格式的介绍：AAC格式简介\nAAC几种不同版本之间的对比：AAC规格（LC，HE，HEv2）及性能对比\nAAC专利方面的介绍：AAC专利介绍\n此外杜比数字的编码标准也比较流行，但是貌似比最新的AAC稍为逊色：AC-3技术综述\n我自己做的小工具： AAC格式分析器\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/72839052.jpg)\n## 现有网络视音频平台对比\n现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。\n### 直播平台参数对比\n主流互联网视音频平台直播服务的参数对比如表所示：\n现有网络视音频平台参数对比\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/88431216.jpg)\n\n可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。\n### 点播平台参数对比\n主流网络视音频平台点播服务的参数对比如表所示：\n现有互联网视音频平台参数对比\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/6813536.jpg)\n可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。\n \n","source":"_posts/2015/转-视音频编解码技术零基础学习方法.md","raw":"---\ntitle: (转)视音频编解码技术零基础学习方法\ndate: 2015-07-17 20:06:07\ntags:\n- 流媒体\ncategories: 基础\n---\n\n原文地址<http://blog.csdn.net/leixiaohua1020/article/details/18893769>\n<!--more-->\n \n## 视频播放器原理\n视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。\n视频播放器的源代码详细解析（Media Player Classic - HC，Mplayer，FFplay，XBMC）可以参考系列文章：\nMedia Player Classic：Media Player Classic - HC源代码分析 1：整体结构[系列文章]\nMplayer：MPlayer源代码分析\nFFplay： FFplay源代码分析：整体流程图\nXBMC： XBMC源代码分析 1：整体结构以及编译方法[系列文章]\n在这里不细说了，仅简要说明一下视频播放器的原理。\n视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/69435586.jpg)\n\n解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。\n解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。\n解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。\n视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。\n接下来的几节我们将会列出主要的流媒体协议，封装格式，以及视音频编码标准。更详细的比较可以参考：\n视频参数（流媒体系统，封装格式，视频编码，音频编码，播放器）对比\n有关本文中涉及到的协议数据、封装格式数据、视频编码数据、音频编码数据、视频像素数据、音频采样数\n\n## 流媒体协议\n流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。\n主要流媒体协议一览\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/52205431.jpg)\nRTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。\nRTSP规范可参考：RTSP协议学习笔记\nRTSP+RTP系统中衡量服务质量可参考：网络视频传输的服务质量（QoS）\n上海IPTV码流分析结果可参考：IPTV视频码流分析\n因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。\n此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。\nRTMP我做的研究相对多一些：比如RTMP规范简单分析，或者RTMP流媒体播放过程\n相关工具的源代码分析：RTMPdump源代码分析 1： main()函数[系列文章]\nRTMP协议学习：RTMP流媒体技术零基础学习方法\n## 封装格式\n封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/78134537.jpg)\n由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。\n这些封装格式都有相关的文档，在这里就不一一例举了。\n我自己也做过辅助学习的小项目：\nTS封装格式分析器\nFLV封装格式分析器\n \n## 视频编码\n视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。\n视频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理\n注：视频编码技术在整个视音频技术中应该是最复杂的技术。如果没有基础的话，可以先买一些书看一下原理，比如说《现代电视原理》《数字电视广播原理与应用》（本科的课本）中的部分章节。\n\n由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/66098092.jpg)\n\n### 4.1 主流编码标准\nH.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。\n基于H.264标准的编码器还是很多的，究竟孰优孰劣？可参考：MSU出品的 H.264编码器比较（2011.5）\n在学习视频编码的时候，可能会用到各种编码器（实际上就是一个exe文件），他们常用的编码命令可以参考：各种视频编码器的命令行格式\n学习H.264最标准的源代码，就是其官方标准JM了。但是要注意，JM速度非常的慢，是无法用于实际的：H.264参考软件JM12.2RC代码详细流程\n实际中使用最多的就是x264了，性能强悍（超过了很多商业编码器），而且开源。其基本教程网上极多，不再赘述。编码时候可参考：x264编码指南——码率控制。编码后统计值的含义：X264输出的统计值的含义（X264 Stats Output）\nGoogle推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。有一篇写的很好的VP8的介绍文章：深入了解 VP8。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交，可参考文章：WebM(VP8) vs H.264\n此外，我国还推出了自己的国产标准AVS，性能也不错，但目前比H.264还是要稍微逊色一点。不过感觉我国在视频编解码领域还算比较先进的，可参考：视频编码国家标准AVS与H.264的比较（节选）\n近期又推出了AVS新一代的版本AVS+，具体的性能测试还没看过。不过据说AVS+得到了国家政策上非常强力的支持。\n### 4.2 下一代编码标准\n下一代的编解码标准就要数HEVC和VP9了。VP9是Google继VP8之后推出的新一代标准。VP9和HEVC相比，要稍微逊色一些。它们的对比可参考：（1）HEVC与VP9编码效率对比 （2）HEVC，VP9，x264性能对比\nHEVC在未来拥有很多大的优势，可参考：HEVC将会取代H.264的原因\n学习HEVC最标准的源代码，就是其官方标准HM了。其速度比H.264的官方标准代码又慢了一大截，使用可参考：HEVC学习—— HM的使用\n未来实际使用的HEVC开源编码器很有可能是x265，目前该项目还处于发展阶段，可参考：x265(HEVC编码器，基于x264)介绍。x265的使用可以参考：HEVC（H.265）标准的编码器（x265，DivX265）试用\n主流以及下一代编码标准之间的比较可以参考文章：视频编码方案之间的比较（HEVC，H.264，MPEG2等）\n此外，在码率一定的情况下，几种编码标准的比较可参考：限制码率的视频编码标准比较（包括MPEG-2，H.263， MPEG-4，以及 H.264）\n结果大致是这样的：\nHEVC > VP9 > H.264> VP8 > MPEG4 > H.263 > MPEG2。\n截了一些图，可以比较直观的了解各种编码标准：\nHEVC码流简析：HEVC码流简单分析\nH.264码流简析：H.264简单码流分析\nMPEG2码流简析：MPEG2简单码流分析\n以上简析使用的工具：视频码流分析工具\n我自己做的小工具：  H.264码流分析器\n\n## 音频编码\n音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。\n音频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理\n\n由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。\n这些编码标准之间的比较可以参考文章：音频编码方案之间音质比较（AAC，MP3，WMA等）\n结果大致是这样的：\nAAC+ > MP3PRO > AAC> RealAudio > WMA > MP3\nAAC格式的介绍：AAC格式简介\nAAC几种不同版本之间的对比：AAC规格（LC，HE，HEv2）及性能对比\nAAC专利方面的介绍：AAC专利介绍\n此外杜比数字的编码标准也比较流行，但是貌似比最新的AAC稍为逊色：AC-3技术综述\n我自己做的小工具： AAC格式分析器\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/72839052.jpg)\n## 现有网络视音频平台对比\n现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。\n### 直播平台参数对比\n主流互联网视音频平台直播服务的参数对比如表所示：\n现有网络视音频平台参数对比\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/88431216.jpg)\n\n可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。\n### 点播平台参数对比\n主流网络视音频平台点播服务的参数对比如表所示：\n现有互联网视音频平台参数对比\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/6813536.jpg)\n可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。\n \n","slug":"2015/转-视音频编解码技术零基础学习方法","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmu0031saua4g0tngud","content":"<p>原文地址<a href=\"http://blog.csdn.net/leixiaohua1020/article/details/18893769\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/leixiaohua1020/article/details/18893769</a><br><a id=\"more\"></a></p>\n<h2 id=\"视频播放器原理\"><a href=\"#视频播放器原理\" class=\"headerlink\" title=\"视频播放器原理\"></a>视频播放器原理</h2><p>视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。<br>视频播放器的源代码详细解析（Media Player Classic - HC，Mplayer，FFplay，XBMC）可以参考系列文章：<br>Media Player Classic：Media Player Classic - HC源代码分析 1：整体结构[系列文章]<br>Mplayer：MPlayer源代码分析<br>FFplay： FFplay源代码分析：整体流程图<br>XBMC： XBMC源代码分析 1：整体结构以及编译方法[系列文章]<br>在这里不细说了，仅简要说明一下视频播放器的原理。<br>视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/69435586.jpg\" alt=\"\"></p>\n<p>解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。<br>解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。<br>解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。<br>视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。<br>接下来的几节我们将会列出主要的流媒体协议，封装格式，以及视音频编码标准。更详细的比较可以参考：<br>视频参数（流媒体系统，封装格式，视频编码，音频编码，播放器）对比<br>有关本文中涉及到的协议数据、封装格式数据、视频编码数据、音频编码数据、视频像素数据、音频采样数</p>\n<h2 id=\"流媒体协议\"><a href=\"#流媒体协议\" class=\"headerlink\" title=\"流媒体协议\"></a>流媒体协议</h2><p>流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。<br>主要流媒体协议一览<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/52205431.jpg\" alt=\"\"><br>RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。<br>RTSP规范可参考：RTSP协议学习笔记<br>RTSP+RTP系统中衡量服务质量可参考：网络视频传输的服务质量（QoS）<br>上海IPTV码流分析结果可参考：IPTV视频码流分析<br>因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。<br>此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。<br>RTMP我做的研究相对多一些：比如RTMP规范简单分析，或者RTMP流媒体播放过程<br>相关工具的源代码分析：RTMPdump源代码分析 1： main()函数[系列文章]<br>RTMP协议学习：RTMP流媒体技术零基础学习方法</p>\n<h2 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a>封装格式</h2><p>封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/78134537.jpg\" alt=\"\"><br>由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。<br>这些封装格式都有相关的文档，在这里就不一一例举了。<br>我自己也做过辅助学习的小项目：<br>TS封装格式分析器<br>FLV封装格式分析器</p>\n<h2 id=\"视频编码\"><a href=\"#视频编码\" class=\"headerlink\" title=\"视频编码\"></a>视频编码</h2><p>视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。<br>视频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理<br>注：视频编码技术在整个视音频技术中应该是最复杂的技术。如果没有基础的话，可以先买一些书看一下原理，比如说《现代电视原理》《数字电视广播原理与应用》（本科的课本）中的部分章节。</p>\n<p>由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/66098092.jpg\" alt=\"\"></p>\n<h3 id=\"4-1-主流编码标准\"><a href=\"#4-1-主流编码标准\" class=\"headerlink\" title=\"4.1 主流编码标准\"></a>4.1 主流编码标准</h3><p>H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。<br>基于H.264标准的编码器还是很多的，究竟孰优孰劣？可参考：MSU出品的 H.264编码器比较（2011.5）<br>在学习视频编码的时候，可能会用到各种编码器（实际上就是一个exe文件），他们常用的编码命令可以参考：各种视频编码器的命令行格式<br>学习H.264最标准的源代码，就是其官方标准JM了。但是要注意，JM速度非常的慢，是无法用于实际的：H.264参考软件JM12.2RC代码详细流程<br>实际中使用最多的就是x264了，性能强悍（超过了很多商业编码器），而且开源。其基本教程网上极多，不再赘述。编码时候可参考：x264编码指南——码率控制。编码后统计值的含义：X264输出的统计值的含义（X264 Stats Output）<br>Google推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。有一篇写的很好的VP8的介绍文章：深入了解 VP8。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交，可参考文章：WebM(VP8) vs H.264<br>此外，我国还推出了自己的国产标准AVS，性能也不错，但目前比H.264还是要稍微逊色一点。不过感觉我国在视频编解码领域还算比较先进的，可参考：视频编码国家标准AVS与H.264的比较（节选）<br>近期又推出了AVS新一代的版本AVS+，具体的性能测试还没看过。不过据说AVS+得到了国家政策上非常强力的支持。</p>\n<h3 id=\"4-2-下一代编码标准\"><a href=\"#4-2-下一代编码标准\" class=\"headerlink\" title=\"4.2 下一代编码标准\"></a>4.2 下一代编码标准</h3><p>下一代的编解码标准就要数HEVC和VP9了。VP9是Google继VP8之后推出的新一代标准。VP9和HEVC相比，要稍微逊色一些。它们的对比可参考：（1）HEVC与VP9编码效率对比 （2）HEVC，VP9，x264性能对比<br>HEVC在未来拥有很多大的优势，可参考：HEVC将会取代H.264的原因<br>学习HEVC最标准的源代码，就是其官方标准HM了。其速度比H.264的官方标准代码又慢了一大截，使用可参考：HEVC学习—— HM的使用<br>未来实际使用的HEVC开源编码器很有可能是x265，目前该项目还处于发展阶段，可参考：x265(HEVC编码器，基于x264)介绍。x265的使用可以参考：HEVC（H.265）标准的编码器（x265，DivX265）试用<br>主流以及下一代编码标准之间的比较可以参考文章：视频编码方案之间的比较（HEVC，H.264，MPEG2等）<br>此外，在码率一定的情况下，几种编码标准的比较可参考：限制码率的视频编码标准比较（包括MPEG-2，H.263， MPEG-4，以及 H.264）<br>结果大致是这样的：<br>HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2。<br>截了一些图，可以比较直观的了解各种编码标准：<br>HEVC码流简析：HEVC码流简单分析<br>H.264码流简析：H.264简单码流分析<br>MPEG2码流简析：MPEG2简单码流分析<br>以上简析使用的工具：视频码流分析工具<br>我自己做的小工具：  H.264码流分析器</p>\n<h2 id=\"音频编码\"><a href=\"#音频编码\" class=\"headerlink\" title=\"音频编码\"></a>音频编码</h2><p>音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。<br>音频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理</p>\n<p>由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。<br>这些编码标准之间的比较可以参考文章：音频编码方案之间音质比较（AAC，MP3，WMA等）<br>结果大致是这样的：<br>AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3<br>AAC格式的介绍：AAC格式简介<br>AAC几种不同版本之间的对比：AAC规格（LC，HE，HEv2）及性能对比<br>AAC专利方面的介绍：AAC专利介绍<br>此外杜比数字的编码标准也比较流行，但是貌似比最新的AAC稍为逊色：AC-3技术综述<br>我自己做的小工具： AAC格式分析器<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/72839052.jpg\" alt=\"\"></p>\n<h2 id=\"现有网络视音频平台对比\"><a href=\"#现有网络视音频平台对比\" class=\"headerlink\" title=\"现有网络视音频平台对比\"></a>现有网络视音频平台对比</h2><p>现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。</p>\n<h3 id=\"直播平台参数对比\"><a href=\"#直播平台参数对比\" class=\"headerlink\" title=\"直播平台参数对比\"></a>直播平台参数对比</h3><p>主流互联网视音频平台直播服务的参数对比如表所示：<br>现有网络视音频平台参数对比<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/88431216.jpg\" alt=\"\"></p>\n<p>可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。</p>\n<h3 id=\"点播平台参数对比\"><a href=\"#点播平台参数对比\" class=\"headerlink\" title=\"点播平台参数对比\"></a>点播平台参数对比</h3><p>主流网络视音频平台点播服务的参数对比如表所示：<br>现有互联网视音频平台参数对比<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/6813536.jpg\" alt=\"\"><br>可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。</p>\n","site":{"data":{}},"excerpt":"<p>原文地址<a href=\"http://blog.csdn.net/leixiaohua1020/article/details/18893769\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/leixiaohua1020/article/details/18893769</a><br>","more":"</p>\n<h2 id=\"视频播放器原理\"><a href=\"#视频播放器原理\" class=\"headerlink\" title=\"视频播放器原理\"></a>视频播放器原理</h2><p>视音频技术主要包含以下几点：封装技术，视频压缩编码技术以及音频压缩编码技术。如果考虑到网络传输的话，还包括流媒体协议技术。<br>视频播放器的源代码详细解析（Media Player Classic - HC，Mplayer，FFplay，XBMC）可以参考系列文章：<br>Media Player Classic：Media Player Classic - HC源代码分析 1：整体结构[系列文章]<br>Mplayer：MPlayer源代码分析<br>FFplay： FFplay源代码分析：整体流程图<br>XBMC： XBMC源代码分析 1：整体结构以及编译方法[系列文章]<br>在这里不细说了，仅简要说明一下视频播放器的原理。<br>视频播放器播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。他们的过程如图所示。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/69435586.jpg\" alt=\"\"></p>\n<p>解协议的作用，就是将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。<br>解封装的作用，就是将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。<br>解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。<br>视音频同步的作用，就是根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。<br>接下来的几节我们将会列出主要的流媒体协议，封装格式，以及视音频编码标准。更详细的比较可以参考：<br>视频参数（流媒体系统，封装格式，视频编码，音频编码，播放器）对比<br>有关本文中涉及到的协议数据、封装格式数据、视频编码数据、音频编码数据、视频像素数据、音频采样数</p>\n<h2 id=\"流媒体协议\"><a href=\"#流媒体协议\" class=\"headerlink\" title=\"流媒体协议\"></a>流媒体协议</h2><p>流媒体协议是服务器与客户端之间通信遵循的规定。当前网络上主要的流媒体协议如表所示。<br>主要流媒体协议一览<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/52205431.jpg\" alt=\"\"><br>RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。因而围绕IPTV的视频质量的研究还是挺多的。<br>RTSP规范可参考：RTSP协议学习笔记<br>RTSP+RTP系统中衡量服务质量可参考：网络视频传输的服务质量（QoS）<br>上海IPTV码流分析结果可参考：IPTV视频码流分析<br>因为互联网网络环境的不稳定性，RTSP+RTP较少用于互联网视音频传输。互联网视频服务通常采用TCP作为其流媒体的传输层协议，因而像RTMP，MMS，HTTP这类的协议广泛用于互联网视音频服务之中。这类协议不会发生丢包，因而保证了视频的质量，但是传输的效率会相对低一些。<br>此外RTMFP是一种比较新的流媒体协议，特点是支持P2P。<br>RTMP我做的研究相对多一些：比如RTMP规范简单分析，或者RTMP流媒体播放过程<br>相关工具的源代码分析：RTMPdump源代码分析 1： main()函数[系列文章]<br>RTMP协议学习：RTMP流媒体技术零基础学习方法</p>\n<h2 id=\"封装格式\"><a href=\"#封装格式\" class=\"headerlink\" title=\"封装格式\"></a>封装格式</h2><p>封装格式的主要作用是把视频码流和音频码流按照一定的格式存储在一个文件中。现如今流行的封装格式如下表所示：<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/78134537.jpg\" alt=\"\"><br>由表可见，除了AVI之外，其他封装格式都支持流媒体，即可以“边下边播”。有些格式更“万能”一些，支持的视音频编码标准多一些，比如MKV。而有些格式则支持的相对比较少，比如说RMVB。<br>这些封装格式都有相关的文档，在这里就不一一例举了。<br>我自己也做过辅助学习的小项目：<br>TS封装格式分析器<br>FLV封装格式分析器</p>\n<h2 id=\"视频编码\"><a href=\"#视频编码\" class=\"headerlink\" title=\"视频编码\"></a>视频编码</h2><p>视频编码的主要作用是将视频像素数据（RGB，YUV等）压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。视频编码是视音频技术中最重要的技术之一。视频码流的数据量占了视音频总数据量的绝大部分。高效率的视频编码在同等的码率下，可以获得更高的视频质量。<br>视频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理<br>注：视频编码技术在整个视音频技术中应该是最复杂的技术。如果没有基础的话，可以先买一些书看一下原理，比如说《现代电视原理》《数字电视广播原理与应用》（本科的课本）中的部分章节。</p>\n<p>由表可见，有两种视频编码方案是最新推出的：VP9和HEVC。目前这两种方案都处于研发阶段，还没有到达实用的程度。当前使用最多的视频编码方案就是H.264。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/66098092.jpg\" alt=\"\"></p>\n<h3 id=\"4-1-主流编码标准\"><a href=\"#4-1-主流编码标准\" class=\"headerlink\" title=\"4.1 主流编码标准\"></a>4.1 主流编码标准</h3><p>H.264仅仅是一个编码标准，而不是一个具体的编码器，H.264只是给编码器的实现提供参照用的。<br>基于H.264标准的编码器还是很多的，究竟孰优孰劣？可参考：MSU出品的 H.264编码器比较（2011.5）<br>在学习视频编码的时候，可能会用到各种编码器（实际上就是一个exe文件），他们常用的编码命令可以参考：各种视频编码器的命令行格式<br>学习H.264最标准的源代码，就是其官方标准JM了。但是要注意，JM速度非常的慢，是无法用于实际的：H.264参考软件JM12.2RC代码详细流程<br>实际中使用最多的就是x264了，性能强悍（超过了很多商业编码器），而且开源。其基本教程网上极多，不再赘述。编码时候可参考：x264编码指南——码率控制。编码后统计值的含义：X264输出的统计值的含义（X264 Stats Output）<br>Google推出的VP8属于和H.264同一时代的标准。总体而言，VP8比H.264要稍微差一点。有一篇写的很好的VP8的介绍文章：深入了解 VP8。除了在技术领域，VP8和H.264在专利等方面也是打的不可开交，可参考文章：WebM(VP8) vs H.264<br>此外，我国还推出了自己的国产标准AVS，性能也不错，但目前比H.264还是要稍微逊色一点。不过感觉我国在视频编解码领域还算比较先进的，可参考：视频编码国家标准AVS与H.264的比较（节选）<br>近期又推出了AVS新一代的版本AVS+，具体的性能测试还没看过。不过据说AVS+得到了国家政策上非常强力的支持。</p>\n<h3 id=\"4-2-下一代编码标准\"><a href=\"#4-2-下一代编码标准\" class=\"headerlink\" title=\"4.2 下一代编码标准\"></a>4.2 下一代编码标准</h3><p>下一代的编解码标准就要数HEVC和VP9了。VP9是Google继VP8之后推出的新一代标准。VP9和HEVC相比，要稍微逊色一些。它们的对比可参考：（1）HEVC与VP9编码效率对比 （2）HEVC，VP9，x264性能对比<br>HEVC在未来拥有很多大的优势，可参考：HEVC将会取代H.264的原因<br>学习HEVC最标准的源代码，就是其官方标准HM了。其速度比H.264的官方标准代码又慢了一大截，使用可参考：HEVC学习—— HM的使用<br>未来实际使用的HEVC开源编码器很有可能是x265，目前该项目还处于发展阶段，可参考：x265(HEVC编码器，基于x264)介绍。x265的使用可以参考：HEVC（H.265）标准的编码器（x265，DivX265）试用<br>主流以及下一代编码标准之间的比较可以参考文章：视频编码方案之间的比较（HEVC，H.264，MPEG2等）<br>此外，在码率一定的情况下，几种编码标准的比较可参考：限制码率的视频编码标准比较（包括MPEG-2，H.263， MPEG-4，以及 H.264）<br>结果大致是这样的：<br>HEVC &gt; VP9 &gt; H.264&gt; VP8 &gt; MPEG4 &gt; H.263 &gt; MPEG2。<br>截了一些图，可以比较直观的了解各种编码标准：<br>HEVC码流简析：HEVC码流简单分析<br>H.264码流简析：H.264简单码流分析<br>MPEG2码流简析：MPEG2简单码流分析<br>以上简析使用的工具：视频码流分析工具<br>我自己做的小工具：  H.264码流分析器</p>\n<h2 id=\"音频编码\"><a href=\"#音频编码\" class=\"headerlink\" title=\"音频编码\"></a>音频编码</h2><p>音频编码的主要作用是将音频采样数据（PCM等）压缩成为音频码流，从而降低音频的数据量。音频编码也是互联网视音频技术中一个重要的技术。但是一般情况下音频的数据量要远小于视频的数据量，因而即使使用稍微落后的音频编码标准，而导致音频数据量有所增加，也不会对视音频的总数据量产生太大的影响。高效率的音频编码在同等的码率下，可以获得更高的音质。<br>音频编码的简单原理可以参考：视频压缩编码和音频压缩编码的基本原理</p>\n<p>由表可见，近年来并未推出全新的音频编码方案，可见音频编码技术已经基本可以满足人们的需要。音频编码技术近期绝大部分的改动都是在MP3的继任者——AAC的基础上完成的。<br>这些编码标准之间的比较可以参考文章：音频编码方案之间音质比较（AAC，MP3，WMA等）<br>结果大致是这样的：<br>AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3<br>AAC格式的介绍：AAC格式简介<br>AAC几种不同版本之间的对比：AAC规格（LC，HE，HEv2）及性能对比<br>AAC专利方面的介绍：AAC专利介绍<br>此外杜比数字的编码标准也比较流行，但是貌似比最新的AAC稍为逊色：AC-3技术综述<br>我自己做的小工具： AAC格式分析器<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/72839052.jpg\" alt=\"\"></p>\n<h2 id=\"现有网络视音频平台对比\"><a href=\"#现有网络视音频平台对比\" class=\"headerlink\" title=\"现有网络视音频平台对比\"></a>现有网络视音频平台对比</h2><p>现有的网络视音频服务主要包括两种方式：点播和直播。点播意即根据用户的需要播放相应的视频节目，这是互联网视音频服务最主要的方式。绝大部分视频网站都提供了点播服务。直播意即互联网视音频平台直接将视频内容实时发送给用户，目前还处于发展阶段。直播在网络电视台，社交视频网站较为常见。</p>\n<h3 id=\"直播平台参数对比\"><a href=\"#直播平台参数对比\" class=\"headerlink\" title=\"直播平台参数对比\"></a>直播平台参数对比</h3><p>主流互联网视音频平台直播服务的参数对比如表所示：<br>现有网络视音频平台参数对比<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/88431216.jpg\" alt=\"\"></p>\n<p>可以看出，直播服务普遍采用了RTMP作为流媒体协议，FLV作为封装格式，H.264作为视频编码格式，AAC作为音频编码格式。采用RTMP作为直播协议的好处在于其被Flash播放器支持。而Flash播放器如今已经安装在全球99%的电脑上，并且与浏览器结合的很好。因此这种流媒体直播平台可以实现“无插件直播”，极大的简化了客户端的操作。封装格式，视频编码，音频编码方面，无一例外的使用了FLV + H.264 + AAC的组合。FLV是RTMP使用的封装格式，H.264是当今实际应用中编码效率最高的视频编码标准，AAC则是当今实际应用中编码效率最高的音频编码标准。视频播放器方面，都使用了Flash播放器。</p>\n<h3 id=\"点播平台参数对比\"><a href=\"#点播平台参数对比\" class=\"headerlink\" title=\"点播平台参数对比\"></a>点播平台参数对比</h3><p>主流网络视音频平台点播服务的参数对比如表所示：<br>现有互联网视音频平台参数对比<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/6813536.jpg\" alt=\"\"><br>可以看出，点播服务普遍采用了HTTP作为流媒体协议，H.264作为视频编码格式，AAC作为音频编码格式。采用HTTP作为点播协议有以下两点优势：一方面，HTTP是基于TCP协议的应用层协议，媒体传输过程中不会出现丢包等现象，从而保证了视频的质量；另一方面，HTTP被绝大部分的Web服务器支持，因而流媒体服务机构不必投资购买额外的流媒体服务器，从而节约了开支。点播服务采用的封装格式有多种：MP4，FLV，F4V等，它们之间的区别不是很大。视频编码标准和音频编码标准是H.264和AAC。这两种标准分别是当今实际应用中编码效率最高的视频标准和音频标准。视频播放器方面，无一例外的都使用了Flash播放器。</p>"},{"title":"流媒体技术概述","date":"2015-01-17T06:05:59.000Z","_content":"## 什么是流媒体技术\n随着现代技术的发展，网络带给人们形式多样的信息，从第一张图片出现在网络上到如今各种形式的网络视频和三维动画，网络让人们的视听觉得到了很大的满足。然而在流媒体技术出现之前，人们必须要先下载这些多媒体内容到本地计算机，在漫长的等待之后（因为受限于带宽，下载通常要花上较长的时间），才可以看到或听到媒体传达的信息。令人欣慰的是，在流媒体技术出现之后，人们便无需再等待媒体完全下载完成了。\n<!--more-->\n流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术.所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,由视频服务器向用户计算机顺序或实时地传送各个压缩包，让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。\n\n## 流媒体技术的应用分类\n流媒体应用形式可以简单分为3类：点播型应用、直播型应用和会议型应用。\n- （1）点播型应用。点播型应用中，一般点播内容存放在服务器上，根据需要进行发布。在同一时间可多点点播相同或不同的节目，即多个终端可在不同的地点、不同的时刻，实时、交互式地点播同一流文件，用户可以通过门户查看和选择内容进行点播。根据用户的需要，点播过程中还可以实现播放、停止、暂停、快进、后退等功能。\n- （2）直播型应用。直播服务模式下，用户只能观看播放的内容，无法进行控制。\n- （3）会议型应用。会议型应用类似于直播型应用，但是两者有不同的要求，如双向通信等。这对一般双方都要有包括媒体采集的硬件和软件，还有流传输技术。会议型的应用有时候不需要很高的音/视频质量。\n- （4）视频广播，是点播的扩展，把节目源组织成频道，以广播的方式提供，用户通过加入频道收看预定好的节目\n- (5)视频监视\n- (6)音乐播放/在线电台\n- (7)电视上网\n## 流媒体技术原理\n如果将文件传输看作是一次接水的过程，过去的传输方式就像是对用户做了一个规定，必须等到一桶水接满才能使用它，这个等待的时间自然要受到水流量大小和桶的大小的影响。而流式传输则是，打开水头龙，等待一小会儿，水就会源源不断地流出来，而且可以随接随用，因此，不管水流量的大小，也不管桶的大小，用户都可以随时用上水。从这个意义上看，流媒体这个词是非常形象的。\n流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。\n### 顺序流式传输\n顺序流式传输是顺序下载，在下载文件的同时用户可以观看，但是，用户的观看与服务器上的传输并不是同步进行的，用户是在一段延时后才能看到服务器上传出来的信息，或者说用户看到的总是服务器在若干时间以前传出来的信息。在这过程中，用户只能观看已下载的那部分，而不能要求跳到还未下载的部分。顺序流式传输比较适合高质量的短片段，因为它可以较好地保证节目播放的最终质量。它适合于在网站上发布的供用户点播的音视频节目。\n对通过调制解调器发布的短片段，顺序流式传输很实用，它允许用比调制解调器跟高的数据速率创建视频片段，尽管有延迟毕竟可让你发布高质量的视频片段。\n顺序流式文件是放在标准HTTP或FTP服务器上，易管理基本上与防火墙无关，顺序流式传播不适合长片段和有随机访问要求的视频，如演讲，演说与演示，它不支持现场广播，严格来说，它是一种点播技术。\n\n### 实时流式传输\n\n在实时流式传输中，音视频信息可被实时观看到。在观看过程中用户可快进或后退以观看前面或后面的内容，但是在这种传输方式中，如果网络传输状况不理想，则收到的信号效果比较差。\n实时流式传输必须匹配连接宽带，意味着以调制解调器速度连接时图像质量较差，而且由于出错丢失的信息被忽略掉，网络拥挤或者出现问题时候，视频质量很差，如欲保证视频质量，顺序流式传输也许更好，实时流式传输需要特定的服务器，如QuickTime Streaming Server/Real Server/Windows Media Server这些服务器允许你对媒体发送进行更多级别的控制，因为而系统设置管理比HTTP服务器更复杂，实时流传输还需要特殊的网络协议，比如RTSP(Real time sreming protocol)或MMS(Microsoft Media Server)这些协议在有防火墙的时候会出现问题，导致用户不能看到一些地点的实时内容。\n\n## 流媒体系统的组成\n通常，组成一个完整的流媒体系统包括以下5个部分：\n\n　　①一种用于创建、捕捉和编辑多媒体数据，形成流媒体格式的编码工具;\n\n　　②流媒体数据;\n\n　　③一个存放和控制流媒体数据的服务器;\n\n　　④要有适合多媒体传输协议甚至是实时传输协议的网络;\n\n　　⑤供客户端浏览流媒体文件的播放器。\n　　\n## 流媒体传输的基本原理\n流媒体传输的基本原理  流媒体服务器架设  流媒体技术也称为流式传输技术，是指在网络上按时间先后次序传输和播放的连续音、视频数据流。随着网络速度的提高，以流媒体技术为核心的视频点播、在线电视、远程培训等业务开展得越来越广泛。本章主要介绍流媒体技术的基础知识、流媒体服务器的安装、运行、配置和使用等内容。  23.1  流媒体技术基础  流媒体是指利用流式传输技术传送的音频、视频等连续媒体数据，它的核心是串流（Streaming）技术和数据压缩技术，具有连续性、实时性、时序性3个特点，可以使用顺序流式传输和实时流式传输两种传输方式。本节主要介绍有关流媒体的技术基础。  23.1.1  流媒体传输的基本原理 实现流式传输需要使用缓存机制。因为音频或视频数据在网络中是以包的形式传输的，而网络是动态变化的，各个数据包选择的路由可能不尽相同，到达客户端所需的时间也就不一样，有可能会出现先发的数据包却后到。因此，客户端如果按照包到达的次序播放数据，必然会得到不正确的结果。使用缓存机制就可以解决这个问题，客户端收到数据包后先缓存起来，播放器再从缓存中按次序读取数据。  使用缓存机制还可以解决停顿问题。网络由于某种原因经常会有一些突发流量，此时会造成暂时的拥塞，使流数据不能实时到达客户端，客户端的播放就会出现停顿。如果采用了缓存机制，暂时的网络阻塞并不会影响播放效果，因为播放器可以读取以前缓存的数据。等网络正常后，新的流数据将会继续添加到缓存中。  虽然音频或视频等流数据容量非常大，但播放流数据时所需的缓存容量并不需要很大，因为缓存可以使用环形链表结构来存储数据，已经播放的内容可以马上丢弃，缓存可以腾出空间用于存放后续尚未播放的内容。  当传输流数据时，需要使用合适的传输协议。TCP虽然是一种可靠的传输协议，但由于需要的开销较多，并不适合传输实时性要求很高的流数据。因此，在实际的流式传输方案中，TCP协议一般用来传输控制信息，而实时的音视频数据则是用效率更高的RTP/UDP等协议来传输。流媒体传输的基本原理如图23-1所示。  在图23-1中，Web服务器只是为用户提供了使用流媒体的操作界面。客户机上的用户在浏览器中选中播放某一流媒体资源后，Web服务器把有关这一资源的流媒体服务器地址、资源路径及编码类型等信息提供给客户端，于是客户端就启动了流媒体播放器，与流媒体服务器进行连接。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/76269153.jpg)\n客户端的流媒体播放器与流媒体服务器之间交换控制信息时使用的是RTSP协议，它是基于TCP协议的一种应用层协议，默认使用的是554端口。RTSP协议提供了有关流媒体播放、快进、快倒、暂停及录制等操作的命令和方法。通过RTSP协议，客户端向服务器提出了播放某一流媒体资源的请求，服务器响应了这个请求后，就可以把流媒体数据传输给客户端了。\n\n需要注意的是，RTSP协议并不具备传输流媒体数据的功能，承担流媒体数据传输任务的是另一种基于UDP的RTP协议，但在RTP协议传输流媒体数据的过程中，RTSP连接是一直存在的，并且控制着流媒体数据的传输。一旦流媒体数据到达了客户端，流媒体播放器就可以播放输出了。流媒体的数据和控制信息使用不同的协议和连接时，还可以带来一个好处，就是播放流媒体的客户机和控制流媒体播放的客户机可以是不同的计算机。\n\n### 实时流媒体协议RTSP\nRTSP（Real Time Streaming Protocol，实时流媒体协议）是由Real Network和Netscape共同提出的一种应用层协议，它定义了如何在IP网络上有效地传输流媒体数据。RTSP提供了一种机制，使音频、视频等数据可以按照需要进行实时传输，并且可以实施诸如暂停、快进等控制。源数据可以是存储的文件，也可以是现场数据的反馈。RTSP协议本身并不传输数据，数据的传输是通过基于UDP协议的RTP协议来完成的。\n\nRTSP协议与HTTP协议有点类似，通信双方是通过请求消息和回应消息进行交互的。请求消息的格式如下：\n```\n<请求方法>  <URI>  <RTSP版本> \n[消息头]  \nCR/ LF  \n[消息体] \n```\n其中，请求方法包括PLAY、DESCRIBE等，可以通过OPTION方法得到对方所支持的其他方法名称。URI是对方的地址，例如：rtsp://192.168.0.1。\"RTSP版本\"一般都是RTSP/1.0。每一行的最后都是回车换行符CR/LF，消息头和消息体之间要有一个空行。回应消息格式如下：\n```\n<RTSP版本> <状态码> <解释> \n[消息头]  \nCR/LF  \n[消息体] \n```\n回应消息的格式规定与请求消息类似。其中状态码是一个3位数，后面跟随着解释文本，例如，200表示成功。\n\nHTTP协议是单向的，即只能是客户端提出请求，服务端给予回应，而使用RTSP时，客户机和服务器都可以发出请求，双方都可以对收到的请求进行应答，即RTSP可以是双向的。一个典型的RSTP交互过程如下所示，其中C表示RTSP客户端，S表示RTSP服务端\n```\nC->S:    OPTION request     //客户端通过OPTION方法询问\n服务端支持哪些方法  \nS->C:    OPTION response    //服务端进行回应，提供了所支持方法的名称  \n \nC->S:    DESCRIBE request   //客户端通过DESCRIBE方法查询服务\n端媒体的初始化描述\n//信息  \nS->C:    DESCRIBE response  //服务端回应媒体初始化描述信息，\n采用的是sdp会话描述\n//格式  \n \nC->S:    SETUP request      //客户端通过SETUP方法设置会话\n的属性、传输模式等参数，\n//并请求建立会话  \nS->C:    SETUP response         //服务端响应回话请求，与客\n户端建立会话，并返回会话标识\n//符及其他相关信息  \n \nC->S:    PLAY request       //客户端通过PLAY方法请求播放某一多媒体资源  \nS->C:    PLAY response      //服务器回应请求，开始发送流数据  \n \nS->C:    …                      //此时，RTSP通过其他协议发送流媒体数据  \n \nC->S:    TEARDOWN request   //客户端通过TEARDOWN方法请求关闭会话  \nS->C:    TEARDOWN response      //服务器回应请求，会话关闭，交互结束 \n```\n实际应用中，RTCP的交互过程可能和以上过程会有区别，但基本的流程是一样的。\n\n说明：还有一种常见的流媒体协议是由Microsoft公司开发的MMS协议，但Microsoft公司没有公开该协议。\n\n## 流媒体播放方式\n流媒体服务器可以提供多种播放方式，它可以根据用户的要求，为每个用户独立地传送流数据，实现VOD（Video On Demand）的功能；也可以为多个用户同时传送流数据，实现在线电视或现场直播的功能。下面介绍一下这些播放方式的特点。\n\n### 单播方式\n当采用单播方式时，每个客户端都与流媒体服务器建立了一个单独的数据通道，从服务器发送的每个数据包都只能传给一台客户机。对用户来说，单播方式可以满足自己的个性化要求，可以根据需要随时使用停止、暂停、快进等控制功能。但对服务器还说，单播方式无疑会带来沉重的负担，因为它必须为每个用户提供单独的查询，向每个用户发送所申请的数据包复制。当用户数很多时，对网络速度、服务器性能的要求都很高。如果这些性能不能满足要求，就会造成播放停顿，甚至停止播放。\n\n### 广播方式\n承载流数据的网络报文还可以使用广播方式发送给子网上所有的用户，此时，所有的用户同时接受一样的流数据，因此，服务器只需要发送一份数据复制就可以为子网上所有的用户服务，大大减轻了服务器的负担。但此时，客户机只能被动地接受流数据，而不能控制流。也就是说，用户不能暂停、快进或后退所播放的内容，而且，用户也不能对节目进行选择。\n\n### 组播方式\n单播方式虽然用户提供了最大的灵活性，但网络和服务器的负担很重。广播方式虽然可以减轻服务器的负担，但用户不能选择播放内容，只能被动地接受流数据。组播吸取了上述两种传输方式的长处，可以将数据包复制发送给需要的多个客户，而不是像单播方式那样复制数据包的多个文件到网络上，也不是像广播方式那样将数据包发送给那些不需要的客户，保证数据包占用最小的网络带宽。当然，组播方式需要在具有组播能力的网络上使用。\n\n## 流媒体关键技术\n流媒体有三个关键技术:数据压缩/解压缩技术，流媒体网络传输和媒体文件在流式传输中的版权保护问题，其中数据压缩和解压缩技术优势重中之重，核心技术。方发送确认嘻嘻，发送发收到确认嘻嘻猴才继续\n\n### 流媒体制作技术方面解决的问题\n在网络中进行流媒体传输，所传输的文件必须制作成适合流媒体传输的流媒体格式文件，由于通常格式存储的多媒体文件容量十分大，传输比较困难，另外流媒体也不能按流媒体传输的协议进行传输，所以必须对问津进行预处理，将文件压缩成流媒体格式文件，这里要注意两点：1，选用合适的算法在质量与体积之间找到平衡，2，需要向文件中添加流式信息。\n\n### 流媒体传输方面需要解决的问题\n流媒体传输需要和实施的传输协议，目前文件初三书大部分是建立在TCP协议上的，也有一些以ftp传输协议方式进行传输，但采用这些传输方法都不能实现实时的方式传输，随着流媒体技术的深入研究，目前成熟的流媒体传输一般都采用建立在UDP协议上的RTP/RTSP实时传输协议。\n之所选择UDP是因为在传输的可靠性上UDP比TCP有很大的有事，TCP协议中包含了专门的数据传送校验机制，当数据接受方收到数据后将自动向发送确认信息，发送方在接收到确认信息后才继续传送数据，否则将一直处于等待状态，而UDP协议则不同，本身并不做任何校验，由此可以看出TCP协议注重传输质量，而UDP注重传输速度，因此对于传输质量要求不是很高，而对速度要求很高的视音频流媒体文件来说，采用UDP更加合适。\n\n### 流媒体的传说过程中需要缓存的支持\n因为internet是以包为单位进行异步传输的，所以多媒体数据在传输过程中被分解为许多的包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包现象，为此，必须采用正确的书序，从而必须使用缓存技术来纠正由于数据到达次序发生改变而产生的混乱的问题，利用缓存对到达的数据包进行正确的排序，从而使音频数据能够连续正确的播放，缓存中存储的是一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的，流媒体在播放时不断的读取缓存中的数据进行播放，播放完后该数据立刻被清楚，新的数据将加入缓存，因此播放流媒体文件的时候并不需要占用太大的缓存空间。\n\n## 流媒体传输的网络协议\nTCP需要较多的开销，所以不太适合传输实时数据，流式传输一般采用HTTP/TCP(RTCP)传输控制信息，而采用RTP/UDP(RTP)来传输实时声音数据。\n### 实时传输协议RTP\n这种协议在一对一或一对多的传输情况下工作，其目的是提供时间信息和实现流同步，RTP通常使用UDP来传送数据，当引用程序开始一个RTP会话时将使用两个端口，一个给RTP，一个给RTCP，RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务，通常RTP算法并不作为一个独立的网络层来实现，而是作为应用程序代码的一部分。\n\n### 实时传输控制协议RTCP\n实时传输控制协议RTCP和RTP一起提供流量控制和拥塞控制服务，在RTP会话期间各参与者周期性的传送RTCP包，RTCP包中含有 已发送的数据包的数量，丢失的数据包数量等统计资料，因此服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷类型。\nRTP和RTCP配合使用，能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。\n\n### 实时流协议RTSP\n实时流协议RTSP定义了一对多应用程序如何有效地通过IP网络传送多媒体数据，RTSP的体系结构上位于RTP和RTCP之上，它使用TCP或RTP完成数据传输，HTTP与RTSP相比，HTTP传送HTML超链接文档，而RTSP传送的是多媒体数据，HTTP请求由客户机发出，服务器作出相应，使用RTSP时，客户机与服务器都可以发出请求，即RTSP可以是双向的，点对点的额手机可视通话，必须在手机终端实现RTSP。\n\n## 流媒体文件格式\n将多媒体信息进行压缩生成一定格式的文件，这就是媒体压缩格式，而要将这些压缩的文件在IP网上进行实时传输，就需要将这些压缩文件进行必要的处理，分割成很多小块，以方便传输，比如rm，rmvb，asf，这就是媒体流格式，要在网上传播还需要将一定的格式告诉用户这就是媒体的发布格式。\n\n### 流式文件格式\n为了减小用户的播放演示和存储空间，实现边下边播，并保证一定的播放质量，就需要对压缩文件进行特殊的处理，添加一些附属信息，如计时，压缩和版权信息，这就是流式文件格式，常见的有如下集中：\n\n#### flv\nFlash MX 以前flash中的视频文件导入是一帧一帧变成位图，结果导致文件巨大，限制了它的引用范围，随着Flash MX的退出，macromedia公司开发了属于自己流式视频格式的FLV，这种个试试在sorenson公司的压缩算法的基础上开发出来的，sorenson公司也为MOV格式提供苏犯法。\nFLV格式不仅可以轻松导入flash中，几百帧的影片两分钟完成导入，同时可以通过rtmp协议从flashcom服务器上流式播出。 \n\n### 流媒体文件的压缩格式\n\n数据压缩技术也是流媒体技术的一项重要内容，由于视频数据的容量往往都非常大，如果不经过压缩或压缩得不够，则不仅会增加服务器的负担，更重要的是会占用大量的网络带宽，影响播放效果。因此如何在保证不影响观看效果或对观看效果影响很小的前提下，最大限度地对流数据进行压缩，是流媒体技术研究的一项重要内容。下面介绍一下几种主流的音视频数据压缩格式。\n\n#### 1．AVI格式\n\nAVI（Audio Video Interleave，音频视频交错）是符合RIFF文件规范的数字音频与视频文件格式，由Microsoft公司开发，目前得到了广泛的支持。AVI格式支持256色和RLE压缩，并允许视频和音频交错在一起同步播放。但AVI文件并未限定压缩算法，只是提供了作为控制界面的标准，用不同压缩算法生成的AVI文件，必须要使用相同的解压缩算法才能解压播放。AVI文件主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息。\n\n#### 2．MPEG格式\n\nMPEG（Moving Picture Experts Group，动态图像专家组）是运动图像压缩算法的国际标准，已被几乎所有的计算机平台共同支持，它采用有损压缩算法减少运动图像中的冗余信息，同时保证每秒30帧的图像刷新率。MPEG标准包括视频压缩、音频压缩和音视频同步3个部分，MPEG音频最典型的应用就是MP3音频文件，广泛使用的消费类视频产品如VCD、DVD其压缩算法采用的也是MPEG标准。\n\nMPEG压缩算法是针对运动图像而设计的，其基本思路是把视频图像按时间分段，然后采集并保存每一段的第一帧数据，其余各帧只存储相对第一帧发生变化的部分，从而达到了数据压缩的目的。MPEG采用了两个基本的压缩技术：运动补偿技术（预测编码和插补码）实现了时间上的压缩，变换域（离散余弦变换DCT）技术实现了空间上的压缩。MPEG在保证图像和声音质量的前提下，压缩效率非常高，平均压缩比为50∶1，最高可达200∶1。\n\n#### 3．RealVideo格式\n\nRealVideo格式是由Real Networks公司开发的一种流式视频文件格式，包含在Real Media音频视频压缩规范中，其设计目标是在低速率的广域网上实时传输视频影像。RealVideo可以根据网络的传输速度来决定视频数据的压缩比率，从而提高适应能力，充分利用带宽。本章后面介绍的Real Server软件就是由Real Networks公司提供的，使用的就是Real Video格式的视频文件。\n\nRealVideo格式文件的扩展名有3种，RA是音频文件、RM和RMVB是视频文件。RMVB格式文件具有可变比特率的特性，它在处理较复杂的动态影像时使用较高的采样率，而在处理一般静止画面时则灵活地转换至较低的采样率，从而在不增加文件大小的前提下提高了图像质量。\n\n#### 4．QuickTime格式\n\nQuickTime是由Apple公司开发的一种音视频数据压缩格式，得到了Mac OS、Microsoft Windows等主流操作系统平台的支持。QuickTime文件格式提供了150多种视频效果，支持25位彩色，支持RLE、JPEG等领先的集成压缩技术。此外，QuickTime还强化了对Internet应用的支持，并采用一种虚拟现实技术，使用户可以通过鼠标或键盘的交互式控制，观察某一地点周围360度的景像，或者从空间的任何角度观察某一物体。QuickTime以其领先的多媒体技术和跨平台特性、较小的存储空间要求、技术细节的独立性以及系统的高度开放性，得到业界的广泛认可。QuickTime格式文件的扩展是MOV或QT。\n\n#### 5．ASF和WMV格式\n\nASF（Advanced Streaming Format，高级流格式）和WMV是由Microsoft公司推出的一种在Internet上实时传播多媒体数据的技术标准，提供了本地或网络回放、可扩充的媒体类型、部件下载以及可扩展性等功能。ASF的应用平台是Net Show服务器和Net Show播放器。\n\nWMV也是Microsoft公司推出的一种流媒体格式，它是以ASF为基础，升级扩展后得到的。在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。WMV文件一般同时包含视频和音频部分，视频部分使用Windows Media Video编码，而音频部分使用Windows Media Audio编码。音频文件可以独立存在，其扩展名是WMA。\n\n","source":"_posts/2015/流媒体技术概述.md","raw":"---\ntitle: 流媒体技术概述\ndate: 2015-01-17 14:05:59\ntags:\n- 流媒体\ncategories: 基础\n---\n## 什么是流媒体技术\n随着现代技术的发展，网络带给人们形式多样的信息，从第一张图片出现在网络上到如今各种形式的网络视频和三维动画，网络让人们的视听觉得到了很大的满足。然而在流媒体技术出现之前，人们必须要先下载这些多媒体内容到本地计算机，在漫长的等待之后（因为受限于带宽，下载通常要花上较长的时间），才可以看到或听到媒体传达的信息。令人欣慰的是，在流媒体技术出现之后，人们便无需再等待媒体完全下载完成了。\n<!--more-->\n流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术.所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,由视频服务器向用户计算机顺序或实时地传送各个压缩包，让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。\n\n## 流媒体技术的应用分类\n流媒体应用形式可以简单分为3类：点播型应用、直播型应用和会议型应用。\n- （1）点播型应用。点播型应用中，一般点播内容存放在服务器上，根据需要进行发布。在同一时间可多点点播相同或不同的节目，即多个终端可在不同的地点、不同的时刻，实时、交互式地点播同一流文件，用户可以通过门户查看和选择内容进行点播。根据用户的需要，点播过程中还可以实现播放、停止、暂停、快进、后退等功能。\n- （2）直播型应用。直播服务模式下，用户只能观看播放的内容，无法进行控制。\n- （3）会议型应用。会议型应用类似于直播型应用，但是两者有不同的要求，如双向通信等。这对一般双方都要有包括媒体采集的硬件和软件，还有流传输技术。会议型的应用有时候不需要很高的音/视频质量。\n- （4）视频广播，是点播的扩展，把节目源组织成频道，以广播的方式提供，用户通过加入频道收看预定好的节目\n- (5)视频监视\n- (6)音乐播放/在线电台\n- (7)电视上网\n## 流媒体技术原理\n如果将文件传输看作是一次接水的过程，过去的传输方式就像是对用户做了一个规定，必须等到一桶水接满才能使用它，这个等待的时间自然要受到水流量大小和桶的大小的影响。而流式传输则是，打开水头龙，等待一小会儿，水就会源源不断地流出来，而且可以随接随用，因此，不管水流量的大小，也不管桶的大小，用户都可以随时用上水。从这个意义上看，流媒体这个词是非常形象的。\n流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。\n### 顺序流式传输\n顺序流式传输是顺序下载，在下载文件的同时用户可以观看，但是，用户的观看与服务器上的传输并不是同步进行的，用户是在一段延时后才能看到服务器上传出来的信息，或者说用户看到的总是服务器在若干时间以前传出来的信息。在这过程中，用户只能观看已下载的那部分，而不能要求跳到还未下载的部分。顺序流式传输比较适合高质量的短片段，因为它可以较好地保证节目播放的最终质量。它适合于在网站上发布的供用户点播的音视频节目。\n对通过调制解调器发布的短片段，顺序流式传输很实用，它允许用比调制解调器跟高的数据速率创建视频片段，尽管有延迟毕竟可让你发布高质量的视频片段。\n顺序流式文件是放在标准HTTP或FTP服务器上，易管理基本上与防火墙无关，顺序流式传播不适合长片段和有随机访问要求的视频，如演讲，演说与演示，它不支持现场广播，严格来说，它是一种点播技术。\n\n### 实时流式传输\n\n在实时流式传输中，音视频信息可被实时观看到。在观看过程中用户可快进或后退以观看前面或后面的内容，但是在这种传输方式中，如果网络传输状况不理想，则收到的信号效果比较差。\n实时流式传输必须匹配连接宽带，意味着以调制解调器速度连接时图像质量较差，而且由于出错丢失的信息被忽略掉，网络拥挤或者出现问题时候，视频质量很差，如欲保证视频质量，顺序流式传输也许更好，实时流式传输需要特定的服务器，如QuickTime Streaming Server/Real Server/Windows Media Server这些服务器允许你对媒体发送进行更多级别的控制，因为而系统设置管理比HTTP服务器更复杂，实时流传输还需要特殊的网络协议，比如RTSP(Real time sreming protocol)或MMS(Microsoft Media Server)这些协议在有防火墙的时候会出现问题，导致用户不能看到一些地点的实时内容。\n\n## 流媒体系统的组成\n通常，组成一个完整的流媒体系统包括以下5个部分：\n\n　　①一种用于创建、捕捉和编辑多媒体数据，形成流媒体格式的编码工具;\n\n　　②流媒体数据;\n\n　　③一个存放和控制流媒体数据的服务器;\n\n　　④要有适合多媒体传输协议甚至是实时传输协议的网络;\n\n　　⑤供客户端浏览流媒体文件的播放器。\n　　\n## 流媒体传输的基本原理\n流媒体传输的基本原理  流媒体服务器架设  流媒体技术也称为流式传输技术，是指在网络上按时间先后次序传输和播放的连续音、视频数据流。随着网络速度的提高，以流媒体技术为核心的视频点播、在线电视、远程培训等业务开展得越来越广泛。本章主要介绍流媒体技术的基础知识、流媒体服务器的安装、运行、配置和使用等内容。  23.1  流媒体技术基础  流媒体是指利用流式传输技术传送的音频、视频等连续媒体数据，它的核心是串流（Streaming）技术和数据压缩技术，具有连续性、实时性、时序性3个特点，可以使用顺序流式传输和实时流式传输两种传输方式。本节主要介绍有关流媒体的技术基础。  23.1.1  流媒体传输的基本原理 实现流式传输需要使用缓存机制。因为音频或视频数据在网络中是以包的形式传输的，而网络是动态变化的，各个数据包选择的路由可能不尽相同，到达客户端所需的时间也就不一样，有可能会出现先发的数据包却后到。因此，客户端如果按照包到达的次序播放数据，必然会得到不正确的结果。使用缓存机制就可以解决这个问题，客户端收到数据包后先缓存起来，播放器再从缓存中按次序读取数据。  使用缓存机制还可以解决停顿问题。网络由于某种原因经常会有一些突发流量，此时会造成暂时的拥塞，使流数据不能实时到达客户端，客户端的播放就会出现停顿。如果采用了缓存机制，暂时的网络阻塞并不会影响播放效果，因为播放器可以读取以前缓存的数据。等网络正常后，新的流数据将会继续添加到缓存中。  虽然音频或视频等流数据容量非常大，但播放流数据时所需的缓存容量并不需要很大，因为缓存可以使用环形链表结构来存储数据，已经播放的内容可以马上丢弃，缓存可以腾出空间用于存放后续尚未播放的内容。  当传输流数据时，需要使用合适的传输协议。TCP虽然是一种可靠的传输协议，但由于需要的开销较多，并不适合传输实时性要求很高的流数据。因此，在实际的流式传输方案中，TCP协议一般用来传输控制信息，而实时的音视频数据则是用效率更高的RTP/UDP等协议来传输。流媒体传输的基本原理如图23-1所示。  在图23-1中，Web服务器只是为用户提供了使用流媒体的操作界面。客户机上的用户在浏览器中选中播放某一流媒体资源后，Web服务器把有关这一资源的流媒体服务器地址、资源路径及编码类型等信息提供给客户端，于是客户端就启动了流媒体播放器，与流媒体服务器进行连接。\n![](http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/76269153.jpg)\n客户端的流媒体播放器与流媒体服务器之间交换控制信息时使用的是RTSP协议，它是基于TCP协议的一种应用层协议，默认使用的是554端口。RTSP协议提供了有关流媒体播放、快进、快倒、暂停及录制等操作的命令和方法。通过RTSP协议，客户端向服务器提出了播放某一流媒体资源的请求，服务器响应了这个请求后，就可以把流媒体数据传输给客户端了。\n\n需要注意的是，RTSP协议并不具备传输流媒体数据的功能，承担流媒体数据传输任务的是另一种基于UDP的RTP协议，但在RTP协议传输流媒体数据的过程中，RTSP连接是一直存在的，并且控制着流媒体数据的传输。一旦流媒体数据到达了客户端，流媒体播放器就可以播放输出了。流媒体的数据和控制信息使用不同的协议和连接时，还可以带来一个好处，就是播放流媒体的客户机和控制流媒体播放的客户机可以是不同的计算机。\n\n### 实时流媒体协议RTSP\nRTSP（Real Time Streaming Protocol，实时流媒体协议）是由Real Network和Netscape共同提出的一种应用层协议，它定义了如何在IP网络上有效地传输流媒体数据。RTSP提供了一种机制，使音频、视频等数据可以按照需要进行实时传输，并且可以实施诸如暂停、快进等控制。源数据可以是存储的文件，也可以是现场数据的反馈。RTSP协议本身并不传输数据，数据的传输是通过基于UDP协议的RTP协议来完成的。\n\nRTSP协议与HTTP协议有点类似，通信双方是通过请求消息和回应消息进行交互的。请求消息的格式如下：\n```\n<请求方法>  <URI>  <RTSP版本> \n[消息头]  \nCR/ LF  \n[消息体] \n```\n其中，请求方法包括PLAY、DESCRIBE等，可以通过OPTION方法得到对方所支持的其他方法名称。URI是对方的地址，例如：rtsp://192.168.0.1。\"RTSP版本\"一般都是RTSP/1.0。每一行的最后都是回车换行符CR/LF，消息头和消息体之间要有一个空行。回应消息格式如下：\n```\n<RTSP版本> <状态码> <解释> \n[消息头]  \nCR/LF  \n[消息体] \n```\n回应消息的格式规定与请求消息类似。其中状态码是一个3位数，后面跟随着解释文本，例如，200表示成功。\n\nHTTP协议是单向的，即只能是客户端提出请求，服务端给予回应，而使用RTSP时，客户机和服务器都可以发出请求，双方都可以对收到的请求进行应答，即RTSP可以是双向的。一个典型的RSTP交互过程如下所示，其中C表示RTSP客户端，S表示RTSP服务端\n```\nC->S:    OPTION request     //客户端通过OPTION方法询问\n服务端支持哪些方法  \nS->C:    OPTION response    //服务端进行回应，提供了所支持方法的名称  \n \nC->S:    DESCRIBE request   //客户端通过DESCRIBE方法查询服务\n端媒体的初始化描述\n//信息  \nS->C:    DESCRIBE response  //服务端回应媒体初始化描述信息，\n采用的是sdp会话描述\n//格式  \n \nC->S:    SETUP request      //客户端通过SETUP方法设置会话\n的属性、传输模式等参数，\n//并请求建立会话  \nS->C:    SETUP response         //服务端响应回话请求，与客\n户端建立会话，并返回会话标识\n//符及其他相关信息  \n \nC->S:    PLAY request       //客户端通过PLAY方法请求播放某一多媒体资源  \nS->C:    PLAY response      //服务器回应请求，开始发送流数据  \n \nS->C:    …                      //此时，RTSP通过其他协议发送流媒体数据  \n \nC->S:    TEARDOWN request   //客户端通过TEARDOWN方法请求关闭会话  \nS->C:    TEARDOWN response      //服务器回应请求，会话关闭，交互结束 \n```\n实际应用中，RTCP的交互过程可能和以上过程会有区别，但基本的流程是一样的。\n\n说明：还有一种常见的流媒体协议是由Microsoft公司开发的MMS协议，但Microsoft公司没有公开该协议。\n\n## 流媒体播放方式\n流媒体服务器可以提供多种播放方式，它可以根据用户的要求，为每个用户独立地传送流数据，实现VOD（Video On Demand）的功能；也可以为多个用户同时传送流数据，实现在线电视或现场直播的功能。下面介绍一下这些播放方式的特点。\n\n### 单播方式\n当采用单播方式时，每个客户端都与流媒体服务器建立了一个单独的数据通道，从服务器发送的每个数据包都只能传给一台客户机。对用户来说，单播方式可以满足自己的个性化要求，可以根据需要随时使用停止、暂停、快进等控制功能。但对服务器还说，单播方式无疑会带来沉重的负担，因为它必须为每个用户提供单独的查询，向每个用户发送所申请的数据包复制。当用户数很多时，对网络速度、服务器性能的要求都很高。如果这些性能不能满足要求，就会造成播放停顿，甚至停止播放。\n\n### 广播方式\n承载流数据的网络报文还可以使用广播方式发送给子网上所有的用户，此时，所有的用户同时接受一样的流数据，因此，服务器只需要发送一份数据复制就可以为子网上所有的用户服务，大大减轻了服务器的负担。但此时，客户机只能被动地接受流数据，而不能控制流。也就是说，用户不能暂停、快进或后退所播放的内容，而且，用户也不能对节目进行选择。\n\n### 组播方式\n单播方式虽然用户提供了最大的灵活性，但网络和服务器的负担很重。广播方式虽然可以减轻服务器的负担，但用户不能选择播放内容，只能被动地接受流数据。组播吸取了上述两种传输方式的长处，可以将数据包复制发送给需要的多个客户，而不是像单播方式那样复制数据包的多个文件到网络上，也不是像广播方式那样将数据包发送给那些不需要的客户，保证数据包占用最小的网络带宽。当然，组播方式需要在具有组播能力的网络上使用。\n\n## 流媒体关键技术\n流媒体有三个关键技术:数据压缩/解压缩技术，流媒体网络传输和媒体文件在流式传输中的版权保护问题，其中数据压缩和解压缩技术优势重中之重，核心技术。方发送确认嘻嘻，发送发收到确认嘻嘻猴才继续\n\n### 流媒体制作技术方面解决的问题\n在网络中进行流媒体传输，所传输的文件必须制作成适合流媒体传输的流媒体格式文件，由于通常格式存储的多媒体文件容量十分大，传输比较困难，另外流媒体也不能按流媒体传输的协议进行传输，所以必须对问津进行预处理，将文件压缩成流媒体格式文件，这里要注意两点：1，选用合适的算法在质量与体积之间找到平衡，2，需要向文件中添加流式信息。\n\n### 流媒体传输方面需要解决的问题\n流媒体传输需要和实施的传输协议，目前文件初三书大部分是建立在TCP协议上的，也有一些以ftp传输协议方式进行传输，但采用这些传输方法都不能实现实时的方式传输，随着流媒体技术的深入研究，目前成熟的流媒体传输一般都采用建立在UDP协议上的RTP/RTSP实时传输协议。\n之所选择UDP是因为在传输的可靠性上UDP比TCP有很大的有事，TCP协议中包含了专门的数据传送校验机制，当数据接受方收到数据后将自动向发送确认信息，发送方在接收到确认信息后才继续传送数据，否则将一直处于等待状态，而UDP协议则不同，本身并不做任何校验，由此可以看出TCP协议注重传输质量，而UDP注重传输速度，因此对于传输质量要求不是很高，而对速度要求很高的视音频流媒体文件来说，采用UDP更加合适。\n\n### 流媒体的传说过程中需要缓存的支持\n因为internet是以包为单位进行异步传输的，所以多媒体数据在传输过程中被分解为许多的包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包现象，为此，必须采用正确的书序，从而必须使用缓存技术来纠正由于数据到达次序发生改变而产生的混乱的问题，利用缓存对到达的数据包进行正确的排序，从而使音频数据能够连续正确的播放，缓存中存储的是一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的，流媒体在播放时不断的读取缓存中的数据进行播放，播放完后该数据立刻被清楚，新的数据将加入缓存，因此播放流媒体文件的时候并不需要占用太大的缓存空间。\n\n## 流媒体传输的网络协议\nTCP需要较多的开销，所以不太适合传输实时数据，流式传输一般采用HTTP/TCP(RTCP)传输控制信息，而采用RTP/UDP(RTP)来传输实时声音数据。\n### 实时传输协议RTP\n这种协议在一对一或一对多的传输情况下工作，其目的是提供时间信息和实现流同步，RTP通常使用UDP来传送数据，当引用程序开始一个RTP会话时将使用两个端口，一个给RTP，一个给RTCP，RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务，通常RTP算法并不作为一个独立的网络层来实现，而是作为应用程序代码的一部分。\n\n### 实时传输控制协议RTCP\n实时传输控制协议RTCP和RTP一起提供流量控制和拥塞控制服务，在RTP会话期间各参与者周期性的传送RTCP包，RTCP包中含有 已发送的数据包的数量，丢失的数据包数量等统计资料，因此服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷类型。\nRTP和RTCP配合使用，能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。\n\n### 实时流协议RTSP\n实时流协议RTSP定义了一对多应用程序如何有效地通过IP网络传送多媒体数据，RTSP的体系结构上位于RTP和RTCP之上，它使用TCP或RTP完成数据传输，HTTP与RTSP相比，HTTP传送HTML超链接文档，而RTSP传送的是多媒体数据，HTTP请求由客户机发出，服务器作出相应，使用RTSP时，客户机与服务器都可以发出请求，即RTSP可以是双向的，点对点的额手机可视通话，必须在手机终端实现RTSP。\n\n## 流媒体文件格式\n将多媒体信息进行压缩生成一定格式的文件，这就是媒体压缩格式，而要将这些压缩的文件在IP网上进行实时传输，就需要将这些压缩文件进行必要的处理，分割成很多小块，以方便传输，比如rm，rmvb，asf，这就是媒体流格式，要在网上传播还需要将一定的格式告诉用户这就是媒体的发布格式。\n\n### 流式文件格式\n为了减小用户的播放演示和存储空间，实现边下边播，并保证一定的播放质量，就需要对压缩文件进行特殊的处理，添加一些附属信息，如计时，压缩和版权信息，这就是流式文件格式，常见的有如下集中：\n\n#### flv\nFlash MX 以前flash中的视频文件导入是一帧一帧变成位图，结果导致文件巨大，限制了它的引用范围，随着Flash MX的退出，macromedia公司开发了属于自己流式视频格式的FLV，这种个试试在sorenson公司的压缩算法的基础上开发出来的，sorenson公司也为MOV格式提供苏犯法。\nFLV格式不仅可以轻松导入flash中，几百帧的影片两分钟完成导入，同时可以通过rtmp协议从flashcom服务器上流式播出。 \n\n### 流媒体文件的压缩格式\n\n数据压缩技术也是流媒体技术的一项重要内容，由于视频数据的容量往往都非常大，如果不经过压缩或压缩得不够，则不仅会增加服务器的负担，更重要的是会占用大量的网络带宽，影响播放效果。因此如何在保证不影响观看效果或对观看效果影响很小的前提下，最大限度地对流数据进行压缩，是流媒体技术研究的一项重要内容。下面介绍一下几种主流的音视频数据压缩格式。\n\n#### 1．AVI格式\n\nAVI（Audio Video Interleave，音频视频交错）是符合RIFF文件规范的数字音频与视频文件格式，由Microsoft公司开发，目前得到了广泛的支持。AVI格式支持256色和RLE压缩，并允许视频和音频交错在一起同步播放。但AVI文件并未限定压缩算法，只是提供了作为控制界面的标准，用不同压缩算法生成的AVI文件，必须要使用相同的解压缩算法才能解压播放。AVI文件主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息。\n\n#### 2．MPEG格式\n\nMPEG（Moving Picture Experts Group，动态图像专家组）是运动图像压缩算法的国际标准，已被几乎所有的计算机平台共同支持，它采用有损压缩算法减少运动图像中的冗余信息，同时保证每秒30帧的图像刷新率。MPEG标准包括视频压缩、音频压缩和音视频同步3个部分，MPEG音频最典型的应用就是MP3音频文件，广泛使用的消费类视频产品如VCD、DVD其压缩算法采用的也是MPEG标准。\n\nMPEG压缩算法是针对运动图像而设计的，其基本思路是把视频图像按时间分段，然后采集并保存每一段的第一帧数据，其余各帧只存储相对第一帧发生变化的部分，从而达到了数据压缩的目的。MPEG采用了两个基本的压缩技术：运动补偿技术（预测编码和插补码）实现了时间上的压缩，变换域（离散余弦变换DCT）技术实现了空间上的压缩。MPEG在保证图像和声音质量的前提下，压缩效率非常高，平均压缩比为50∶1，最高可达200∶1。\n\n#### 3．RealVideo格式\n\nRealVideo格式是由Real Networks公司开发的一种流式视频文件格式，包含在Real Media音频视频压缩规范中，其设计目标是在低速率的广域网上实时传输视频影像。RealVideo可以根据网络的传输速度来决定视频数据的压缩比率，从而提高适应能力，充分利用带宽。本章后面介绍的Real Server软件就是由Real Networks公司提供的，使用的就是Real Video格式的视频文件。\n\nRealVideo格式文件的扩展名有3种，RA是音频文件、RM和RMVB是视频文件。RMVB格式文件具有可变比特率的特性，它在处理较复杂的动态影像时使用较高的采样率，而在处理一般静止画面时则灵活地转换至较低的采样率，从而在不增加文件大小的前提下提高了图像质量。\n\n#### 4．QuickTime格式\n\nQuickTime是由Apple公司开发的一种音视频数据压缩格式，得到了Mac OS、Microsoft Windows等主流操作系统平台的支持。QuickTime文件格式提供了150多种视频效果，支持25位彩色，支持RLE、JPEG等领先的集成压缩技术。此外，QuickTime还强化了对Internet应用的支持，并采用一种虚拟现实技术，使用户可以通过鼠标或键盘的交互式控制，观察某一地点周围360度的景像，或者从空间的任何角度观察某一物体。QuickTime以其领先的多媒体技术和跨平台特性、较小的存储空间要求、技术细节的独立性以及系统的高度开放性，得到业界的广泛认可。QuickTime格式文件的扩展是MOV或QT。\n\n#### 5．ASF和WMV格式\n\nASF（Advanced Streaming Format，高级流格式）和WMV是由Microsoft公司推出的一种在Internet上实时传播多媒体数据的技术标准，提供了本地或网络回放、可扩充的媒体类型、部件下载以及可扩展性等功能。ASF的应用平台是Net Show服务器和Net Show播放器。\n\nWMV也是Microsoft公司推出的一种流媒体格式，它是以ASF为基础，升级扩展后得到的。在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。WMV文件一般同时包含视频和音频部分，视频部分使用Windows Media Video编码，而音频部分使用Windows Media Audio编码。音频文件可以独立存在，其扩展名是WMA。\n\n","slug":"2015/流媒体技术概述","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmv0034sauavd8c9uic","content":"<h2 id=\"什么是流媒体技术\"><a href=\"#什么是流媒体技术\" class=\"headerlink\" title=\"什么是流媒体技术\"></a>什么是流媒体技术</h2><p>随着现代技术的发展，网络带给人们形式多样的信息，从第一张图片出现在网络上到如今各种形式的网络视频和三维动画，网络让人们的视听觉得到了很大的满足。然而在流媒体技术出现之前，人们必须要先下载这些多媒体内容到本地计算机，在漫长的等待之后（因为受限于带宽，下载通常要花上较长的时间），才可以看到或听到媒体传达的信息。令人欣慰的是，在流媒体技术出现之后，人们便无需再等待媒体完全下载完成了。<br><a id=\"more\"></a><br>流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术.所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,由视频服务器向用户计算机顺序或实时地传送各个压缩包，让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。</p>\n<h2 id=\"流媒体技术的应用分类\"><a href=\"#流媒体技术的应用分类\" class=\"headerlink\" title=\"流媒体技术的应用分类\"></a>流媒体技术的应用分类</h2><p>流媒体应用形式可以简单分为3类：点播型应用、直播型应用和会议型应用。</p>\n<ul>\n<li>（1）点播型应用。点播型应用中，一般点播内容存放在服务器上，根据需要进行发布。在同一时间可多点点播相同或不同的节目，即多个终端可在不同的地点、不同的时刻，实时、交互式地点播同一流文件，用户可以通过门户查看和选择内容进行点播。根据用户的需要，点播过程中还可以实现播放、停止、暂停、快进、后退等功能。</li>\n<li>（2）直播型应用。直播服务模式下，用户只能观看播放的内容，无法进行控制。</li>\n<li>（3）会议型应用。会议型应用类似于直播型应用，但是两者有不同的要求，如双向通信等。这对一般双方都要有包括媒体采集的硬件和软件，还有流传输技术。会议型的应用有时候不需要很高的音/视频质量。</li>\n<li>（4）视频广播，是点播的扩展，把节目源组织成频道，以广播的方式提供，用户通过加入频道收看预定好的节目</li>\n<li>(5)视频监视</li>\n<li>(6)音乐播放/在线电台</li>\n<li>(7)电视上网<h2 id=\"流媒体技术原理\"><a href=\"#流媒体技术原理\" class=\"headerlink\" title=\"流媒体技术原理\"></a>流媒体技术原理</h2>如果将文件传输看作是一次接水的过程，过去的传输方式就像是对用户做了一个规定，必须等到一桶水接满才能使用它，这个等待的时间自然要受到水流量大小和桶的大小的影响。而流式传输则是，打开水头龙，等待一小会儿，水就会源源不断地流出来，而且可以随接随用，因此，不管水流量的大小，也不管桶的大小，用户都可以随时用上水。从这个意义上看，流媒体这个词是非常形象的。<br>流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。<h3 id=\"顺序流式传输\"><a href=\"#顺序流式传输\" class=\"headerlink\" title=\"顺序流式传输\"></a>顺序流式传输</h3>顺序流式传输是顺序下载，在下载文件的同时用户可以观看，但是，用户的观看与服务器上的传输并不是同步进行的，用户是在一段延时后才能看到服务器上传出来的信息，或者说用户看到的总是服务器在若干时间以前传出来的信息。在这过程中，用户只能观看已下载的那部分，而不能要求跳到还未下载的部分。顺序流式传输比较适合高质量的短片段，因为它可以较好地保证节目播放的最终质量。它适合于在网站上发布的供用户点播的音视频节目。<br>对通过调制解调器发布的短片段，顺序流式传输很实用，它允许用比调制解调器跟高的数据速率创建视频片段，尽管有延迟毕竟可让你发布高质量的视频片段。<br>顺序流式文件是放在标准HTTP或FTP服务器上，易管理基本上与防火墙无关，顺序流式传播不适合长片段和有随机访问要求的视频，如演讲，演说与演示，它不支持现场广播，严格来说，它是一种点播技术。</li>\n</ul>\n<h3 id=\"实时流式传输\"><a href=\"#实时流式传输\" class=\"headerlink\" title=\"实时流式传输\"></a>实时流式传输</h3><p>在实时流式传输中，音视频信息可被实时观看到。在观看过程中用户可快进或后退以观看前面或后面的内容，但是在这种传输方式中，如果网络传输状况不理想，则收到的信号效果比较差。<br>实时流式传输必须匹配连接宽带，意味着以调制解调器速度连接时图像质量较差，而且由于出错丢失的信息被忽略掉，网络拥挤或者出现问题时候，视频质量很差，如欲保证视频质量，顺序流式传输也许更好，实时流式传输需要特定的服务器，如QuickTime Streaming Server/Real Server/Windows Media Server这些服务器允许你对媒体发送进行更多级别的控制，因为而系统设置管理比HTTP服务器更复杂，实时流传输还需要特殊的网络协议，比如RTSP(Real time sreming protocol)或MMS(Microsoft Media Server)这些协议在有防火墙的时候会出现问题，导致用户不能看到一些地点的实时内容。</p>\n<h2 id=\"流媒体系统的组成\"><a href=\"#流媒体系统的组成\" class=\"headerlink\" title=\"流媒体系统的组成\"></a>流媒体系统的组成</h2><p>通常，组成一个完整的流媒体系统包括以下5个部分：</p>\n<p>　　①一种用于创建、捕捉和编辑多媒体数据，形成流媒体格式的编码工具;</p>\n<p>　　②流媒体数据;</p>\n<p>　　③一个存放和控制流媒体数据的服务器;</p>\n<p>　　④要有适合多媒体传输协议甚至是实时传输协议的网络;</p>\n<p>　　⑤供客户端浏览流媒体文件的播放器。\n　　</p>\n<h2 id=\"流媒体传输的基本原理\"><a href=\"#流媒体传输的基本原理\" class=\"headerlink\" title=\"流媒体传输的基本原理\"></a>流媒体传输的基本原理</h2><p>流媒体传输的基本原理  流媒体服务器架设  流媒体技术也称为流式传输技术，是指在网络上按时间先后次序传输和播放的连续音、视频数据流。随着网络速度的提高，以流媒体技术为核心的视频点播、在线电视、远程培训等业务开展得越来越广泛。本章主要介绍流媒体技术的基础知识、流媒体服务器的安装、运行、配置和使用等内容。  23.1  流媒体技术基础  流媒体是指利用流式传输技术传送的音频、视频等连续媒体数据，它的核心是串流（Streaming）技术和数据压缩技术，具有连续性、实时性、时序性3个特点，可以使用顺序流式传输和实时流式传输两种传输方式。本节主要介绍有关流媒体的技术基础。  23.1.1  流媒体传输的基本原理 实现流式传输需要使用缓存机制。因为音频或视频数据在网络中是以包的形式传输的，而网络是动态变化的，各个数据包选择的路由可能不尽相同，到达客户端所需的时间也就不一样，有可能会出现先发的数据包却后到。因此，客户端如果按照包到达的次序播放数据，必然会得到不正确的结果。使用缓存机制就可以解决这个问题，客户端收到数据包后先缓存起来，播放器再从缓存中按次序读取数据。  使用缓存机制还可以解决停顿问题。网络由于某种原因经常会有一些突发流量，此时会造成暂时的拥塞，使流数据不能实时到达客户端，客户端的播放就会出现停顿。如果采用了缓存机制，暂时的网络阻塞并不会影响播放效果，因为播放器可以读取以前缓存的数据。等网络正常后，新的流数据将会继续添加到缓存中。  虽然音频或视频等流数据容量非常大，但播放流数据时所需的缓存容量并不需要很大，因为缓存可以使用环形链表结构来存储数据，已经播放的内容可以马上丢弃，缓存可以腾出空间用于存放后续尚未播放的内容。  当传输流数据时，需要使用合适的传输协议。TCP虽然是一种可靠的传输协议，但由于需要的开销较多，并不适合传输实时性要求很高的流数据。因此，在实际的流式传输方案中，TCP协议一般用来传输控制信息，而实时的音视频数据则是用效率更高的RTP/UDP等协议来传输。流媒体传输的基本原理如图23-1所示。  在图23-1中，Web服务器只是为用户提供了使用流媒体的操作界面。客户机上的用户在浏览器中选中播放某一流媒体资源后，Web服务器把有关这一资源的流媒体服务器地址、资源路径及编码类型等信息提供给客户端，于是客户端就启动了流媒体播放器，与流媒体服务器进行连接。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/76269153.jpg\" alt=\"\"><br>客户端的流媒体播放器与流媒体服务器之间交换控制信息时使用的是RTSP协议，它是基于TCP协议的一种应用层协议，默认使用的是554端口。RTSP协议提供了有关流媒体播放、快进、快倒、暂停及录制等操作的命令和方法。通过RTSP协议，客户端向服务器提出了播放某一流媒体资源的请求，服务器响应了这个请求后，就可以把流媒体数据传输给客户端了。</p>\n<p>需要注意的是，RTSP协议并不具备传输流媒体数据的功能，承担流媒体数据传输任务的是另一种基于UDP的RTP协议，但在RTP协议传输流媒体数据的过程中，RTSP连接是一直存在的，并且控制着流媒体数据的传输。一旦流媒体数据到达了客户端，流媒体播放器就可以播放输出了。流媒体的数据和控制信息使用不同的协议和连接时，还可以带来一个好处，就是播放流媒体的客户机和控制流媒体播放的客户机可以是不同的计算机。</p>\n<h3 id=\"实时流媒体协议RTSP\"><a href=\"#实时流媒体协议RTSP\" class=\"headerlink\" title=\"实时流媒体协议RTSP\"></a>实时流媒体协议RTSP</h3><p>RTSP（Real Time Streaming Protocol，实时流媒体协议）是由Real Network和Netscape共同提出的一种应用层协议，它定义了如何在IP网络上有效地传输流媒体数据。RTSP提供了一种机制，使音频、视频等数据可以按照需要进行实时传输，并且可以实施诸如暂停、快进等控制。源数据可以是存储的文件，也可以是现场数据的反馈。RTSP协议本身并不传输数据，数据的传输是通过基于UDP协议的RTP协议来完成的。</p>\n<p>RTSP协议与HTTP协议有点类似，通信双方是通过请求消息和回应消息进行交互的。请求消息的格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;请求方法&gt;  &lt;URI&gt;  &lt;RTSP版本&gt; </div><div class=\"line\">[消息头]  </div><div class=\"line\">CR/ LF  </div><div class=\"line\">[消息体]</div></pre></td></tr></table></figure></p>\n<p>其中，请求方法包括PLAY、DESCRIBE等，可以通过OPTION方法得到对方所支持的其他方法名称。URI是对方的地址，例如：rtsp://192.168.0.1。”RTSP版本”一般都是RTSP/1.0。每一行的最后都是回车换行符CR/LF，消息头和消息体之间要有一个空行。回应消息格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RTSP版本&gt; &lt;状态码&gt; &lt;解释&gt; </div><div class=\"line\">[消息头]  </div><div class=\"line\">CR/LF  </div><div class=\"line\">[消息体]</div></pre></td></tr></table></figure></p>\n<p>回应消息的格式规定与请求消息类似。其中状态码是一个3位数，后面跟随着解释文本，例如，200表示成功。</p>\n<p>HTTP协议是单向的，即只能是客户端提出请求，服务端给予回应，而使用RTSP时，客户机和服务器都可以发出请求，双方都可以对收到的请求进行应答，即RTSP可以是双向的。一个典型的RSTP交互过程如下所示，其中C表示RTSP客户端，S表示RTSP服务端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">C-&gt;S:    OPTION request     //客户端通过OPTION方法询问</div><div class=\"line\">服务端支持哪些方法  </div><div class=\"line\">S-&gt;C:    OPTION response    //服务端进行回应，提供了所支持方法的名称  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    DESCRIBE request   //客户端通过DESCRIBE方法查询服务</div><div class=\"line\">端媒体的初始化描述</div><div class=\"line\">//信息  </div><div class=\"line\">S-&gt;C:    DESCRIBE response  //服务端回应媒体初始化描述信息，</div><div class=\"line\">采用的是sdp会话描述</div><div class=\"line\">//格式  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    SETUP request      //客户端通过SETUP方法设置会话</div><div class=\"line\">的属性、传输模式等参数，</div><div class=\"line\">//并请求建立会话  </div><div class=\"line\">S-&gt;C:    SETUP response         //服务端响应回话请求，与客</div><div class=\"line\">户端建立会话，并返回会话标识</div><div class=\"line\">//符及其他相关信息  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    PLAY request       //客户端通过PLAY方法请求播放某一多媒体资源  </div><div class=\"line\">S-&gt;C:    PLAY response      //服务器回应请求，开始发送流数据  </div><div class=\"line\"> </div><div class=\"line\">S-&gt;C:    …                      //此时，RTSP通过其他协议发送流媒体数据  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    TEARDOWN request   //客户端通过TEARDOWN方法请求关闭会话  </div><div class=\"line\">S-&gt;C:    TEARDOWN response      //服务器回应请求，会话关闭，交互结束</div></pre></td></tr></table></figure></p>\n<p>实际应用中，RTCP的交互过程可能和以上过程会有区别，但基本的流程是一样的。</p>\n<p>说明：还有一种常见的流媒体协议是由Microsoft公司开发的MMS协议，但Microsoft公司没有公开该协议。</p>\n<h2 id=\"流媒体播放方式\"><a href=\"#流媒体播放方式\" class=\"headerlink\" title=\"流媒体播放方式\"></a>流媒体播放方式</h2><p>流媒体服务器可以提供多种播放方式，它可以根据用户的要求，为每个用户独立地传送流数据，实现VOD（Video On Demand）的功能；也可以为多个用户同时传送流数据，实现在线电视或现场直播的功能。下面介绍一下这些播放方式的特点。</p>\n<h3 id=\"单播方式\"><a href=\"#单播方式\" class=\"headerlink\" title=\"单播方式\"></a>单播方式</h3><p>当采用单播方式时，每个客户端都与流媒体服务器建立了一个单独的数据通道，从服务器发送的每个数据包都只能传给一台客户机。对用户来说，单播方式可以满足自己的个性化要求，可以根据需要随时使用停止、暂停、快进等控制功能。但对服务器还说，单播方式无疑会带来沉重的负担，因为它必须为每个用户提供单独的查询，向每个用户发送所申请的数据包复制。当用户数很多时，对网络速度、服务器性能的要求都很高。如果这些性能不能满足要求，就会造成播放停顿，甚至停止播放。</p>\n<h3 id=\"广播方式\"><a href=\"#广播方式\" class=\"headerlink\" title=\"广播方式\"></a>广播方式</h3><p>承载流数据的网络报文还可以使用广播方式发送给子网上所有的用户，此时，所有的用户同时接受一样的流数据，因此，服务器只需要发送一份数据复制就可以为子网上所有的用户服务，大大减轻了服务器的负担。但此时，客户机只能被动地接受流数据，而不能控制流。也就是说，用户不能暂停、快进或后退所播放的内容，而且，用户也不能对节目进行选择。</p>\n<h3 id=\"组播方式\"><a href=\"#组播方式\" class=\"headerlink\" title=\"组播方式\"></a>组播方式</h3><p>单播方式虽然用户提供了最大的灵活性，但网络和服务器的负担很重。广播方式虽然可以减轻服务器的负担，但用户不能选择播放内容，只能被动地接受流数据。组播吸取了上述两种传输方式的长处，可以将数据包复制发送给需要的多个客户，而不是像单播方式那样复制数据包的多个文件到网络上，也不是像广播方式那样将数据包发送给那些不需要的客户，保证数据包占用最小的网络带宽。当然，组播方式需要在具有组播能力的网络上使用。</p>\n<h2 id=\"流媒体关键技术\"><a href=\"#流媒体关键技术\" class=\"headerlink\" title=\"流媒体关键技术\"></a>流媒体关键技术</h2><p>流媒体有三个关键技术:数据压缩/解压缩技术，流媒体网络传输和媒体文件在流式传输中的版权保护问题，其中数据压缩和解压缩技术优势重中之重，核心技术。方发送确认嘻嘻，发送发收到确认嘻嘻猴才继续</p>\n<h3 id=\"流媒体制作技术方面解决的问题\"><a href=\"#流媒体制作技术方面解决的问题\" class=\"headerlink\" title=\"流媒体制作技术方面解决的问题\"></a>流媒体制作技术方面解决的问题</h3><p>在网络中进行流媒体传输，所传输的文件必须制作成适合流媒体传输的流媒体格式文件，由于通常格式存储的多媒体文件容量十分大，传输比较困难，另外流媒体也不能按流媒体传输的协议进行传输，所以必须对问津进行预处理，将文件压缩成流媒体格式文件，这里要注意两点：1，选用合适的算法在质量与体积之间找到平衡，2，需要向文件中添加流式信息。</p>\n<h3 id=\"流媒体传输方面需要解决的问题\"><a href=\"#流媒体传输方面需要解决的问题\" class=\"headerlink\" title=\"流媒体传输方面需要解决的问题\"></a>流媒体传输方面需要解决的问题</h3><p>流媒体传输需要和实施的传输协议，目前文件初三书大部分是建立在TCP协议上的，也有一些以ftp传输协议方式进行传输，但采用这些传输方法都不能实现实时的方式传输，随着流媒体技术的深入研究，目前成熟的流媒体传输一般都采用建立在UDP协议上的RTP/RTSP实时传输协议。<br>之所选择UDP是因为在传输的可靠性上UDP比TCP有很大的有事，TCP协议中包含了专门的数据传送校验机制，当数据接受方收到数据后将自动向发送确认信息，发送方在接收到确认信息后才继续传送数据，否则将一直处于等待状态，而UDP协议则不同，本身并不做任何校验，由此可以看出TCP协议注重传输质量，而UDP注重传输速度，因此对于传输质量要求不是很高，而对速度要求很高的视音频流媒体文件来说，采用UDP更加合适。</p>\n<h3 id=\"流媒体的传说过程中需要缓存的支持\"><a href=\"#流媒体的传说过程中需要缓存的支持\" class=\"headerlink\" title=\"流媒体的传说过程中需要缓存的支持\"></a>流媒体的传说过程中需要缓存的支持</h3><p>因为internet是以包为单位进行异步传输的，所以多媒体数据在传输过程中被分解为许多的包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包现象，为此，必须采用正确的书序，从而必须使用缓存技术来纠正由于数据到达次序发生改变而产生的混乱的问题，利用缓存对到达的数据包进行正确的排序，从而使音频数据能够连续正确的播放，缓存中存储的是一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的，流媒体在播放时不断的读取缓存中的数据进行播放，播放完后该数据立刻被清楚，新的数据将加入缓存，因此播放流媒体文件的时候并不需要占用太大的缓存空间。</p>\n<h2 id=\"流媒体传输的网络协议\"><a href=\"#流媒体传输的网络协议\" class=\"headerlink\" title=\"流媒体传输的网络协议\"></a>流媒体传输的网络协议</h2><p>TCP需要较多的开销，所以不太适合传输实时数据，流式传输一般采用HTTP/TCP(RTCP)传输控制信息，而采用RTP/UDP(RTP)来传输实时声音数据。</p>\n<h3 id=\"实时传输协议RTP\"><a href=\"#实时传输协议RTP\" class=\"headerlink\" title=\"实时传输协议RTP\"></a>实时传输协议RTP</h3><p>这种协议在一对一或一对多的传输情况下工作，其目的是提供时间信息和实现流同步，RTP通常使用UDP来传送数据，当引用程序开始一个RTP会话时将使用两个端口，一个给RTP，一个给RTCP，RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务，通常RTP算法并不作为一个独立的网络层来实现，而是作为应用程序代码的一部分。</p>\n<h3 id=\"实时传输控制协议RTCP\"><a href=\"#实时传输控制协议RTCP\" class=\"headerlink\" title=\"实时传输控制协议RTCP\"></a>实时传输控制协议RTCP</h3><p>实时传输控制协议RTCP和RTP一起提供流量控制和拥塞控制服务，在RTP会话期间各参与者周期性的传送RTCP包，RTCP包中含有 已发送的数据包的数量，丢失的数据包数量等统计资料，因此服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷类型。<br>RTP和RTCP配合使用，能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</p>\n<h3 id=\"实时流协议RTSP\"><a href=\"#实时流协议RTSP\" class=\"headerlink\" title=\"实时流协议RTSP\"></a>实时流协议RTSP</h3><p>实时流协议RTSP定义了一对多应用程序如何有效地通过IP网络传送多媒体数据，RTSP的体系结构上位于RTP和RTCP之上，它使用TCP或RTP完成数据传输，HTTP与RTSP相比，HTTP传送HTML超链接文档，而RTSP传送的是多媒体数据，HTTP请求由客户机发出，服务器作出相应，使用RTSP时，客户机与服务器都可以发出请求，即RTSP可以是双向的，点对点的额手机可视通话，必须在手机终端实现RTSP。</p>\n<h2 id=\"流媒体文件格式\"><a href=\"#流媒体文件格式\" class=\"headerlink\" title=\"流媒体文件格式\"></a>流媒体文件格式</h2><p>将多媒体信息进行压缩生成一定格式的文件，这就是媒体压缩格式，而要将这些压缩的文件在IP网上进行实时传输，就需要将这些压缩文件进行必要的处理，分割成很多小块，以方便传输，比如rm，rmvb，asf，这就是媒体流格式，要在网上传播还需要将一定的格式告诉用户这就是媒体的发布格式。</p>\n<h3 id=\"流式文件格式\"><a href=\"#流式文件格式\" class=\"headerlink\" title=\"流式文件格式\"></a>流式文件格式</h3><p>为了减小用户的播放演示和存储空间，实现边下边播，并保证一定的播放质量，就需要对压缩文件进行特殊的处理，添加一些附属信息，如计时，压缩和版权信息，这就是流式文件格式，常见的有如下集中：</p>\n<h4 id=\"flv\"><a href=\"#flv\" class=\"headerlink\" title=\"flv\"></a>flv</h4><p>Flash MX 以前flash中的视频文件导入是一帧一帧变成位图，结果导致文件巨大，限制了它的引用范围，随着Flash MX的退出，macromedia公司开发了属于自己流式视频格式的FLV，这种个试试在sorenson公司的压缩算法的基础上开发出来的，sorenson公司也为MOV格式提供苏犯法。<br>FLV格式不仅可以轻松导入flash中，几百帧的影片两分钟完成导入，同时可以通过rtmp协议从flashcom服务器上流式播出。 </p>\n<h3 id=\"流媒体文件的压缩格式\"><a href=\"#流媒体文件的压缩格式\" class=\"headerlink\" title=\"流媒体文件的压缩格式\"></a>流媒体文件的压缩格式</h3><p>数据压缩技术也是流媒体技术的一项重要内容，由于视频数据的容量往往都非常大，如果不经过压缩或压缩得不够，则不仅会增加服务器的负担，更重要的是会占用大量的网络带宽，影响播放效果。因此如何在保证不影响观看效果或对观看效果影响很小的前提下，最大限度地对流数据进行压缩，是流媒体技术研究的一项重要内容。下面介绍一下几种主流的音视频数据压缩格式。</p>\n<h4 id=\"1．AVI格式\"><a href=\"#1．AVI格式\" class=\"headerlink\" title=\"1．AVI格式\"></a>1．AVI格式</h4><p>AVI（Audio Video Interleave，音频视频交错）是符合RIFF文件规范的数字音频与视频文件格式，由Microsoft公司开发，目前得到了广泛的支持。AVI格式支持256色和RLE压缩，并允许视频和音频交错在一起同步播放。但AVI文件并未限定压缩算法，只是提供了作为控制界面的标准，用不同压缩算法生成的AVI文件，必须要使用相同的解压缩算法才能解压播放。AVI文件主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息。</p>\n<h4 id=\"2．MPEG格式\"><a href=\"#2．MPEG格式\" class=\"headerlink\" title=\"2．MPEG格式\"></a>2．MPEG格式</h4><p>MPEG（Moving Picture Experts Group，动态图像专家组）是运动图像压缩算法的国际标准，已被几乎所有的计算机平台共同支持，它采用有损压缩算法减少运动图像中的冗余信息，同时保证每秒30帧的图像刷新率。MPEG标准包括视频压缩、音频压缩和音视频同步3个部分，MPEG音频最典型的应用就是MP3音频文件，广泛使用的消费类视频产品如VCD、DVD其压缩算法采用的也是MPEG标准。</p>\n<p>MPEG压缩算法是针对运动图像而设计的，其基本思路是把视频图像按时间分段，然后采集并保存每一段的第一帧数据，其余各帧只存储相对第一帧发生变化的部分，从而达到了数据压缩的目的。MPEG采用了两个基本的压缩技术：运动补偿技术（预测编码和插补码）实现了时间上的压缩，变换域（离散余弦变换DCT）技术实现了空间上的压缩。MPEG在保证图像和声音质量的前提下，压缩效率非常高，平均压缩比为50∶1，最高可达200∶1。</p>\n<h4 id=\"3．RealVideo格式\"><a href=\"#3．RealVideo格式\" class=\"headerlink\" title=\"3．RealVideo格式\"></a>3．RealVideo格式</h4><p>RealVideo格式是由Real Networks公司开发的一种流式视频文件格式，包含在Real Media音频视频压缩规范中，其设计目标是在低速率的广域网上实时传输视频影像。RealVideo可以根据网络的传输速度来决定视频数据的压缩比率，从而提高适应能力，充分利用带宽。本章后面介绍的Real Server软件就是由Real Networks公司提供的，使用的就是Real Video格式的视频文件。</p>\n<p>RealVideo格式文件的扩展名有3种，RA是音频文件、RM和RMVB是视频文件。RMVB格式文件具有可变比特率的特性，它在处理较复杂的动态影像时使用较高的采样率，而在处理一般静止画面时则灵活地转换至较低的采样率，从而在不增加文件大小的前提下提高了图像质量。</p>\n<h4 id=\"4．QuickTime格式\"><a href=\"#4．QuickTime格式\" class=\"headerlink\" title=\"4．QuickTime格式\"></a>4．QuickTime格式</h4><p>QuickTime是由Apple公司开发的一种音视频数据压缩格式，得到了Mac OS、Microsoft Windows等主流操作系统平台的支持。QuickTime文件格式提供了150多种视频效果，支持25位彩色，支持RLE、JPEG等领先的集成压缩技术。此外，QuickTime还强化了对Internet应用的支持，并采用一种虚拟现实技术，使用户可以通过鼠标或键盘的交互式控制，观察某一地点周围360度的景像，或者从空间的任何角度观察某一物体。QuickTime以其领先的多媒体技术和跨平台特性、较小的存储空间要求、技术细节的独立性以及系统的高度开放性，得到业界的广泛认可。QuickTime格式文件的扩展是MOV或QT。</p>\n<h4 id=\"5．ASF和WMV格式\"><a href=\"#5．ASF和WMV格式\" class=\"headerlink\" title=\"5．ASF和WMV格式\"></a>5．ASF和WMV格式</h4><p>ASF（Advanced Streaming Format，高级流格式）和WMV是由Microsoft公司推出的一种在Internet上实时传播多媒体数据的技术标准，提供了本地或网络回放、可扩充的媒体类型、部件下载以及可扩展性等功能。ASF的应用平台是Net Show服务器和Net Show播放器。</p>\n<p>WMV也是Microsoft公司推出的一种流媒体格式，它是以ASF为基础，升级扩展后得到的。在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。WMV文件一般同时包含视频和音频部分，视频部分使用Windows Media Video编码，而音频部分使用Windows Media Audio编码。音频文件可以独立存在，其扩展名是WMA。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是流媒体技术\"><a href=\"#什么是流媒体技术\" class=\"headerlink\" title=\"什么是流媒体技术\"></a>什么是流媒体技术</h2><p>随着现代技术的发展，网络带给人们形式多样的信息，从第一张图片出现在网络上到如今各种形式的网络视频和三维动画，网络让人们的视听觉得到了很大的满足。然而在流媒体技术出现之前，人们必须要先下载这些多媒体内容到本地计算机，在漫长的等待之后（因为受限于带宽，下载通常要花上较长的时间），才可以看到或听到媒体传达的信息。令人欣慰的是，在流媒体技术出现之后，人们便无需再等待媒体完全下载完成了。<br>","more":"<br>流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术.所谓流媒体技术就是把连续的影像和声音信息经过压缩处理后放上网站服务器,由视频服务器向用户计算机顺序或实时地传送各个压缩包，让用户一边下载一边观看、收听，而不要等整个压缩文件下载到自己的计算机上才可以观看的网络传输技术。该技术先在使用者端的计算机上创建一个缓冲区，在播放前预先下一段数据作为缓冲，在网路实际连线速度小于播放所耗的速度时，播放程序就会取用一小段缓冲区内的数据，这样可以避免播放的中断，也使得播放品质得以保证。</p>\n<h2 id=\"流媒体技术的应用分类\"><a href=\"#流媒体技术的应用分类\" class=\"headerlink\" title=\"流媒体技术的应用分类\"></a>流媒体技术的应用分类</h2><p>流媒体应用形式可以简单分为3类：点播型应用、直播型应用和会议型应用。</p>\n<ul>\n<li>（1）点播型应用。点播型应用中，一般点播内容存放在服务器上，根据需要进行发布。在同一时间可多点点播相同或不同的节目，即多个终端可在不同的地点、不同的时刻，实时、交互式地点播同一流文件，用户可以通过门户查看和选择内容进行点播。根据用户的需要，点播过程中还可以实现播放、停止、暂停、快进、后退等功能。</li>\n<li>（2）直播型应用。直播服务模式下，用户只能观看播放的内容，无法进行控制。</li>\n<li>（3）会议型应用。会议型应用类似于直播型应用，但是两者有不同的要求，如双向通信等。这对一般双方都要有包括媒体采集的硬件和软件，还有流传输技术。会议型的应用有时候不需要很高的音/视频质量。</li>\n<li>（4）视频广播，是点播的扩展，把节目源组织成频道，以广播的方式提供，用户通过加入频道收看预定好的节目</li>\n<li>(5)视频监视</li>\n<li>(6)音乐播放/在线电台</li>\n<li>(7)电视上网<h2 id=\"流媒体技术原理\"><a href=\"#流媒体技术原理\" class=\"headerlink\" title=\"流媒体技术原理\"></a>流媒体技术原理</h2>如果将文件传输看作是一次接水的过程，过去的传输方式就像是对用户做了一个规定，必须等到一桶水接满才能使用它，这个等待的时间自然要受到水流量大小和桶的大小的影响。而流式传输则是，打开水头龙，等待一小会儿，水就会源源不断地流出来，而且可以随接随用，因此，不管水流量的大小，也不管桶的大小，用户都可以随时用上水。从这个意义上看，流媒体这个词是非常形象的。<br>流式传输技术又分两种，一种是顺序流式传输，另一种是实时流式传输。<h3 id=\"顺序流式传输\"><a href=\"#顺序流式传输\" class=\"headerlink\" title=\"顺序流式传输\"></a>顺序流式传输</h3>顺序流式传输是顺序下载，在下载文件的同时用户可以观看，但是，用户的观看与服务器上的传输并不是同步进行的，用户是在一段延时后才能看到服务器上传出来的信息，或者说用户看到的总是服务器在若干时间以前传出来的信息。在这过程中，用户只能观看已下载的那部分，而不能要求跳到还未下载的部分。顺序流式传输比较适合高质量的短片段，因为它可以较好地保证节目播放的最终质量。它适合于在网站上发布的供用户点播的音视频节目。<br>对通过调制解调器发布的短片段，顺序流式传输很实用，它允许用比调制解调器跟高的数据速率创建视频片段，尽管有延迟毕竟可让你发布高质量的视频片段。<br>顺序流式文件是放在标准HTTP或FTP服务器上，易管理基本上与防火墙无关，顺序流式传播不适合长片段和有随机访问要求的视频，如演讲，演说与演示，它不支持现场广播，严格来说，它是一种点播技术。</li>\n</ul>\n<h3 id=\"实时流式传输\"><a href=\"#实时流式传输\" class=\"headerlink\" title=\"实时流式传输\"></a>实时流式传输</h3><p>在实时流式传输中，音视频信息可被实时观看到。在观看过程中用户可快进或后退以观看前面或后面的内容，但是在这种传输方式中，如果网络传输状况不理想，则收到的信号效果比较差。<br>实时流式传输必须匹配连接宽带，意味着以调制解调器速度连接时图像质量较差，而且由于出错丢失的信息被忽略掉，网络拥挤或者出现问题时候，视频质量很差，如欲保证视频质量，顺序流式传输也许更好，实时流式传输需要特定的服务器，如QuickTime Streaming Server/Real Server/Windows Media Server这些服务器允许你对媒体发送进行更多级别的控制，因为而系统设置管理比HTTP服务器更复杂，实时流传输还需要特殊的网络协议，比如RTSP(Real time sreming protocol)或MMS(Microsoft Media Server)这些协议在有防火墙的时候会出现问题，导致用户不能看到一些地点的实时内容。</p>\n<h2 id=\"流媒体系统的组成\"><a href=\"#流媒体系统的组成\" class=\"headerlink\" title=\"流媒体系统的组成\"></a>流媒体系统的组成</h2><p>通常，组成一个完整的流媒体系统包括以下5个部分：</p>\n<p>　　①一种用于创建、捕捉和编辑多媒体数据，形成流媒体格式的编码工具;</p>\n<p>　　②流媒体数据;</p>\n<p>　　③一个存放和控制流媒体数据的服务器;</p>\n<p>　　④要有适合多媒体传输协议甚至是实时传输协议的网络;</p>\n<p>　　⑤供客户端浏览流媒体文件的播放器。\n　　</p>\n<h2 id=\"流媒体传输的基本原理\"><a href=\"#流媒体传输的基本原理\" class=\"headerlink\" title=\"流媒体传输的基本原理\"></a>流媒体传输的基本原理</h2><p>流媒体传输的基本原理  流媒体服务器架设  流媒体技术也称为流式传输技术，是指在网络上按时间先后次序传输和播放的连续音、视频数据流。随着网络速度的提高，以流媒体技术为核心的视频点播、在线电视、远程培训等业务开展得越来越广泛。本章主要介绍流媒体技术的基础知识、流媒体服务器的安装、运行、配置和使用等内容。  23.1  流媒体技术基础  流媒体是指利用流式传输技术传送的音频、视频等连续媒体数据，它的核心是串流（Streaming）技术和数据压缩技术，具有连续性、实时性、时序性3个特点，可以使用顺序流式传输和实时流式传输两种传输方式。本节主要介绍有关流媒体的技术基础。  23.1.1  流媒体传输的基本原理 实现流式传输需要使用缓存机制。因为音频或视频数据在网络中是以包的形式传输的，而网络是动态变化的，各个数据包选择的路由可能不尽相同，到达客户端所需的时间也就不一样，有可能会出现先发的数据包却后到。因此，客户端如果按照包到达的次序播放数据，必然会得到不正确的结果。使用缓存机制就可以解决这个问题，客户端收到数据包后先缓存起来，播放器再从缓存中按次序读取数据。  使用缓存机制还可以解决停顿问题。网络由于某种原因经常会有一些突发流量，此时会造成暂时的拥塞，使流数据不能实时到达客户端，客户端的播放就会出现停顿。如果采用了缓存机制，暂时的网络阻塞并不会影响播放效果，因为播放器可以读取以前缓存的数据。等网络正常后，新的流数据将会继续添加到缓存中。  虽然音频或视频等流数据容量非常大，但播放流数据时所需的缓存容量并不需要很大，因为缓存可以使用环形链表结构来存储数据，已经播放的内容可以马上丢弃，缓存可以腾出空间用于存放后续尚未播放的内容。  当传输流数据时，需要使用合适的传输协议。TCP虽然是一种可靠的传输协议，但由于需要的开销较多，并不适合传输实时性要求很高的流数据。因此，在实际的流式传输方案中，TCP协议一般用来传输控制信息，而实时的音视频数据则是用效率更高的RTP/UDP等协议来传输。流媒体传输的基本原理如图23-1所示。  在图23-1中，Web服务器只是为用户提供了使用流媒体的操作界面。客户机上的用户在浏览器中选中播放某一流媒体资源后，Web服务器把有关这一资源的流媒体服务器地址、资源路径及编码类型等信息提供给客户端，于是客户端就启动了流媒体播放器，与流媒体服务器进行连接。<br><img src=\"http://7xrn7f.com1.z0.glb.clouddn.com/16-7-17/76269153.jpg\" alt=\"\"><br>客户端的流媒体播放器与流媒体服务器之间交换控制信息时使用的是RTSP协议，它是基于TCP协议的一种应用层协议，默认使用的是554端口。RTSP协议提供了有关流媒体播放、快进、快倒、暂停及录制等操作的命令和方法。通过RTSP协议，客户端向服务器提出了播放某一流媒体资源的请求，服务器响应了这个请求后，就可以把流媒体数据传输给客户端了。</p>\n<p>需要注意的是，RTSP协议并不具备传输流媒体数据的功能，承担流媒体数据传输任务的是另一种基于UDP的RTP协议，但在RTP协议传输流媒体数据的过程中，RTSP连接是一直存在的，并且控制着流媒体数据的传输。一旦流媒体数据到达了客户端，流媒体播放器就可以播放输出了。流媒体的数据和控制信息使用不同的协议和连接时，还可以带来一个好处，就是播放流媒体的客户机和控制流媒体播放的客户机可以是不同的计算机。</p>\n<h3 id=\"实时流媒体协议RTSP\"><a href=\"#实时流媒体协议RTSP\" class=\"headerlink\" title=\"实时流媒体协议RTSP\"></a>实时流媒体协议RTSP</h3><p>RTSP（Real Time Streaming Protocol，实时流媒体协议）是由Real Network和Netscape共同提出的一种应用层协议，它定义了如何在IP网络上有效地传输流媒体数据。RTSP提供了一种机制，使音频、视频等数据可以按照需要进行实时传输，并且可以实施诸如暂停、快进等控制。源数据可以是存储的文件，也可以是现场数据的反馈。RTSP协议本身并不传输数据，数据的传输是通过基于UDP协议的RTP协议来完成的。</p>\n<p>RTSP协议与HTTP协议有点类似，通信双方是通过请求消息和回应消息进行交互的。请求消息的格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;请求方法&gt;  &lt;URI&gt;  &lt;RTSP版本&gt; </div><div class=\"line\">[消息头]  </div><div class=\"line\">CR/ LF  </div><div class=\"line\">[消息体]</div></pre></td></tr></table></figure></p>\n<p>其中，请求方法包括PLAY、DESCRIBE等，可以通过OPTION方法得到对方所支持的其他方法名称。URI是对方的地址，例如：rtsp://192.168.0.1。”RTSP版本”一般都是RTSP/1.0。每一行的最后都是回车换行符CR/LF，消息头和消息体之间要有一个空行。回应消息格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;RTSP版本&gt; &lt;状态码&gt; &lt;解释&gt; </div><div class=\"line\">[消息头]  </div><div class=\"line\">CR/LF  </div><div class=\"line\">[消息体]</div></pre></td></tr></table></figure></p>\n<p>回应消息的格式规定与请求消息类似。其中状态码是一个3位数，后面跟随着解释文本，例如，200表示成功。</p>\n<p>HTTP协议是单向的，即只能是客户端提出请求，服务端给予回应，而使用RTSP时，客户机和服务器都可以发出请求，双方都可以对收到的请求进行应答，即RTSP可以是双向的。一个典型的RSTP交互过程如下所示，其中C表示RTSP客户端，S表示RTSP服务端<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">C-&gt;S:    OPTION request     //客户端通过OPTION方法询问</div><div class=\"line\">服务端支持哪些方法  </div><div class=\"line\">S-&gt;C:    OPTION response    //服务端进行回应，提供了所支持方法的名称  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    DESCRIBE request   //客户端通过DESCRIBE方法查询服务</div><div class=\"line\">端媒体的初始化描述</div><div class=\"line\">//信息  </div><div class=\"line\">S-&gt;C:    DESCRIBE response  //服务端回应媒体初始化描述信息，</div><div class=\"line\">采用的是sdp会话描述</div><div class=\"line\">//格式  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    SETUP request      //客户端通过SETUP方法设置会话</div><div class=\"line\">的属性、传输模式等参数，</div><div class=\"line\">//并请求建立会话  </div><div class=\"line\">S-&gt;C:    SETUP response         //服务端响应回话请求，与客</div><div class=\"line\">户端建立会话，并返回会话标识</div><div class=\"line\">//符及其他相关信息  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    PLAY request       //客户端通过PLAY方法请求播放某一多媒体资源  </div><div class=\"line\">S-&gt;C:    PLAY response      //服务器回应请求，开始发送流数据  </div><div class=\"line\"> </div><div class=\"line\">S-&gt;C:    …                      //此时，RTSP通过其他协议发送流媒体数据  </div><div class=\"line\"> </div><div class=\"line\">C-&gt;S:    TEARDOWN request   //客户端通过TEARDOWN方法请求关闭会话  </div><div class=\"line\">S-&gt;C:    TEARDOWN response      //服务器回应请求，会话关闭，交互结束</div></pre></td></tr></table></figure></p>\n<p>实际应用中，RTCP的交互过程可能和以上过程会有区别，但基本的流程是一样的。</p>\n<p>说明：还有一种常见的流媒体协议是由Microsoft公司开发的MMS协议，但Microsoft公司没有公开该协议。</p>\n<h2 id=\"流媒体播放方式\"><a href=\"#流媒体播放方式\" class=\"headerlink\" title=\"流媒体播放方式\"></a>流媒体播放方式</h2><p>流媒体服务器可以提供多种播放方式，它可以根据用户的要求，为每个用户独立地传送流数据，实现VOD（Video On Demand）的功能；也可以为多个用户同时传送流数据，实现在线电视或现场直播的功能。下面介绍一下这些播放方式的特点。</p>\n<h3 id=\"单播方式\"><a href=\"#单播方式\" class=\"headerlink\" title=\"单播方式\"></a>单播方式</h3><p>当采用单播方式时，每个客户端都与流媒体服务器建立了一个单独的数据通道，从服务器发送的每个数据包都只能传给一台客户机。对用户来说，单播方式可以满足自己的个性化要求，可以根据需要随时使用停止、暂停、快进等控制功能。但对服务器还说，单播方式无疑会带来沉重的负担，因为它必须为每个用户提供单独的查询，向每个用户发送所申请的数据包复制。当用户数很多时，对网络速度、服务器性能的要求都很高。如果这些性能不能满足要求，就会造成播放停顿，甚至停止播放。</p>\n<h3 id=\"广播方式\"><a href=\"#广播方式\" class=\"headerlink\" title=\"广播方式\"></a>广播方式</h3><p>承载流数据的网络报文还可以使用广播方式发送给子网上所有的用户，此时，所有的用户同时接受一样的流数据，因此，服务器只需要发送一份数据复制就可以为子网上所有的用户服务，大大减轻了服务器的负担。但此时，客户机只能被动地接受流数据，而不能控制流。也就是说，用户不能暂停、快进或后退所播放的内容，而且，用户也不能对节目进行选择。</p>\n<h3 id=\"组播方式\"><a href=\"#组播方式\" class=\"headerlink\" title=\"组播方式\"></a>组播方式</h3><p>单播方式虽然用户提供了最大的灵活性，但网络和服务器的负担很重。广播方式虽然可以减轻服务器的负担，但用户不能选择播放内容，只能被动地接受流数据。组播吸取了上述两种传输方式的长处，可以将数据包复制发送给需要的多个客户，而不是像单播方式那样复制数据包的多个文件到网络上，也不是像广播方式那样将数据包发送给那些不需要的客户，保证数据包占用最小的网络带宽。当然，组播方式需要在具有组播能力的网络上使用。</p>\n<h2 id=\"流媒体关键技术\"><a href=\"#流媒体关键技术\" class=\"headerlink\" title=\"流媒体关键技术\"></a>流媒体关键技术</h2><p>流媒体有三个关键技术:数据压缩/解压缩技术，流媒体网络传输和媒体文件在流式传输中的版权保护问题，其中数据压缩和解压缩技术优势重中之重，核心技术。方发送确认嘻嘻，发送发收到确认嘻嘻猴才继续</p>\n<h3 id=\"流媒体制作技术方面解决的问题\"><a href=\"#流媒体制作技术方面解决的问题\" class=\"headerlink\" title=\"流媒体制作技术方面解决的问题\"></a>流媒体制作技术方面解决的问题</h3><p>在网络中进行流媒体传输，所传输的文件必须制作成适合流媒体传输的流媒体格式文件，由于通常格式存储的多媒体文件容量十分大，传输比较困难，另外流媒体也不能按流媒体传输的协议进行传输，所以必须对问津进行预处理，将文件压缩成流媒体格式文件，这里要注意两点：1，选用合适的算法在质量与体积之间找到平衡，2，需要向文件中添加流式信息。</p>\n<h3 id=\"流媒体传输方面需要解决的问题\"><a href=\"#流媒体传输方面需要解决的问题\" class=\"headerlink\" title=\"流媒体传输方面需要解决的问题\"></a>流媒体传输方面需要解决的问题</h3><p>流媒体传输需要和实施的传输协议，目前文件初三书大部分是建立在TCP协议上的，也有一些以ftp传输协议方式进行传输，但采用这些传输方法都不能实现实时的方式传输，随着流媒体技术的深入研究，目前成熟的流媒体传输一般都采用建立在UDP协议上的RTP/RTSP实时传输协议。<br>之所选择UDP是因为在传输的可靠性上UDP比TCP有很大的有事，TCP协议中包含了专门的数据传送校验机制，当数据接受方收到数据后将自动向发送确认信息，发送方在接收到确认信息后才继续传送数据，否则将一直处于等待状态，而UDP协议则不同，本身并不做任何校验，由此可以看出TCP协议注重传输质量，而UDP注重传输速度，因此对于传输质量要求不是很高，而对速度要求很高的视音频流媒体文件来说，采用UDP更加合适。</p>\n<h3 id=\"流媒体的传说过程中需要缓存的支持\"><a href=\"#流媒体的传说过程中需要缓存的支持\" class=\"headerlink\" title=\"流媒体的传说过程中需要缓存的支持\"></a>流媒体的传说过程中需要缓存的支持</h3><p>因为internet是以包为单位进行异步传输的，所以多媒体数据在传输过程中被分解为许多的包，由于网络传输的不稳定性，各个包选择的路由不同，所以到达客户端的时间次序可能发生改变，甚至产生丢包现象，为此，必须采用正确的书序，从而必须使用缓存技术来纠正由于数据到达次序发生改变而产生的混乱的问题，利用缓存对到达的数据包进行正确的排序，从而使音频数据能够连续正确的播放，缓存中存储的是一段时间内的数据，数据在缓存中存放的时间是暂时的，缓存中的数据也是动态的，不断更新的，流媒体在播放时不断的读取缓存中的数据进行播放，播放完后该数据立刻被清楚，新的数据将加入缓存，因此播放流媒体文件的时候并不需要占用太大的缓存空间。</p>\n<h2 id=\"流媒体传输的网络协议\"><a href=\"#流媒体传输的网络协议\" class=\"headerlink\" title=\"流媒体传输的网络协议\"></a>流媒体传输的网络协议</h2><p>TCP需要较多的开销，所以不太适合传输实时数据，流式传输一般采用HTTP/TCP(RTCP)传输控制信息，而采用RTP/UDP(RTP)来传输实时声音数据。</p>\n<h3 id=\"实时传输协议RTP\"><a href=\"#实时传输协议RTP\" class=\"headerlink\" title=\"实时传输协议RTP\"></a>实时传输协议RTP</h3><p>这种协议在一对一或一对多的传输情况下工作，其目的是提供时间信息和实现流同步，RTP通常使用UDP来传送数据，当引用程序开始一个RTP会话时将使用两个端口，一个给RTP，一个给RTCP，RTP本身并不能为按顺序传送数据包提供可靠的传送机制，也不提供流量控制或拥塞控制，它依靠RTCP提供这些服务，通常RTP算法并不作为一个独立的网络层来实现，而是作为应用程序代码的一部分。</p>\n<h3 id=\"实时传输控制协议RTCP\"><a href=\"#实时传输控制协议RTCP\" class=\"headerlink\" title=\"实时传输控制协议RTCP\"></a>实时传输控制协议RTCP</h3><p>实时传输控制协议RTCP和RTP一起提供流量控制和拥塞控制服务，在RTP会话期间各参与者周期性的传送RTCP包，RTCP包中含有 已发送的数据包的数量，丢失的数据包数量等统计资料，因此服务器可以利用这些信息动态的改变传输速率，甚至改变有效载荷类型。<br>RTP和RTCP配合使用，能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</p>\n<h3 id=\"实时流协议RTSP\"><a href=\"#实时流协议RTSP\" class=\"headerlink\" title=\"实时流协议RTSP\"></a>实时流协议RTSP</h3><p>实时流协议RTSP定义了一对多应用程序如何有效地通过IP网络传送多媒体数据，RTSP的体系结构上位于RTP和RTCP之上，它使用TCP或RTP完成数据传输，HTTP与RTSP相比，HTTP传送HTML超链接文档，而RTSP传送的是多媒体数据，HTTP请求由客户机发出，服务器作出相应，使用RTSP时，客户机与服务器都可以发出请求，即RTSP可以是双向的，点对点的额手机可视通话，必须在手机终端实现RTSP。</p>\n<h2 id=\"流媒体文件格式\"><a href=\"#流媒体文件格式\" class=\"headerlink\" title=\"流媒体文件格式\"></a>流媒体文件格式</h2><p>将多媒体信息进行压缩生成一定格式的文件，这就是媒体压缩格式，而要将这些压缩的文件在IP网上进行实时传输，就需要将这些压缩文件进行必要的处理，分割成很多小块，以方便传输，比如rm，rmvb，asf，这就是媒体流格式，要在网上传播还需要将一定的格式告诉用户这就是媒体的发布格式。</p>\n<h3 id=\"流式文件格式\"><a href=\"#流式文件格式\" class=\"headerlink\" title=\"流式文件格式\"></a>流式文件格式</h3><p>为了减小用户的播放演示和存储空间，实现边下边播，并保证一定的播放质量，就需要对压缩文件进行特殊的处理，添加一些附属信息，如计时，压缩和版权信息，这就是流式文件格式，常见的有如下集中：</p>\n<h4 id=\"flv\"><a href=\"#flv\" class=\"headerlink\" title=\"flv\"></a>flv</h4><p>Flash MX 以前flash中的视频文件导入是一帧一帧变成位图，结果导致文件巨大，限制了它的引用范围，随着Flash MX的退出，macromedia公司开发了属于自己流式视频格式的FLV，这种个试试在sorenson公司的压缩算法的基础上开发出来的，sorenson公司也为MOV格式提供苏犯法。<br>FLV格式不仅可以轻松导入flash中，几百帧的影片两分钟完成导入，同时可以通过rtmp协议从flashcom服务器上流式播出。 </p>\n<h3 id=\"流媒体文件的压缩格式\"><a href=\"#流媒体文件的压缩格式\" class=\"headerlink\" title=\"流媒体文件的压缩格式\"></a>流媒体文件的压缩格式</h3><p>数据压缩技术也是流媒体技术的一项重要内容，由于视频数据的容量往往都非常大，如果不经过压缩或压缩得不够，则不仅会增加服务器的负担，更重要的是会占用大量的网络带宽，影响播放效果。因此如何在保证不影响观看效果或对观看效果影响很小的前提下，最大限度地对流数据进行压缩，是流媒体技术研究的一项重要内容。下面介绍一下几种主流的音视频数据压缩格式。</p>\n<h4 id=\"1．AVI格式\"><a href=\"#1．AVI格式\" class=\"headerlink\" title=\"1．AVI格式\"></a>1．AVI格式</h4><p>AVI（Audio Video Interleave，音频视频交错）是符合RIFF文件规范的数字音频与视频文件格式，由Microsoft公司开发，目前得到了广泛的支持。AVI格式支持256色和RLE压缩，并允许视频和音频交错在一起同步播放。但AVI文件并未限定压缩算法，只是提供了作为控制界面的标准，用不同压缩算法生成的AVI文件，必须要使用相同的解压缩算法才能解压播放。AVI文件主要应用在多媒体光盘上，用来保存电影、电视等各种影像信息。</p>\n<h4 id=\"2．MPEG格式\"><a href=\"#2．MPEG格式\" class=\"headerlink\" title=\"2．MPEG格式\"></a>2．MPEG格式</h4><p>MPEG（Moving Picture Experts Group，动态图像专家组）是运动图像压缩算法的国际标准，已被几乎所有的计算机平台共同支持，它采用有损压缩算法减少运动图像中的冗余信息，同时保证每秒30帧的图像刷新率。MPEG标准包括视频压缩、音频压缩和音视频同步3个部分，MPEG音频最典型的应用就是MP3音频文件，广泛使用的消费类视频产品如VCD、DVD其压缩算法采用的也是MPEG标准。</p>\n<p>MPEG压缩算法是针对运动图像而设计的，其基本思路是把视频图像按时间分段，然后采集并保存每一段的第一帧数据，其余各帧只存储相对第一帧发生变化的部分，从而达到了数据压缩的目的。MPEG采用了两个基本的压缩技术：运动补偿技术（预测编码和插补码）实现了时间上的压缩，变换域（离散余弦变换DCT）技术实现了空间上的压缩。MPEG在保证图像和声音质量的前提下，压缩效率非常高，平均压缩比为50∶1，最高可达200∶1。</p>\n<h4 id=\"3．RealVideo格式\"><a href=\"#3．RealVideo格式\" class=\"headerlink\" title=\"3．RealVideo格式\"></a>3．RealVideo格式</h4><p>RealVideo格式是由Real Networks公司开发的一种流式视频文件格式，包含在Real Media音频视频压缩规范中，其设计目标是在低速率的广域网上实时传输视频影像。RealVideo可以根据网络的传输速度来决定视频数据的压缩比率，从而提高适应能力，充分利用带宽。本章后面介绍的Real Server软件就是由Real Networks公司提供的，使用的就是Real Video格式的视频文件。</p>\n<p>RealVideo格式文件的扩展名有3种，RA是音频文件、RM和RMVB是视频文件。RMVB格式文件具有可变比特率的特性，它在处理较复杂的动态影像时使用较高的采样率，而在处理一般静止画面时则灵活地转换至较低的采样率，从而在不增加文件大小的前提下提高了图像质量。</p>\n<h4 id=\"4．QuickTime格式\"><a href=\"#4．QuickTime格式\" class=\"headerlink\" title=\"4．QuickTime格式\"></a>4．QuickTime格式</h4><p>QuickTime是由Apple公司开发的一种音视频数据压缩格式，得到了Mac OS、Microsoft Windows等主流操作系统平台的支持。QuickTime文件格式提供了150多种视频效果，支持25位彩色，支持RLE、JPEG等领先的集成压缩技术。此外，QuickTime还强化了对Internet应用的支持，并采用一种虚拟现实技术，使用户可以通过鼠标或键盘的交互式控制，观察某一地点周围360度的景像，或者从空间的任何角度观察某一物体。QuickTime以其领先的多媒体技术和跨平台特性、较小的存储空间要求、技术细节的独立性以及系统的高度开放性，得到业界的广泛认可。QuickTime格式文件的扩展是MOV或QT。</p>\n<h4 id=\"5．ASF和WMV格式\"><a href=\"#5．ASF和WMV格式\" class=\"headerlink\" title=\"5．ASF和WMV格式\"></a>5．ASF和WMV格式</h4><p>ASF（Advanced Streaming Format，高级流格式）和WMV是由Microsoft公司推出的一种在Internet上实时传播多媒体数据的技术标准，提供了本地或网络回放、可扩充的媒体类型、部件下载以及可扩展性等功能。ASF的应用平台是Net Show服务器和Net Show播放器。</p>\n<p>WMV也是Microsoft公司推出的一种流媒体格式，它是以ASF为基础，升级扩展后得到的。在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。WMV文件一般同时包含视频和音频部分，视频部分使用Windows Media Video编码，而音频部分使用Windows Media Audio编码。音频文件可以独立存在，其扩展名是WMA。</p>"},{"title":"2017年死磕几件事","date":"2017-01-06T11:12:08.000Z","_content":"- 每周跑步三次，更新三次技术博客(英文)\n- 每天6点半起床，10点入睡\n- python完整的大数据处理系统和爬虫以及人工智能分析，展示系统\n- swift做一个完整项目\n","source":"_posts/2017/2017年死磕几件事.md","raw":"---\ntitle: 2017年死磕几件事\ndate: 2017-01-06 19:12:08\ntags:\n---\n- 每周跑步三次，更新三次技术博客(英文)\n- 每天6点半起床，10点入睡\n- python完整的大数据处理系统和爬虫以及人工智能分析，展示系统\n- swift做一个完整项目\n","slug":"2017/2017年死磕几件事","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmx0038sauayf8wlvoa","content":"<ul>\n<li>每周跑步三次，更新三次技术博客(英文)</li>\n<li>每天6点半起床，10点入睡</li>\n<li>python完整的大数据处理系统和爬虫以及人工智能分析，展示系统</li>\n<li>swift做一个完整项目</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>每周跑步三次，更新三次技术博客(英文)</li>\n<li>每天6点半起床，10点入睡</li>\n<li>python完整的大数据处理系统和爬虫以及人工智能分析，展示系统</li>\n<li>swift做一个完整项目</li>\n</ul>\n"},{"title":"Andorid自动打包gradle安装笔记","date":"2016-12-16T00:41:48.000Z","_content":"\n- 安装andorid studio\n- copy一份sdk过来\n- 设置andorid studio的sdk路径\n<!--more-->\n- 安装sdkman\n  - 在控制台或者item2中输入\n    ```\n    curl -s https://get.sdkman.io | bash\n    source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n    ```\n\n    检验sdkman是否安装成功\n    ```\n    sdk version\n    ```\n- 安装andorid studio中认可的gradle版本\n```\nsdk install gradle 2.8\n```\n- 升级jdk到andorid studio认可的版本比如说1.7\n- 到工程根目录，执行gradle build就可以了'gradle assembleDebug'\n- 打包出来的文件在outputs中\n\n","source":"_posts/2017/Andorid自动打包gradle安装笔记.md","raw":"---\ntitle: Andorid自动打包gradle安装笔记\ndate: 2016-12-16 08:41:48\ntags:\n- 自动化\n---\n\n- 安装andorid studio\n- copy一份sdk过来\n- 设置andorid studio的sdk路径\n<!--more-->\n- 安装sdkman\n  - 在控制台或者item2中输入\n    ```\n    curl -s https://get.sdkman.io | bash\n    source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n    ```\n\n    检验sdkman是否安装成功\n    ```\n    sdk version\n    ```\n- 安装andorid studio中认可的gradle版本\n```\nsdk install gradle 2.8\n```\n- 升级jdk到andorid studio认可的版本比如说1.7\n- 到工程根目录，执行gradle build就可以了'gradle assembleDebug'\n- 打包出来的文件在outputs中\n\n","slug":"2017/Andorid自动打包gradle安装笔记","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pmz003bsaua2afv7qli","content":"<ul>\n<li>安装andorid studio</li>\n<li>copy一份sdk过来</li>\n<li>设置andorid studio的sdk路径<a id=\"more\"></a></li>\n<li><p>安装sdkman</p>\n<ul>\n<li><p>在控制台或者item2中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -s https://get.sdkman.io | bash</div><div class=\"line\">source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</div></pre></td></tr></table></figure>\n<p>检验sdkman是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sdk version</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>安装andorid studio中认可的gradle版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sdk install gradle 2.8</div></pre></td></tr></table></figure>\n</li>\n<li><p>升级jdk到andorid studio认可的版本比如说1.7</p>\n</li>\n<li>到工程根目录，执行gradle build就可以了’gradle assembleDebug’</li>\n<li>打包出来的文件在outputs中</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li>安装andorid studio</li>\n<li>copy一份sdk过来</li>\n<li>设置andorid studio的sdk路径","more":"</li>\n<li><p>安装sdkman</p>\n<ul>\n<li><p>在控制台或者item2中输入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -s https://get.sdkman.io | bash</div><div class=\"line\">source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</div></pre></td></tr></table></figure>\n<p>检验sdkman是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sdk version</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>安装andorid studio中认可的gradle版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sdk install gradle 2.8</div></pre></td></tr></table></figure>\n</li>\n<li><p>升级jdk到andorid studio认可的版本比如说1.7</p>\n</li>\n<li>到工程根目录，执行gradle build就可以了’gradle assembleDebug’</li>\n<li>打包出来的文件在outputs中</li>\n</ul>"},{"title":"Lunix云服务器折腾小记","date":"2017-01-17T09:33:07.000Z","_content":"### Mac登录云服务器\n```\nssh root@127.987.883.888\n```\n这样再输入密码我们就进入了我们的服务器的命令行界面，这里执行的命令行与本机是一致的，不过你看到的是你服务器的一些情况\n\n### 文件的上传和下载\n- 上传\n```\nscp ceshi.txt root@127.987.883.888:~\n```\n这样文件会被传输到你的用户名下的文件夹下\n- 下载\n```\nscp root@127.987.883.888:~／ceshi.txt ceshi.txt\n```\n\n### apache安装\n-1. 运行 Terminal，输入命令：\n```\nssh username@ip，然后输入密码。\n```\n2. 安装 Apache 软件：\n```\nyum install httpd\n```\n3. 设置 Apache 在服务器启动时运行：\n```\nchkconfig --levels 235 httpd on\n```\n4. 在 Apache 配置文件中配置域名：\n```\nvi /etc/httpd/conf/httpd.conf，找到 ServerName ，添加“域名:80”，保存并退出。\n```\n5. 重启 Apache：\n```\nservice httpd restart\n```\n6. 浏览器中访问第4步配置的域名，如果出现“Apache 2 Test Page powered by CentOS”的页面，说明配置成功。\n\n### django安装\n- 安装工具\n```\nyum install setuptools\n```\n- pip安装\n```\npip install Django\n```\n\n### 重新格式化云服务器之后登录不上怎么办\n将本地的./ssh文件夹中的know_hosts里边对应的ip的记录删除掉，重新生成\n\n### lunix中的复制文件以及文件夹\n```\ncp -r xxx xxx\n```\n-r代表我们复制其中的所有文件以及文件夹\n\n### lunix删除文件\n```\nrm -rf xxx\n```\n\n### 在python 的django服务不可用\n查看\n\n### lunix升级python\n```\n首先下载源tar包\n\n　　可利用linux自带下载工具wget下载，如下所示：\n\n1# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz\n　　下载完成后到下载目录下，解压\n\n1\ttar -zxvf Python-2.7.3.tgz\n2\t\n　　进入解压缩后的文件夹\n\n1\tcd Python-2.7.3\n　　在编译前先在/usr/local建一个文件夹python27（作为python的安装路径，以免覆盖老的版本）\n\n1\tmkdir /usr/local/python27\n　　在解压缩后的目录下编译安装\n\n1\t./configure --prefix=/usr/local/python27\n2\tmake\n3\tmake install\n　　此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字\n\n1\tmv /usr/bin/python /usr/bin/python_old\n　　再建立新版本python的链接\n\n1\nln -s /usr/local/python27/bin/python2.7 \n　　这个时候输入\n\n1\tpython\n　　就会显示出python的新版本信息\n\n1\tPython 2.7.3 (default, Sep 29 2013, 11:05:02)\n2\t[GCC 4.1.2 20080704 (Red Hat 4.1.2-54)] on linux2\n3\tType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n4\t>>>\n修改YUM   /usr/bin/yum\n\n文件让yum能正常的工作：改成上面我们修改的PYTHON 2.6.6的名字\n```\n\n>lunix解压命令\n```\n1、*.tar 用 tar -xvf 解压\n\n2、*.gz 用 gzip -d或者gunzip 解压\n\n3、*.tar.gz和*.tgz 用 tar -xzf 解压\n\n4、*.bz2 用 bzip2 -d或者用bunzip2 解压\n\n5、*.tar.bz2用tar -xjf 解压\n\n6、*.Z 用 uncompress 解压\n\n7、*.tar.Z 用tar -xZf 解压\n\n8、*.rar 用 unrar e解压\n\n9、*.zip 用 unzip 解压\n```\n\n### 安装apex\n```\n\nlunix 安装apxs扩展\n\n好像命令行安装的，自带了这个模块，手动编译的apache，同样需要手动编译这个模块，编译的时候可能会遇到这个错误：mod_wsgi.c Python.h：没有那个文件或目录,，解决方法：yum install python-devel，安装apache的apxs扩展。\npython 2.7 No module named ‘zlib'\n\nyum -y install zlib-devel openssl-devel\ncd /wls/softwares/Python-2.7.10\n./configure --prefix=/usr/local/python27 make make install\n\npip是python的包管理工具，我们通过pip来安装python所需要的一些模块，当然如果你有多版本存在，可能需要将pip这个模块copy到对应的python版本下边\n\n在安装   Linux 系统是顺便把apache 服务装好了 ，这时这是装了一个服务不能进行二次开发，\n\n所以很多的开发工具和文件在apache下找不到，比如模块编译工具apxs ，这时就要求安装 开发包，\n\n\n命令 rpm -ql httpd-devel   ，然后会在  usr/local/下面多出个 apache2文件夹，里面有不少开发需要的文件。\n如果提示没有apxs，那就先yum install httpd-devel\n```\n\n### lunix 安装git\n```\n1.2 CentOS6.6下\n\n在CentOS5的时代，由于yum源中没有git，所以需要预先安装一系列的依赖包。但在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装。\n\n$ sudo yum install git\n但是yum源中安装的git版本是1.7.1，太老了，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法。而是下载git源码，编译安装。\n\n编译安装的步骤是【4】：\n\n（1）首先先更新系统\n\nsudo yum update\n（2）安装依赖的包\n\nsudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker\n（3）下载git源码并解压缩\n\n$ wget https://github.com/git/git/archive/v2.3.0.zip\n$ unzip v2.3.0.zip\n$ cd git-2.3.0\n（4）编译安装\n\n将其安装在“/usr/local/git”目录下。\n\nmake prefix=/usr/local/git all\nsudo make prefix=/usr/local/git install\n（5）此时你如果使用git --version 查看git版本的话，发现git仍然是1.7.1版本。这是因为它默认使用了\"/usr/bin\"下的git。\n\n你可以用下面的命令查看git所在的路径：\n\n$ whereis git\ngit: /usr/bin/git /usr/local/git /usr/share/man/man1/git.1.gz\n（6）我们要把编译安装的git路径放到环境变量里，让它替换\"/usr/bin\"下的git。为此我们可以修改“/etc/profile”文件（或者/etc/bashrc文件）。\n\nsudo vim /etc/profile\n然后在文件的最后一行，添加下面的内容，然后保存退出。\n\nexport PATH=/usr/local/git/bin:$PATH\n（7）使用source命令应用修改。\n\nsource /etc/profile\n\n（8）然后再次使用git --version 查看git版本，发现输出2.3.0，表明安装成功。\n```\n\n### django错误\n```\nDisallowedHost at /\n\nInvalid HTTP_HOST header: '10.211.55.6:8000'. You may need to add u'10.211.55.6' to ALLOWED_HOSTS.\nRequest Method:\tGET\nRequest URL:\thttp://10.211.55.6:8000/\nDjango Version:\t1.10.4\nException Type:\tDisallowedHost\nException Value:\t\nInvalid HTTP_HOST header: '10.211.55.6:8000'. You may need to add u'10.211.55.6' to ALLOWED_HOSTS.\nException Location:\t/usr/lib/python2.7/site-packages/django/http/request.py in get_host, line 113\nPython Executable:\t/usr/bin/python\nPython Version:\n\n1，以上时我访问请求的时候出现的，原因在于Django框架中的创建的一个项目的时候，\n\n2，跑下这个命令：Python manage.py runserver 10.211.55.5:8000\n\n3，然后在我本机的浏览器中写入上述IP和端口请求过去：http://10.211.55.6:8000\n\n4，于是就出现了最上面的那个问题；\n\n5，于是就去django-admin.py startproject project-name创建的项目中去修改 setting.py 文件：\n\nALLOWED_HOSTS = ['*']  ＃在这里请求的host添加了＊\n\n\n6，于是就成功的访问到了Django的项目了；\n```\n","source":"_posts/2017/Lunix云服务器折腾小记.md","raw":"---\ntitle: Lunix云服务器折腾小记\ndate: 2017-01-17 17:33:07\ntags:\n- Lunix\n---\n### Mac登录云服务器\n```\nssh root@127.987.883.888\n```\n这样再输入密码我们就进入了我们的服务器的命令行界面，这里执行的命令行与本机是一致的，不过你看到的是你服务器的一些情况\n\n### 文件的上传和下载\n- 上传\n```\nscp ceshi.txt root@127.987.883.888:~\n```\n这样文件会被传输到你的用户名下的文件夹下\n- 下载\n```\nscp root@127.987.883.888:~／ceshi.txt ceshi.txt\n```\n\n### apache安装\n-1. 运行 Terminal，输入命令：\n```\nssh username@ip，然后输入密码。\n```\n2. 安装 Apache 软件：\n```\nyum install httpd\n```\n3. 设置 Apache 在服务器启动时运行：\n```\nchkconfig --levels 235 httpd on\n```\n4. 在 Apache 配置文件中配置域名：\n```\nvi /etc/httpd/conf/httpd.conf，找到 ServerName ，添加“域名:80”，保存并退出。\n```\n5. 重启 Apache：\n```\nservice httpd restart\n```\n6. 浏览器中访问第4步配置的域名，如果出现“Apache 2 Test Page powered by CentOS”的页面，说明配置成功。\n\n### django安装\n- 安装工具\n```\nyum install setuptools\n```\n- pip安装\n```\npip install Django\n```\n\n### 重新格式化云服务器之后登录不上怎么办\n将本地的./ssh文件夹中的know_hosts里边对应的ip的记录删除掉，重新生成\n\n### lunix中的复制文件以及文件夹\n```\ncp -r xxx xxx\n```\n-r代表我们复制其中的所有文件以及文件夹\n\n### lunix删除文件\n```\nrm -rf xxx\n```\n\n### 在python 的django服务不可用\n查看\n\n### lunix升级python\n```\n首先下载源tar包\n\n　　可利用linux自带下载工具wget下载，如下所示：\n\n1# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz\n　　下载完成后到下载目录下，解压\n\n1\ttar -zxvf Python-2.7.3.tgz\n2\t\n　　进入解压缩后的文件夹\n\n1\tcd Python-2.7.3\n　　在编译前先在/usr/local建一个文件夹python27（作为python的安装路径，以免覆盖老的版本）\n\n1\tmkdir /usr/local/python27\n　　在解压缩后的目录下编译安装\n\n1\t./configure --prefix=/usr/local/python27\n2\tmake\n3\tmake install\n　　此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字\n\n1\tmv /usr/bin/python /usr/bin/python_old\n　　再建立新版本python的链接\n\n1\nln -s /usr/local/python27/bin/python2.7 \n　　这个时候输入\n\n1\tpython\n　　就会显示出python的新版本信息\n\n1\tPython 2.7.3 (default, Sep 29 2013, 11:05:02)\n2\t[GCC 4.1.2 20080704 (Red Hat 4.1.2-54)] on linux2\n3\tType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n4\t>>>\n修改YUM   /usr/bin/yum\n\n文件让yum能正常的工作：改成上面我们修改的PYTHON 2.6.6的名字\n```\n\n>lunix解压命令\n```\n1、*.tar 用 tar -xvf 解压\n\n2、*.gz 用 gzip -d或者gunzip 解压\n\n3、*.tar.gz和*.tgz 用 tar -xzf 解压\n\n4、*.bz2 用 bzip2 -d或者用bunzip2 解压\n\n5、*.tar.bz2用tar -xjf 解压\n\n6、*.Z 用 uncompress 解压\n\n7、*.tar.Z 用tar -xZf 解压\n\n8、*.rar 用 unrar e解压\n\n9、*.zip 用 unzip 解压\n```\n\n### 安装apex\n```\n\nlunix 安装apxs扩展\n\n好像命令行安装的，自带了这个模块，手动编译的apache，同样需要手动编译这个模块，编译的时候可能会遇到这个错误：mod_wsgi.c Python.h：没有那个文件或目录,，解决方法：yum install python-devel，安装apache的apxs扩展。\npython 2.7 No module named ‘zlib'\n\nyum -y install zlib-devel openssl-devel\ncd /wls/softwares/Python-2.7.10\n./configure --prefix=/usr/local/python27 make make install\n\npip是python的包管理工具，我们通过pip来安装python所需要的一些模块，当然如果你有多版本存在，可能需要将pip这个模块copy到对应的python版本下边\n\n在安装   Linux 系统是顺便把apache 服务装好了 ，这时这是装了一个服务不能进行二次开发，\n\n所以很多的开发工具和文件在apache下找不到，比如模块编译工具apxs ，这时就要求安装 开发包，\n\n\n命令 rpm -ql httpd-devel   ，然后会在  usr/local/下面多出个 apache2文件夹，里面有不少开发需要的文件。\n如果提示没有apxs，那就先yum install httpd-devel\n```\n\n### lunix 安装git\n```\n1.2 CentOS6.6下\n\n在CentOS5的时代，由于yum源中没有git，所以需要预先安装一系列的依赖包。但在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装。\n\n$ sudo yum install git\n但是yum源中安装的git版本是1.7.1，太老了，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法。而是下载git源码，编译安装。\n\n编译安装的步骤是【4】：\n\n（1）首先先更新系统\n\nsudo yum update\n（2）安装依赖的包\n\nsudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker\n（3）下载git源码并解压缩\n\n$ wget https://github.com/git/git/archive/v2.3.0.zip\n$ unzip v2.3.0.zip\n$ cd git-2.3.0\n（4）编译安装\n\n将其安装在“/usr/local/git”目录下。\n\nmake prefix=/usr/local/git all\nsudo make prefix=/usr/local/git install\n（5）此时你如果使用git --version 查看git版本的话，发现git仍然是1.7.1版本。这是因为它默认使用了\"/usr/bin\"下的git。\n\n你可以用下面的命令查看git所在的路径：\n\n$ whereis git\ngit: /usr/bin/git /usr/local/git /usr/share/man/man1/git.1.gz\n（6）我们要把编译安装的git路径放到环境变量里，让它替换\"/usr/bin\"下的git。为此我们可以修改“/etc/profile”文件（或者/etc/bashrc文件）。\n\nsudo vim /etc/profile\n然后在文件的最后一行，添加下面的内容，然后保存退出。\n\nexport PATH=/usr/local/git/bin:$PATH\n（7）使用source命令应用修改。\n\nsource /etc/profile\n\n（8）然后再次使用git --version 查看git版本，发现输出2.3.0，表明安装成功。\n```\n\n### django错误\n```\nDisallowedHost at /\n\nInvalid HTTP_HOST header: '10.211.55.6:8000'. You may need to add u'10.211.55.6' to ALLOWED_HOSTS.\nRequest Method:\tGET\nRequest URL:\thttp://10.211.55.6:8000/\nDjango Version:\t1.10.4\nException Type:\tDisallowedHost\nException Value:\t\nInvalid HTTP_HOST header: '10.211.55.6:8000'. You may need to add u'10.211.55.6' to ALLOWED_HOSTS.\nException Location:\t/usr/lib/python2.7/site-packages/django/http/request.py in get_host, line 113\nPython Executable:\t/usr/bin/python\nPython Version:\n\n1，以上时我访问请求的时候出现的，原因在于Django框架中的创建的一个项目的时候，\n\n2，跑下这个命令：Python manage.py runserver 10.211.55.5:8000\n\n3，然后在我本机的浏览器中写入上述IP和端口请求过去：http://10.211.55.6:8000\n\n4，于是就出现了最上面的那个问题；\n\n5，于是就去django-admin.py startproject project-name创建的项目中去修改 setting.py 文件：\n\nALLOWED_HOSTS = ['*']  ＃在这里请求的host添加了＊\n\n\n6，于是就成功的访问到了Django的项目了；\n```\n","slug":"2017/Lunix云服务器折腾小记","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pn0003dsaua3uvnbqcx","content":"<h3 id=\"Mac登录云服务器\"><a href=\"#Mac登录云服务器\" class=\"headerlink\" title=\"Mac登录云服务器\"></a>Mac登录云服务器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh root@127.987.883.888</div></pre></td></tr></table></figure>\n<p>这样再输入密码我们就进入了我们的服务器的命令行界面，这里执行的命令行与本机是一致的，不过你看到的是你服务器的一些情况</p>\n<h3 id=\"文件的上传和下载\"><a href=\"#文件的上传和下载\" class=\"headerlink\" title=\"文件的上传和下载\"></a>文件的上传和下载</h3><ul>\n<li>上传<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp ceshi.txt root@127.987.883.888:~</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样文件会被传输到你的用户名下的文件夹下</p>\n<ul>\n<li>下载<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp root@127.987.883.888:~／ceshi.txt ceshi.txt</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"apache安装\"><a href=\"#apache安装\" class=\"headerlink\" title=\"apache安装\"></a>apache安装</h3><p>-1. 运行 Terminal，输入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh username@ip，然后输入密码。</div></pre></td></tr></table></figure></p>\n<ol>\n<li><p>安装 Apache 软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install httpd</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置 Apache 在服务器启动时运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --levels 235 httpd on</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Apache 配置文件中配置域名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/httpd/conf/httpd.conf，找到 ServerName ，添加“域名:80”，保存并退出。</div></pre></td></tr></table></figure>\n</li>\n<li><p>重启 Apache：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service httpd restart</div></pre></td></tr></table></figure>\n</li>\n<li><p>浏览器中访问第4步配置的域名，如果出现“Apache 2 Test Page powered by CentOS”的页面，说明配置成功。</p>\n</li>\n</ol>\n<h3 id=\"django安装\"><a href=\"#django安装\" class=\"headerlink\" title=\"django安装\"></a>django安装</h3><ul>\n<li><p>安装工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install setuptools</div></pre></td></tr></table></figure>\n</li>\n<li><p>pip安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install Django</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"重新格式化云服务器之后登录不上怎么办\"><a href=\"#重新格式化云服务器之后登录不上怎么办\" class=\"headerlink\" title=\"重新格式化云服务器之后登录不上怎么办\"></a>重新格式化云服务器之后登录不上怎么办</h3><p>将本地的./ssh文件夹中的know_hosts里边对应的ip的记录删除掉，重新生成</p>\n<h3 id=\"lunix中的复制文件以及文件夹\"><a href=\"#lunix中的复制文件以及文件夹\" class=\"headerlink\" title=\"lunix中的复制文件以及文件夹\"></a>lunix中的复制文件以及文件夹</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -r xxx xxx</div></pre></td></tr></table></figure>\n<p>-r代表我们复制其中的所有文件以及文件夹</p>\n<h3 id=\"lunix删除文件\"><a href=\"#lunix删除文件\" class=\"headerlink\" title=\"lunix删除文件\"></a>lunix删除文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf xxx</div></pre></td></tr></table></figure>\n<h3 id=\"在python-的django服务不可用\"><a href=\"#在python-的django服务不可用\" class=\"headerlink\" title=\"在python 的django服务不可用\"></a>在python 的django服务不可用</h3><p>查看</p>\n<h3 id=\"lunix升级python\"><a href=\"#lunix升级python\" class=\"headerlink\" title=\"lunix升级python\"></a>lunix升级python</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">首先下载源tar包</div><div class=\"line\"></div><div class=\"line\">　　可利用linux自带下载工具wget下载，如下所示：</div><div class=\"line\"></div><div class=\"line\">1# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz</div><div class=\"line\">　　下载完成后到下载目录下，解压</div><div class=\"line\"></div><div class=\"line\">1\ttar -zxvf Python-2.7.3.tgz</div><div class=\"line\">2\t</div><div class=\"line\">　　进入解压缩后的文件夹</div><div class=\"line\"></div><div class=\"line\">1\tcd Python-2.7.3</div><div class=\"line\">　　在编译前先在/usr/local建一个文件夹python27（作为python的安装路径，以免覆盖老的版本）</div><div class=\"line\"></div><div class=\"line\">1\tmkdir /usr/local/python27</div><div class=\"line\">　　在解压缩后的目录下编译安装</div><div class=\"line\"></div><div class=\"line\">1\t./configure --prefix=/usr/local/python27</div><div class=\"line\">2\tmake</div><div class=\"line\">3\tmake install</div><div class=\"line\">　　此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字</div><div class=\"line\"></div><div class=\"line\">1\tmv /usr/bin/python /usr/bin/python_old</div><div class=\"line\">　　再建立新版本python的链接</div><div class=\"line\"></div><div class=\"line\">1</div><div class=\"line\">ln -s /usr/local/python27/bin/python2.7 </div><div class=\"line\">　　这个时候输入</div><div class=\"line\"></div><div class=\"line\">1\tpython</div><div class=\"line\">　　就会显示出python的新版本信息</div><div class=\"line\"></div><div class=\"line\">1\tPython 2.7.3 (default, Sep 29 2013, 11:05:02)</div><div class=\"line\">2\t[GCC 4.1.2 20080704 (Red Hat 4.1.2-54)] on linux2</div><div class=\"line\">3\tType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class=\"line\">4\t&gt;&gt;&gt;</div><div class=\"line\">修改YUM   /usr/bin/yum</div><div class=\"line\"></div><div class=\"line\">文件让yum能正常的工作：改成上面我们修改的PYTHON 2.6.6的名字</div></pre></td></tr></table></figure>\n<blockquote>\n<p>lunix解压命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、*.tar 用 tar -xvf 解压</div><div class=\"line\"></div><div class=\"line\">2、*.gz 用 gzip -d或者gunzip 解压</div><div class=\"line\"></div><div class=\"line\">3、*.tar.gz和*.tgz 用 tar -xzf 解压</div><div class=\"line\"></div><div class=\"line\">4、*.bz2 用 bzip2 -d或者用bunzip2 解压</div><div class=\"line\"></div><div class=\"line\">5、*.tar.bz2用tar -xjf 解压</div><div class=\"line\"></div><div class=\"line\">6、*.Z 用 uncompress 解压</div><div class=\"line\"></div><div class=\"line\">7、*.tar.Z 用tar -xZf 解压</div><div class=\"line\"></div><div class=\"line\">8、*.rar 用 unrar e解压</div><div class=\"line\"></div><div class=\"line\">9、*.zip 用 unzip 解压</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"安装apex\"><a href=\"#安装apex\" class=\"headerlink\" title=\"安装apex\"></a>安装apex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">lunix 安装apxs扩展</div><div class=\"line\"></div><div class=\"line\">好像命令行安装的，自带了这个模块，手动编译的apache，同样需要手动编译这个模块，编译的时候可能会遇到这个错误：mod_wsgi.c Python.h：没有那个文件或目录,，解决方法：yum install python-devel，安装apache的apxs扩展。</div><div class=\"line\">python 2.7 No module named ‘zlib&apos;</div><div class=\"line\"></div><div class=\"line\">yum -y install zlib-devel openssl-devel</div><div class=\"line\">cd /wls/softwares/Python-2.7.10</div><div class=\"line\">./configure --prefix=/usr/local/python27 make make install</div><div class=\"line\"></div><div class=\"line\">pip是python的包管理工具，我们通过pip来安装python所需要的一些模块，当然如果你有多版本存在，可能需要将pip这个模块copy到对应的python版本下边</div><div class=\"line\"></div><div class=\"line\">在安装   Linux 系统是顺便把apache 服务装好了 ，这时这是装了一个服务不能进行二次开发，</div><div class=\"line\"></div><div class=\"line\">所以很多的开发工具和文件在apache下找不到，比如模块编译工具apxs ，这时就要求安装 开发包，</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">命令 rpm -ql httpd-devel   ，然后会在  usr/local/下面多出个 apache2文件夹，里面有不少开发需要的文件。</div><div class=\"line\">如果提示没有apxs，那就先yum install httpd-devel</div></pre></td></tr></table></figure>\n<h3 id=\"lunix-安装git\"><a href=\"#lunix-安装git\" class=\"headerlink\" title=\"lunix 安装git\"></a>lunix 安装git</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.2 CentOS6.6下</div><div class=\"line\"></div><div class=\"line\">在CentOS5的时代，由于yum源中没有git，所以需要预先安装一系列的依赖包。但在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装。</div><div class=\"line\"></div><div class=\"line\">$ sudo yum install git</div><div class=\"line\">但是yum源中安装的git版本是1.7.1，太老了，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法。而是下载git源码，编译安装。</div><div class=\"line\"></div><div class=\"line\">编译安装的步骤是【4】：</div><div class=\"line\"></div><div class=\"line\">（1）首先先更新系统</div><div class=\"line\"></div><div class=\"line\">sudo yum update</div><div class=\"line\">（2）安装依赖的包</div><div class=\"line\"></div><div class=\"line\">sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</div><div class=\"line\">（3）下载git源码并解压缩</div><div class=\"line\"></div><div class=\"line\">$ wget https://github.com/git/git/archive/v2.3.0.zip</div><div class=\"line\">$ unzip v2.3.0.zip</div><div class=\"line\">$ cd git-2.3.0</div><div class=\"line\">（4）编译安装</div><div class=\"line\"></div><div class=\"line\">将其安装在“/usr/local/git”目录下。</div><div class=\"line\"></div><div class=\"line\">make prefix=/usr/local/git all</div><div class=\"line\">sudo make prefix=/usr/local/git install</div><div class=\"line\">（5）此时你如果使用git --version 查看git版本的话，发现git仍然是1.7.1版本。这是因为它默认使用了&quot;/usr/bin&quot;下的git。</div><div class=\"line\"></div><div class=\"line\">你可以用下面的命令查看git所在的路径：</div><div class=\"line\"></div><div class=\"line\">$ whereis git</div><div class=\"line\">git: /usr/bin/git /usr/local/git /usr/share/man/man1/git.1.gz</div><div class=\"line\">（6）我们要把编译安装的git路径放到环境变量里，让它替换&quot;/usr/bin&quot;下的git。为此我们可以修改“/etc/profile”文件（或者/etc/bashrc文件）。</div><div class=\"line\"></div><div class=\"line\">sudo vim /etc/profile</div><div class=\"line\">然后在文件的最后一行，添加下面的内容，然后保存退出。</div><div class=\"line\"></div><div class=\"line\">export PATH=/usr/local/git/bin:$PATH</div><div class=\"line\">（7）使用source命令应用修改。</div><div class=\"line\"></div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\">（8）然后再次使用git --version 查看git版本，发现输出2.3.0，表明安装成功。</div></pre></td></tr></table></figure>\n<h3 id=\"django错误\"><a href=\"#django错误\" class=\"headerlink\" title=\"django错误\"></a>django错误</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">DisallowedHost at /</div><div class=\"line\"></div><div class=\"line\">Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.</div><div class=\"line\">Request Method:\tGET</div><div class=\"line\">Request URL:\thttp://10.211.55.6:8000/</div><div class=\"line\">Django Version:\t1.10.4</div><div class=\"line\">Exception Type:\tDisallowedHost</div><div class=\"line\">Exception Value:\t</div><div class=\"line\">Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.</div><div class=\"line\">Exception Location:\t/usr/lib/python2.7/site-packages/django/http/request.py in get_host, line 113</div><div class=\"line\">Python Executable:\t/usr/bin/python</div><div class=\"line\">Python Version:</div><div class=\"line\"></div><div class=\"line\">1，以上时我访问请求的时候出现的，原因在于Django框架中的创建的一个项目的时候，</div><div class=\"line\"></div><div class=\"line\">2，跑下这个命令：Python manage.py runserver 10.211.55.5:8000</div><div class=\"line\"></div><div class=\"line\">3，然后在我本机的浏览器中写入上述IP和端口请求过去：http://10.211.55.6:8000</div><div class=\"line\"></div><div class=\"line\">4，于是就出现了最上面的那个问题；</div><div class=\"line\"></div><div class=\"line\">5，于是就去django-admin.py startproject project-name创建的项目中去修改 setting.py 文件：</div><div class=\"line\"></div><div class=\"line\">ALLOWED_HOSTS = [&apos;*&apos;]  ＃在这里请求的host添加了＊</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">6，于是就成功的访问到了Django的项目了；</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Mac登录云服务器\"><a href=\"#Mac登录云服务器\" class=\"headerlink\" title=\"Mac登录云服务器\"></a>Mac登录云服务器</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh root@127.987.883.888</div></pre></td></tr></table></figure>\n<p>这样再输入密码我们就进入了我们的服务器的命令行界面，这里执行的命令行与本机是一致的，不过你看到的是你服务器的一些情况</p>\n<h3 id=\"文件的上传和下载\"><a href=\"#文件的上传和下载\" class=\"headerlink\" title=\"文件的上传和下载\"></a>文件的上传和下载</h3><ul>\n<li>上传<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp ceshi.txt root@127.987.883.888:~</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样文件会被传输到你的用户名下的文件夹下</p>\n<ul>\n<li>下载<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp root@127.987.883.888:~／ceshi.txt ceshi.txt</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"apache安装\"><a href=\"#apache安装\" class=\"headerlink\" title=\"apache安装\"></a>apache安装</h3><p>-1. 运行 Terminal，输入命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh username@ip，然后输入密码。</div></pre></td></tr></table></figure></p>\n<ol>\n<li><p>安装 Apache 软件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install httpd</div></pre></td></tr></table></figure>\n</li>\n<li><p>设置 Apache 在服务器启动时运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chkconfig --levels 235 httpd on</div></pre></td></tr></table></figure>\n</li>\n<li><p>在 Apache 配置文件中配置域名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /etc/httpd/conf/httpd.conf，找到 ServerName ，添加“域名:80”，保存并退出。</div></pre></td></tr></table></figure>\n</li>\n<li><p>重启 Apache：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">service httpd restart</div></pre></td></tr></table></figure>\n</li>\n<li><p>浏览器中访问第4步配置的域名，如果出现“Apache 2 Test Page powered by CentOS”的页面，说明配置成功。</p>\n</li>\n</ol>\n<h3 id=\"django安装\"><a href=\"#django安装\" class=\"headerlink\" title=\"django安装\"></a>django安装</h3><ul>\n<li><p>安装工具</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install setuptools</div></pre></td></tr></table></figure>\n</li>\n<li><p>pip安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pip install Django</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"重新格式化云服务器之后登录不上怎么办\"><a href=\"#重新格式化云服务器之后登录不上怎么办\" class=\"headerlink\" title=\"重新格式化云服务器之后登录不上怎么办\"></a>重新格式化云服务器之后登录不上怎么办</h3><p>将本地的./ssh文件夹中的know_hosts里边对应的ip的记录删除掉，重新生成</p>\n<h3 id=\"lunix中的复制文件以及文件夹\"><a href=\"#lunix中的复制文件以及文件夹\" class=\"headerlink\" title=\"lunix中的复制文件以及文件夹\"></a>lunix中的复制文件以及文件夹</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp -r xxx xxx</div></pre></td></tr></table></figure>\n<p>-r代表我们复制其中的所有文件以及文件夹</p>\n<h3 id=\"lunix删除文件\"><a href=\"#lunix删除文件\" class=\"headerlink\" title=\"lunix删除文件\"></a>lunix删除文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf xxx</div></pre></td></tr></table></figure>\n<h3 id=\"在python-的django服务不可用\"><a href=\"#在python-的django服务不可用\" class=\"headerlink\" title=\"在python 的django服务不可用\"></a>在python 的django服务不可用</h3><p>查看</p>\n<h3 id=\"lunix升级python\"><a href=\"#lunix升级python\" class=\"headerlink\" title=\"lunix升级python\"></a>lunix升级python</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">首先下载源tar包</div><div class=\"line\"></div><div class=\"line\">　　可利用linux自带下载工具wget下载，如下所示：</div><div class=\"line\"></div><div class=\"line\">1# wget http://www.python.org/ftp/python/2.7.3/Python-2.7.3.tgz</div><div class=\"line\">　　下载完成后到下载目录下，解压</div><div class=\"line\"></div><div class=\"line\">1\ttar -zxvf Python-2.7.3.tgz</div><div class=\"line\">2\t</div><div class=\"line\">　　进入解压缩后的文件夹</div><div class=\"line\"></div><div class=\"line\">1\tcd Python-2.7.3</div><div class=\"line\">　　在编译前先在/usr/local建一个文件夹python27（作为python的安装路径，以免覆盖老的版本）</div><div class=\"line\"></div><div class=\"line\">1\tmkdir /usr/local/python27</div><div class=\"line\">　　在解压缩后的目录下编译安装</div><div class=\"line\"></div><div class=\"line\">1\t./configure --prefix=/usr/local/python27</div><div class=\"line\">2\tmake</div><div class=\"line\">3\tmake install</div><div class=\"line\">　　此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字</div><div class=\"line\"></div><div class=\"line\">1\tmv /usr/bin/python /usr/bin/python_old</div><div class=\"line\">　　再建立新版本python的链接</div><div class=\"line\"></div><div class=\"line\">1</div><div class=\"line\">ln -s /usr/local/python27/bin/python2.7 </div><div class=\"line\">　　这个时候输入</div><div class=\"line\"></div><div class=\"line\">1\tpython</div><div class=\"line\">　　就会显示出python的新版本信息</div><div class=\"line\"></div><div class=\"line\">1\tPython 2.7.3 (default, Sep 29 2013, 11:05:02)</div><div class=\"line\">2\t[GCC 4.1.2 20080704 (Red Hat 4.1.2-54)] on linux2</div><div class=\"line\">3\tType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class=\"line\">4\t&gt;&gt;&gt;</div><div class=\"line\">修改YUM   /usr/bin/yum</div><div class=\"line\"></div><div class=\"line\">文件让yum能正常的工作：改成上面我们修改的PYTHON 2.6.6的名字</div></pre></td></tr></table></figure>\n<blockquote>\n<p>lunix解压命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">1、*.tar 用 tar -xvf 解压</div><div class=\"line\"></div><div class=\"line\">2、*.gz 用 gzip -d或者gunzip 解压</div><div class=\"line\"></div><div class=\"line\">3、*.tar.gz和*.tgz 用 tar -xzf 解压</div><div class=\"line\"></div><div class=\"line\">4、*.bz2 用 bzip2 -d或者用bunzip2 解压</div><div class=\"line\"></div><div class=\"line\">5、*.tar.bz2用tar -xjf 解压</div><div class=\"line\"></div><div class=\"line\">6、*.Z 用 uncompress 解压</div><div class=\"line\"></div><div class=\"line\">7、*.tar.Z 用tar -xZf 解压</div><div class=\"line\"></div><div class=\"line\">8、*.rar 用 unrar e解压</div><div class=\"line\"></div><div class=\"line\">9、*.zip 用 unzip 解压</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"安装apex\"><a href=\"#安装apex\" class=\"headerlink\" title=\"安装apex\"></a>安装apex</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">lunix 安装apxs扩展</div><div class=\"line\"></div><div class=\"line\">好像命令行安装的，自带了这个模块，手动编译的apache，同样需要手动编译这个模块，编译的时候可能会遇到这个错误：mod_wsgi.c Python.h：没有那个文件或目录,，解决方法：yum install python-devel，安装apache的apxs扩展。</div><div class=\"line\">python 2.7 No module named ‘zlib&apos;</div><div class=\"line\"></div><div class=\"line\">yum -y install zlib-devel openssl-devel</div><div class=\"line\">cd /wls/softwares/Python-2.7.10</div><div class=\"line\">./configure --prefix=/usr/local/python27 make make install</div><div class=\"line\"></div><div class=\"line\">pip是python的包管理工具，我们通过pip来安装python所需要的一些模块，当然如果你有多版本存在，可能需要将pip这个模块copy到对应的python版本下边</div><div class=\"line\"></div><div class=\"line\">在安装   Linux 系统是顺便把apache 服务装好了 ，这时这是装了一个服务不能进行二次开发，</div><div class=\"line\"></div><div class=\"line\">所以很多的开发工具和文件在apache下找不到，比如模块编译工具apxs ，这时就要求安装 开发包，</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">命令 rpm -ql httpd-devel   ，然后会在  usr/local/下面多出个 apache2文件夹，里面有不少开发需要的文件。</div><div class=\"line\">如果提示没有apxs，那就先yum install httpd-devel</div></pre></td></tr></table></figure>\n<h3 id=\"lunix-安装git\"><a href=\"#lunix-安装git\" class=\"headerlink\" title=\"lunix 安装git\"></a>lunix 安装git</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.2 CentOS6.6下</div><div class=\"line\"></div><div class=\"line\">在CentOS5的时代，由于yum源中没有git，所以需要预先安装一系列的依赖包。但在CentOS6的yum源中已经有git的版本了，可以直接使用yum源进行安装。</div><div class=\"line\"></div><div class=\"line\">$ sudo yum install git</div><div class=\"line\">但是yum源中安装的git版本是1.7.1，太老了，Github等需要的Git版本最低都不能低于1.7.2 。所以我们一般不用上面的方法。而是下载git源码，编译安装。</div><div class=\"line\"></div><div class=\"line\">编译安装的步骤是【4】：</div><div class=\"line\"></div><div class=\"line\">（1）首先先更新系统</div><div class=\"line\"></div><div class=\"line\">sudo yum update</div><div class=\"line\">（2）安装依赖的包</div><div class=\"line\"></div><div class=\"line\">sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker</div><div class=\"line\">（3）下载git源码并解压缩</div><div class=\"line\"></div><div class=\"line\">$ wget https://github.com/git/git/archive/v2.3.0.zip</div><div class=\"line\">$ unzip v2.3.0.zip</div><div class=\"line\">$ cd git-2.3.0</div><div class=\"line\">（4）编译安装</div><div class=\"line\"></div><div class=\"line\">将其安装在“/usr/local/git”目录下。</div><div class=\"line\"></div><div class=\"line\">make prefix=/usr/local/git all</div><div class=\"line\">sudo make prefix=/usr/local/git install</div><div class=\"line\">（5）此时你如果使用git --version 查看git版本的话，发现git仍然是1.7.1版本。这是因为它默认使用了&quot;/usr/bin&quot;下的git。</div><div class=\"line\"></div><div class=\"line\">你可以用下面的命令查看git所在的路径：</div><div class=\"line\"></div><div class=\"line\">$ whereis git</div><div class=\"line\">git: /usr/bin/git /usr/local/git /usr/share/man/man1/git.1.gz</div><div class=\"line\">（6）我们要把编译安装的git路径放到环境变量里，让它替换&quot;/usr/bin&quot;下的git。为此我们可以修改“/etc/profile”文件（或者/etc/bashrc文件）。</div><div class=\"line\"></div><div class=\"line\">sudo vim /etc/profile</div><div class=\"line\">然后在文件的最后一行，添加下面的内容，然后保存退出。</div><div class=\"line\"></div><div class=\"line\">export PATH=/usr/local/git/bin:$PATH</div><div class=\"line\">（7）使用source命令应用修改。</div><div class=\"line\"></div><div class=\"line\">source /etc/profile</div><div class=\"line\"></div><div class=\"line\">（8）然后再次使用git --version 查看git版本，发现输出2.3.0，表明安装成功。</div></pre></td></tr></table></figure>\n<h3 id=\"django错误\"><a href=\"#django错误\" class=\"headerlink\" title=\"django错误\"></a>django错误</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">DisallowedHost at /</div><div class=\"line\"></div><div class=\"line\">Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.</div><div class=\"line\">Request Method:\tGET</div><div class=\"line\">Request URL:\thttp://10.211.55.6:8000/</div><div class=\"line\">Django Version:\t1.10.4</div><div class=\"line\">Exception Type:\tDisallowedHost</div><div class=\"line\">Exception Value:\t</div><div class=\"line\">Invalid HTTP_HOST header: &apos;10.211.55.6:8000&apos;. You may need to add u&apos;10.211.55.6&apos; to ALLOWED_HOSTS.</div><div class=\"line\">Exception Location:\t/usr/lib/python2.7/site-packages/django/http/request.py in get_host, line 113</div><div class=\"line\">Python Executable:\t/usr/bin/python</div><div class=\"line\">Python Version:</div><div class=\"line\"></div><div class=\"line\">1，以上时我访问请求的时候出现的，原因在于Django框架中的创建的一个项目的时候，</div><div class=\"line\"></div><div class=\"line\">2，跑下这个命令：Python manage.py runserver 10.211.55.5:8000</div><div class=\"line\"></div><div class=\"line\">3，然后在我本机的浏览器中写入上述IP和端口请求过去：http://10.211.55.6:8000</div><div class=\"line\"></div><div class=\"line\">4，于是就出现了最上面的那个问题；</div><div class=\"line\"></div><div class=\"line\">5，于是就去django-admin.py startproject project-name创建的项目中去修改 setting.py 文件：</div><div class=\"line\"></div><div class=\"line\">ALLOWED_HOSTS = [&apos;*&apos;]  ＃在这里请求的host添加了＊</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">6，于是就成功的访问到了Django的项目了；</div></pre></td></tr></table></figure>\n"},{"title":"Python基础知识-列表/元组/字符串","date":"2016-04-09T02:53:55.000Z","_content":"## 列表和元组\n在python中我们有两种很重要的数据结构，分别为序列和映射，对应到OC中就是数组和字典，序列又分为列表和元组，他们的区别在于，列表可修改，元组不能，列表用方括号[]，而元组用小括号（）\n<!--more-->\n```\nlist = ['hanshenghui','xiaoming']\nlist1 = ('hanshenghui','xiaoming')\n```\n<!--more-->\n### 序列通用操作\n列表和元组都能做的操作\n#### 索引\n```\n>>> greeting = 'hello'\n>>> greeting[1]\n'e'\n>>> greeting[2]\n'l'\n>>> \n\n>>> greeting1 = ('h','e','l')\n>>> greeting1[0]\n'h'\n>>> greeting1[1]\n'e'\n>>> \n```\n字符串可以理解为由一个个的字符拼成的列表\n#### 分片\n我们不但可以用一个索引来获取某一个元素，也可以获取某个范围的元素。\n```\n>>> numbers = [1,2,3,4,5,6,7,8,9,0]\n>>> numbers[0:2]\n[1, 2]\n```\n我们可以看到，左边的边界包含在其中，而右边的边界是不包含在其中的\n```\n>>> numbers[-1:2]\n[]\n>>> numbers[-1:-3]\n[]\n>>> numbers[-3:-1]\n[8, 9]\n>>> \n>>> numbers[-3:]\n[8, 9, 0]\n```\n我们还可以用倒序来取元素，但是切记一定要左边小，右边的大，只标记一个就会从这个开始取所有，或者到这个为止\n\n还可以给一个步长\n```\n>>> numbers[::3]\n[1, 4, 7, 0]\n```\n#### 相加\n```\n>>> item1 = [1,2,3]\n>>> item2 = [4,5,6]\n>>> item1 + item2\n[1, 2, 3, 4, 5, 6]\n\n>>> string1 = 'hansheng'\n>>> string2 = 'hui'\n>>> string1 + string2\n'hanshenghui'\n\n>>> string1 + item1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: cannot concatenate 'str' and 'list' objects\n```\n但是只有同种类型才能相加\n#### 乘法\n```\n>>> 'python' * 5\n'pythonpythonpythonpythonpython'\n>>> [10,11] * 3\n[10, 11, 10, 11, 10, 11]\n```\n#### 成员资格\n```\n>>> han = 'hanshenghui'\n>>> 'shenghui' in han\nTrue\n>>> 'wahha' in han\nFalse\n>>> \n```\n\n#### 长度，最大值，最小值\n```\nhan = 'hanshenghui'\nitem1 = [1,2,3]\n\n>>> len(han)\n11\n>>> max(han)\n'u'\n>>> min(han)\n'a'\n>>> len(item1)\n3\n>>> max(item1)\n3\n>>> min(item1)\n1\n>>> \n```\n\n### 列表操作\n#### list与join\n```\n>>> name = list('hanshenghui')\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n>>> len(name)\n11\n>>> ''.join(name)\n'hanshenghui'\n>>> 'a'.join(name)\n'haaanasahaeanagahauai'\n```\n#### 赋值\n更改某个元素的值\n```\n>>> name[0] = 'i'\n>>> name\n['i', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n```\n#### 删除del\n```\n>>> name = 'han'\n>>> name\n'han'\n>>> name = list(name)\n>>> del name[0]\n>>> name\n['a', 'n']\n>>> \n```\n#### 分片赋值\n这是异常强大的一个特性，可以用来插入元素，更改元素，甚至删除元素\n```\n>>> name = list('han')\n>>> name[1:] = list('python')\n>>> name\n['h', 'p', 'y', 't', 'h', 'o', 'n']\n>>> name[2:]=[]\n>>> name\n['h', 'p']\n>>> name[1:1] = list('wahha')\n>>> name\n['h', 'w', 'a', 'h', 'h', 'a', 'p']\n>>> \n```\n#### append追加\n```\n>>> name = list('han')\n>>> name\n['h', 'a', 'n']\n>>> name.append('shenghui')\n>>> name\n['h', 'a', 'n', 'shenghui']\n>>> ''.join(name)\n'hanshenghui'\n>>> \n```\n#### count统计出现的次数\n```\n>>> name = 'hanshenghui'\n>>> name.count('h')\n3\n>>> name.count('n')\n2\n>>> \n```\n#### extend\n一个列表后追加一个新的列表，同加法作用一致\n```\n>>> name\n['h', 'a', 'n']\n>>> name1 = list('sheng')\n>>> name1\n['s', 'h', 'e', 'n', 'g']\n>>> name.extend(name1)\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> \n```\n#### index\n找出列表中某个项的第一个匹配索引\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.index('h')\n0\n>>> \n```\n#### insert\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.insert(0,'wahha')\n>>> name\n['wahha', 'h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> \n```\n#### pop\n移除某个值并且将该值返回，需要提供索引\n```\n>>> name\n['wahha', 'h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.pop()\n'g'\n>>> name.pop()\n'n'\n>>> name.pop(0)\n'wahha'\n>>> \n```\n#### remove\n移除某个匹配项\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e']\n>>> name.remove('s')\n>>> name\n['h', 'a', 'n', 'h', 'e']\n>>> name.remove('s')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: list.remove(x): x not in list\n```\n如果该值不存在，那么就会报错\n#### reverse\n```\n>>> name\n['h', 'a', 'n', 'h', 'e']\n>>> name.reverse()\n>>> name\n['e', 'h', 'n', 'a', 'h']\n```\n#### sort\n改变原来的列表，返回一个空值\n```\n>>> name\n['e', 'h', 'n', 'a', 'h']\n>>> name.sort()\n>>> name\n['a', 'e', 'h', 'h', 'n']\n>>>\n```\n需要返回值，sorted\n```\n>>> name = list('hna')\n>>> name1 = sorted(name)\n>>> name1\n['a', 'h', 'n']\n>>> \n```\n\n#### 高级排序\n```\n>>> name = list('hanshenghui')\n>>> name.sort(reverse = True)\n>>> name\n['u', 's', 'n', 'n', 'i', 'h', 'h', 'h', 'g', 'e', 'a']\n>>> \n```\n\n## 字符串\n### 字符串格式化\n```\n>>> python = '%s is a %s' \n>>> value = ('xiaohong','dog')\n>>> print python % value\nxiaohong is a dog\n```\n>符号说明:`s`代表字符串，后边的对象将以str转译，`%`代表占位，只有元组才会被分开解释，如果是一个列表，那么只能被解释为一个对象，这点要特别注意。d代表整型，f代表浮点数\n\n```\n>>> python = '%10.1fha'\n>>> print python % 10\n      10.0ha\n```\nf前边的小数点后的数字代表，小数点的保留位数，而前边的10代表字段宽。\n\n```\n>>> python = '%010.1fha'\n>>> print python % 10\n00000010.0ha\n\n>>> python = '%+10.1fha'\n>>> print python % 10\n     +10.0ha\n\n>>> print python % 10\n10.0      ha\n>>> \n\n```\n在字段宽和精度前边还可以放置一个标志，这个标志可以是零，加号和减号或者空格，用法见上\n\n### 字符串方法\n#### 1、find\nfind方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。\n```\n>>> name = 'hanshenghui'\n>>> name.find('h')\n0\n>>> name.find('h',2)\n4\n>>> name.find('h',2,6)\n4\n>>> name.find('h',2,5)\n4\n>>> name.find('h',2,3)\n-1\n```\n#### 2、join && split\njoin方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素：\n```\n>>> s = ['1', '2', '3']\n>>> '+'.join(s)\n'1+2+3'\n```\n注意：需要添加的队列元素都必须是字符串。\n\nsplit这是个非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。\n```\n>>> '1+2+3+4'.split('+')\n['1', '2', '3', '4']\n>>> '1 2 3 4'.split()\n['1', '2', '3', '4']\n```\n#### 3.lower && upper\nlower方法返回字符串的小写字母版。\n```\n>>> name = 'A'\n>>> name.lower()\n'a'\n>>> b = name.lower()\n>>> b.upper()\n'A'\n\nS.lower() #小写 \nS.upper() #大写 \nS.swapcase() #大小写互换 \nS.capitalize() #首字母大写 \n```\n#### 4.strip\nstrip方法返回去除两侧（不包含内部）空格的字符串\n去两边空格：str.strip()\n去左空格：str.lstrip()\n去右空格：str.rstrip()\n去两边字符串：str.strip('d')，相应的也有lstrip，rstrip\n\n#### 5.replace && translate\ntranslate方法和replace方法一样，可以替换字符串中的某些部分，但是和前者不同的是，translate方法只处理单个字符。它的优势在于可以同时进行多个替换，有些时候比replace效率高得多。\n\n```\n>>> name = 'hanshenghui'\n>>> name.replace('h','z')\n'zanszengzui'\n```\n\n在使用translate转换前，需要先完成一张转换表。转换表中是以某字符替换某字符的对应关系。因为这个表（事实上是字符串）有多达256个项目，我们还是不要自己写了，用string模块里面的maketrans函数就行了。\n\nmaketrans函数接收两个参数：两个等长的字符串，表示第一个字符串中的每个字符都用第二个字符串中相同位置的字符替换。\n```\n>>> from string import maketrans\n>>> table = maketrans('cs', 'kz')\n　　创建这个表后，可以将它用作translate方法的参数，进行字符串的转换：\n\n>>> 'this is an incredible test'.translate(table)\n'thiz iz an inkredible tezt'\ntranslate的第二个参数是可选的，这个参数是用来指定需要删除的字符。\n\n>>> 'this is an incredible test'.translate(table, ' ')\n'thizizaninkredibletezt'\n```\n\n#### 6.字符串判断相关\n字符串判断相关\n是否以start开头：str.startswith('start')\n是否以end结尾：str.endswith('end')\n是否全为字母或数字：str.isalnum()\n是否全字母：str.isalpha()\n是否全数字：str.isdigit()\n是否全小写：str.islower()\n是否全大写：str.isupper()\n\n\n#### 7.字符串比较\ncmp方法比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X< Y,返回值是负数 如果X>Y 返回的值为正数。\nsStr1 = 'strch'\nsStr2 = 'strchr'\nprint cmp(sStr1,sStr2)##-1\n\n### 列表，元组，字符串的转换list与tuple\n意义在于元组可以作为一个参数整体使用，而列表不可以\n```\n>>> name = 'hanshenghui'\n>>> tuple(name)\n('h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i')\n>>> list(name)\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n>>> tuple(list(name))\n('h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i')\n```\n","source":"_posts/2017/Python基础知识-列表-元组-字符串.md","raw":"---\ntitle: Python基础知识-列表/元组/字符串\ndate: 2016-04-09 10:53:55\ntags:\n- Python\ncategories: Python\n---\n## 列表和元组\n在python中我们有两种很重要的数据结构，分别为序列和映射，对应到OC中就是数组和字典，序列又分为列表和元组，他们的区别在于，列表可修改，元组不能，列表用方括号[]，而元组用小括号（）\n<!--more-->\n```\nlist = ['hanshenghui','xiaoming']\nlist1 = ('hanshenghui','xiaoming')\n```\n<!--more-->\n### 序列通用操作\n列表和元组都能做的操作\n#### 索引\n```\n>>> greeting = 'hello'\n>>> greeting[1]\n'e'\n>>> greeting[2]\n'l'\n>>> \n\n>>> greeting1 = ('h','e','l')\n>>> greeting1[0]\n'h'\n>>> greeting1[1]\n'e'\n>>> \n```\n字符串可以理解为由一个个的字符拼成的列表\n#### 分片\n我们不但可以用一个索引来获取某一个元素，也可以获取某个范围的元素。\n```\n>>> numbers = [1,2,3,4,5,6,7,8,9,0]\n>>> numbers[0:2]\n[1, 2]\n```\n我们可以看到，左边的边界包含在其中，而右边的边界是不包含在其中的\n```\n>>> numbers[-1:2]\n[]\n>>> numbers[-1:-3]\n[]\n>>> numbers[-3:-1]\n[8, 9]\n>>> \n>>> numbers[-3:]\n[8, 9, 0]\n```\n我们还可以用倒序来取元素，但是切记一定要左边小，右边的大，只标记一个就会从这个开始取所有，或者到这个为止\n\n还可以给一个步长\n```\n>>> numbers[::3]\n[1, 4, 7, 0]\n```\n#### 相加\n```\n>>> item1 = [1,2,3]\n>>> item2 = [4,5,6]\n>>> item1 + item2\n[1, 2, 3, 4, 5, 6]\n\n>>> string1 = 'hansheng'\n>>> string2 = 'hui'\n>>> string1 + string2\n'hanshenghui'\n\n>>> string1 + item1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: cannot concatenate 'str' and 'list' objects\n```\n但是只有同种类型才能相加\n#### 乘法\n```\n>>> 'python' * 5\n'pythonpythonpythonpythonpython'\n>>> [10,11] * 3\n[10, 11, 10, 11, 10, 11]\n```\n#### 成员资格\n```\n>>> han = 'hanshenghui'\n>>> 'shenghui' in han\nTrue\n>>> 'wahha' in han\nFalse\n>>> \n```\n\n#### 长度，最大值，最小值\n```\nhan = 'hanshenghui'\nitem1 = [1,2,3]\n\n>>> len(han)\n11\n>>> max(han)\n'u'\n>>> min(han)\n'a'\n>>> len(item1)\n3\n>>> max(item1)\n3\n>>> min(item1)\n1\n>>> \n```\n\n### 列表操作\n#### list与join\n```\n>>> name = list('hanshenghui')\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n>>> len(name)\n11\n>>> ''.join(name)\n'hanshenghui'\n>>> 'a'.join(name)\n'haaanasahaeanagahauai'\n```\n#### 赋值\n更改某个元素的值\n```\n>>> name[0] = 'i'\n>>> name\n['i', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n```\n#### 删除del\n```\n>>> name = 'han'\n>>> name\n'han'\n>>> name = list(name)\n>>> del name[0]\n>>> name\n['a', 'n']\n>>> \n```\n#### 分片赋值\n这是异常强大的一个特性，可以用来插入元素，更改元素，甚至删除元素\n```\n>>> name = list('han')\n>>> name[1:] = list('python')\n>>> name\n['h', 'p', 'y', 't', 'h', 'o', 'n']\n>>> name[2:]=[]\n>>> name\n['h', 'p']\n>>> name[1:1] = list('wahha')\n>>> name\n['h', 'w', 'a', 'h', 'h', 'a', 'p']\n>>> \n```\n#### append追加\n```\n>>> name = list('han')\n>>> name\n['h', 'a', 'n']\n>>> name.append('shenghui')\n>>> name\n['h', 'a', 'n', 'shenghui']\n>>> ''.join(name)\n'hanshenghui'\n>>> \n```\n#### count统计出现的次数\n```\n>>> name = 'hanshenghui'\n>>> name.count('h')\n3\n>>> name.count('n')\n2\n>>> \n```\n#### extend\n一个列表后追加一个新的列表，同加法作用一致\n```\n>>> name\n['h', 'a', 'n']\n>>> name1 = list('sheng')\n>>> name1\n['s', 'h', 'e', 'n', 'g']\n>>> name.extend(name1)\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> \n```\n#### index\n找出列表中某个项的第一个匹配索引\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.index('h')\n0\n>>> \n```\n#### insert\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.insert(0,'wahha')\n>>> name\n['wahha', 'h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> \n```\n#### pop\n移除某个值并且将该值返回，需要提供索引\n```\n>>> name\n['wahha', 'h', 'a', 'n', 's', 'h', 'e', 'n', 'g']\n>>> name.pop()\n'g'\n>>> name.pop()\n'n'\n>>> name.pop(0)\n'wahha'\n>>> \n```\n#### remove\n移除某个匹配项\n```\n>>> name\n['h', 'a', 'n', 's', 'h', 'e']\n>>> name.remove('s')\n>>> name\n['h', 'a', 'n', 'h', 'e']\n>>> name.remove('s')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: list.remove(x): x not in list\n```\n如果该值不存在，那么就会报错\n#### reverse\n```\n>>> name\n['h', 'a', 'n', 'h', 'e']\n>>> name.reverse()\n>>> name\n['e', 'h', 'n', 'a', 'h']\n```\n#### sort\n改变原来的列表，返回一个空值\n```\n>>> name\n['e', 'h', 'n', 'a', 'h']\n>>> name.sort()\n>>> name\n['a', 'e', 'h', 'h', 'n']\n>>>\n```\n需要返回值，sorted\n```\n>>> name = list('hna')\n>>> name1 = sorted(name)\n>>> name1\n['a', 'h', 'n']\n>>> \n```\n\n#### 高级排序\n```\n>>> name = list('hanshenghui')\n>>> name.sort(reverse = True)\n>>> name\n['u', 's', 'n', 'n', 'i', 'h', 'h', 'h', 'g', 'e', 'a']\n>>> \n```\n\n## 字符串\n### 字符串格式化\n```\n>>> python = '%s is a %s' \n>>> value = ('xiaohong','dog')\n>>> print python % value\nxiaohong is a dog\n```\n>符号说明:`s`代表字符串，后边的对象将以str转译，`%`代表占位，只有元组才会被分开解释，如果是一个列表，那么只能被解释为一个对象，这点要特别注意。d代表整型，f代表浮点数\n\n```\n>>> python = '%10.1fha'\n>>> print python % 10\n      10.0ha\n```\nf前边的小数点后的数字代表，小数点的保留位数，而前边的10代表字段宽。\n\n```\n>>> python = '%010.1fha'\n>>> print python % 10\n00000010.0ha\n\n>>> python = '%+10.1fha'\n>>> print python % 10\n     +10.0ha\n\n>>> print python % 10\n10.0      ha\n>>> \n\n```\n在字段宽和精度前边还可以放置一个标志，这个标志可以是零，加号和减号或者空格，用法见上\n\n### 字符串方法\n#### 1、find\nfind方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。\n```\n>>> name = 'hanshenghui'\n>>> name.find('h')\n0\n>>> name.find('h',2)\n4\n>>> name.find('h',2,6)\n4\n>>> name.find('h',2,5)\n4\n>>> name.find('h',2,3)\n-1\n```\n#### 2、join && split\njoin方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素：\n```\n>>> s = ['1', '2', '3']\n>>> '+'.join(s)\n'1+2+3'\n```\n注意：需要添加的队列元素都必须是字符串。\n\nsplit这是个非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。\n```\n>>> '1+2+3+4'.split('+')\n['1', '2', '3', '4']\n>>> '1 2 3 4'.split()\n['1', '2', '3', '4']\n```\n#### 3.lower && upper\nlower方法返回字符串的小写字母版。\n```\n>>> name = 'A'\n>>> name.lower()\n'a'\n>>> b = name.lower()\n>>> b.upper()\n'A'\n\nS.lower() #小写 \nS.upper() #大写 \nS.swapcase() #大小写互换 \nS.capitalize() #首字母大写 \n```\n#### 4.strip\nstrip方法返回去除两侧（不包含内部）空格的字符串\n去两边空格：str.strip()\n去左空格：str.lstrip()\n去右空格：str.rstrip()\n去两边字符串：str.strip('d')，相应的也有lstrip，rstrip\n\n#### 5.replace && translate\ntranslate方法和replace方法一样，可以替换字符串中的某些部分，但是和前者不同的是，translate方法只处理单个字符。它的优势在于可以同时进行多个替换，有些时候比replace效率高得多。\n\n```\n>>> name = 'hanshenghui'\n>>> name.replace('h','z')\n'zanszengzui'\n```\n\n在使用translate转换前，需要先完成一张转换表。转换表中是以某字符替换某字符的对应关系。因为这个表（事实上是字符串）有多达256个项目，我们还是不要自己写了，用string模块里面的maketrans函数就行了。\n\nmaketrans函数接收两个参数：两个等长的字符串，表示第一个字符串中的每个字符都用第二个字符串中相同位置的字符替换。\n```\n>>> from string import maketrans\n>>> table = maketrans('cs', 'kz')\n　　创建这个表后，可以将它用作translate方法的参数，进行字符串的转换：\n\n>>> 'this is an incredible test'.translate(table)\n'thiz iz an inkredible tezt'\ntranslate的第二个参数是可选的，这个参数是用来指定需要删除的字符。\n\n>>> 'this is an incredible test'.translate(table, ' ')\n'thizizaninkredibletezt'\n```\n\n#### 6.字符串判断相关\n字符串判断相关\n是否以start开头：str.startswith('start')\n是否以end结尾：str.endswith('end')\n是否全为字母或数字：str.isalnum()\n是否全字母：str.isalpha()\n是否全数字：str.isdigit()\n是否全小写：str.islower()\n是否全大写：str.isupper()\n\n\n#### 7.字符串比较\ncmp方法比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X< Y,返回值是负数 如果X>Y 返回的值为正数。\nsStr1 = 'strch'\nsStr2 = 'strchr'\nprint cmp(sStr1,sStr2)##-1\n\n### 列表，元组，字符串的转换list与tuple\n意义在于元组可以作为一个参数整体使用，而列表不可以\n```\n>>> name = 'hanshenghui'\n>>> tuple(name)\n('h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i')\n>>> list(name)\n['h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i']\n>>> tuple(list(name))\n('h', 'a', 'n', 's', 'h', 'e', 'n', 'g', 'h', 'u', 'i')\n```\n","slug":"2017/Python基础知识-列表-元组-字符串","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pn1003hsauaha6qh1ga","content":"<h2 id=\"列表和元组\"><a href=\"#列表和元组\" class=\"headerlink\" title=\"列表和元组\"></a>列表和元组</h2><p>在python中我们有两种很重要的数据结构，分别为序列和映射，对应到OC中就是数组和字典，序列又分为列表和元组，他们的区别在于，列表可修改，元组不能，列表用方括号[]，而元组用小括号（）<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [&apos;hanshenghui&apos;,&apos;xiaoming&apos;]</div><div class=\"line\">list1 = (&apos;hanshenghui&apos;,&apos;xiaoming&apos;)</div></pre></td></tr></table></figure></p>\n<!--more-->\n<h3 id=\"序列通用操作\"><a href=\"#序列通用操作\" class=\"headerlink\" title=\"序列通用操作\"></a>序列通用操作</h3><p>列表和元组都能做的操作</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; greeting = &apos;hello&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting[1]</div><div class=\"line\">&apos;e&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting[2]</div><div class=\"line\">&apos;l&apos;</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; greeting1 = (&apos;h&apos;,&apos;e&apos;,&apos;l&apos;)</div><div class=\"line\">&gt;&gt;&gt; greeting1[0]</div><div class=\"line\">&apos;h&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting1[1]</div><div class=\"line\">&apos;e&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>字符串可以理解为由一个个的字符拼成的列表</p>\n<h4 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h4><p>我们不但可以用一个索引来获取某一个元素，也可以获取某个范围的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,0]</div><div class=\"line\">&gt;&gt;&gt; numbers[0:2]</div><div class=\"line\">[1, 2]</div></pre></td></tr></table></figure></p>\n<p>我们可以看到，左边的边界包含在其中，而右边的边界是不包含在其中的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers[-1:2]</div><div class=\"line\">[]</div><div class=\"line\">&gt;&gt;&gt; numbers[-1:-3]</div><div class=\"line\">[]</div><div class=\"line\">&gt;&gt;&gt; numbers[-3:-1]</div><div class=\"line\">[8, 9]</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\">&gt;&gt;&gt; numbers[-3:]</div><div class=\"line\">[8, 9, 0]</div></pre></td></tr></table></figure></p>\n<p>我们还可以用倒序来取元素，但是切记一定要左边小，右边的大，只标记一个就会从这个开始取所有，或者到这个为止</p>\n<p>还可以给一个步长<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers[::3]</div><div class=\"line\">[1, 4, 7, 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"相加\"><a href=\"#相加\" class=\"headerlink\" title=\"相加\"></a>相加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; item1 = [1,2,3]</div><div class=\"line\">&gt;&gt;&gt; item2 = [4,5,6]</div><div class=\"line\">&gt;&gt;&gt; item1 + item2</div><div class=\"line\">[1, 2, 3, 4, 5, 6]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; string1 = &apos;hansheng&apos;</div><div class=\"line\">&gt;&gt;&gt; string2 = &apos;hui&apos;</div><div class=\"line\">&gt;&gt;&gt; string1 + string2</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; string1 + item1</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class=\"line\">TypeError: cannot concatenate &apos;str&apos; and &apos;list&apos; objects</div></pre></td></tr></table></figure>\n<p>但是只有同种类型才能相加</p>\n<h4 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; &apos;python&apos; * 5</div><div class=\"line\">&apos;pythonpythonpythonpythonpython&apos;</div><div class=\"line\">&gt;&gt;&gt; [10,11] * 3</div><div class=\"line\">[10, 11, 10, 11, 10, 11]</div></pre></td></tr></table></figure>\n<h4 id=\"成员资格\"><a href=\"#成员资格\" class=\"headerlink\" title=\"成员资格\"></a>成员资格</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; han = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; &apos;shenghui&apos; in han</div><div class=\"line\">True</div><div class=\"line\">&gt;&gt;&gt; &apos;wahha&apos; in han</div><div class=\"line\">False</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"长度，最大值，最小值\"><a href=\"#长度，最大值，最小值\" class=\"headerlink\" title=\"长度，最大值，最小值\"></a>长度，最大值，最小值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">han = &apos;hanshenghui&apos;</div><div class=\"line\">item1 = [1,2,3]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; len(han)</div><div class=\"line\">11</div><div class=\"line\">&gt;&gt;&gt; max(han)</div><div class=\"line\">&apos;u&apos;</div><div class=\"line\">&gt;&gt;&gt; min(han)</div><div class=\"line\">&apos;a&apos;</div><div class=\"line\">&gt;&gt;&gt; len(item1)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; max(item1)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; min(item1)</div><div class=\"line\">1</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"列表操作\"><a href=\"#列表操作\" class=\"headerlink\" title=\"列表操作\"></a>列表操作</h3><h4 id=\"list与join\"><a href=\"#list与join\" class=\"headerlink\" title=\"list与join\"></a>list与join</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div><div class=\"line\">&gt;&gt;&gt; len(name)</div><div class=\"line\">11</div><div class=\"line\">&gt;&gt;&gt; &apos;&apos;.join(name)</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; &apos;a&apos;.join(name)</div><div class=\"line\">&apos;haaanasahaeanagahauai&apos;</div></pre></td></tr></table></figure>\n<h4 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h4><p>更改某个元素的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name[0] = &apos;i&apos;</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;i&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"删除del\"><a href=\"#删除del\" class=\"headerlink\" title=\"删除del\"></a>删除del</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;han&apos;</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">&apos;han&apos;</div><div class=\"line\">&gt;&gt;&gt; name = list(name)</div><div class=\"line\">&gt;&gt;&gt; del name[0]</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"分片赋值\"><a href=\"#分片赋值\" class=\"headerlink\" title=\"分片赋值\"></a>分片赋值</h4><p>这是异常强大的一个特性，可以用来插入元素，更改元素，甚至删除元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;han&apos;)</div><div class=\"line\">&gt;&gt;&gt; name[1:] = list(&apos;python&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name[2:]=[]</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;p&apos;]</div><div class=\"line\">&gt;&gt;&gt; name[1:1] = list(&apos;wahha&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;w&apos;, &apos;a&apos;, &apos;h&apos;, &apos;h&apos;, &apos;a&apos;, &apos;p&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"append追加\"><a href=\"#append追加\" class=\"headerlink\" title=\"append追加\"></a>append追加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;han&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.append(&apos;shenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;shenghui&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;&apos;.join(name)</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"count统计出现的次数\"><a href=\"#count统计出现的次数\" class=\"headerlink\" title=\"count统计出现的次数\"></a>count统计出现的次数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.count(&apos;h&apos;)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; name.count(&apos;n&apos;)</div><div class=\"line\">2</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h4><p>一个列表后追加一个新的列表，同加法作用一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name1 = list(&apos;sheng&apos;)</div><div class=\"line\">&gt;&gt;&gt; name1</div><div class=\"line\">[&apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.extend(name1)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h4><p>找出列表中某个项的第一个匹配索引<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.index(&apos;h&apos;)</div><div class=\"line\">0</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.insert(0,&apos;wahha&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>移除某个值并且将该值返回，需要提供索引<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.pop()</div><div class=\"line\">&apos;g&apos;</div><div class=\"line\">&gt;&gt;&gt; name.pop()</div><div class=\"line\">&apos;n&apos;</div><div class=\"line\">&gt;&gt;&gt; name.pop(0)</div><div class=\"line\">&apos;wahha&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h4><p>移除某个匹配项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.remove(&apos;s&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.remove(&apos;s&apos;)</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class=\"line\">ValueError: list.remove(x): x not in list</div></pre></td></tr></table></figure></p>\n<p>如果该值不存在，那么就会报错</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.reverse()</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;]</div></pre></td></tr></table></figure>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>改变原来的列表，返回一个空值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.sort()</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;a&apos;, &apos;e&apos;, &apos;h&apos;, &apos;h&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<p>需要返回值，sorted<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hna&apos;)</div><div class=\"line\">&gt;&gt;&gt; name1 = sorted(name)</div><div class=\"line\">&gt;&gt;&gt; name1</div><div class=\"line\">[&apos;a&apos;, &apos;h&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"高级排序\"><a href=\"#高级排序\" class=\"headerlink\" title=\"高级排序\"></a>高级排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name.sort(reverse = True)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;u&apos;, &apos;s&apos;, &apos;n&apos;, &apos;n&apos;, &apos;i&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;g&apos;, &apos;e&apos;, &apos;a&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"字符串格式化\"><a href=\"#字符串格式化\" class=\"headerlink\" title=\"字符串格式化\"></a>字符串格式化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%s is a %s&apos; </div><div class=\"line\">&gt;&gt;&gt; value = (&apos;xiaohong&apos;,&apos;dog&apos;)</div><div class=\"line\">&gt;&gt;&gt; print python % value</div><div class=\"line\">xiaohong is a dog</div></pre></td></tr></table></figure>\n<blockquote>\n<p>符号说明:<code>s</code>代表字符串，后边的对象将以str转译，<code>%</code>代表占位，只有元组才会被分开解释，如果是一个列表，那么只能被解释为一个对象，这点要特别注意。d代表整型，f代表浮点数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%10.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">      10.0ha</div></pre></td></tr></table></figure>\n<p>f前边的小数点后的数字代表，小数点的保留位数，而前边的10代表字段宽。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%010.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">00000010.0ha</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; python = &apos;%+10.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">     +10.0ha</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">10.0      ha</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>在字段宽和精度前边还可以放置一个标志，这个标志可以是零，加号和减号或者空格，用法见上</p>\n<h3 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a>字符串方法</h3><h4 id=\"1、find\"><a href=\"#1、find\" class=\"headerlink\" title=\"1、find\"></a>1、find</h4><p>find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;)</div><div class=\"line\">0</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,6)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,5)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,3)</div><div class=\"line\">-1</div></pre></td></tr></table></figure></p>\n<h4 id=\"2、join-amp-amp-split\"><a href=\"#2、join-amp-amp-split\" class=\"headerlink\" title=\"2、join &amp;&amp; split\"></a>2、join &amp;&amp; split</h4><p>join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;+&apos;.join(s)</div><div class=\"line\">&apos;1+2+3&apos;</div></pre></td></tr></table></figure></p>\n<p>注意：需要添加的队列元素都必须是字符串。</p>\n<p>split这是个非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; &apos;1+2+3+4&apos;.split(&apos;+&apos;)</div><div class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;1 2 3 4&apos;.split()</div><div class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-lower-amp-amp-upper\"><a href=\"#3-lower-amp-amp-upper\" class=\"headerlink\" title=\"3.lower &amp;&amp; upper\"></a>3.lower &amp;&amp; upper</h4><p>lower方法返回字符串的小写字母版。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;A&apos;</div><div class=\"line\">&gt;&gt;&gt; name.lower()</div><div class=\"line\">&apos;a&apos;</div><div class=\"line\">&gt;&gt;&gt; b = name.lower()</div><div class=\"line\">&gt;&gt;&gt; b.upper()</div><div class=\"line\">&apos;A&apos;</div><div class=\"line\"></div><div class=\"line\">S.lower() #小写 </div><div class=\"line\">S.upper() #大写 </div><div class=\"line\">S.swapcase() #大小写互换 </div><div class=\"line\">S.capitalize() #首字母大写</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-strip\"><a href=\"#4-strip\" class=\"headerlink\" title=\"4.strip\"></a>4.strip</h4><p>strip方法返回去除两侧（不包含内部）空格的字符串<br>去两边空格：str.strip()<br>去左空格：str.lstrip()<br>去右空格：str.rstrip()<br>去两边字符串：str.strip(‘d’)，相应的也有lstrip，rstrip</p>\n<h4 id=\"5-replace-amp-amp-translate\"><a href=\"#5-replace-amp-amp-translate\" class=\"headerlink\" title=\"5.replace &amp;&amp; translate\"></a>5.replace &amp;&amp; translate</h4><p>translate方法和replace方法一样，可以替换字符串中的某些部分，但是和前者不同的是，translate方法只处理单个字符。它的优势在于可以同时进行多个替换，有些时候比replace效率高得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.replace(&apos;h&apos;,&apos;z&apos;)</div><div class=\"line\">&apos;zanszengzui&apos;</div></pre></td></tr></table></figure>\n<p>在使用translate转换前，需要先完成一张转换表。转换表中是以某字符替换某字符的对应关系。因为这个表（事实上是字符串）有多达256个项目，我们还是不要自己写了，用string模块里面的maketrans函数就行了。</p>\n<p>maketrans函数接收两个参数：两个等长的字符串，表示第一个字符串中的每个字符都用第二个字符串中相同位置的字符替换。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; from string import maketrans</div><div class=\"line\">&gt;&gt;&gt; table = maketrans(&apos;cs&apos;, &apos;kz&apos;)</div><div class=\"line\">　　创建这个表后，可以将它用作translate方法的参数，进行字符串的转换：</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table)</div><div class=\"line\">&apos;thiz iz an inkredible tezt&apos;</div><div class=\"line\">translate的第二个参数是可选的，这个参数是用来指定需要删除的字符。</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table, &apos; &apos;)</div><div class=\"line\">&apos;thizizaninkredibletezt&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"6-字符串判断相关\"><a href=\"#6-字符串判断相关\" class=\"headerlink\" title=\"6.字符串判断相关\"></a>6.字符串判断相关</h4><p>字符串判断相关<br>是否以start开头：str.startswith(‘start’)<br>是否以end结尾：str.endswith(‘end’)<br>是否全为字母或数字：str.isalnum()<br>是否全字母：str.isalpha()<br>是否全数字：str.isdigit()<br>是否全小写：str.islower()<br>是否全大写：str.isupper()</p>\n<h4 id=\"7-字符串比较\"><a href=\"#7-字符串比较\" class=\"headerlink\" title=\"7.字符串比较\"></a>7.字符串比较</h4><p>cmp方法比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X&lt; Y,返回值是负数 如果X&gt;Y 返回的值为正数。<br>sStr1 = ‘strch’<br>sStr2 = ‘strchr’<br>print cmp(sStr1,sStr2)##-1</p>\n<h3 id=\"列表，元组，字符串的转换list与tuple\"><a href=\"#列表，元组，字符串的转换list与tuple\" class=\"headerlink\" title=\"列表，元组，字符串的转换list与tuple\"></a>列表，元组，字符串的转换list与tuple</h3><p>意义在于元组可以作为一个参数整体使用，而列表不可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; tuple(name)</div><div class=\"line\">(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)</div><div class=\"line\">&gt;&gt;&gt; list(name)</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div><div class=\"line\">&gt;&gt;&gt; tuple(list(name))</div><div class=\"line\">(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"列表和元组\"><a href=\"#列表和元组\" class=\"headerlink\" title=\"列表和元组\"></a>列表和元组</h2><p>在python中我们有两种很重要的数据结构，分别为序列和映射，对应到OC中就是数组和字典，序列又分为列表和元组，他们的区别在于，列表可修改，元组不能，列表用方括号[]，而元组用小括号（）<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = [&apos;hanshenghui&apos;,&apos;xiaoming&apos;]</div><div class=\"line\">list1 = (&apos;hanshenghui&apos;,&apos;xiaoming&apos;)</div></pre></td></tr></table></figure></p>\n<!--more-->\n<h3 id=\"序列通用操作\"><a href=\"#序列通用操作\" class=\"headerlink\" title=\"序列通用操作\"></a>序列通用操作</h3><p>列表和元组都能做的操作</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; greeting = &apos;hello&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting[1]</div><div class=\"line\">&apos;e&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting[2]</div><div class=\"line\">&apos;l&apos;</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; greeting1 = (&apos;h&apos;,&apos;e&apos;,&apos;l&apos;)</div><div class=\"line\">&gt;&gt;&gt; greeting1[0]</div><div class=\"line\">&apos;h&apos;</div><div class=\"line\">&gt;&gt;&gt; greeting1[1]</div><div class=\"line\">&apos;e&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>字符串可以理解为由一个个的字符拼成的列表</p>\n<h4 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h4><p>我们不但可以用一个索引来获取某一个元素，也可以获取某个范围的元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers = [1,2,3,4,5,6,7,8,9,0]</div><div class=\"line\">&gt;&gt;&gt; numbers[0:2]</div><div class=\"line\">[1, 2]</div></pre></td></tr></table></figure></p>\n<p>我们可以看到，左边的边界包含在其中，而右边的边界是不包含在其中的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers[-1:2]</div><div class=\"line\">[]</div><div class=\"line\">&gt;&gt;&gt; numbers[-1:-3]</div><div class=\"line\">[]</div><div class=\"line\">&gt;&gt;&gt; numbers[-3:-1]</div><div class=\"line\">[8, 9]</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\">&gt;&gt;&gt; numbers[-3:]</div><div class=\"line\">[8, 9, 0]</div></pre></td></tr></table></figure></p>\n<p>我们还可以用倒序来取元素，但是切记一定要左边小，右边的大，只标记一个就会从这个开始取所有，或者到这个为止</p>\n<p>还可以给一个步长<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; numbers[::3]</div><div class=\"line\">[1, 4, 7, 0]</div></pre></td></tr></table></figure></p>\n<h4 id=\"相加\"><a href=\"#相加\" class=\"headerlink\" title=\"相加\"></a>相加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; item1 = [1,2,3]</div><div class=\"line\">&gt;&gt;&gt; item2 = [4,5,6]</div><div class=\"line\">&gt;&gt;&gt; item1 + item2</div><div class=\"line\">[1, 2, 3, 4, 5, 6]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; string1 = &apos;hansheng&apos;</div><div class=\"line\">&gt;&gt;&gt; string2 = &apos;hui&apos;</div><div class=\"line\">&gt;&gt;&gt; string1 + string2</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; string1 + item1</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class=\"line\">TypeError: cannot concatenate &apos;str&apos; and &apos;list&apos; objects</div></pre></td></tr></table></figure>\n<p>但是只有同种类型才能相加</p>\n<h4 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; &apos;python&apos; * 5</div><div class=\"line\">&apos;pythonpythonpythonpythonpython&apos;</div><div class=\"line\">&gt;&gt;&gt; [10,11] * 3</div><div class=\"line\">[10, 11, 10, 11, 10, 11]</div></pre></td></tr></table></figure>\n<h4 id=\"成员资格\"><a href=\"#成员资格\" class=\"headerlink\" title=\"成员资格\"></a>成员资格</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; han = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; &apos;shenghui&apos; in han</div><div class=\"line\">True</div><div class=\"line\">&gt;&gt;&gt; &apos;wahha&apos; in han</div><div class=\"line\">False</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"长度，最大值，最小值\"><a href=\"#长度，最大值，最小值\" class=\"headerlink\" title=\"长度，最大值，最小值\"></a>长度，最大值，最小值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">han = &apos;hanshenghui&apos;</div><div class=\"line\">item1 = [1,2,3]</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; len(han)</div><div class=\"line\">11</div><div class=\"line\">&gt;&gt;&gt; max(han)</div><div class=\"line\">&apos;u&apos;</div><div class=\"line\">&gt;&gt;&gt; min(han)</div><div class=\"line\">&apos;a&apos;</div><div class=\"line\">&gt;&gt;&gt; len(item1)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; max(item1)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; min(item1)</div><div class=\"line\">1</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"列表操作\"><a href=\"#列表操作\" class=\"headerlink\" title=\"列表操作\"></a>列表操作</h3><h4 id=\"list与join\"><a href=\"#list与join\" class=\"headerlink\" title=\"list与join\"></a>list与join</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div><div class=\"line\">&gt;&gt;&gt; len(name)</div><div class=\"line\">11</div><div class=\"line\">&gt;&gt;&gt; &apos;&apos;.join(name)</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; &apos;a&apos;.join(name)</div><div class=\"line\">&apos;haaanasahaeanagahauai&apos;</div></pre></td></tr></table></figure>\n<h4 id=\"赋值\"><a href=\"#赋值\" class=\"headerlink\" title=\"赋值\"></a>赋值</h4><p>更改某个元素的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name[0] = &apos;i&apos;</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;i&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"删除del\"><a href=\"#删除del\" class=\"headerlink\" title=\"删除del\"></a>删除del</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;han&apos;</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">&apos;han&apos;</div><div class=\"line\">&gt;&gt;&gt; name = list(name)</div><div class=\"line\">&gt;&gt;&gt; del name[0]</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"分片赋值\"><a href=\"#分片赋值\" class=\"headerlink\" title=\"分片赋值\"></a>分片赋值</h4><p>这是异常强大的一个特性，可以用来插入元素，更改元素，甚至删除元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;han&apos;)</div><div class=\"line\">&gt;&gt;&gt; name[1:] = list(&apos;python&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;p&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name[2:]=[]</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;p&apos;]</div><div class=\"line\">&gt;&gt;&gt; name[1:1] = list(&apos;wahha&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;w&apos;, &apos;a&apos;, &apos;h&apos;, &apos;h&apos;, &apos;a&apos;, &apos;p&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"append追加\"><a href=\"#append追加\" class=\"headerlink\" title=\"append追加\"></a>append追加</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;han&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.append(&apos;shenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;shenghui&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;&apos;.join(name)</div><div class=\"line\">&apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"count统计出现的次数\"><a href=\"#count统计出现的次数\" class=\"headerlink\" title=\"count统计出现的次数\"></a>count统计出现的次数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.count(&apos;h&apos;)</div><div class=\"line\">3</div><div class=\"line\">&gt;&gt;&gt; name.count(&apos;n&apos;)</div><div class=\"line\">2</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"extend\"><a href=\"#extend\" class=\"headerlink\" title=\"extend\"></a>extend</h4><p>一个列表后追加一个新的列表，同加法作用一致<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt; name1 = list(&apos;sheng&apos;)</div><div class=\"line\">&gt;&gt;&gt; name1</div><div class=\"line\">[&apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.extend(name1)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h4><p>找出列表中某个项的第一个匹配索引<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.index(&apos;h&apos;)</div><div class=\"line\">0</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert\"></a>insert</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.insert(0,&apos;wahha&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop\"></a>pop</h4><p>移除某个值并且将该值返回，需要提供索引<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;wahha&apos;, &apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.pop()</div><div class=\"line\">&apos;g&apos;</div><div class=\"line\">&gt;&gt;&gt; name.pop()</div><div class=\"line\">&apos;n&apos;</div><div class=\"line\">&gt;&gt;&gt; name.pop(0)</div><div class=\"line\">&apos;wahha&apos;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h4><p>移除某个匹配项<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.remove(&apos;s&apos;)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.remove(&apos;s&apos;)</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class=\"line\">ValueError: list.remove(x): x not in list</div></pre></td></tr></table></figure></p>\n<p>如果该值不存在，那么就会报错</p>\n<h4 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;h&apos;, &apos;e&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.reverse()</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;]</div></pre></td></tr></table></figure>\n<h4 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h4><p>改变原来的列表，返回一个空值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;e&apos;, &apos;h&apos;, &apos;n&apos;, &apos;a&apos;, &apos;h&apos;]</div><div class=\"line\">&gt;&gt;&gt; name.sort()</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;a&apos;, &apos;e&apos;, &apos;h&apos;, &apos;h&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<p>需要返回值，sorted<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hna&apos;)</div><div class=\"line\">&gt;&gt;&gt; name1 = sorted(name)</div><div class=\"line\">&gt;&gt;&gt; name1</div><div class=\"line\">[&apos;a&apos;, &apos;h&apos;, &apos;n&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"高级排序\"><a href=\"#高级排序\" class=\"headerlink\" title=\"高级排序\"></a>高级排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = list(&apos;hanshenghui&apos;)</div><div class=\"line\">&gt;&gt;&gt; name.sort(reverse = True)</div><div class=\"line\">&gt;&gt;&gt; name</div><div class=\"line\">[&apos;u&apos;, &apos;s&apos;, &apos;n&apos;, &apos;n&apos;, &apos;i&apos;, &apos;h&apos;, &apos;h&apos;, &apos;h&apos;, &apos;g&apos;, &apos;e&apos;, &apos;a&apos;]</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"字符串格式化\"><a href=\"#字符串格式化\" class=\"headerlink\" title=\"字符串格式化\"></a>字符串格式化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%s is a %s&apos; </div><div class=\"line\">&gt;&gt;&gt; value = (&apos;xiaohong&apos;,&apos;dog&apos;)</div><div class=\"line\">&gt;&gt;&gt; print python % value</div><div class=\"line\">xiaohong is a dog</div></pre></td></tr></table></figure>\n<blockquote>\n<p>符号说明:<code>s</code>代表字符串，后边的对象将以str转译，<code>%</code>代表占位，只有元组才会被分开解释，如果是一个列表，那么只能被解释为一个对象，这点要特别注意。d代表整型，f代表浮点数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%10.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">      10.0ha</div></pre></td></tr></table></figure>\n<p>f前边的小数点后的数字代表，小数点的保留位数，而前边的10代表字段宽。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; python = &apos;%010.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">00000010.0ha</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; python = &apos;%+10.1fha&apos;</div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">     +10.0ha</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; print python % 10</div><div class=\"line\">10.0      ha</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<p>在字段宽和精度前边还可以放置一个标志，这个标志可以是零，加号和减号或者空格，用法见上</p>\n<h3 id=\"字符串方法\"><a href=\"#字符串方法\" class=\"headerlink\" title=\"字符串方法\"></a>字符串方法</h3><h4 id=\"1、find\"><a href=\"#1、find\" class=\"headerlink\" title=\"1、find\"></a>1、find</h4><p>find方法可以在一个较长的字符串中查找子字符串。它返回子串所在位置的最左端索引。如果没有找到则返回-1。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;)</div><div class=\"line\">0</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,6)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,5)</div><div class=\"line\">4</div><div class=\"line\">&gt;&gt;&gt; name.find(&apos;h&apos;,2,3)</div><div class=\"line\">-1</div></pre></td></tr></table></figure></p>\n<h4 id=\"2、join-amp-amp-split\"><a href=\"#2、join-amp-amp-split\" class=\"headerlink\" title=\"2、join &amp;&amp; split\"></a>2、join &amp;&amp; split</h4><p>join方法是非常重要的字符串方法，它是split方法的逆方法，用来在队列中添加元素：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; s = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;+&apos;.join(s)</div><div class=\"line\">&apos;1+2+3&apos;</div></pre></td></tr></table></figure></p>\n<p>注意：需要添加的队列元素都必须是字符串。</p>\n<p>split这是个非常重要的字符串方法，它是join的逆方法，用来将字符串分割成序列。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; &apos;1+2+3+4&apos;.split(&apos;+&apos;)</div><div class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div><div class=\"line\">&gt;&gt;&gt; &apos;1 2 3 4&apos;.split()</div><div class=\"line\">[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;]</div></pre></td></tr></table></figure></p>\n<h4 id=\"3-lower-amp-amp-upper\"><a href=\"#3-lower-amp-amp-upper\" class=\"headerlink\" title=\"3.lower &amp;&amp; upper\"></a>3.lower &amp;&amp; upper</h4><p>lower方法返回字符串的小写字母版。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;A&apos;</div><div class=\"line\">&gt;&gt;&gt; name.lower()</div><div class=\"line\">&apos;a&apos;</div><div class=\"line\">&gt;&gt;&gt; b = name.lower()</div><div class=\"line\">&gt;&gt;&gt; b.upper()</div><div class=\"line\">&apos;A&apos;</div><div class=\"line\"></div><div class=\"line\">S.lower() #小写 </div><div class=\"line\">S.upper() #大写 </div><div class=\"line\">S.swapcase() #大小写互换 </div><div class=\"line\">S.capitalize() #首字母大写</div></pre></td></tr></table></figure></p>\n<h4 id=\"4-strip\"><a href=\"#4-strip\" class=\"headerlink\" title=\"4.strip\"></a>4.strip</h4><p>strip方法返回去除两侧（不包含内部）空格的字符串<br>去两边空格：str.strip()<br>去左空格：str.lstrip()<br>去右空格：str.rstrip()<br>去两边字符串：str.strip(‘d’)，相应的也有lstrip，rstrip</p>\n<h4 id=\"5-replace-amp-amp-translate\"><a href=\"#5-replace-amp-amp-translate\" class=\"headerlink\" title=\"5.replace &amp;&amp; translate\"></a>5.replace &amp;&amp; translate</h4><p>translate方法和replace方法一样，可以替换字符串中的某些部分，但是和前者不同的是，translate方法只处理单个字符。它的优势在于可以同时进行多个替换，有些时候比replace效率高得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; name.replace(&apos;h&apos;,&apos;z&apos;)</div><div class=\"line\">&apos;zanszengzui&apos;</div></pre></td></tr></table></figure>\n<p>在使用translate转换前，需要先完成一张转换表。转换表中是以某字符替换某字符的对应关系。因为这个表（事实上是字符串）有多达256个项目，我们还是不要自己写了，用string模块里面的maketrans函数就行了。</p>\n<p>maketrans函数接收两个参数：两个等长的字符串，表示第一个字符串中的每个字符都用第二个字符串中相同位置的字符替换。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; from string import maketrans</div><div class=\"line\">&gt;&gt;&gt; table = maketrans(&apos;cs&apos;, &apos;kz&apos;)</div><div class=\"line\">　　创建这个表后，可以将它用作translate方法的参数，进行字符串的转换：</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table)</div><div class=\"line\">&apos;thiz iz an inkredible tezt&apos;</div><div class=\"line\">translate的第二个参数是可选的，这个参数是用来指定需要删除的字符。</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; &apos;this is an incredible test&apos;.translate(table, &apos; &apos;)</div><div class=\"line\">&apos;thizizaninkredibletezt&apos;</div></pre></td></tr></table></figure></p>\n<h4 id=\"6-字符串判断相关\"><a href=\"#6-字符串判断相关\" class=\"headerlink\" title=\"6.字符串判断相关\"></a>6.字符串判断相关</h4><p>字符串判断相关<br>是否以start开头：str.startswith(‘start’)<br>是否以end结尾：str.endswith(‘end’)<br>是否全为字母或数字：str.isalnum()<br>是否全字母：str.isalpha()<br>是否全数字：str.isdigit()<br>是否全小写：str.islower()<br>是否全大写：str.isupper()</p>\n<h4 id=\"7-字符串比较\"><a href=\"#7-字符串比较\" class=\"headerlink\" title=\"7.字符串比较\"></a>7.字符串比较</h4><p>cmp方法比较两个对象，并根据结果返回一个整数。cmp(x,y)如果X&lt; Y,返回值是负数 如果X&gt;Y 返回的值为正数。<br>sStr1 = ‘strch’<br>sStr2 = ‘strchr’<br>print cmp(sStr1,sStr2)##-1</p>\n<h3 id=\"列表，元组，字符串的转换list与tuple\"><a href=\"#列表，元组，字符串的转换list与tuple\" class=\"headerlink\" title=\"列表，元组，字符串的转换list与tuple\"></a>列表，元组，字符串的转换list与tuple</h3><p>意义在于元组可以作为一个参数整体使用，而列表不可以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; name = &apos;hanshenghui&apos;</div><div class=\"line\">&gt;&gt;&gt; tuple(name)</div><div class=\"line\">(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)</div><div class=\"line\">&gt;&gt;&gt; list(name)</div><div class=\"line\">[&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;]</div><div class=\"line\">&gt;&gt;&gt; tuple(list(name))</div><div class=\"line\">(&apos;h&apos;, &apos;a&apos;, &apos;n&apos;, &apos;s&apos;, &apos;h&apos;, &apos;e&apos;, &apos;n&apos;, &apos;g&apos;, &apos;h&apos;, &apos;u&apos;, &apos;i&apos;)</div></pre></td></tr></table></figure></p>"},{"title":"(转)音视频基础概念汇总","date":"2015-07-17T11:56:08.000Z","_content":"\n## 第一部分：基本概念讲解\n\n- 媒体：是表示，传输，存储信息的载体，常人们见到的文字、声音、图像、图形等都是表示信息的媒体。\n<!--more-->\n- 多媒体： 是声音、动画、文字、图像和录像等各种媒体的组合，以图文并茂，生动活泼的动态形式表现出来，给人以很强的视觉冲击力，留下深刻印象\n\n- 多媒体技术：是将文字、声音、图形、静态图像、动态图像与计算集成在一起的技术。它要解决的问题是计算机进一步帮助人类按最自然的和最习惯的方式接受和处理信息。\n\n- 流媒体 ：流媒体是指采用流式传输的方式在Internet播放的连续时基媒体格式，实际指的是一种新的媒体传送方式，而不是一种新的媒体格式（在网络上传输音/视频等多媒体信息现在主要有下载和流式传输两种方式）流式传输分两种方法：实时流式传输方式(Realtime streaming)和顺序流式传输方式(progressive streaming)。\n\n- 多媒体文件：是既包括视频又包括音频，甚至还带有脚本的一个集合，也可以叫容器；\n\n- 媒体编码：是文件当中的视频和音频所采用的压缩算法。也就是说一个avi的文件，当中的视频编码有可能是A，也可能是B，而其音频编码有可能是1，也有可能是2。  转码 ：指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式\n\n- 视频：连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频\n\n- 音频 ：人类能听到的声音都成为音频，但是一般我们所说到的音频时存储在计算机里的声音\n\n## 第二部分：视频文件格式\n\n- 码率：码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质.\n \n- 帧：帧就是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。\n \n\n- 帧率：帧率即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。\n关键帧：相当于二维动画中的原画，指角色或者物体运动或变化中的关键动作所处的那一帧，它包含了图像的所有信息，后来帧仅包含了改变了的信息。如果你没有足够的关键帧，你的影片品质可能比较差，因为所有的帧从别的帧处产生。对于一般的用途，一个比较好的原则是每5秒设一个关键键。但如果时那种实时传输的流文件，那么要考虑传输网络的可靠度，所以要1到2秒增加一个关键帧。目前我们经常见的视频格式无非就是两大类： \n1、影像格式（Video）\n2、流媒体格式（Stream Video）\n\n在影像格式中还可以根据出处划分为三大种： \n1、AVI格式：这是由微软（Microsoft）提出，具有“悠久历史”的一种视频格式\n2、MOV格式：这是由苹果（Apple）公司提出的一种视频格式\n3、MPEG/MPG/DAT：这是由国际标准化组织ISO(International Standards Organization)与IEC(International Electronic Committee)联合开发的一种编码视频格式。MPEG是运动图像压缩算法的国际标准，现已被几乎所有的计算机平台共同支持。\n\n在流媒体格式中同样还可以划分为三种： \n1、RM格式：这是由Real Networks公司开发的一种新型流式视频文件格式。\n2、MOV/QT格式：MOV也可以作为一种流文件格式。QuickTime能够通过Internet提供实时的数字化信息流、工作流与文件回放功能，为了适应这一网络多媒体应用，QuickTime为多种流行的浏览器软件提供了相应的QuickTime Viewer插件（Plug－in），能够在浏览器中实现多媒体数据的实时回放。\n3、ASF格式：这是由微软公司开发的流媒体格式，是一个在Internet上实时传播多媒体的技术标准。\n4、FLV\n\n\n## 具体视频文件格式详解：\n\n- *. MPEG/.MPG/.DAT \nMPEG也是Motion Picture Experts Group的缩写。这类格式包括了MPEG-1, MPEG-2和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在VCD的制作和一些视频片段下载的网络应用上面，大部分的VCD都是用 MPEG1格式压缩的( 刻录软件自动将MPEG1转为.DAT格式)，使用 MPEG-1的压缩算法，可以把一部 120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2则是应用在DVD 的制作，同时在一些HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB的大小（MPEG2的图像质量MPEG-1与其无法比拟的）。\n\n- *.AVI\n　它的英文全称为Audio Video Interleaved，即音频视频交错格式。是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，但压缩比较高，因此尽管面面质量不是太好，但其应用范围仍然非常广泛。AVI支持256色和RLE压缩。AVI信息主要应用在多媒体光盘上，用来保存电视、电影等各种影像信息。它于1992年被Microsoft公司推出，随Windows3.1一起被人们所认识和熟知。所谓“音频视频交错”，就是可以将视频和音频交织在一起进行同步播放。这种视频格式的优点是图像质量好，可以跨多个平台使用，其缺点是体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本Windows媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本Windows媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题，如果用户在进行AVI格式的视频播放时遇到了这些问题，可以通过下载相应的解码器来解决。是目前视频文件的主流。 这种格式的文件随处可见，比如一些游戏、教育软件的片头，多媒体光盘中，都会有不少的 AVI 。现在，在WINDOWS 95或98里都能直接播放AVI，同一种格式的avi文件有可能采用不同的编码方式，最常见的有Intel Indeo（R）Video R3.2（像游戏过场动画等，是目前使用最广泛的一种avi编码技术）、Microsoft video 等。\n\n- *.RA/RM/RAM\n　*.RM，Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash（Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO（RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，从RealVideo的定位来看，就是牺牲画面质量来换取可连续观看性。其实RealVideo也可以实现不错的画面质量，由于RealVideo可以拥有非常高的压缩效率，很多人把VCD编码成RealVideo格式的，这样一来，一张光盘上可以存放好几部电影。REAL VIDEO存在颜色还原不准确的问题，RealVideo就不太适合专业的场合，但RealVideo出色的压缩效率和支持流式播放的特征，使得RealVideo在网络和娱乐场合占有不错的市场份额。\n\n- *.MOV \nMOV格式，美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTimePlayer。具有较高的压缩比率和较完美的视频清晰度等特点，但是其最大的特点还是跨平台性，即不仅能支持MacOS，同样也能支持Windows系列,在所有视频格式当中，也许MOV格式是最不知名的。也许你会听说过QuickTime，MOV格式的文件正是由它来播放的。在PC几乎一统天下的今天，从Apple移植过来的MOV格式自然是受到排挤的。它具有跨平台、存储空间要求小的技术特点，而采用了有损压缩方式的MOV格式文件，画面效果较AVI格式要稍微好一些。到目前为止，它共有4个版本，其中以 4.0 版本的压缩率最好。这种编码支持16位图像深度的帧内压缩和帧间压缩，帧率每秒10帧以上。现在这种格式有些非编软件也可以对它时行处理，其中包括ADOBE公司的专业级多媒体视频处理软件AFTEREFFECT和PREMIERE。\n\n- *.ASF\n　ASF (Advanced Streaming format高级流格式)。ASF是MICROSOFT 为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了MPEG4的压缩算法，压缩率和图像的质量都很不错。因为ASF是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD差一点点并不出奇，但比同是视频“流”格式的RAM格式要好。 ASF支持任意的压缩/解压缩编码方式，并可以使用任何一种底层网络传输协议，具有很大的灵活性。ASF流文件的数据速率可以在28.8Kbps到3Mbps之间变化。用户可以根据自己应用环境和网络条件选择一个合适的速率，实现VOD点播和直播。\n\n- *.WMV\n　WMV是微软推出的一种流媒体格式，它是ASF的升级延伸，在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。微软希望用其取代QuickTime之类的技术标准以及WAV、AVI之类的文件扩展名。WMV的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。\n\n- *. NAVI\n　如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm的地下组织发展起来的一种新视频格式。它是由Microsoft ASF压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以NAVI为了追求这个目标，改善了原始的ASF格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI是一种去掉视频流特性的改良型ASF格式。\n\n- *.FLV\n\nFLV 是 FLASH VIDEO的简称，是由Macromedia公司开发的属于自己的流式视频格式。FLV也就是随着Flash MX的推出发展而来的视频格式，是在sorenson公司的压缩算法的基础上开发出来的。FLV格式不仅可以轻松的导入Flash中，速度极快，并且能其到保护版权的作用，并且可以不通过本地的微软或者REAL播放器播放视频。Flash MX 2004对其提供了完美的支持，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。\n\n\n## 视频文件转换：\n\n比较常见的视频格式转化有： \n\nRM→ASF\n\nAVI→RMVB\n\ndat-->divx\n\nmpg-->divx\n\nvcd-->rm\n\ndat-->rm\n\nmpg,dat、avi、mov-->rm\n\n*-->FLV\n\n最近视频博客的兴起，导致了flv的快速发展\n\n\nAVI→MPEG(MPEG－1)\n     例如有纪念性的家庭录影带，可以事先转换成AVI格式，再用软件将它转换成MPEG－1格式，然后用刻录器将MPEG－1格式文件刻录光盘片，得到的就是普通的VCD光盘了，可以拿到任何VCD播放器上播放。 \n\nMPEG(MPEG－1)→AVI\n       从MPEG到AVI文件之间的转换，为磁盘节省空间。\n\nMPEG(MPEG－1)→ASF\n       将vcd文件转码后实现VOD点播和直播。\n\n\nASF→MPEG(MPEG－1)\n      由于ASF视频格式的先天限制，一般来说它的图像质量往往比不上MPEG－1，所以转换之前，请三思而后行。\n        \nDVD(MPEG－2)→VCD (MPEG－1)\n       由于DVD驱动器尚未普及以及DVD光盘成本昂贵等客观原因，DVD影片一直未能像VCD一样流行。但我们可以将喜爱的DVD影片转换成MPEG－1格式的视频文件，留在硬盘上观看或是刻成VCD光盘。\n\ndat/mpg->mp3\n\nCD-->wav,mp3,wma\n\nrm-->mp3\n\nmp3-->wma\n\n以上列举的视频格式转化都是比较常见的，当然了，说到底，是有这方面的实际应用需求才会出现这方面的视频转化需要。\n比如说，要把一部VCD（也就是MPEG1编码的视频文件）制作成可以在线观看的影片，最大的瓶颈就在于文件尺寸的改变，并且要能够适应网络的特点，这样原始的格式就不能满足需  要，必须要转化成互联网视频播放规范的流媒体格式才可以，比如说是RM或者ASF，这就是需要，所以针对影像格式转化为流媒体格式的软件也就应用而生了，还有现在非常流行的MPEG4视频压缩技术，它能够把一张DVD压缩到一张CD上去，并且视频效果也不会有太大的变化，至少在我们普通用户看来也是非常不错的，而文件体积则大大减小了，这就要求有能够把DVD转化成MPEG4文件的软件出现，但是如果有人想要把RM转化成MPEG1（VCD），就没有太大的实际意义了，因为这样并不能给视频效果带来太大的提升，反而文件尺寸大了许多，所以我们很少能够看到这样的转化软件，其他的也类似，所以，在视频转化领域，可以参照以下两个原则：\n1 有明确的应用方向：就是说一种视频格式转化成另一种视频格式，必须要有明确的应用方向，即目标格式能够有很广泛的应用价值，而不是说为了转化而转化，比如上文所说的VCD->RM，它的应用方向就是网络播放，因为现在在线电影是一个很大的市场和网络的应用方向。\n2 能够提升播放价值： 就是说一种视频格式转化成另一种视频格式除了有明确的应用方向外，还要考虑转化是不是有价值，如果说转化后的文件播放效果没有明显提升，但是文件尺寸却大了一倍，我想这样亏本的买卖是没有人会去做的，RM转化成VCD就没有实际的意义，原因如前文所述，而DVD转化成MPEG4价值就很大，不说转化后的播放效果，单说成本就降低了不少。\n\n \n\n## 音视频压缩编码标准：\n\n多媒体编辑码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，现在主要的编码方式有：\n\n1.   MPEG系列： 视频编码方面主要是Mpeg1、Mpeg2、Mpeg4、Mpeg4 AVC； \n音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3、MPEG-2 AAC、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的\n2. H.26X系列：包括H261、H262、H263、H263+、H263++、H264\n\n2.   微软windows media系列：视频编码有Mpeg-4 v1/v2/v3、Windows Media Video 7/8/9/10；音频编码有Windows Media audeo v1/v2/7/8/9\n\n3.   Real Media系列： 视频编码有RealVideo G2、RealVideo 8/9/10；音频编码有RealAudio cook/sipro、RealAudio AAC/AACPlus等\n\n4.   QuickTime系列： 视频编码有Sorenson Video 3、Apple MPEG-4、Apple H.264；音频编码有QDesign Music 2、Apple MPEG-4 AAC\n\n5.   其它，如：Ogg、On2-vpx、flash vidio，以及M-JPEG视频压缩方式\n\n \n\n## 各视频编码的应用场合简要：\n<http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx>这里讲的挺详细的\n\n- 1.    Mpeg1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1；\n\n- 2.    在 MPEG-1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD-Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。\n\n- 3.    MPEG-3是MPEG组织制定的视频和音频压缩标准。本来的目标是为HDTV提供20-40Mbps视频压缩技术。在标准制定的过程中，委员会很快发现MPEG-2可以取得类似的效果。随后，MPEG-3项目停止了。\n\n- 4.    MPEG-4是为了适应网络的需求，采用一系列新技术，以最少的数据获得最佳的图像质量为目标的新一代编码方式。主要应用在数字电视、动态图像、互联网、实时多媒体监控、移动多媒体通信、Internet／intranet上的视频流与可视游戏、DVD上的交互多媒体应用等方面。Divx，xvid，ms mpeg4都是采用mpeg-4视频编码的。对于普通用户来说，MPEG-4在目前来说最有吸引力的地方还在于它能在普通CD-ROM上基本实现DVD的质量；用MPEG-4压缩算法的ASF(Advanced Streaming format，高级格式流)可以将120分钟的电影压缩为300MB左右的视频流；采用MPEG-4压缩算法的DIVX视频编码技术可以将120分钟的电影压缩600MB左右\n\n- 5.    Mpeg4 AVC和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编码方案之一，相信 AVC 的发展前途会非常好。AVC/H.264极有可能成为下一代视频格式，（avs，中国标准）\n\n- 6.    H.261是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。\n\n- 7.    H.262是由ITU-T的VCEG组织和ISO/IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是\"ITU-T建议H.262\"和\"ISO/IEC 13818-2\"。这两个标准在所有的文字叙述上都是相同的。\n\n- 8.    H.263是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的\n\n- 9.    H263+是H.263 的第二个版本，加入了许多新技术来扩展 H.263 的应用范围。\n\n- 10.H.263++是在 H.263+ 上增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。\n\n- 11.H.264也就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO/IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为H.264标准。\n\n- 12.Microsoft MPEG-4 v1/v2/v3，最早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来才进行了重写。\n\n- 13.Windows Media Video 7，Microsoft 正式开发的第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。\n\n- 14.Windows Media Video 8，在 WMV7 基础上改进的版本，质量上面进不了不少\n\n- 15.Windows Media Video 9，微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。\n\n- 16.RealVideo G2，早期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。\n\n- 17.RealVideo 8，随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。\n\n- 18.RealVideo 9，RealNetworks 开发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。\n\n- 19.RealVideo 10，在 RealVideo 9 基础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。\n\n- 20.Sorenson Video 3，Sorenson Media 公司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。\n\n- 21.Apple MPEG-4，Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。\n\n- 22.Apple H.264，Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。\n\n- 23.Ogg 是 Xiph.org 基金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为止 128kbps 码率上最好的编码器。\n\n- 24.On2 VPX系列，On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们就采用了 VP3，VP5，VP6 视频编码。\n\n- 25.Flash Video，Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。\n\n- 26.M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。\n\n \n\n## 各音频编码的应用场合简要：\n\n1.     MPEG Audio Layer 1典型数据压缩率是1：4，即每个立体声信号为384 kbps\n\n2.     MPEG Audio Layer 2典型数据压缩率是1：4---1：8，即每个立体声信号为256到192 kbps。MPEG Audio Layer1/2主要用于vcd，svcd的音频编码\n\n3.     MPEG Audio Layer 3，也就是大名鼎鼎的mp3，已经成为网络音频的主流格式，能在128kbps的码率下接近cd音质。典型数据压缩率是1：10---1：12，即每个立体声信号为128到112 kbps\n\n4.     MPEG-2 AAC（Advanced Audio Coding）是在1997年由以Bosi、Brandenburg、Johnston等为首的音频编码研究提出的，它总结了MPEG-1、MPEG-2和AC-3等的长处，在MPEG 系统上进一步改进了很多新的功能，大大增强了编码的灵活度，在保证音质的同时更大限度地压缩了码率。它和传统的mpeg audio不兼容，在理论上质量要高于mp3，并且支持多声道，在96kbps的码率范围内能接近cd音质，比mp3更加适合低码率传输；同时，MPEG-2 AAC已经成为MPEG-4标准中高质量音频编码的核心，是下一代音频压缩标准。\n\n5.     MPEG-4 AAC：是MPEG-4标准音频编码标准的一部分，apple公司自己开发有这种 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布\n\n6.     杜比数字AC-3技术也就是5.1声道技术\n\n7.     Windows Media Audio v1/v2，微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。\n\n8.     Windows Media Audio 7/8/9，随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化\n\n9.     Windows Media Audio 9 Professional，WMA9 中出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。\n\n10.  RealAudio Cook，早期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、RealAudio 8。\n\n11.  RealAudio Sipro，采用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。\n\n12.  RealAudio AAC，AAC 音频编码，用于 RealAudio 10 中。\n\n13.  RealAudio aacPlus，aacPlus 音频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。\n\n14.  QDesign Music 2，QDesign Music 的第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。\n\n15.  Apple MPEG-4 AAC，Apple 公司自己开发的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。\n\n \n\n \n\n \n\n## 四种主流的视频压缩编码标准：\n\n1、Windows Media Video 9\n\n　　相比起其他三种图像压缩技术，WMV可能是使用率最高的视频编码格式。原因十分简单，如果想使自己的影片直接给网上其他用户观看到的话，利用微软自身的视频编码标准是最简单的做法。因为只要用户的电脑中有Windows Media Player(媒体播放器)，就能够播放WMV影片，而且不用额外安装Codec（编码），所以兼容性方面完全不用担心。借助Windows Media 9.0 Series的新技术，Windows Media Video 9.0比旧的8.0版有多达15-50%的压缩率提高。而且与MPEG-4画质相比时，其容量大小只需一半即可达到。加上配合Windows Media Service 9.0服务器，在Streaming media（流媒体）方面也有更佳的表现。　　\n\n官方网站：http://www.microsoft.com\n\n2、Real Video 9\n\n玩电脑时间长的朋友都知道，Real Video是多年前市场上最普及的音乐、图像格式。不过随着MP3、WMV及WMV等的兴起，已经使Real Media格式的普及率大不如前。但现在全世界仍然有许多的电脑玩家是Real Video的支持者，网上供下载的影片很多也是RM或RMVB格式。　RealNetwork新推出了一套名为Helix Producer的工具（也就是Real Producer 9），其中的RealVideo 9在图像压缩编码技术方面作出重大优化，无论在下载或Streaming时都声称比Windows Media 9出色，能够以一半的比特速率（bitrate）达到MPEG-4级图像，在约500 Kbps时达到接近DVD的画质表现。同样地，配合服务器可获得更出色的效果。\n\n官方网址：http://www.realnetworks.com\n\n \n\n3、DivX\n\n　　历史介绍：\n\nISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。\n\n1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MS MPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS　MPEG4V3才开始有好转，画质有了显著的进步，但是不知微软出于什么目的，却将这个MS　MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是广为流传的MPEG编码器－DivX3.11。\n\nDivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展的大潮是势不可挡了。\n\n看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO　MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。\n\n接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码--XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。\n\nDivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。\n\n官方网站：http://www.divx.com\n\n4、Koepi's XviD Codec\n\n相比起前三种视频编码标准来说，Xvid推出市场的时间最迟。从其名字就知道这种标准是针对DivX而来的。原来，DivX由免费转为收费编码后，使部份原有开发人员不满，继而离开并组成一个新的开发小组，设计免费且开放源代码的XviD Codec。当前，Koepi和Nic的XviD都是比较活跃和最多人使用的版本，虽然两者在编译上有所不同，但实际做出的效果相差无几。Xivd与DivX一样，在编译后都是一个.AVI文件，播放时只要安装Xvid codec就能用Windows媒体播放器中播放。\n\n官方网站：http://roeder.goe.net/~koepi\n\n \n\n## 视频压缩基本概念：\n一、有损和无损压缩：在视频压缩中有损（Lossy）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。\n\n二、帧内和帧间压缩：帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。\n    采用帧间（Interframe）压缩是基于许多视频或动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。\n\n三、对称和不对称编码：对称性（symmetric）是压缩编码的一个关键特征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。\n\n \n\n第三部分：音频文件格式\n\n \n\n## 一些音视频的参数含义:\n\n声道：目前人们所使用的各种声场技术规范非常多，但最常见的几乎都来自三家公司，他们是Dolby（杜比）、HTX和DTS。声卡所支持的声道数是衡量声卡档次的重要指标之一，从单声道到最新的环绕立体声，下面一一详细介绍：1.单声道：单声道是比较原始的声音复制形式，早期的声卡采用的比较普遍。当通过两个扬声器回放单声道信息的时候，我们可以明显感觉到声音是从两个音箱中间传递到我们耳朵里的。这种缺乏位置感的录制方式用现在的眼光看自然是很落后的，但在声卡刚刚起步时，已经是非常先进的技术了。2.立体声：单声道缺乏对声音的位置定位，而立体声技术则彻底改变了这一状况。声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果。这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自的方向，从而使音乐更富想象力，更加接近于临场感受。立体声技术广泛运用于自Sound Blaster Pro以后的大量声卡，成为了影响深远的一个音频标准。时至今日，立体声依然是许多产品遵循的技术标准。3.准立体声：准立体声声卡的基本概念就是：在录制声音的时候采用单声道，而放音有时是立体声，有时是单声道。采用这种技术的声卡也曾在市面上流行过一段时间，但现在已经销声匿迹了。4.四声道环绕：人们的欲望是无止境的，立体声虽然满足了人们对左右声道位置感体验的要求，但是随着技术的进一步发展，大家逐渐发现双声道已经越来越不能满足我们的需求。由于PCI声卡的出现带来了许多新的技术，其中发展最为神速的当数三维音效。三维音效的主旨是为人们带来一个虚拟的声音环境，通过特殊的HRTF技术营造一个趋于真实的声场，从而获得更好的游戏听觉效果和声场定位。而要达到好的效果，仅仅依靠两个音箱是远远不够的，所以立体声技术在三维音效面前就显得捉襟见肘了，但四声道环绕音频技术则很好的解决了这一问题。四声道环绕规定了4个发音点：前左、前右，后左、后右，听众则被包围在这中间。同时还建议增加一个低音音箱，以加强对低频信号的回放处理(这也就是如今4.1声道音箱系统广泛流行的原因)。就整体效果而言，四声道系统可以为听众带来来自多个不同方向的声音环绕，可以获得身临各种不同环境的听觉感受，给用户以全新的体验。如今四声道技术已经广泛融入于各类中高档声卡的设计中，成为未来发展的主流趋势。5.5.1声道5.1声道已广泛运用于各类传统影院和家庭影院中，一些比较知名的声音录制压缩格式，譬如杜比AC-3（Dolby Digital）、DTS等都是以5.1声音系统为技术蓝本的。其实5.1声音系统来源于4.1环绕，不同之处在于它增加了一个中置单元。这个中置单元负责传送低于80Hz的声音信号，在欣赏影片时有利于加强人声，把对话集中在整个声场的中部，以增加整体效果。相信每一个真正体验过Dolby AC-3音效的朋友都会为5.1声道所折服。千万不要以为5.1已经是环绕立体声的顶峰了，更强大的7.1系统已经出现了。它在5.1的基础上又增加了中左和中右两个发音点，以求达到更加完美的境界。由于成本比较高，没有广泛普及。\n\n \n\n \n\n一.WMA\n　　WMA的全称是Windows Media Audio，是微软力推的一种音频格式。WMA格式是以减少数据流量但保持音质的方法来达到更高的压缩率目的，其压缩率一般可以达到1:18，生成的文件大小只有相应MP3文件的一半。此外，WMA还可以通过DRM（Digital Rights Management）方案加入防止拷贝，或者加入限制播放时间和播放次数，甚至是播放机器的限制，可有力地防止盗版。\n\n优点 \nWMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小一倍而音质不变，也得到了兑现。事实上，这个说法，仅仅适用于低比特率的情况，另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比相同的MP3体积少1/3左右。\n缺点 \n在高比率的渲染能力低下，同音源的一个320KBPS的MP3与比较192KBPS的WMA相比，音质和渲染力很容易分别出是前者较优。\n\n　　二.VQF\n　　VQF即TwinVQ（Transform－domain Weighted Interleave Vector Quantization），是由NTT（Nippon Telegraph and Telephone）与Yamaha共同开发的一种音频压缩技术。VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。\n\n但是VQF不支持\"流\"，这可能也是为什么现在它完全被WMA压下去的一个主要原因.\n\n　　三.MP3\nMP3的全称是Moving Picture Experts Group Audio Layer III。简单的说，MP3就是一种音频压缩技术，由于这种压缩方式的全称叫MPEG Audio Layer3，所以人们把它简称为MP3。MP3是利用MPEG Audio Layer 3的技术，将音乐以1:10甚至1:12 的压缩率，压缩成容量较小的file，换句话说，能够在音质丢失很小的情况下把文件压缩到更小的程度。而且还非常好的保持了原来的音质。正是因为MP3体积小，音质高的特点使得MP3格式几乎成为网上音乐的代名词。每分钟音乐的MP3格式只有1MB左右大小，这样每首歌的大小只有3-4兆字节。使用MP3播放器对MP3文件进行实时的解压缩(解码)，这样，高品质的MP3音乐就播放出来了。　　\n\nMP3最受争议的就是音质问题(尤其是随着WMA的普及)，其高频损失很大，很多MP3编码器粗糙的编码算法不但导致高频丢失，还丢失了许多细节，类似吉他擦弦的感觉在MP3中是找不到的.在对MP3快要失望时，偶发现了Lame,它支持根据人耳遮蔽效应原理来分析波形，配合VBR技术，可以让音质达到令人吃惊的地步;其独创的心理音响模型技术保证了CD音频还原的真实性，配合VBR(动态比特率)和ABR(平均比特率)参数，编码出来的MP3音色纯厚、空间宽广、低音清晰、细节表现良好,音质几乎可以媲美CD音频，但文件体积却非常小.很多网友在使用LAME后的反映就是：立刻删除硬盘上所有的MP3和其他编码器，全部用Lame重新来过。Lame提供EXE和DLL，其中DLL是作为标准的动态运行库供其他程序调用.EXE是Command Line程序，象DOS程序一样工作，两者彼此独立，互不关联。但大家很快能发现两者编码的质量是不一样的,那是由于dll可控性差，与具备丰富调节参数的EXE版相比，其压缩出来的MP3效果稍逊一筹。但EXE是一个命令行工具，操作很麻烦，幸亏有了WinLAMEr或lameGUIxp这些Shell。只要学会使用这些Shell(是傻瓜型的,一看即会)，就可以用LAME压缩出最最精彩的MP3了。再说说APS,在LAME出现以前，APS就是最好的MP3编码器，它使用的Fraunhofer IIS编码算法，这比LAME使用的编码算法要先进，在192k Bitrate(CBR)下，甚至比LAME编码的曲子要优秀，细节明显要丰富一些，但APS本身不支持VBR，当Bitrate往上提高时，音质就要比LAME编码的要差了，大部分朋友的MP3的一般都是128-192K Bitrate的，因此APS仍旧有推荐的价值。特别是有很多MP3随身听不支持VBR和256K Bitrate以上的MP3，LAME就不一定合适这些朋友了，APS就成了不错的选择，由它编码的曲子，绝对不会辱没你昂贵的PLAYER.\n\n　　四.MP3PRO\n　　MP3PRO完全是基于传统MP3编码技术的一种改良，本身最大的技术亮点就在于SBR(Spectral Band Replication频段复制),这是一种新的音频编码增强算法.它提供了改善低位率情况下音频和语音编码的性能的可能.这种方法可在指定的位率下增加音频的带宽或改善编码效率,SBR最大的优势就是在低数据速率下实现非常高效的编码.如果在高数据速率的情况下，SBR将如同虚设.当制作MP3PRO文件时，编码器将音频分为两部分。一部分是将音频数据中的低频段部分分离出来，通过传统的MP3技术而编码得出的正常的MP3音频流，此举可令到MP3编码器可以专注于低频段信号从而获得更好的压缩质量，而且原来的MP3播放器也可播放MP3PRO文件。另一部分则是将分离出来的高频段信号进行编码并嵌入到MP3流中，传统的MP3播放器会将其忽略掉，而新的MP3PRO播放器则可从中还原出高频信号，并将两者进行组合，得到高质量的全带宽的声音.官方宣称通过这样的技术，使得MP3PRO能在64kbps的编码率便可提供与128kbps的mp3相同的质量。低比特率下MP3PRO的性能很明显地比MP3要高,但是它与WMA谁胜谁负就很难说了,根据一些发烧友的评测, MP3PRO似乎略胜一些.高比特率下很少有人用到MP3PRO.\n\n \n\n五.OGG\n　　OGG格式的全称应该是OGG Vobis。它是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。OGG Vobis有一个很出众的特点，就是支持多声道，随着它的流行，以后用随身听来听DTS编码的多声道作品将不会是梦想。OGG Vobis在压缩技术上比MP3好，而且它的多声道，免费，开源这些特点，使它很有可能成为一个流行的趋势，这也正是一些MP3播放器对其支持的原因\n\n在高音质要求下,有损音频编码世界中是三足项立，分别为MP3、MPC、OGG。　\n\nOgg Vorbis中的主要算法还是利用MDCT（修饰离散余弦变换Modified Discrete Cosine Transform ）而不是用现在比较时兴的小波（wavelet）技术。Ogg的多通道编码技术，统称为立体声通道耦合Stereo Channel Coupling。而该技术实际又是由两种不同的技术组成的：channel interleaving 和 square polar mapping，而这也是Ogg能成为免费制式的一个必要条件，以往的“联合立体声Joint Stereo”的编码模式是有专利限制的。据官方声称，与其他会造成立体空间感减弱的编码模型相比，这两种技术都可以在保持编码器的灵活性的同时而不损害本来的立体声空间影像――相信配合iRiver的3d音效会有更好的表现力，而且实现的复杂程度比联合立体声方式要低。\n　　OGG Vorbis这种编码也远比90年代开发成功的MP3先进，它可以在相对较低的数据速率下实现比MP3更好的音质！――我认为Ogg很象MD的atrac格式，特别象新的lp2编码，它能在低别特率下有着很要的音质。此外，在编码上，Ogg Vorbis是使用了VBR（可变比特率）和ABR（平均比特率）方式进行编码，所以理论上，Ogg Vorbis带来的音乐可以比采用CBR文件有更好的声音表现，当然前提是两者使用同样比特率(Bit Rate)的压缩模式――这里可以知道。Ogg Vorbis的比特率缩放功能可以在不用重新编码的情况下调节文件的相关压缩率，与此同时，Ogg文件的单位编辑能力和超越左右声道的音频流技术可以带来更为奇妙的音乐享受。Vorbis还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。\n　　Vorbis文件可以被分成小块并以样本粒度（granularity，专业术语，指数据可以被分割的最小尺寸）进行编辑；Vorbis支持多通道（大于2）音频流并使用了独创性的处理技术；这意味着什么？这意味着Ogg Vorbis在SACD、DTSCD、DVD AUDIO抓轨软件（目前这种软件还没有）的支持下，可以对所有的声道进行编码，而不是MP3只能编码2个声道。多声道音乐的兴起，给音乐欣赏带来了革命性的变化，尤其在欣赏交响时，会带来更多临场感。这场革命性的变化是MP3无法适应的。在以后的播放技术不断提高以后，而且人们对音质要求不断提高，Ogg的优势将更加明显。\n　　六. MPC\n　　MusePaCk是由德国人Andree Buschmann开发的一种完全免费的高品质音频格式。在其问世之前，Lame MP3是公认音质最好的有损压缩方案，追求音质的人对它趋之若鹜。但现在这个桂冠无疑该让给MPC了，在中高码率下，MPC可以做到比MP3更好音质。在高码率下，MPC的高频要比MP3细腻不少，可以在节省大量空间的前提下获得最佳音质的音乐欣赏，是目前最适合用于音乐欣赏的有损编码。\n\nMPC的编码方案是在MP2的基础上改进而来。它同样采用子带编码技术，但相比MP2，它所采用的心理声学模型要优秀得多，并加入了像ANS（Adaptive Noise Shaping）、CVD(ClearVoiceDetection)等技术，甚至改变了压缩时所用的Huffman（哈夫曼）编码，以得到更大的压缩率。另外，MPC采用的是可变码率进行编码。毫无疑问，可变码率的编码效率要高于固定码率，因为前者可以合理地分配数据量，在信号复杂（微弱）时提高（降低）比特率，在得到满意的效果又能确保不错的压缩率。为了保证高音质，MPC的瞬间最大码率甚至高达1.32Mbps，这已经快接近CD的1.41Mbps了\n\n较高比特率下(250kbps左右),MPC表现非常的出众,甚至超过了MP3，很难分辨它和原始信号有多少区别，无论从频率保留还是细节保留，以及信号强度失真来说，MPC太优秀了.但MPC并非万能的，它无法编码48khz采样率的曲子，所幸的是，这样的曲子来源很少.可惜这种格式并没有像MP3或WMA那样流行.\n\n　　七.ATRAC\n　　ATRAC（Adaptive TRansform Acoustic Coding自适应声学转换编码技术）：是Sony的原创音乐压缩技术，主要用于MD Walkman的录音及播放方面。是一项基于听觉心理学领域的研究和不损伤可闻声质量的数码音频译码压缩技术，对音乐资讯有效的进行压缩，压缩的比率为原来的五分之一，因为MD使用了ATRAC压缩技术，这样的压缩大大节省了许多空间，所以 CD的碟片要120mm大小，而MD只需64mm就可以录下74分钟的音乐。\n\nATRAC压缩技术主要是利用了人耳的蔽遮效应，在心理声学原理上，在进行音频录入的同时，有许多外部的频段同时也会被录入，当人耳同时听到两个不同频率、不同音量的声音时，音量较小的低频及音量较小的高频连同不为人耳所察觉的频段信号都会被自动减弱或忽略不予记录，因此又可以称为适应性变换声码技术，由于近年來编码压缩技术（ATRAC的版本）越來越成熟，所以经过编码解码过程后的声音仍直逼CD，大家就不必担心音质差啦。\n\nATRAC将16比特44.1KHz的数字信号以频率响应轴分成52个区段（在低频时分割较细而在高频时分割较粗），根据声音心理学的原理，将声音信号中人耳听不到和对人的听力影响不大的信息给剔除出去而达到缩小声音文件的目的。利用这种原理，ATRAC可以将录音的资料量压缩为原来的五分之一（即压缩比为1：5）。\n\n.\n\n　　八. APE　\n　　  APE的本质，其实它是一种无损压缩音频格式。庞大的WAV音频文件可以通过Monkey''s Audio这个软件进行“瘦身”压缩为APE。很时候它被用做网络音频文件传输，因为被压缩后的APE文件容量要比WAV源文件小一半多，可以节约传输所用的时间。更重要的是，通过Monkey''s Audio解压缩还原以后得到的WAV文件可以做到与压缩前的源文件完全一致。所以APE被誉为“无损音频压缩格式”，Monkey''s Audio被誉为“无损音频压缩软件”。与采用WinZip或者WinRAR这类专业数据压缩软件来压缩音频文件不同，压缩之后的APE音频文件是可以直接被播放的。 Monkey''s Audio会向Winamp中安装一个“in_APE.dll”插件，从而使Winamp也具备播放APE文件的能力。 \n\n和上面介绍的几款编码不同的是，这个编码提供了最好的音质保证(无损压缩)！还提供了Winamp的插件支持,可以直接用Winamp来播放.所谓无损就是指压缩后的格式和源文件在音质上并无差异，而Mp3、WMA等的编码方案是基于有损的，在损失部分音质的前提下节约存贮空间，所以说音质再好的Mp3、WMA也只能是无限接近源文件的音质。APE非常适合来编码讲究细节的独奏曲目和大动态的交响曲。向各位音乐迷们(不是歌迷)作最强烈的推荐！它的压缩比约为2:1.\n\n　　九. WAV\n　　WAV是录音时用的标准的windows文件格式，文件的扩展名为“.wav”，WAVE文件作为最经典的Windows多媒体音频格式，应用非常广泛。声道有单声道和立体声之分，采样频率一般有11kHz、22kHz和44kHz三种。\n\nWAVE文件所占容量=（采样频率×采样位数×声道）×时间/8（1字节=8bit）。\n\n　　WAV文件与MIDIMP3这类多媒体声音文件比较起来，所占的硬盘空间要大得多，但WAV文件的回放效果是最好的，WAV文件直接反映了一个声音在每个时刻的大小值，1分钟44khz采样率的WAV文件就会占用10M硬盘空间！\n\n它通常作为制作高质量音乐的中间体\n　　十.RM\n　　Real Networks公司所制定的音频视频压缩规范称为Real Media，用户可以使用RealPlayer或RealOne Player对符合RealMedia技术规范的网络音频/视频资源进行实况转播并且RealMedia可以根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。这种格式的另一个特点是用户使用RealPlayer或RealOne Player播放器可以在不下载音频/视频内容的条件下实现在线播放。另外，RM作为目前主流网络视频格式，它还可以通过其Real Server服务器将其它格式的视频转换成RM视频并由Real Server服务器负责对外发布和播放。RM和ASF格式可以说各有千秋，通常RM视频更柔和一些，而ASF视频则相对清晰一些。\n  RM格式一开始就定位在视频流应用方面，也可以说是视频流技术的始创者。它可以在用56 K Modem拨号上网的条件下实现不间断的视频播放，当然，其图像质量和MPEG2，DIVX等相比有一定差距，毕竟要实现在网上传输不间断的视频是需要很大带宽的。\n\nRM已经是昨日黄花，没有任何新意，低Bitrate比不过WMA，高Bitrate比不过MP3，虽然新的RM导入了ATRAC3算法，但颓势已定，很难东山再起了。\n","source":"_posts/2015/转-音视频基础概念汇总.md","raw":"---\ntitle: (转)音视频基础概念汇总\ndate: 2015-07-17 19:56:08\ntags:\n- 流媒体\ncategories: 基础\n---\n\n## 第一部分：基本概念讲解\n\n- 媒体：是表示，传输，存储信息的载体，常人们见到的文字、声音、图像、图形等都是表示信息的媒体。\n<!--more-->\n- 多媒体： 是声音、动画、文字、图像和录像等各种媒体的组合，以图文并茂，生动活泼的动态形式表现出来，给人以很强的视觉冲击力，留下深刻印象\n\n- 多媒体技术：是将文字、声音、图形、静态图像、动态图像与计算集成在一起的技术。它要解决的问题是计算机进一步帮助人类按最自然的和最习惯的方式接受和处理信息。\n\n- 流媒体 ：流媒体是指采用流式传输的方式在Internet播放的连续时基媒体格式，实际指的是一种新的媒体传送方式，而不是一种新的媒体格式（在网络上传输音/视频等多媒体信息现在主要有下载和流式传输两种方式）流式传输分两种方法：实时流式传输方式(Realtime streaming)和顺序流式传输方式(progressive streaming)。\n\n- 多媒体文件：是既包括视频又包括音频，甚至还带有脚本的一个集合，也可以叫容器；\n\n- 媒体编码：是文件当中的视频和音频所采用的压缩算法。也就是说一个avi的文件，当中的视频编码有可能是A，也可能是B，而其音频编码有可能是1，也有可能是2。  转码 ：指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式\n\n- 视频：连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频\n\n- 音频 ：人类能听到的声音都成为音频，但是一般我们所说到的音频时存储在计算机里的声音\n\n## 第二部分：视频文件格式\n\n- 码率：码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质.\n \n- 帧：帧就是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。\n \n\n- 帧率：帧率即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。\n关键帧：相当于二维动画中的原画，指角色或者物体运动或变化中的关键动作所处的那一帧，它包含了图像的所有信息，后来帧仅包含了改变了的信息。如果你没有足够的关键帧，你的影片品质可能比较差，因为所有的帧从别的帧处产生。对于一般的用途，一个比较好的原则是每5秒设一个关键键。但如果时那种实时传输的流文件，那么要考虑传输网络的可靠度，所以要1到2秒增加一个关键帧。目前我们经常见的视频格式无非就是两大类： \n1、影像格式（Video）\n2、流媒体格式（Stream Video）\n\n在影像格式中还可以根据出处划分为三大种： \n1、AVI格式：这是由微软（Microsoft）提出，具有“悠久历史”的一种视频格式\n2、MOV格式：这是由苹果（Apple）公司提出的一种视频格式\n3、MPEG/MPG/DAT：这是由国际标准化组织ISO(International Standards Organization)与IEC(International Electronic Committee)联合开发的一种编码视频格式。MPEG是运动图像压缩算法的国际标准，现已被几乎所有的计算机平台共同支持。\n\n在流媒体格式中同样还可以划分为三种： \n1、RM格式：这是由Real Networks公司开发的一种新型流式视频文件格式。\n2、MOV/QT格式：MOV也可以作为一种流文件格式。QuickTime能够通过Internet提供实时的数字化信息流、工作流与文件回放功能，为了适应这一网络多媒体应用，QuickTime为多种流行的浏览器软件提供了相应的QuickTime Viewer插件（Plug－in），能够在浏览器中实现多媒体数据的实时回放。\n3、ASF格式：这是由微软公司开发的流媒体格式，是一个在Internet上实时传播多媒体的技术标准。\n4、FLV\n\n\n## 具体视频文件格式详解：\n\n- *. MPEG/.MPG/.DAT \nMPEG也是Motion Picture Experts Group的缩写。这类格式包括了MPEG-1, MPEG-2和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在VCD的制作和一些视频片段下载的网络应用上面，大部分的VCD都是用 MPEG1格式压缩的( 刻录软件自动将MPEG1转为.DAT格式)，使用 MPEG-1的压缩算法，可以把一部 120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2则是应用在DVD 的制作，同时在一些HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB的大小（MPEG2的图像质量MPEG-1与其无法比拟的）。\n\n- *.AVI\n　它的英文全称为Audio Video Interleaved，即音频视频交错格式。是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，但压缩比较高，因此尽管面面质量不是太好，但其应用范围仍然非常广泛。AVI支持256色和RLE压缩。AVI信息主要应用在多媒体光盘上，用来保存电视、电影等各种影像信息。它于1992年被Microsoft公司推出，随Windows3.1一起被人们所认识和熟知。所谓“音频视频交错”，就是可以将视频和音频交织在一起进行同步播放。这种视频格式的优点是图像质量好，可以跨多个平台使用，其缺点是体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本Windows媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本Windows媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题，如果用户在进行AVI格式的视频播放时遇到了这些问题，可以通过下载相应的解码器来解决。是目前视频文件的主流。 这种格式的文件随处可见，比如一些游戏、教育软件的片头，多媒体光盘中，都会有不少的 AVI 。现在，在WINDOWS 95或98里都能直接播放AVI，同一种格式的avi文件有可能采用不同的编码方式，最常见的有Intel Indeo（R）Video R3.2（像游戏过场动画等，是目前使用最广泛的一种avi编码技术）、Microsoft video 等。\n\n- *.RA/RM/RAM\n　*.RM，Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash（Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO（RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，从RealVideo的定位来看，就是牺牲画面质量来换取可连续观看性。其实RealVideo也可以实现不错的画面质量，由于RealVideo可以拥有非常高的压缩效率，很多人把VCD编码成RealVideo格式的，这样一来，一张光盘上可以存放好几部电影。REAL VIDEO存在颜色还原不准确的问题，RealVideo就不太适合专业的场合，但RealVideo出色的压缩效率和支持流式播放的特征，使得RealVideo在网络和娱乐场合占有不错的市场份额。\n\n- *.MOV \nMOV格式，美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTimePlayer。具有较高的压缩比率和较完美的视频清晰度等特点，但是其最大的特点还是跨平台性，即不仅能支持MacOS，同样也能支持Windows系列,在所有视频格式当中，也许MOV格式是最不知名的。也许你会听说过QuickTime，MOV格式的文件正是由它来播放的。在PC几乎一统天下的今天，从Apple移植过来的MOV格式自然是受到排挤的。它具有跨平台、存储空间要求小的技术特点，而采用了有损压缩方式的MOV格式文件，画面效果较AVI格式要稍微好一些。到目前为止，它共有4个版本，其中以 4.0 版本的压缩率最好。这种编码支持16位图像深度的帧内压缩和帧间压缩，帧率每秒10帧以上。现在这种格式有些非编软件也可以对它时行处理，其中包括ADOBE公司的专业级多媒体视频处理软件AFTEREFFECT和PREMIERE。\n\n- *.ASF\n　ASF (Advanced Streaming format高级流格式)。ASF是MICROSOFT 为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了MPEG4的压缩算法，压缩率和图像的质量都很不错。因为ASF是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD差一点点并不出奇，但比同是视频“流”格式的RAM格式要好。 ASF支持任意的压缩/解压缩编码方式，并可以使用任何一种底层网络传输协议，具有很大的灵活性。ASF流文件的数据速率可以在28.8Kbps到3Mbps之间变化。用户可以根据自己应用环境和网络条件选择一个合适的速率，实现VOD点播和直播。\n\n- *.WMV\n　WMV是微软推出的一种流媒体格式，它是ASF的升级延伸，在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。微软希望用其取代QuickTime之类的技术标准以及WAV、AVI之类的文件扩展名。WMV的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。\n\n- *. NAVI\n　如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm的地下组织发展起来的一种新视频格式。它是由Microsoft ASF压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以NAVI为了追求这个目标，改善了原始的ASF格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI是一种去掉视频流特性的改良型ASF格式。\n\n- *.FLV\n\nFLV 是 FLASH VIDEO的简称，是由Macromedia公司开发的属于自己的流式视频格式。FLV也就是随着Flash MX的推出发展而来的视频格式，是在sorenson公司的压缩算法的基础上开发出来的。FLV格式不仅可以轻松的导入Flash中，速度极快，并且能其到保护版权的作用，并且可以不通过本地的微软或者REAL播放器播放视频。Flash MX 2004对其提供了完美的支持，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。\n\n\n## 视频文件转换：\n\n比较常见的视频格式转化有： \n\nRM→ASF\n\nAVI→RMVB\n\ndat-->divx\n\nmpg-->divx\n\nvcd-->rm\n\ndat-->rm\n\nmpg,dat、avi、mov-->rm\n\n*-->FLV\n\n最近视频博客的兴起，导致了flv的快速发展\n\n\nAVI→MPEG(MPEG－1)\n     例如有纪念性的家庭录影带，可以事先转换成AVI格式，再用软件将它转换成MPEG－1格式，然后用刻录器将MPEG－1格式文件刻录光盘片，得到的就是普通的VCD光盘了，可以拿到任何VCD播放器上播放。 \n\nMPEG(MPEG－1)→AVI\n       从MPEG到AVI文件之间的转换，为磁盘节省空间。\n\nMPEG(MPEG－1)→ASF\n       将vcd文件转码后实现VOD点播和直播。\n\n\nASF→MPEG(MPEG－1)\n      由于ASF视频格式的先天限制，一般来说它的图像质量往往比不上MPEG－1，所以转换之前，请三思而后行。\n        \nDVD(MPEG－2)→VCD (MPEG－1)\n       由于DVD驱动器尚未普及以及DVD光盘成本昂贵等客观原因，DVD影片一直未能像VCD一样流行。但我们可以将喜爱的DVD影片转换成MPEG－1格式的视频文件，留在硬盘上观看或是刻成VCD光盘。\n\ndat/mpg->mp3\n\nCD-->wav,mp3,wma\n\nrm-->mp3\n\nmp3-->wma\n\n以上列举的视频格式转化都是比较常见的，当然了，说到底，是有这方面的实际应用需求才会出现这方面的视频转化需要。\n比如说，要把一部VCD（也就是MPEG1编码的视频文件）制作成可以在线观看的影片，最大的瓶颈就在于文件尺寸的改变，并且要能够适应网络的特点，这样原始的格式就不能满足需  要，必须要转化成互联网视频播放规范的流媒体格式才可以，比如说是RM或者ASF，这就是需要，所以针对影像格式转化为流媒体格式的软件也就应用而生了，还有现在非常流行的MPEG4视频压缩技术，它能够把一张DVD压缩到一张CD上去，并且视频效果也不会有太大的变化，至少在我们普通用户看来也是非常不错的，而文件体积则大大减小了，这就要求有能够把DVD转化成MPEG4文件的软件出现，但是如果有人想要把RM转化成MPEG1（VCD），就没有太大的实际意义了，因为这样并不能给视频效果带来太大的提升，反而文件尺寸大了许多，所以我们很少能够看到这样的转化软件，其他的也类似，所以，在视频转化领域，可以参照以下两个原则：\n1 有明确的应用方向：就是说一种视频格式转化成另一种视频格式，必须要有明确的应用方向，即目标格式能够有很广泛的应用价值，而不是说为了转化而转化，比如上文所说的VCD->RM，它的应用方向就是网络播放，因为现在在线电影是一个很大的市场和网络的应用方向。\n2 能够提升播放价值： 就是说一种视频格式转化成另一种视频格式除了有明确的应用方向外，还要考虑转化是不是有价值，如果说转化后的文件播放效果没有明显提升，但是文件尺寸却大了一倍，我想这样亏本的买卖是没有人会去做的，RM转化成VCD就没有实际的意义，原因如前文所述，而DVD转化成MPEG4价值就很大，不说转化后的播放效果，单说成本就降低了不少。\n\n \n\n## 音视频压缩编码标准：\n\n多媒体编辑码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，现在主要的编码方式有：\n\n1.   MPEG系列： 视频编码方面主要是Mpeg1、Mpeg2、Mpeg4、Mpeg4 AVC； \n音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3、MPEG-2 AAC、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的\n2. H.26X系列：包括H261、H262、H263、H263+、H263++、H264\n\n2.   微软windows media系列：视频编码有Mpeg-4 v1/v2/v3、Windows Media Video 7/8/9/10；音频编码有Windows Media audeo v1/v2/7/8/9\n\n3.   Real Media系列： 视频编码有RealVideo G2、RealVideo 8/9/10；音频编码有RealAudio cook/sipro、RealAudio AAC/AACPlus等\n\n4.   QuickTime系列： 视频编码有Sorenson Video 3、Apple MPEG-4、Apple H.264；音频编码有QDesign Music 2、Apple MPEG-4 AAC\n\n5.   其它，如：Ogg、On2-vpx、flash vidio，以及M-JPEG视频压缩方式\n\n \n\n## 各视频编码的应用场合简要：\n<http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx>这里讲的挺详细的\n\n- 1.    Mpeg1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1；\n\n- 2.    在 MPEG-1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD-Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。\n\n- 3.    MPEG-3是MPEG组织制定的视频和音频压缩标准。本来的目标是为HDTV提供20-40Mbps视频压缩技术。在标准制定的过程中，委员会很快发现MPEG-2可以取得类似的效果。随后，MPEG-3项目停止了。\n\n- 4.    MPEG-4是为了适应网络的需求，采用一系列新技术，以最少的数据获得最佳的图像质量为目标的新一代编码方式。主要应用在数字电视、动态图像、互联网、实时多媒体监控、移动多媒体通信、Internet／intranet上的视频流与可视游戏、DVD上的交互多媒体应用等方面。Divx，xvid，ms mpeg4都是采用mpeg-4视频编码的。对于普通用户来说，MPEG-4在目前来说最有吸引力的地方还在于它能在普通CD-ROM上基本实现DVD的质量；用MPEG-4压缩算法的ASF(Advanced Streaming format，高级格式流)可以将120分钟的电影压缩为300MB左右的视频流；采用MPEG-4压缩算法的DIVX视频编码技术可以将120分钟的电影压缩600MB左右\n\n- 5.    Mpeg4 AVC和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编码方案之一，相信 AVC 的发展前途会非常好。AVC/H.264极有可能成为下一代视频格式，（avs，中国标准）\n\n- 6.    H.261是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。\n\n- 7.    H.262是由ITU-T的VCEG组织和ISO/IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是\"ITU-T建议H.262\"和\"ISO/IEC 13818-2\"。这两个标准在所有的文字叙述上都是相同的。\n\n- 8.    H.263是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的\n\n- 9.    H263+是H.263 的第二个版本，加入了许多新技术来扩展 H.263 的应用范围。\n\n- 10.H.263++是在 H.263+ 上增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。\n\n- 11.H.264也就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO/IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为H.264标准。\n\n- 12.Microsoft MPEG-4 v1/v2/v3，最早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来才进行了重写。\n\n- 13.Windows Media Video 7，Microsoft 正式开发的第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。\n\n- 14.Windows Media Video 8，在 WMV7 基础上改进的版本，质量上面进不了不少\n\n- 15.Windows Media Video 9，微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。\n\n- 16.RealVideo G2，早期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。\n\n- 17.RealVideo 8，随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。\n\n- 18.RealVideo 9，RealNetworks 开发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。\n\n- 19.RealVideo 10，在 RealVideo 9 基础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。\n\n- 20.Sorenson Video 3，Sorenson Media 公司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。\n\n- 21.Apple MPEG-4，Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。\n\n- 22.Apple H.264，Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。\n\n- 23.Ogg 是 Xiph.org 基金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为止 128kbps 码率上最好的编码器。\n\n- 24.On2 VPX系列，On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们就采用了 VP3，VP5，VP6 视频编码。\n\n- 25.Flash Video，Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。\n\n- 26.M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。\n\n \n\n## 各音频编码的应用场合简要：\n\n1.     MPEG Audio Layer 1典型数据压缩率是1：4，即每个立体声信号为384 kbps\n\n2.     MPEG Audio Layer 2典型数据压缩率是1：4---1：8，即每个立体声信号为256到192 kbps。MPEG Audio Layer1/2主要用于vcd，svcd的音频编码\n\n3.     MPEG Audio Layer 3，也就是大名鼎鼎的mp3，已经成为网络音频的主流格式，能在128kbps的码率下接近cd音质。典型数据压缩率是1：10---1：12，即每个立体声信号为128到112 kbps\n\n4.     MPEG-2 AAC（Advanced Audio Coding）是在1997年由以Bosi、Brandenburg、Johnston等为首的音频编码研究提出的，它总结了MPEG-1、MPEG-2和AC-3等的长处，在MPEG 系统上进一步改进了很多新的功能，大大增强了编码的灵活度，在保证音质的同时更大限度地压缩了码率。它和传统的mpeg audio不兼容，在理论上质量要高于mp3，并且支持多声道，在96kbps的码率范围内能接近cd音质，比mp3更加适合低码率传输；同时，MPEG-2 AAC已经成为MPEG-4标准中高质量音频编码的核心，是下一代音频压缩标准。\n\n5.     MPEG-4 AAC：是MPEG-4标准音频编码标准的一部分，apple公司自己开发有这种 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布\n\n6.     杜比数字AC-3技术也就是5.1声道技术\n\n7.     Windows Media Audio v1/v2，微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。\n\n8.     Windows Media Audio 7/8/9，随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化\n\n9.     Windows Media Audio 9 Professional，WMA9 中出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。\n\n10.  RealAudio Cook，早期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、RealAudio 8。\n\n11.  RealAudio Sipro，采用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。\n\n12.  RealAudio AAC，AAC 音频编码，用于 RealAudio 10 中。\n\n13.  RealAudio aacPlus，aacPlus 音频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。\n\n14.  QDesign Music 2，QDesign Music 的第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。\n\n15.  Apple MPEG-4 AAC，Apple 公司自己开发的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。\n\n \n\n \n\n \n\n## 四种主流的视频压缩编码标准：\n\n1、Windows Media Video 9\n\n　　相比起其他三种图像压缩技术，WMV可能是使用率最高的视频编码格式。原因十分简单，如果想使自己的影片直接给网上其他用户观看到的话，利用微软自身的视频编码标准是最简单的做法。因为只要用户的电脑中有Windows Media Player(媒体播放器)，就能够播放WMV影片，而且不用额外安装Codec（编码），所以兼容性方面完全不用担心。借助Windows Media 9.0 Series的新技术，Windows Media Video 9.0比旧的8.0版有多达15-50%的压缩率提高。而且与MPEG-4画质相比时，其容量大小只需一半即可达到。加上配合Windows Media Service 9.0服务器，在Streaming media（流媒体）方面也有更佳的表现。　　\n\n官方网站：http://www.microsoft.com\n\n2、Real Video 9\n\n玩电脑时间长的朋友都知道，Real Video是多年前市场上最普及的音乐、图像格式。不过随着MP3、WMV及WMV等的兴起，已经使Real Media格式的普及率大不如前。但现在全世界仍然有许多的电脑玩家是Real Video的支持者，网上供下载的影片很多也是RM或RMVB格式。　RealNetwork新推出了一套名为Helix Producer的工具（也就是Real Producer 9），其中的RealVideo 9在图像压缩编码技术方面作出重大优化，无论在下载或Streaming时都声称比Windows Media 9出色，能够以一半的比特速率（bitrate）达到MPEG-4级图像，在约500 Kbps时达到接近DVD的画质表现。同样地，配合服务器可获得更出色的效果。\n\n官方网址：http://www.realnetworks.com\n\n \n\n3、DivX\n\n　　历史介绍：\n\nISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。\n\n1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MS MPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS　MPEG4V3才开始有好转，画质有了显著的进步，但是不知微软出于什么目的，却将这个MS　MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是广为流传的MPEG编码器－DivX3.11。\n\nDivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展的大潮是势不可挡了。\n\n看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO　MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。\n\n接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码--XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。\n\nDivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。\n\n官方网站：http://www.divx.com\n\n4、Koepi's XviD Codec\n\n相比起前三种视频编码标准来说，Xvid推出市场的时间最迟。从其名字就知道这种标准是针对DivX而来的。原来，DivX由免费转为收费编码后，使部份原有开发人员不满，继而离开并组成一个新的开发小组，设计免费且开放源代码的XviD Codec。当前，Koepi和Nic的XviD都是比较活跃和最多人使用的版本，虽然两者在编译上有所不同，但实际做出的效果相差无几。Xivd与DivX一样，在编译后都是一个.AVI文件，播放时只要安装Xvid codec就能用Windows媒体播放器中播放。\n\n官方网站：http://roeder.goe.net/~koepi\n\n \n\n## 视频压缩基本概念：\n一、有损和无损压缩：在视频压缩中有损（Lossy）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。\n\n二、帧内和帧间压缩：帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。\n    采用帧间（Interframe）压缩是基于许多视频或动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。\n\n三、对称和不对称编码：对称性（symmetric）是压缩编码的一个关键特征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。\n\n \n\n第三部分：音频文件格式\n\n \n\n## 一些音视频的参数含义:\n\n声道：目前人们所使用的各种声场技术规范非常多，但最常见的几乎都来自三家公司，他们是Dolby（杜比）、HTX和DTS。声卡所支持的声道数是衡量声卡档次的重要指标之一，从单声道到最新的环绕立体声，下面一一详细介绍：1.单声道：单声道是比较原始的声音复制形式，早期的声卡采用的比较普遍。当通过两个扬声器回放单声道信息的时候，我们可以明显感觉到声音是从两个音箱中间传递到我们耳朵里的。这种缺乏位置感的录制方式用现在的眼光看自然是很落后的，但在声卡刚刚起步时，已经是非常先进的技术了。2.立体声：单声道缺乏对声音的位置定位，而立体声技术则彻底改变了这一状况。声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果。这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自的方向，从而使音乐更富想象力，更加接近于临场感受。立体声技术广泛运用于自Sound Blaster Pro以后的大量声卡，成为了影响深远的一个音频标准。时至今日，立体声依然是许多产品遵循的技术标准。3.准立体声：准立体声声卡的基本概念就是：在录制声音的时候采用单声道，而放音有时是立体声，有时是单声道。采用这种技术的声卡也曾在市面上流行过一段时间，但现在已经销声匿迹了。4.四声道环绕：人们的欲望是无止境的，立体声虽然满足了人们对左右声道位置感体验的要求，但是随着技术的进一步发展，大家逐渐发现双声道已经越来越不能满足我们的需求。由于PCI声卡的出现带来了许多新的技术，其中发展最为神速的当数三维音效。三维音效的主旨是为人们带来一个虚拟的声音环境，通过特殊的HRTF技术营造一个趋于真实的声场，从而获得更好的游戏听觉效果和声场定位。而要达到好的效果，仅仅依靠两个音箱是远远不够的，所以立体声技术在三维音效面前就显得捉襟见肘了，但四声道环绕音频技术则很好的解决了这一问题。四声道环绕规定了4个发音点：前左、前右，后左、后右，听众则被包围在这中间。同时还建议增加一个低音音箱，以加强对低频信号的回放处理(这也就是如今4.1声道音箱系统广泛流行的原因)。就整体效果而言，四声道系统可以为听众带来来自多个不同方向的声音环绕，可以获得身临各种不同环境的听觉感受，给用户以全新的体验。如今四声道技术已经广泛融入于各类中高档声卡的设计中，成为未来发展的主流趋势。5.5.1声道5.1声道已广泛运用于各类传统影院和家庭影院中，一些比较知名的声音录制压缩格式，譬如杜比AC-3（Dolby Digital）、DTS等都是以5.1声音系统为技术蓝本的。其实5.1声音系统来源于4.1环绕，不同之处在于它增加了一个中置单元。这个中置单元负责传送低于80Hz的声音信号，在欣赏影片时有利于加强人声，把对话集中在整个声场的中部，以增加整体效果。相信每一个真正体验过Dolby AC-3音效的朋友都会为5.1声道所折服。千万不要以为5.1已经是环绕立体声的顶峰了，更强大的7.1系统已经出现了。它在5.1的基础上又增加了中左和中右两个发音点，以求达到更加完美的境界。由于成本比较高，没有广泛普及。\n\n \n\n \n\n一.WMA\n　　WMA的全称是Windows Media Audio，是微软力推的一种音频格式。WMA格式是以减少数据流量但保持音质的方法来达到更高的压缩率目的，其压缩率一般可以达到1:18，生成的文件大小只有相应MP3文件的一半。此外，WMA还可以通过DRM（Digital Rights Management）方案加入防止拷贝，或者加入限制播放时间和播放次数，甚至是播放机器的限制，可有力地防止盗版。\n\n优点 \nWMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小一倍而音质不变，也得到了兑现。事实上，这个说法，仅仅适用于低比特率的情况，另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比相同的MP3体积少1/3左右。\n缺点 \n在高比率的渲染能力低下，同音源的一个320KBPS的MP3与比较192KBPS的WMA相比，音质和渲染力很容易分别出是前者较优。\n\n　　二.VQF\n　　VQF即TwinVQ（Transform－domain Weighted Interleave Vector Quantization），是由NTT（Nippon Telegraph and Telephone）与Yamaha共同开发的一种音频压缩技术。VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。\n\n但是VQF不支持\"流\"，这可能也是为什么现在它完全被WMA压下去的一个主要原因.\n\n　　三.MP3\nMP3的全称是Moving Picture Experts Group Audio Layer III。简单的说，MP3就是一种音频压缩技术，由于这种压缩方式的全称叫MPEG Audio Layer3，所以人们把它简称为MP3。MP3是利用MPEG Audio Layer 3的技术，将音乐以1:10甚至1:12 的压缩率，压缩成容量较小的file，换句话说，能够在音质丢失很小的情况下把文件压缩到更小的程度。而且还非常好的保持了原来的音质。正是因为MP3体积小，音质高的特点使得MP3格式几乎成为网上音乐的代名词。每分钟音乐的MP3格式只有1MB左右大小，这样每首歌的大小只有3-4兆字节。使用MP3播放器对MP3文件进行实时的解压缩(解码)，这样，高品质的MP3音乐就播放出来了。　　\n\nMP3最受争议的就是音质问题(尤其是随着WMA的普及)，其高频损失很大，很多MP3编码器粗糙的编码算法不但导致高频丢失，还丢失了许多细节，类似吉他擦弦的感觉在MP3中是找不到的.在对MP3快要失望时，偶发现了Lame,它支持根据人耳遮蔽效应原理来分析波形，配合VBR技术，可以让音质达到令人吃惊的地步;其独创的心理音响模型技术保证了CD音频还原的真实性，配合VBR(动态比特率)和ABR(平均比特率)参数，编码出来的MP3音色纯厚、空间宽广、低音清晰、细节表现良好,音质几乎可以媲美CD音频，但文件体积却非常小.很多网友在使用LAME后的反映就是：立刻删除硬盘上所有的MP3和其他编码器，全部用Lame重新来过。Lame提供EXE和DLL，其中DLL是作为标准的动态运行库供其他程序调用.EXE是Command Line程序，象DOS程序一样工作，两者彼此独立，互不关联。但大家很快能发现两者编码的质量是不一样的,那是由于dll可控性差，与具备丰富调节参数的EXE版相比，其压缩出来的MP3效果稍逊一筹。但EXE是一个命令行工具，操作很麻烦，幸亏有了WinLAMEr或lameGUIxp这些Shell。只要学会使用这些Shell(是傻瓜型的,一看即会)，就可以用LAME压缩出最最精彩的MP3了。再说说APS,在LAME出现以前，APS就是最好的MP3编码器，它使用的Fraunhofer IIS编码算法，这比LAME使用的编码算法要先进，在192k Bitrate(CBR)下，甚至比LAME编码的曲子要优秀，细节明显要丰富一些，但APS本身不支持VBR，当Bitrate往上提高时，音质就要比LAME编码的要差了，大部分朋友的MP3的一般都是128-192K Bitrate的，因此APS仍旧有推荐的价值。特别是有很多MP3随身听不支持VBR和256K Bitrate以上的MP3，LAME就不一定合适这些朋友了，APS就成了不错的选择，由它编码的曲子，绝对不会辱没你昂贵的PLAYER.\n\n　　四.MP3PRO\n　　MP3PRO完全是基于传统MP3编码技术的一种改良，本身最大的技术亮点就在于SBR(Spectral Band Replication频段复制),这是一种新的音频编码增强算法.它提供了改善低位率情况下音频和语音编码的性能的可能.这种方法可在指定的位率下增加音频的带宽或改善编码效率,SBR最大的优势就是在低数据速率下实现非常高效的编码.如果在高数据速率的情况下，SBR将如同虚设.当制作MP3PRO文件时，编码器将音频分为两部分。一部分是将音频数据中的低频段部分分离出来，通过传统的MP3技术而编码得出的正常的MP3音频流，此举可令到MP3编码器可以专注于低频段信号从而获得更好的压缩质量，而且原来的MP3播放器也可播放MP3PRO文件。另一部分则是将分离出来的高频段信号进行编码并嵌入到MP3流中，传统的MP3播放器会将其忽略掉，而新的MP3PRO播放器则可从中还原出高频信号，并将两者进行组合，得到高质量的全带宽的声音.官方宣称通过这样的技术，使得MP3PRO能在64kbps的编码率便可提供与128kbps的mp3相同的质量。低比特率下MP3PRO的性能很明显地比MP3要高,但是它与WMA谁胜谁负就很难说了,根据一些发烧友的评测, MP3PRO似乎略胜一些.高比特率下很少有人用到MP3PRO.\n\n \n\n五.OGG\n　　OGG格式的全称应该是OGG Vobis。它是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。OGG Vobis有一个很出众的特点，就是支持多声道，随着它的流行，以后用随身听来听DTS编码的多声道作品将不会是梦想。OGG Vobis在压缩技术上比MP3好，而且它的多声道，免费，开源这些特点，使它很有可能成为一个流行的趋势，这也正是一些MP3播放器对其支持的原因\n\n在高音质要求下,有损音频编码世界中是三足项立，分别为MP3、MPC、OGG。　\n\nOgg Vorbis中的主要算法还是利用MDCT（修饰离散余弦变换Modified Discrete Cosine Transform ）而不是用现在比较时兴的小波（wavelet）技术。Ogg的多通道编码技术，统称为立体声通道耦合Stereo Channel Coupling。而该技术实际又是由两种不同的技术组成的：channel interleaving 和 square polar mapping，而这也是Ogg能成为免费制式的一个必要条件，以往的“联合立体声Joint Stereo”的编码模式是有专利限制的。据官方声称，与其他会造成立体空间感减弱的编码模型相比，这两种技术都可以在保持编码器的灵活性的同时而不损害本来的立体声空间影像――相信配合iRiver的3d音效会有更好的表现力，而且实现的复杂程度比联合立体声方式要低。\n　　OGG Vorbis这种编码也远比90年代开发成功的MP3先进，它可以在相对较低的数据速率下实现比MP3更好的音质！――我认为Ogg很象MD的atrac格式，特别象新的lp2编码，它能在低别特率下有着很要的音质。此外，在编码上，Ogg Vorbis是使用了VBR（可变比特率）和ABR（平均比特率）方式进行编码，所以理论上，Ogg Vorbis带来的音乐可以比采用CBR文件有更好的声音表现，当然前提是两者使用同样比特率(Bit Rate)的压缩模式――这里可以知道。Ogg Vorbis的比特率缩放功能可以在不用重新编码的情况下调节文件的相关压缩率，与此同时，Ogg文件的单位编辑能力和超越左右声道的音频流技术可以带来更为奇妙的音乐享受。Vorbis还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。\n　　Vorbis文件可以被分成小块并以样本粒度（granularity，专业术语，指数据可以被分割的最小尺寸）进行编辑；Vorbis支持多通道（大于2）音频流并使用了独创性的处理技术；这意味着什么？这意味着Ogg Vorbis在SACD、DTSCD、DVD AUDIO抓轨软件（目前这种软件还没有）的支持下，可以对所有的声道进行编码，而不是MP3只能编码2个声道。多声道音乐的兴起，给音乐欣赏带来了革命性的变化，尤其在欣赏交响时，会带来更多临场感。这场革命性的变化是MP3无法适应的。在以后的播放技术不断提高以后，而且人们对音质要求不断提高，Ogg的优势将更加明显。\n　　六. MPC\n　　MusePaCk是由德国人Andree Buschmann开发的一种完全免费的高品质音频格式。在其问世之前，Lame MP3是公认音质最好的有损压缩方案，追求音质的人对它趋之若鹜。但现在这个桂冠无疑该让给MPC了，在中高码率下，MPC可以做到比MP3更好音质。在高码率下，MPC的高频要比MP3细腻不少，可以在节省大量空间的前提下获得最佳音质的音乐欣赏，是目前最适合用于音乐欣赏的有损编码。\n\nMPC的编码方案是在MP2的基础上改进而来。它同样采用子带编码技术，但相比MP2，它所采用的心理声学模型要优秀得多，并加入了像ANS（Adaptive Noise Shaping）、CVD(ClearVoiceDetection)等技术，甚至改变了压缩时所用的Huffman（哈夫曼）编码，以得到更大的压缩率。另外，MPC采用的是可变码率进行编码。毫无疑问，可变码率的编码效率要高于固定码率，因为前者可以合理地分配数据量，在信号复杂（微弱）时提高（降低）比特率，在得到满意的效果又能确保不错的压缩率。为了保证高音质，MPC的瞬间最大码率甚至高达1.32Mbps，这已经快接近CD的1.41Mbps了\n\n较高比特率下(250kbps左右),MPC表现非常的出众,甚至超过了MP3，很难分辨它和原始信号有多少区别，无论从频率保留还是细节保留，以及信号强度失真来说，MPC太优秀了.但MPC并非万能的，它无法编码48khz采样率的曲子，所幸的是，这样的曲子来源很少.可惜这种格式并没有像MP3或WMA那样流行.\n\n　　七.ATRAC\n　　ATRAC（Adaptive TRansform Acoustic Coding自适应声学转换编码技术）：是Sony的原创音乐压缩技术，主要用于MD Walkman的录音及播放方面。是一项基于听觉心理学领域的研究和不损伤可闻声质量的数码音频译码压缩技术，对音乐资讯有效的进行压缩，压缩的比率为原来的五分之一，因为MD使用了ATRAC压缩技术，这样的压缩大大节省了许多空间，所以 CD的碟片要120mm大小，而MD只需64mm就可以录下74分钟的音乐。\n\nATRAC压缩技术主要是利用了人耳的蔽遮效应，在心理声学原理上，在进行音频录入的同时，有许多外部的频段同时也会被录入，当人耳同时听到两个不同频率、不同音量的声音时，音量较小的低频及音量较小的高频连同不为人耳所察觉的频段信号都会被自动减弱或忽略不予记录，因此又可以称为适应性变换声码技术，由于近年來编码压缩技术（ATRAC的版本）越來越成熟，所以经过编码解码过程后的声音仍直逼CD，大家就不必担心音质差啦。\n\nATRAC将16比特44.1KHz的数字信号以频率响应轴分成52个区段（在低频时分割较细而在高频时分割较粗），根据声音心理学的原理，将声音信号中人耳听不到和对人的听力影响不大的信息给剔除出去而达到缩小声音文件的目的。利用这种原理，ATRAC可以将录音的资料量压缩为原来的五分之一（即压缩比为1：5）。\n\n.\n\n　　八. APE　\n　　  APE的本质，其实它是一种无损压缩音频格式。庞大的WAV音频文件可以通过Monkey''s Audio这个软件进行“瘦身”压缩为APE。很时候它被用做网络音频文件传输，因为被压缩后的APE文件容量要比WAV源文件小一半多，可以节约传输所用的时间。更重要的是，通过Monkey''s Audio解压缩还原以后得到的WAV文件可以做到与压缩前的源文件完全一致。所以APE被誉为“无损音频压缩格式”，Monkey''s Audio被誉为“无损音频压缩软件”。与采用WinZip或者WinRAR这类专业数据压缩软件来压缩音频文件不同，压缩之后的APE音频文件是可以直接被播放的。 Monkey''s Audio会向Winamp中安装一个“in_APE.dll”插件，从而使Winamp也具备播放APE文件的能力。 \n\n和上面介绍的几款编码不同的是，这个编码提供了最好的音质保证(无损压缩)！还提供了Winamp的插件支持,可以直接用Winamp来播放.所谓无损就是指压缩后的格式和源文件在音质上并无差异，而Mp3、WMA等的编码方案是基于有损的，在损失部分音质的前提下节约存贮空间，所以说音质再好的Mp3、WMA也只能是无限接近源文件的音质。APE非常适合来编码讲究细节的独奏曲目和大动态的交响曲。向各位音乐迷们(不是歌迷)作最强烈的推荐！它的压缩比约为2:1.\n\n　　九. WAV\n　　WAV是录音时用的标准的windows文件格式，文件的扩展名为“.wav”，WAVE文件作为最经典的Windows多媒体音频格式，应用非常广泛。声道有单声道和立体声之分，采样频率一般有11kHz、22kHz和44kHz三种。\n\nWAVE文件所占容量=（采样频率×采样位数×声道）×时间/8（1字节=8bit）。\n\n　　WAV文件与MIDIMP3这类多媒体声音文件比较起来，所占的硬盘空间要大得多，但WAV文件的回放效果是最好的，WAV文件直接反映了一个声音在每个时刻的大小值，1分钟44khz采样率的WAV文件就会占用10M硬盘空间！\n\n它通常作为制作高质量音乐的中间体\n　　十.RM\n　　Real Networks公司所制定的音频视频压缩规范称为Real Media，用户可以使用RealPlayer或RealOne Player对符合RealMedia技术规范的网络音频/视频资源进行实况转播并且RealMedia可以根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。这种格式的另一个特点是用户使用RealPlayer或RealOne Player播放器可以在不下载音频/视频内容的条件下实现在线播放。另外，RM作为目前主流网络视频格式，它还可以通过其Real Server服务器将其它格式的视频转换成RM视频并由Real Server服务器负责对外发布和播放。RM和ASF格式可以说各有千秋，通常RM视频更柔和一些，而ASF视频则相对清晰一些。\n  RM格式一开始就定位在视频流应用方面，也可以说是视频流技术的始创者。它可以在用56 K Modem拨号上网的条件下实现不间断的视频播放，当然，其图像质量和MPEG2，DIVX等相比有一定差距，毕竟要实现在网上传输不间断的视频是需要很大带宽的。\n\nRM已经是昨日黄花，没有任何新意，低Bitrate比不过WMA，高Bitrate比不过MP3，虽然新的RM导入了ATRAC3算法，但颓势已定，很难东山再起了。\n","slug":"2015/转-音视频基础概念汇总","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pn2003jsaua7cq0ds0z","content":"<h2 id=\"第一部分：基本概念讲解\"><a href=\"#第一部分：基本概念讲解\" class=\"headerlink\" title=\"第一部分：基本概念讲解\"></a>第一部分：基本概念讲解</h2><ul>\n<li>媒体：是表示，传输，存储信息的载体，常人们见到的文字、声音、图像、图形等都是表示信息的媒体。<a id=\"more\"></a></li>\n<li><p>多媒体： 是声音、动画、文字、图像和录像等各种媒体的组合，以图文并茂，生动活泼的动态形式表现出来，给人以很强的视觉冲击力，留下深刻印象</p>\n</li>\n<li><p>多媒体技术：是将文字、声音、图形、静态图像、动态图像与计算集成在一起的技术。它要解决的问题是计算机进一步帮助人类按最自然的和最习惯的方式接受和处理信息。</p>\n</li>\n<li><p>流媒体 ：流媒体是指采用流式传输的方式在Internet播放的连续时基媒体格式，实际指的是一种新的媒体传送方式，而不是一种新的媒体格式（在网络上传输音/视频等多媒体信息现在主要有下载和流式传输两种方式）流式传输分两种方法：实时流式传输方式(Realtime streaming)和顺序流式传输方式(progressive streaming)。</p>\n</li>\n<li><p>多媒体文件：是既包括视频又包括音频，甚至还带有脚本的一个集合，也可以叫容器；</p>\n</li>\n<li><p>媒体编码：是文件当中的视频和音频所采用的压缩算法。也就是说一个avi的文件，当中的视频编码有可能是A，也可能是B，而其音频编码有可能是1，也有可能是2。  转码 ：指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式</p>\n</li>\n<li><p>视频：连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频</p>\n</li>\n<li><p>音频 ：人类能听到的声音都成为音频，但是一般我们所说到的音频时存储在计算机里的声音</p>\n</li>\n</ul>\n<h2 id=\"第二部分：视频文件格式\"><a href=\"#第二部分：视频文件格式\" class=\"headerlink\" title=\"第二部分：视频文件格式\"></a>第二部分：视频文件格式</h2><ul>\n<li><p>码率：码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质.</p>\n</li>\n<li><p>帧：帧就是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。</p>\n</li>\n</ul>\n<ul>\n<li>帧率：帧率即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。<br>关键帧：相当于二维动画中的原画，指角色或者物体运动或变化中的关键动作所处的那一帧，它包含了图像的所有信息，后来帧仅包含了改变了的信息。如果你没有足够的关键帧，你的影片品质可能比较差，因为所有的帧从别的帧处产生。对于一般的用途，一个比较好的原则是每5秒设一个关键键。但如果时那种实时传输的流文件，那么要考虑传输网络的可靠度，所以要1到2秒增加一个关键帧。目前我们经常见的视频格式无非就是两大类：<br>1、影像格式（Video）<br>2、流媒体格式（Stream Video）</li>\n</ul>\n<p>在影像格式中还可以根据出处划分为三大种：<br>1、AVI格式：这是由微软（Microsoft）提出，具有“悠久历史”的一种视频格式<br>2、MOV格式：这是由苹果（Apple）公司提出的一种视频格式<br>3、MPEG/MPG/DAT：这是由国际标准化组织ISO(International Standards Organization)与IEC(International Electronic Committee)联合开发的一种编码视频格式。MPEG是运动图像压缩算法的国际标准，现已被几乎所有的计算机平台共同支持。</p>\n<p>在流媒体格式中同样还可以划分为三种：<br>1、RM格式：这是由Real Networks公司开发的一种新型流式视频文件格式。<br>2、MOV/QT格式：MOV也可以作为一种流文件格式。QuickTime能够通过Internet提供实时的数字化信息流、工作流与文件回放功能，为了适应这一网络多媒体应用，QuickTime为多种流行的浏览器软件提供了相应的QuickTime Viewer插件（Plug－in），能够在浏览器中实现多媒体数据的实时回放。<br>3、ASF格式：这是由微软公司开发的流媒体格式，是一个在Internet上实时传播多媒体的技术标准。<br>4、FLV</p>\n<h2 id=\"具体视频文件格式详解：\"><a href=\"#具体视频文件格式详解：\" class=\"headerlink\" title=\"具体视频文件格式详解：\"></a>具体视频文件格式详解：</h2><ul>\n<li><p>*. MPEG/.MPG/.DAT<br>MPEG也是Motion Picture Experts Group的缩写。这类格式包括了MPEG-1, MPEG-2和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在VCD的制作和一些视频片段下载的网络应用上面，大部分的VCD都是用 MPEG1格式压缩的( 刻录软件自动将MPEG1转为.DAT格式)，使用 MPEG-1的压缩算法，可以把一部 120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2则是应用在DVD 的制作，同时在一些HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB的大小（MPEG2的图像质量MPEG-1与其无法比拟的）。</p>\n</li>\n<li><p>*.AVI<br>　它的英文全称为Audio Video Interleaved，即音频视频交错格式。是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，但压缩比较高，因此尽管面面质量不是太好，但其应用范围仍然非常广泛。AVI支持256色和RLE压缩。AVI信息主要应用在多媒体光盘上，用来保存电视、电影等各种影像信息。它于1992年被Microsoft公司推出，随Windows3.1一起被人们所认识和熟知。所谓“音频视频交错”，就是可以将视频和音频交织在一起进行同步播放。这种视频格式的优点是图像质量好，可以跨多个平台使用，其缺点是体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本Windows媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本Windows媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题，如果用户在进行AVI格式的视频播放时遇到了这些问题，可以通过下载相应的解码器来解决。是目前视频文件的主流。 这种格式的文件随处可见，比如一些游戏、教育软件的片头，多媒体光盘中，都会有不少的 AVI 。现在，在WINDOWS 95或98里都能直接播放AVI，同一种格式的avi文件有可能采用不同的编码方式，最常见的有Intel Indeo（R）Video R3.2（像游戏过场动画等，是目前使用最广泛的一种avi编码技术）、Microsoft video 等。</p>\n</li>\n<li><p><em>.RA/RM/RAM\n　</em>.RM，Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash（Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO（RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，从RealVideo的定位来看，就是牺牲画面质量来换取可连续观看性。其实RealVideo也可以实现不错的画面质量，由于RealVideo可以拥有非常高的压缩效率，很多人把VCD编码成RealVideo格式的，这样一来，一张光盘上可以存放好几部电影。REAL VIDEO存在颜色还原不准确的问题，RealVideo就不太适合专业的场合，但RealVideo出色的压缩效率和支持流式播放的特征，使得RealVideo在网络和娱乐场合占有不错的市场份额。</p>\n</li>\n<li><p>*.MOV<br>MOV格式，美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTimePlayer。具有较高的压缩比率和较完美的视频清晰度等特点，但是其最大的特点还是跨平台性，即不仅能支持MacOS，同样也能支持Windows系列,在所有视频格式当中，也许MOV格式是最不知名的。也许你会听说过QuickTime，MOV格式的文件正是由它来播放的。在PC几乎一统天下的今天，从Apple移植过来的MOV格式自然是受到排挤的。它具有跨平台、存储空间要求小的技术特点，而采用了有损压缩方式的MOV格式文件，画面效果较AVI格式要稍微好一些。到目前为止，它共有4个版本，其中以 4.0 版本的压缩率最好。这种编码支持16位图像深度的帧内压缩和帧间压缩，帧率每秒10帧以上。现在这种格式有些非编软件也可以对它时行处理，其中包括ADOBE公司的专业级多媒体视频处理软件AFTEREFFECT和PREMIERE。</p>\n</li>\n<li><p>*.ASF<br>　ASF (Advanced Streaming format高级流格式)。ASF是MICROSOFT 为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了MPEG4的压缩算法，压缩率和图像的质量都很不错。因为ASF是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD差一点点并不出奇，但比同是视频“流”格式的RAM格式要好。 ASF支持任意的压缩/解压缩编码方式，并可以使用任何一种底层网络传输协议，具有很大的灵活性。ASF流文件的数据速率可以在28.8Kbps到3Mbps之间变化。用户可以根据自己应用环境和网络条件选择一个合适的速率，实现VOD点播和直播。</p>\n</li>\n<li><p>*.WMV<br>　WMV是微软推出的一种流媒体格式，它是ASF的升级延伸，在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。微软希望用其取代QuickTime之类的技术标准以及WAV、AVI之类的文件扩展名。WMV的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。</p>\n</li>\n<li><p>*. NAVI<br>　如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm的地下组织发展起来的一种新视频格式。它是由Microsoft ASF压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以NAVI为了追求这个目标，改善了原始的ASF格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI是一种去掉视频流特性的改良型ASF格式。</p>\n</li>\n<li><p>*.FLV</p>\n</li>\n</ul>\n<p>FLV 是 FLASH VIDEO的简称，是由Macromedia公司开发的属于自己的流式视频格式。FLV也就是随着Flash MX的推出发展而来的视频格式，是在sorenson公司的压缩算法的基础上开发出来的。FLV格式不仅可以轻松的导入Flash中，速度极快，并且能其到保护版权的作用，并且可以不通过本地的微软或者REAL播放器播放视频。Flash MX 2004对其提供了完美的支持，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。</p>\n<h2 id=\"视频文件转换：\"><a href=\"#视频文件转换：\" class=\"headerlink\" title=\"视频文件转换：\"></a>视频文件转换：</h2><p>比较常见的视频格式转化有： </p>\n<p>RM→ASF</p>\n<p>AVI→RMVB</p>\n<p>dat–&gt;divx</p>\n<p>mpg–&gt;divx</p>\n<p>vcd–&gt;rm</p>\n<p>dat–&gt;rm</p>\n<p>mpg,dat、avi、mov–&gt;rm</p>\n<p>*–&gt;FLV</p>\n<p>最近视频博客的兴起，导致了flv的快速发展</p>\n<p>AVI→MPEG(MPEG－1)<br>     例如有纪念性的家庭录影带，可以事先转换成AVI格式，再用软件将它转换成MPEG－1格式，然后用刻录器将MPEG－1格式文件刻录光盘片，得到的就是普通的VCD光盘了，可以拿到任何VCD播放器上播放。 </p>\n<p>MPEG(MPEG－1)→AVI<br>       从MPEG到AVI文件之间的转换，为磁盘节省空间。</p>\n<p>MPEG(MPEG－1)→ASF<br>       将vcd文件转码后实现VOD点播和直播。</p>\n<p>ASF→MPEG(MPEG－1)<br>      由于ASF视频格式的先天限制，一般来说它的图像质量往往比不上MPEG－1，所以转换之前，请三思而后行。</p>\n<p>DVD(MPEG－2)→VCD (MPEG－1)<br>       由于DVD驱动器尚未普及以及DVD光盘成本昂贵等客观原因，DVD影片一直未能像VCD一样流行。但我们可以将喜爱的DVD影片转换成MPEG－1格式的视频文件，留在硬盘上观看或是刻成VCD光盘。</p>\n<p>dat/mpg-&gt;mp3</p>\n<p>CD–&gt;wav,mp3,wma</p>\n<p>rm–&gt;mp3</p>\n<p>mp3–&gt;wma</p>\n<p>以上列举的视频格式转化都是比较常见的，当然了，说到底，是有这方面的实际应用需求才会出现这方面的视频转化需要。<br>比如说，要把一部VCD（也就是MPEG1编码的视频文件）制作成可以在线观看的影片，最大的瓶颈就在于文件尺寸的改变，并且要能够适应网络的特点，这样原始的格式就不能满足需  要，必须要转化成互联网视频播放规范的流媒体格式才可以，比如说是RM或者ASF，这就是需要，所以针对影像格式转化为流媒体格式的软件也就应用而生了，还有现在非常流行的MPEG4视频压缩技术，它能够把一张DVD压缩到一张CD上去，并且视频效果也不会有太大的变化，至少在我们普通用户看来也是非常不错的，而文件体积则大大减小了，这就要求有能够把DVD转化成MPEG4文件的软件出现，但是如果有人想要把RM转化成MPEG1（VCD），就没有太大的实际意义了，因为这样并不能给视频效果带来太大的提升，反而文件尺寸大了许多，所以我们很少能够看到这样的转化软件，其他的也类似，所以，在视频转化领域，可以参照以下两个原则：<br>1 有明确的应用方向：就是说一种视频格式转化成另一种视频格式，必须要有明确的应用方向，即目标格式能够有很广泛的应用价值，而不是说为了转化而转化，比如上文所说的VCD-&gt;RM，它的应用方向就是网络播放，因为现在在线电影是一个很大的市场和网络的应用方向。<br>2 能够提升播放价值： 就是说一种视频格式转化成另一种视频格式除了有明确的应用方向外，还要考虑转化是不是有价值，如果说转化后的文件播放效果没有明显提升，但是文件尺寸却大了一倍，我想这样亏本的买卖是没有人会去做的，RM转化成VCD就没有实际的意义，原因如前文所述，而DVD转化成MPEG4价值就很大，不说转化后的播放效果，单说成本就降低了不少。</p>\n<h2 id=\"音视频压缩编码标准：\"><a href=\"#音视频压缩编码标准：\" class=\"headerlink\" title=\"音视频压缩编码标准：\"></a>音视频压缩编码标准：</h2><p>多媒体编辑码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，现在主要的编码方式有：</p>\n<ol>\n<li>MPEG系列： 视频编码方面主要是Mpeg1、Mpeg2、Mpeg4、Mpeg4 AVC；<br>音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3、MPEG-2 AAC、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的</li>\n<li><p>H.26X系列：包括H261、H262、H263、H263+、H263++、H264</p>\n</li>\n<li><p>微软windows media系列：视频编码有Mpeg-4 v1/v2/v3、Windows Media Video 7/8/9/10；音频编码有Windows Media audeo v1/v2/7/8/9</p>\n</li>\n<li><p>Real Media系列： 视频编码有RealVideo G2、RealVideo 8/9/10；音频编码有RealAudio cook/sipro、RealAudio AAC/AACPlus等</p>\n</li>\n<li><p>QuickTime系列： 视频编码有Sorenson Video 3、Apple MPEG-4、Apple H.264；音频编码有QDesign Music 2、Apple MPEG-4 AAC</p>\n</li>\n<li><p>其它，如：Ogg、On2-vpx、flash vidio，以及M-JPEG视频压缩方式</p>\n</li>\n</ol>\n<h2 id=\"各视频编码的应用场合简要：\"><a href=\"#各视频编码的应用场合简要：\" class=\"headerlink\" title=\"各视频编码的应用场合简要：\"></a>各视频编码的应用场合简要：</h2><p><a href=\"http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx</a>这里讲的挺详细的</p>\n<ul>\n<li><ol>\n<li>Mpeg1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1；</li>\n</ol>\n</li>\n<li><ol>\n<li>在 MPEG-1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD-Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。</li>\n</ol>\n</li>\n<li><ol>\n<li>MPEG-3是MPEG组织制定的视频和音频压缩标准。本来的目标是为HDTV提供20-40Mbps视频压缩技术。在标准制定的过程中，委员会很快发现MPEG-2可以取得类似的效果。随后，MPEG-3项目停止了。</li>\n</ol>\n</li>\n<li><ol>\n<li>MPEG-4是为了适应网络的需求，采用一系列新技术，以最少的数据获得最佳的图像质量为目标的新一代编码方式。主要应用在数字电视、动态图像、互联网、实时多媒体监控、移动多媒体通信、Internet／intranet上的视频流与可视游戏、DVD上的交互多媒体应用等方面。Divx，xvid，ms mpeg4都是采用mpeg-4视频编码的。对于普通用户来说，MPEG-4在目前来说最有吸引力的地方还在于它能在普通CD-ROM上基本实现DVD的质量；用MPEG-4压缩算法的ASF(Advanced Streaming format，高级格式流)可以将120分钟的电影压缩为300MB左右的视频流；采用MPEG-4压缩算法的DIVX视频编码技术可以将120分钟的电影压缩600MB左右</li>\n</ol>\n</li>\n<li><ol>\n<li>Mpeg4 AVC和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编码方案之一，相信 AVC 的发展前途会非常好。AVC/H.264极有可能成为下一代视频格式，（avs，中国标准）</li>\n</ol>\n</li>\n<li><ol>\n<li>H.261是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。</li>\n</ol>\n</li>\n<li><ol>\n<li>H.262是由ITU-T的VCEG组织和ISO/IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是”ITU-T建议H.262”和”ISO/IEC 13818-2”。这两个标准在所有的文字叙述上都是相同的。</li>\n</ol>\n</li>\n<li><ol>\n<li>H.263是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的</li>\n</ol>\n</li>\n<li><ol>\n<li>H263+是H.263 的第二个版本，加入了许多新技术来扩展 H.263 的应用范围。</li>\n</ol>\n</li>\n<li><p>10.H.263++是在 H.263+ 上增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。</p>\n</li>\n<li><p>11.H.264也就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO/IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为H.264标准。</p>\n</li>\n<li><p>12.Microsoft MPEG-4 v1/v2/v3，最早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来才进行了重写。</p>\n</li>\n<li><p>13.Windows Media Video 7，Microsoft 正式开发的第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。</p>\n</li>\n<li><p>14.Windows Media Video 8，在 WMV7 基础上改进的版本，质量上面进不了不少</p>\n</li>\n<li><p>15.Windows Media Video 9，微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。</p>\n</li>\n<li><p>16.RealVideo G2，早期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。</p>\n</li>\n<li><p>17.RealVideo 8，随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。</p>\n</li>\n<li><p>18.RealVideo 9，RealNetworks 开发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。</p>\n</li>\n<li><p>19.RealVideo 10，在 RealVideo 9 基础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。</p>\n</li>\n<li><p>20.Sorenson Video 3，Sorenson Media 公司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。</p>\n</li>\n<li><p>21.Apple MPEG-4，Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。</p>\n</li>\n<li><p>22.Apple H.264，Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。</p>\n</li>\n<li><p>23.Ogg 是 Xiph.org 基金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为止 128kbps 码率上最好的编码器。</p>\n</li>\n<li><p>24.On2 VPX系列，On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们就采用了 VP3，VP5，VP6 视频编码。</p>\n</li>\n<li><p>25.Flash Video，Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。</p>\n</li>\n<li><p>26.M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。</p>\n</li>\n</ul>\n<h2 id=\"各音频编码的应用场合简要：\"><a href=\"#各音频编码的应用场合简要：\" class=\"headerlink\" title=\"各音频编码的应用场合简要：\"></a>各音频编码的应用场合简要：</h2><ol>\n<li><p>MPEG Audio Layer 1典型数据压缩率是1：4，即每个立体声信号为384 kbps</p>\n</li>\n<li><p>MPEG Audio Layer 2典型数据压缩率是1：4—1：8，即每个立体声信号为256到192 kbps。MPEG Audio Layer1/2主要用于vcd，svcd的音频编码</p>\n</li>\n<li><p>MPEG Audio Layer 3，也就是大名鼎鼎的mp3，已经成为网络音频的主流格式，能在128kbps的码率下接近cd音质。典型数据压缩率是1：10—1：12，即每个立体声信号为128到112 kbps</p>\n</li>\n<li><p>MPEG-2 AAC（Advanced Audio Coding）是在1997年由以Bosi、Brandenburg、Johnston等为首的音频编码研究提出的，它总结了MPEG-1、MPEG-2和AC-3等的长处，在MPEG 系统上进一步改进了很多新的功能，大大增强了编码的灵活度，在保证音质的同时更大限度地压缩了码率。它和传统的mpeg audio不兼容，在理论上质量要高于mp3，并且支持多声道，在96kbps的码率范围内能接近cd音质，比mp3更加适合低码率传输；同时，MPEG-2 AAC已经成为MPEG-4标准中高质量音频编码的核心，是下一代音频压缩标准。</p>\n</li>\n<li><p>MPEG-4 AAC：是MPEG-4标准音频编码标准的一部分，apple公司自己开发有这种 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布</p>\n</li>\n<li><p>杜比数字AC-3技术也就是5.1声道技术</p>\n</li>\n<li><p>Windows Media Audio v1/v2，微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。</p>\n</li>\n<li><p>Windows Media Audio 7/8/9，随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化</p>\n</li>\n<li><p>Windows Media Audio 9 Professional，WMA9 中出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。</p>\n</li>\n<li><p>RealAudio Cook，早期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、RealAudio 8。</p>\n</li>\n<li><p>RealAudio Sipro，采用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。</p>\n</li>\n<li><p>RealAudio AAC，AAC 音频编码，用于 RealAudio 10 中。</p>\n</li>\n<li><p>RealAudio aacPlus，aacPlus 音频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。</p>\n</li>\n<li><p>QDesign Music 2，QDesign Music 的第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。</p>\n</li>\n<li><p>Apple MPEG-4 AAC，Apple 公司自己开发的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。</p>\n</li>\n</ol>\n<h2 id=\"四种主流的视频压缩编码标准：\"><a href=\"#四种主流的视频压缩编码标准：\" class=\"headerlink\" title=\"四种主流的视频压缩编码标准：\"></a>四种主流的视频压缩编码标准：</h2><p>1、Windows Media Video 9</p>\n<p>　　相比起其他三种图像压缩技术，WMV可能是使用率最高的视频编码格式。原因十分简单，如果想使自己的影片直接给网上其他用户观看到的话，利用微软自身的视频编码标准是最简单的做法。因为只要用户的电脑中有Windows Media Player(媒体播放器)，就能够播放WMV影片，而且不用额外安装Codec（编码），所以兼容性方面完全不用担心。借助Windows Media 9.0 Series的新技术，Windows Media Video 9.0比旧的8.0版有多达15-50%的压缩率提高。而且与MPEG-4画质相比时，其容量大小只需一半即可达到。加上配合Windows Media Service 9.0服务器，在Streaming media（流媒体）方面也有更佳的表现。　　</p>\n<p>官方网站：<a href=\"http://www.microsoft.com\" target=\"_blank\" rel=\"external\">http://www.microsoft.com</a></p>\n<p>2、Real Video 9</p>\n<p>玩电脑时间长的朋友都知道，Real Video是多年前市场上最普及的音乐、图像格式。不过随着MP3、WMV及WMV等的兴起，已经使Real Media格式的普及率大不如前。但现在全世界仍然有许多的电脑玩家是Real Video的支持者，网上供下载的影片很多也是RM或RMVB格式。　RealNetwork新推出了一套名为Helix Producer的工具（也就是Real Producer 9），其中的RealVideo 9在图像压缩编码技术方面作出重大优化，无论在下载或Streaming时都声称比Windows Media 9出色，能够以一半的比特速率（bitrate）达到MPEG-4级图像，在约500 Kbps时达到接近DVD的画质表现。同样地，配合服务器可获得更出色的效果。</p>\n<p>官方网址：<a href=\"http://www.realnetworks.com\" target=\"_blank\" rel=\"external\">http://www.realnetworks.com</a></p>\n<p>3、DivX</p>\n<p>　　历史介绍：</p>\n<p>ISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。</p>\n<p>1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MS MPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS　MPEG4V3才开始有好转，画质有了显著的进步，但是不知微软出于什么目的，却将这个MS　MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是广为流传的MPEG编码器－DivX3.11。</p>\n<p>DivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展的大潮是势不可挡了。</p>\n<p>看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO　MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。</p>\n<p>接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码–XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。</p>\n<p>DivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。</p>\n<p>官方网站：<a href=\"http://www.divx.com\" target=\"_blank\" rel=\"external\">http://www.divx.com</a></p>\n<p>4、Koepi’s XviD Codec</p>\n<p>相比起前三种视频编码标准来说，Xvid推出市场的时间最迟。从其名字就知道这种标准是针对DivX而来的。原来，DivX由免费转为收费编码后，使部份原有开发人员不满，继而离开并组成一个新的开发小组，设计免费且开放源代码的XviD Codec。当前，Koepi和Nic的XviD都是比较活跃和最多人使用的版本，虽然两者在编译上有所不同，但实际做出的效果相差无几。Xivd与DivX一样，在编译后都是一个.AVI文件，播放时只要安装Xvid codec就能用Windows媒体播放器中播放。</p>\n<p>官方网站：<a href=\"http://roeder.goe.net/~koepi\" target=\"_blank\" rel=\"external\">http://roeder.goe.net/~koepi</a></p>\n<h2 id=\"视频压缩基本概念：\"><a href=\"#视频压缩基本概念：\" class=\"headerlink\" title=\"视频压缩基本概念：\"></a>视频压缩基本概念：</h2><p>一、有损和无损压缩：在视频压缩中有损（Lossy）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。</p>\n<p>二、帧内和帧间压缩：帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。<br>    采用帧间（Interframe）压缩是基于许多视频或动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>\n<p>三、对称和不对称编码：对称性（symmetric）是压缩编码的一个关键特征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。</p>\n<p>第三部分：音频文件格式</p>\n<h2 id=\"一些音视频的参数含义\"><a href=\"#一些音视频的参数含义\" class=\"headerlink\" title=\"一些音视频的参数含义:\"></a>一些音视频的参数含义:</h2><p>声道：目前人们所使用的各种声场技术规范非常多，但最常见的几乎都来自三家公司，他们是Dolby（杜比）、HTX和DTS。声卡所支持的声道数是衡量声卡档次的重要指标之一，从单声道到最新的环绕立体声，下面一一详细介绍：1.单声道：单声道是比较原始的声音复制形式，早期的声卡采用的比较普遍。当通过两个扬声器回放单声道信息的时候，我们可以明显感觉到声音是从两个音箱中间传递到我们耳朵里的。这种缺乏位置感的录制方式用现在的眼光看自然是很落后的，但在声卡刚刚起步时，已经是非常先进的技术了。2.立体声：单声道缺乏对声音的位置定位，而立体声技术则彻底改变了这一状况。声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果。这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自的方向，从而使音乐更富想象力，更加接近于临场感受。立体声技术广泛运用于自Sound Blaster Pro以后的大量声卡，成为了影响深远的一个音频标准。时至今日，立体声依然是许多产品遵循的技术标准。3.准立体声：准立体声声卡的基本概念就是：在录制声音的时候采用单声道，而放音有时是立体声，有时是单声道。采用这种技术的声卡也曾在市面上流行过一段时间，但现在已经销声匿迹了。4.四声道环绕：人们的欲望是无止境的，立体声虽然满足了人们对左右声道位置感体验的要求，但是随着技术的进一步发展，大家逐渐发现双声道已经越来越不能满足我们的需求。由于PCI声卡的出现带来了许多新的技术，其中发展最为神速的当数三维音效。三维音效的主旨是为人们带来一个虚拟的声音环境，通过特殊的HRTF技术营造一个趋于真实的声场，从而获得更好的游戏听觉效果和声场定位。而要达到好的效果，仅仅依靠两个音箱是远远不够的，所以立体声技术在三维音效面前就显得捉襟见肘了，但四声道环绕音频技术则很好的解决了这一问题。四声道环绕规定了4个发音点：前左、前右，后左、后右，听众则被包围在这中间。同时还建议增加一个低音音箱，以加强对低频信号的回放处理(这也就是如今4.1声道音箱系统广泛流行的原因)。就整体效果而言，四声道系统可以为听众带来来自多个不同方向的声音环绕，可以获得身临各种不同环境的听觉感受，给用户以全新的体验。如今四声道技术已经广泛融入于各类中高档声卡的设计中，成为未来发展的主流趋势。5.5.1声道5.1声道已广泛运用于各类传统影院和家庭影院中，一些比较知名的声音录制压缩格式，譬如杜比AC-3（Dolby Digital）、DTS等都是以5.1声音系统为技术蓝本的。其实5.1声音系统来源于4.1环绕，不同之处在于它增加了一个中置单元。这个中置单元负责传送低于80Hz的声音信号，在欣赏影片时有利于加强人声，把对话集中在整个声场的中部，以增加整体效果。相信每一个真正体验过Dolby AC-3音效的朋友都会为5.1声道所折服。千万不要以为5.1已经是环绕立体声的顶峰了，更强大的7.1系统已经出现了。它在5.1的基础上又增加了中左和中右两个发音点，以求达到更加完美的境界。由于成本比较高，没有广泛普及。</p>\n<p>一.WMA<br>　　WMA的全称是Windows Media Audio，是微软力推的一种音频格式。WMA格式是以减少数据流量但保持音质的方法来达到更高的压缩率目的，其压缩率一般可以达到1:18，生成的文件大小只有相应MP3文件的一半。此外，WMA还可以通过DRM（Digital Rights Management）方案加入防止拷贝，或者加入限制播放时间和播放次数，甚至是播放机器的限制，可有力地防止盗版。</p>\n<p>优点<br>WMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小一倍而音质不变，也得到了兑现。事实上，这个说法，仅仅适用于低比特率的情况，另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比相同的MP3体积少1/3左右。<br>缺点<br>在高比率的渲染能力低下，同音源的一个320KBPS的MP3与比较192KBPS的WMA相比，音质和渲染力很容易分别出是前者较优。</p>\n<p>　　二.VQF<br>　　VQF即TwinVQ（Transform－domain Weighted Interleave Vector Quantization），是由NTT（Nippon Telegraph and Telephone）与Yamaha共同开发的一种音频压缩技术。VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。</p>\n<p>但是VQF不支持”流”，这可能也是为什么现在它完全被WMA压下去的一个主要原因.</p>\n<p>　　三.MP3<br>MP3的全称是Moving Picture Experts Group Audio Layer III。简单的说，MP3就是一种音频压缩技术，由于这种压缩方式的全称叫MPEG Audio Layer3，所以人们把它简称为MP3。MP3是利用MPEG Audio Layer 3的技术，将音乐以1:10甚至1:12 的压缩率，压缩成容量较小的file，换句话说，能够在音质丢失很小的情况下把文件压缩到更小的程度。而且还非常好的保持了原来的音质。正是因为MP3体积小，音质高的特点使得MP3格式几乎成为网上音乐的代名词。每分钟音乐的MP3格式只有1MB左右大小，这样每首歌的大小只有3-4兆字节。使用MP3播放器对MP3文件进行实时的解压缩(解码)，这样，高品质的MP3音乐就播放出来了。　　</p>\n<p>MP3最受争议的就是音质问题(尤其是随着WMA的普及)，其高频损失很大，很多MP3编码器粗糙的编码算法不但导致高频丢失，还丢失了许多细节，类似吉他擦弦的感觉在MP3中是找不到的.在对MP3快要失望时，偶发现了Lame,它支持根据人耳遮蔽效应原理来分析波形，配合VBR技术，可以让音质达到令人吃惊的地步;其独创的心理音响模型技术保证了CD音频还原的真实性，配合VBR(动态比特率)和ABR(平均比特率)参数，编码出来的MP3音色纯厚、空间宽广、低音清晰、细节表现良好,音质几乎可以媲美CD音频，但文件体积却非常小.很多网友在使用LAME后的反映就是：立刻删除硬盘上所有的MP3和其他编码器，全部用Lame重新来过。Lame提供EXE和DLL，其中DLL是作为标准的动态运行库供其他程序调用.EXE是Command Line程序，象DOS程序一样工作，两者彼此独立，互不关联。但大家很快能发现两者编码的质量是不一样的,那是由于dll可控性差，与具备丰富调节参数的EXE版相比，其压缩出来的MP3效果稍逊一筹。但EXE是一个命令行工具，操作很麻烦，幸亏有了WinLAMEr或lameGUIxp这些Shell。只要学会使用这些Shell(是傻瓜型的,一看即会)，就可以用LAME压缩出最最精彩的MP3了。再说说APS,在LAME出现以前，APS就是最好的MP3编码器，它使用的Fraunhofer IIS编码算法，这比LAME使用的编码算法要先进，在192k Bitrate(CBR)下，甚至比LAME编码的曲子要优秀，细节明显要丰富一些，但APS本身不支持VBR，当Bitrate往上提高时，音质就要比LAME编码的要差了，大部分朋友的MP3的一般都是128-192K Bitrate的，因此APS仍旧有推荐的价值。特别是有很多MP3随身听不支持VBR和256K Bitrate以上的MP3，LAME就不一定合适这些朋友了，APS就成了不错的选择，由它编码的曲子，绝对不会辱没你昂贵的PLAYER.</p>\n<p>　　四.MP3PRO<br>　　MP3PRO完全是基于传统MP3编码技术的一种改良，本身最大的技术亮点就在于SBR(Spectral Band Replication频段复制),这是一种新的音频编码增强算法.它提供了改善低位率情况下音频和语音编码的性能的可能.这种方法可在指定的位率下增加音频的带宽或改善编码效率,SBR最大的优势就是在低数据速率下实现非常高效的编码.如果在高数据速率的情况下，SBR将如同虚设.当制作MP3PRO文件时，编码器将音频分为两部分。一部分是将音频数据中的低频段部分分离出来，通过传统的MP3技术而编码得出的正常的MP3音频流，此举可令到MP3编码器可以专注于低频段信号从而获得更好的压缩质量，而且原来的MP3播放器也可播放MP3PRO文件。另一部分则是将分离出来的高频段信号进行编码并嵌入到MP3流中，传统的MP3播放器会将其忽略掉，而新的MP3PRO播放器则可从中还原出高频信号，并将两者进行组合，得到高质量的全带宽的声音.官方宣称通过这样的技术，使得MP3PRO能在64kbps的编码率便可提供与128kbps的mp3相同的质量。低比特率下MP3PRO的性能很明显地比MP3要高,但是它与WMA谁胜谁负就很难说了,根据一些发烧友的评测, MP3PRO似乎略胜一些.高比特率下很少有人用到MP3PRO.</p>\n<p>五.OGG<br>　　OGG格式的全称应该是OGG Vobis。它是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。OGG Vobis有一个很出众的特点，就是支持多声道，随着它的流行，以后用随身听来听DTS编码的多声道作品将不会是梦想。OGG Vobis在压缩技术上比MP3好，而且它的多声道，免费，开源这些特点，使它很有可能成为一个流行的趋势，这也正是一些MP3播放器对其支持的原因</p>\n<p>在高音质要求下,有损音频编码世界中是三足项立，分别为MP3、MPC、OGG。　</p>\n<p>Ogg Vorbis中的主要算法还是利用MDCT（修饰离散余弦变换Modified Discrete Cosine Transform ）而不是用现在比较时兴的小波（wavelet）技术。Ogg的多通道编码技术，统称为立体声通道耦合Stereo Channel Coupling。而该技术实际又是由两种不同的技术组成的：channel interleaving 和 square polar mapping，而这也是Ogg能成为免费制式的一个必要条件，以往的“联合立体声Joint Stereo”的编码模式是有专利限制的。据官方声称，与其他会造成立体空间感减弱的编码模型相比，这两种技术都可以在保持编码器的灵活性的同时而不损害本来的立体声空间影像――相信配合iRiver的3d音效会有更好的表现力，而且实现的复杂程度比联合立体声方式要低。<br>　　OGG Vorbis这种编码也远比90年代开发成功的MP3先进，它可以在相对较低的数据速率下实现比MP3更好的音质！――我认为Ogg很象MD的atrac格式，特别象新的lp2编码，它能在低别特率下有着很要的音质。此外，在编码上，Ogg Vorbis是使用了VBR（可变比特率）和ABR（平均比特率）方式进行编码，所以理论上，Ogg Vorbis带来的音乐可以比采用CBR文件有更好的声音表现，当然前提是两者使用同样比特率(Bit Rate)的压缩模式――这里可以知道。Ogg Vorbis的比特率缩放功能可以在不用重新编码的情况下调节文件的相关压缩率，与此同时，Ogg文件的单位编辑能力和超越左右声道的音频流技术可以带来更为奇妙的音乐享受。Vorbis还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。<br>　　Vorbis文件可以被分成小块并以样本粒度（granularity，专业术语，指数据可以被分割的最小尺寸）进行编辑；Vorbis支持多通道（大于2）音频流并使用了独创性的处理技术；这意味着什么？这意味着Ogg Vorbis在SACD、DTSCD、DVD AUDIO抓轨软件（目前这种软件还没有）的支持下，可以对所有的声道进行编码，而不是MP3只能编码2个声道。多声道音乐的兴起，给音乐欣赏带来了革命性的变化，尤其在欣赏交响时，会带来更多临场感。这场革命性的变化是MP3无法适应的。在以后的播放技术不断提高以后，而且人们对音质要求不断提高，Ogg的优势将更加明显。<br>　　六. MPC<br>　　MusePaCk是由德国人Andree Buschmann开发的一种完全免费的高品质音频格式。在其问世之前，Lame MP3是公认音质最好的有损压缩方案，追求音质的人对它趋之若鹜。但现在这个桂冠无疑该让给MPC了，在中高码率下，MPC可以做到比MP3更好音质。在高码率下，MPC的高频要比MP3细腻不少，可以在节省大量空间的前提下获得最佳音质的音乐欣赏，是目前最适合用于音乐欣赏的有损编码。</p>\n<p>MPC的编码方案是在MP2的基础上改进而来。它同样采用子带编码技术，但相比MP2，它所采用的心理声学模型要优秀得多，并加入了像ANS（Adaptive Noise Shaping）、CVD(ClearVoiceDetection)等技术，甚至改变了压缩时所用的Huffman（哈夫曼）编码，以得到更大的压缩率。另外，MPC采用的是可变码率进行编码。毫无疑问，可变码率的编码效率要高于固定码率，因为前者可以合理地分配数据量，在信号复杂（微弱）时提高（降低）比特率，在得到满意的效果又能确保不错的压缩率。为了保证高音质，MPC的瞬间最大码率甚至高达1.32Mbps，这已经快接近CD的1.41Mbps了</p>\n<p>较高比特率下(250kbps左右),MPC表现非常的出众,甚至超过了MP3，很难分辨它和原始信号有多少区别，无论从频率保留还是细节保留，以及信号强度失真来说，MPC太优秀了.但MPC并非万能的，它无法编码48khz采样率的曲子，所幸的是，这样的曲子来源很少.可惜这种格式并没有像MP3或WMA那样流行.</p>\n<p>　　七.ATRAC<br>　　ATRAC（Adaptive TRansform Acoustic Coding自适应声学转换编码技术）：是Sony的原创音乐压缩技术，主要用于MD Walkman的录音及播放方面。是一项基于听觉心理学领域的研究和不损伤可闻声质量的数码音频译码压缩技术，对音乐资讯有效的进行压缩，压缩的比率为原来的五分之一，因为MD使用了ATRAC压缩技术，这样的压缩大大节省了许多空间，所以 CD的碟片要120mm大小，而MD只需64mm就可以录下74分钟的音乐。</p>\n<p>ATRAC压缩技术主要是利用了人耳的蔽遮效应，在心理声学原理上，在进行音频录入的同时，有许多外部的频段同时也会被录入，当人耳同时听到两个不同频率、不同音量的声音时，音量较小的低频及音量较小的高频连同不为人耳所察觉的频段信号都会被自动减弱或忽略不予记录，因此又可以称为适应性变换声码技术，由于近年來编码压缩技术（ATRAC的版本）越來越成熟，所以经过编码解码过程后的声音仍直逼CD，大家就不必担心音质差啦。</p>\n<p>ATRAC将16比特44.1KHz的数字信号以频率响应轴分成52个区段（在低频时分割较细而在高频时分割较粗），根据声音心理学的原理，将声音信号中人耳听不到和对人的听力影响不大的信息给剔除出去而达到缩小声音文件的目的。利用这种原理，ATRAC可以将录音的资料量压缩为原来的五分之一（即压缩比为1：5）。</p>\n<p>.</p>\n<p>　　八. APE　<br>　　  APE的本质，其实它是一种无损压缩音频格式。庞大的WAV音频文件可以通过Monkey’’s Audio这个软件进行“瘦身”压缩为APE。很时候它被用做网络音频文件传输，因为被压缩后的APE文件容量要比WAV源文件小一半多，可以节约传输所用的时间。更重要的是，通过Monkey’’s Audio解压缩还原以后得到的WAV文件可以做到与压缩前的源文件完全一致。所以APE被誉为“无损音频压缩格式”，Monkey’’s Audio被誉为“无损音频压缩软件”。与采用WinZip或者WinRAR这类专业数据压缩软件来压缩音频文件不同，压缩之后的APE音频文件是可以直接被播放的。 Monkey’’s Audio会向Winamp中安装一个“in_APE.dll”插件，从而使Winamp也具备播放APE文件的能力。 </p>\n<p>和上面介绍的几款编码不同的是，这个编码提供了最好的音质保证(无损压缩)！还提供了Winamp的插件支持,可以直接用Winamp来播放.所谓无损就是指压缩后的格式和源文件在音质上并无差异，而Mp3、WMA等的编码方案是基于有损的，在损失部分音质的前提下节约存贮空间，所以说音质再好的Mp3、WMA也只能是无限接近源文件的音质。APE非常适合来编码讲究细节的独奏曲目和大动态的交响曲。向各位音乐迷们(不是歌迷)作最强烈的推荐！它的压缩比约为2:1.</p>\n<p>　　九. WAV<br>　　WAV是录音时用的标准的windows文件格式，文件的扩展名为“.wav”，WAVE文件作为最经典的Windows多媒体音频格式，应用非常广泛。声道有单声道和立体声之分，采样频率一般有11kHz、22kHz和44kHz三种。</p>\n<p>WAVE文件所占容量=（采样频率×采样位数×声道）×时间/8（1字节=8bit）。</p>\n<p>　　WAV文件与MIDIMP3这类多媒体声音文件比较起来，所占的硬盘空间要大得多，但WAV文件的回放效果是最好的，WAV文件直接反映了一个声音在每个时刻的大小值，1分钟44khz采样率的WAV文件就会占用10M硬盘空间！</p>\n<p>它通常作为制作高质量音乐的中间体<br>　　十.RM<br>　　Real Networks公司所制定的音频视频压缩规范称为Real Media，用户可以使用RealPlayer或RealOne Player对符合RealMedia技术规范的网络音频/视频资源进行实况转播并且RealMedia可以根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。这种格式的另一个特点是用户使用RealPlayer或RealOne Player播放器可以在不下载音频/视频内容的条件下实现在线播放。另外，RM作为目前主流网络视频格式，它还可以通过其Real Server服务器将其它格式的视频转换成RM视频并由Real Server服务器负责对外发布和播放。RM和ASF格式可以说各有千秋，通常RM视频更柔和一些，而ASF视频则相对清晰一些。<br>  RM格式一开始就定位在视频流应用方面，也可以说是视频流技术的始创者。它可以在用56 K Modem拨号上网的条件下实现不间断的视频播放，当然，其图像质量和MPEG2，DIVX等相比有一定差距，毕竟要实现在网上传输不间断的视频是需要很大带宽的。</p>\n<p>RM已经是昨日黄花，没有任何新意，低Bitrate比不过WMA，高Bitrate比不过MP3，虽然新的RM导入了ATRAC3算法，但颓势已定，很难东山再起了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"第一部分：基本概念讲解\"><a href=\"#第一部分：基本概念讲解\" class=\"headerlink\" title=\"第一部分：基本概念讲解\"></a>第一部分：基本概念讲解</h2><ul>\n<li>媒体：是表示，传输，存储信息的载体，常人们见到的文字、声音、图像、图形等都是表示信息的媒体。","more":"</li>\n<li><p>多媒体： 是声音、动画、文字、图像和录像等各种媒体的组合，以图文并茂，生动活泼的动态形式表现出来，给人以很强的视觉冲击力，留下深刻印象</p>\n</li>\n<li><p>多媒体技术：是将文字、声音、图形、静态图像、动态图像与计算集成在一起的技术。它要解决的问题是计算机进一步帮助人类按最自然的和最习惯的方式接受和处理信息。</p>\n</li>\n<li><p>流媒体 ：流媒体是指采用流式传输的方式在Internet播放的连续时基媒体格式，实际指的是一种新的媒体传送方式，而不是一种新的媒体格式（在网络上传输音/视频等多媒体信息现在主要有下载和流式传输两种方式）流式传输分两种方法：实时流式传输方式(Realtime streaming)和顺序流式传输方式(progressive streaming)。</p>\n</li>\n<li><p>多媒体文件：是既包括视频又包括音频，甚至还带有脚本的一个集合，也可以叫容器；</p>\n</li>\n<li><p>媒体编码：是文件当中的视频和音频所采用的压缩算法。也就是说一个avi的文件，当中的视频编码有可能是A，也可能是B，而其音频编码有可能是1，也有可能是2。  转码 ：指将一段多媒体包括音频、视频或者其他的内容从一种编码格式转换成为另外一种编码格式</p>\n</li>\n<li><p>视频：连续的图象变化每秒超过24帧（Frame）画面以上时，根据视觉暂留原理，人眼无法辨别单幅的静态画面，看上去是平滑连续的视觉效果，这样连续的画面叫做视频</p>\n</li>\n<li><p>音频 ：人类能听到的声音都成为音频，但是一般我们所说到的音频时存储在计算机里的声音</p>\n</li>\n</ul>\n<h2 id=\"第二部分：视频文件格式\"><a href=\"#第二部分：视频文件格式\" class=\"headerlink\" title=\"第二部分：视频文件格式\"></a>第二部分：视频文件格式</h2><ul>\n<li><p>码率：码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。 通俗一点的理解就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真。但是因为编码算法不一样，所以也不能用码率来统一衡量音质或者画质.</p>\n</li>\n<li><p>帧：帧就是一段数据的组合，它是数据传输的基本单位。就是影像动画中最小单位的单幅影像画面，相当于电影胶片上的每一格镜头。一帧就是一副静止的画面，连续的帧就形成动画，如电视图像等。</p>\n</li>\n</ul>\n<ul>\n<li>帧率：帧率即每秒显示帧数，帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过新率的帧率就浪费掉了。<br>关键帧：相当于二维动画中的原画，指角色或者物体运动或变化中的关键动作所处的那一帧，它包含了图像的所有信息，后来帧仅包含了改变了的信息。如果你没有足够的关键帧，你的影片品质可能比较差，因为所有的帧从别的帧处产生。对于一般的用途，一个比较好的原则是每5秒设一个关键键。但如果时那种实时传输的流文件，那么要考虑传输网络的可靠度，所以要1到2秒增加一个关键帧。目前我们经常见的视频格式无非就是两大类：<br>1、影像格式（Video）<br>2、流媒体格式（Stream Video）</li>\n</ul>\n<p>在影像格式中还可以根据出处划分为三大种：<br>1、AVI格式：这是由微软（Microsoft）提出，具有“悠久历史”的一种视频格式<br>2、MOV格式：这是由苹果（Apple）公司提出的一种视频格式<br>3、MPEG/MPG/DAT：这是由国际标准化组织ISO(International Standards Organization)与IEC(International Electronic Committee)联合开发的一种编码视频格式。MPEG是运动图像压缩算法的国际标准，现已被几乎所有的计算机平台共同支持。</p>\n<p>在流媒体格式中同样还可以划分为三种：<br>1、RM格式：这是由Real Networks公司开发的一种新型流式视频文件格式。<br>2、MOV/QT格式：MOV也可以作为一种流文件格式。QuickTime能够通过Internet提供实时的数字化信息流、工作流与文件回放功能，为了适应这一网络多媒体应用，QuickTime为多种流行的浏览器软件提供了相应的QuickTime Viewer插件（Plug－in），能够在浏览器中实现多媒体数据的实时回放。<br>3、ASF格式：这是由微软公司开发的流媒体格式，是一个在Internet上实时传播多媒体的技术标准。<br>4、FLV</p>\n<h2 id=\"具体视频文件格式详解：\"><a href=\"#具体视频文件格式详解：\" class=\"headerlink\" title=\"具体视频文件格式详解：\"></a>具体视频文件格式详解：</h2><ul>\n<li><p>*. MPEG/.MPG/.DAT<br>MPEG也是Motion Picture Experts Group的缩写。这类格式包括了MPEG-1, MPEG-2和 MPEG-4在内的多种视频格式。MPEG-1相信是大家接触得最多的了，因为目前其正在被广泛地应用在VCD的制作和一些视频片段下载的网络应用上面，大部分的VCD都是用 MPEG1格式压缩的( 刻录软件自动将MPEG1转为.DAT格式)，使用 MPEG-1的压缩算法，可以把一部 120 分钟长的电影压缩到1.2 GB 左右大小。MPEG-2则是应用在DVD 的制作，同时在一些HDTV（高清晰电视广播）和一些高要求视频编辑、处理上面也有相当多的应用。使用MPEG-2的压缩算法压缩一部 120 分钟长的电影可以压缩到 5-8 GB的大小（MPEG2的图像质量MPEG-1与其无法比拟的）。</p>\n</li>\n<li><p>*.AVI<br>　它的英文全称为Audio Video Interleaved，即音频视频交错格式。是将语音和影像同步组合在一起的文件格式。它对视频文件采用了一种有损压缩方式，但压缩比较高，因此尽管面面质量不是太好，但其应用范围仍然非常广泛。AVI支持256色和RLE压缩。AVI信息主要应用在多媒体光盘上，用来保存电视、电影等各种影像信息。它于1992年被Microsoft公司推出，随Windows3.1一起被人们所认识和熟知。所谓“音频视频交错”，就是可以将视频和音频交织在一起进行同步播放。这种视频格式的优点是图像质量好，可以跨多个平台使用，其缺点是体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本Windows媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本Windows媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题，如果用户在进行AVI格式的视频播放时遇到了这些问题，可以通过下载相应的解码器来解决。是目前视频文件的主流。 这种格式的文件随处可见，比如一些游戏、教育软件的片头，多媒体光盘中，都会有不少的 AVI 。现在，在WINDOWS 95或98里都能直接播放AVI，同一种格式的avi文件有可能采用不同的编码方式，最常见的有Intel Indeo（R）Video R3.2（像游戏过场动画等，是目前使用最广泛的一种avi编码技术）、Microsoft video 等。</p>\n</li>\n<li><p><em>.RA/RM/RAM\n　</em>.RM，Real Networks公司所制定的音频/视频压缩规范Real Media中的一种，Real Player能做的就是利用Internet资源对这些符合Real Media技术规范的音频/视频进行实况转播。在Real Media规范中主要包括三类文件：RealAudio、Real Video和Real Flash（Real Networks公司与Macromedia公司合作推出的新一代高压缩比动画格式）。REAL VIDEO（RA、RAM）格式由一开始就是定位就是在视频流应用方面的，也可以说是视频流技术的始创者。它可以在用56K MODEM 拨号上网的条件实现不间断的视频播放，从RealVideo的定位来看，就是牺牲画面质量来换取可连续观看性。其实RealVideo也可以实现不错的画面质量，由于RealVideo可以拥有非常高的压缩效率，很多人把VCD编码成RealVideo格式的，这样一来，一张光盘上可以存放好几部电影。REAL VIDEO存在颜色还原不准确的问题，RealVideo就不太适合专业的场合，但RealVideo出色的压缩效率和支持流式播放的特征，使得RealVideo在网络和娱乐场合占有不错的市场份额。</p>\n</li>\n<li><p>*.MOV<br>MOV格式，美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTimePlayer。具有较高的压缩比率和较完美的视频清晰度等特点，但是其最大的特点还是跨平台性，即不仅能支持MacOS，同样也能支持Windows系列,在所有视频格式当中，也许MOV格式是最不知名的。也许你会听说过QuickTime，MOV格式的文件正是由它来播放的。在PC几乎一统天下的今天，从Apple移植过来的MOV格式自然是受到排挤的。它具有跨平台、存储空间要求小的技术特点，而采用了有损压缩方式的MOV格式文件，画面效果较AVI格式要稍微好一些。到目前为止，它共有4个版本，其中以 4.0 版本的压缩率最好。这种编码支持16位图像深度的帧内压缩和帧间压缩，帧率每秒10帧以上。现在这种格式有些非编软件也可以对它时行处理，其中包括ADOBE公司的专业级多媒体视频处理软件AFTEREFFECT和PREMIERE。</p>\n</li>\n<li><p>*.ASF<br>　ASF (Advanced Streaming format高级流格式)。ASF是MICROSOFT 为了和现在的 Real player 竞争而发展出来的一种可以直接在网上观看视频节目的文件压缩格式。ASF使用了MPEG4的压缩算法，压缩率和图像的质量都很不错。因为ASF是以一个可以在网上即时观赏的视频“流”格式存在的，所以它的图像质量比VCD差一点点并不出奇，但比同是视频“流”格式的RAM格式要好。 ASF支持任意的压缩/解压缩编码方式，并可以使用任何一种底层网络传输协议，具有很大的灵活性。ASF流文件的数据速率可以在28.8Kbps到3Mbps之间变化。用户可以根据自己应用环境和网络条件选择一个合适的速率，实现VOD点播和直播。</p>\n</li>\n<li><p>*.WMV<br>　WMV是微软推出的一种流媒体格式，它是ASF的升级延伸，在同等视频质量下，WMV格式的体积非常小，因此很适合在网上播放和传输。微软希望用其取代QuickTime之类的技术标准以及WAV、AVI之类的文件扩展名。WMV的主要优点在于：可扩充的媒体类型、本地或网络回放、可伸缩的媒体类型、流的优先级化、多语言支持、扩展性等。</p>\n</li>\n<li><p>*. NAVI<br>　如果你发现原来的播放软件突然打不开此类格式的AVI文件，那你就要考虑是不是碰到了n AVI。n AVI是New AVI 的缩写，是一个名为Shadow Realm的地下组织发展起来的一种新视频格式。它是由Microsoft ASF压缩算法的修改而来的（并不是想象中的AVI），视频格式追求的无非是压缩率和图像质量，所以NAVI为了追求这个目标，改善了原始的ASF格式的一些不足，让 NAVI 可以拥有更高的帧率。可以这样说，NAVI是一种去掉视频流特性的改良型ASF格式。</p>\n</li>\n<li><p>*.FLV</p>\n</li>\n</ul>\n<p>FLV 是 FLASH VIDEO的简称，是由Macromedia公司开发的属于自己的流式视频格式。FLV也就是随着Flash MX的推出发展而来的视频格式，是在sorenson公司的压缩算法的基础上开发出来的。FLV格式不仅可以轻松的导入Flash中，速度极快，并且能其到保护版权的作用，并且可以不通过本地的微软或者REAL播放器播放视频。Flash MX 2004对其提供了完美的支持，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能，它的出现有效地解决了视频文件导入Flash后，使导出的SWF文件体积庞大，不能在网络上很好的使用等缺点。</p>\n<h2 id=\"视频文件转换：\"><a href=\"#视频文件转换：\" class=\"headerlink\" title=\"视频文件转换：\"></a>视频文件转换：</h2><p>比较常见的视频格式转化有： </p>\n<p>RM→ASF</p>\n<p>AVI→RMVB</p>\n<p>dat–&gt;divx</p>\n<p>mpg–&gt;divx</p>\n<p>vcd–&gt;rm</p>\n<p>dat–&gt;rm</p>\n<p>mpg,dat、avi、mov–&gt;rm</p>\n<p>*–&gt;FLV</p>\n<p>最近视频博客的兴起，导致了flv的快速发展</p>\n<p>AVI→MPEG(MPEG－1)<br>     例如有纪念性的家庭录影带，可以事先转换成AVI格式，再用软件将它转换成MPEG－1格式，然后用刻录器将MPEG－1格式文件刻录光盘片，得到的就是普通的VCD光盘了，可以拿到任何VCD播放器上播放。 </p>\n<p>MPEG(MPEG－1)→AVI<br>       从MPEG到AVI文件之间的转换，为磁盘节省空间。</p>\n<p>MPEG(MPEG－1)→ASF<br>       将vcd文件转码后实现VOD点播和直播。</p>\n<p>ASF→MPEG(MPEG－1)<br>      由于ASF视频格式的先天限制，一般来说它的图像质量往往比不上MPEG－1，所以转换之前，请三思而后行。</p>\n<p>DVD(MPEG－2)→VCD (MPEG－1)<br>       由于DVD驱动器尚未普及以及DVD光盘成本昂贵等客观原因，DVD影片一直未能像VCD一样流行。但我们可以将喜爱的DVD影片转换成MPEG－1格式的视频文件，留在硬盘上观看或是刻成VCD光盘。</p>\n<p>dat/mpg-&gt;mp3</p>\n<p>CD–&gt;wav,mp3,wma</p>\n<p>rm–&gt;mp3</p>\n<p>mp3–&gt;wma</p>\n<p>以上列举的视频格式转化都是比较常见的，当然了，说到底，是有这方面的实际应用需求才会出现这方面的视频转化需要。<br>比如说，要把一部VCD（也就是MPEG1编码的视频文件）制作成可以在线观看的影片，最大的瓶颈就在于文件尺寸的改变，并且要能够适应网络的特点，这样原始的格式就不能满足需  要，必须要转化成互联网视频播放规范的流媒体格式才可以，比如说是RM或者ASF，这就是需要，所以针对影像格式转化为流媒体格式的软件也就应用而生了，还有现在非常流行的MPEG4视频压缩技术，它能够把一张DVD压缩到一张CD上去，并且视频效果也不会有太大的变化，至少在我们普通用户看来也是非常不错的，而文件体积则大大减小了，这就要求有能够把DVD转化成MPEG4文件的软件出现，但是如果有人想要把RM转化成MPEG1（VCD），就没有太大的实际意义了，因为这样并不能给视频效果带来太大的提升，反而文件尺寸大了许多，所以我们很少能够看到这样的转化软件，其他的也类似，所以，在视频转化领域，可以参照以下两个原则：<br>1 有明确的应用方向：就是说一种视频格式转化成另一种视频格式，必须要有明确的应用方向，即目标格式能够有很广泛的应用价值，而不是说为了转化而转化，比如上文所说的VCD-&gt;RM，它的应用方向就是网络播放，因为现在在线电影是一个很大的市场和网络的应用方向。<br>2 能够提升播放价值： 就是说一种视频格式转化成另一种视频格式除了有明确的应用方向外，还要考虑转化是不是有价值，如果说转化后的文件播放效果没有明显提升，但是文件尺寸却大了一倍，我想这样亏本的买卖是没有人会去做的，RM转化成VCD就没有实际的意义，原因如前文所述，而DVD转化成MPEG4价值就很大，不说转化后的播放效果，单说成本就降低了不少。</p>\n<h2 id=\"音视频压缩编码标准：\"><a href=\"#音视频压缩编码标准：\" class=\"headerlink\" title=\"音视频压缩编码标准：\"></a>音视频压缩编码标准：</h2><p>多媒体编辑码方式就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，现在主要的编码方式有：</p>\n<ol>\n<li>MPEG系列： 视频编码方面主要是Mpeg1、Mpeg2、Mpeg4、Mpeg4 AVC；<br>音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3、MPEG-2 AAC、MPEG-4 AAC等等。 注意：DVD音频没有采用Mpeg的</li>\n<li><p>H.26X系列：包括H261、H262、H263、H263+、H263++、H264</p>\n</li>\n<li><p>微软windows media系列：视频编码有Mpeg-4 v1/v2/v3、Windows Media Video 7/8/9/10；音频编码有Windows Media audeo v1/v2/7/8/9</p>\n</li>\n<li><p>Real Media系列： 视频编码有RealVideo G2、RealVideo 8/9/10；音频编码有RealAudio cook/sipro、RealAudio AAC/AACPlus等</p>\n</li>\n<li><p>QuickTime系列： 视频编码有Sorenson Video 3、Apple MPEG-4、Apple H.264；音频编码有QDesign Music 2、Apple MPEG-4 AAC</p>\n</li>\n<li><p>其它，如：Ogg、On2-vpx、flash vidio，以及M-JPEG视频压缩方式</p>\n</li>\n</ol>\n<h2 id=\"各视频编码的应用场合简要：\"><a href=\"#各视频编码的应用场合简要：\" class=\"headerlink\" title=\"各视频编码的应用场合简要：\"></a>各视频编码的应用场合简要：</h2><p><a href=\"http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/luchy/archive/2007/03/27/1542478.aspx</a>这里讲的挺详细的</p>\n<ul>\n<li><ol>\n<li>Mpeg1较早的视频编码，质量比较差，主要用于 CD-ROM 存储视频，国内最为大家熟悉的就是 VCD（Video CD），他的视频编码就是采用 MPEG-1；</li>\n</ol>\n</li>\n<li><ol>\n<li>在 MPEG-1 的基础上开发的一种视频编码，它的质量远远好于 MPEG-1，所以被运用在了 DVD-Video 上面，MPEG-2 是 DVD-Video 唯一指定的视频编码。MPEG-2 不光运用于 DVD-Video ，现在大部分 HDTV（高清电视）也采用 MPEG-2 编码，分辨率达到了 1920x1080。</li>\n</ol>\n</li>\n<li><ol>\n<li>MPEG-3是MPEG组织制定的视频和音频压缩标准。本来的目标是为HDTV提供20-40Mbps视频压缩技术。在标准制定的过程中，委员会很快发现MPEG-2可以取得类似的效果。随后，MPEG-3项目停止了。</li>\n</ol>\n</li>\n<li><ol>\n<li>MPEG-4是为了适应网络的需求，采用一系列新技术，以最少的数据获得最佳的图像质量为目标的新一代编码方式。主要应用在数字电视、动态图像、互联网、实时多媒体监控、移动多媒体通信、Internet／intranet上的视频流与可视游戏、DVD上的交互多媒体应用等方面。Divx，xvid，ms mpeg4都是采用mpeg-4视频编码的。对于普通用户来说，MPEG-4在目前来说最有吸引力的地方还在于它能在普通CD-ROM上基本实现DVD的质量；用MPEG-4压缩算法的ASF(Advanced Streaming format，高级格式流)可以将120分钟的电影压缩为300MB左右的视频流；采用MPEG-4压缩算法的DIVX视频编码技术可以将120分钟的电影压缩600MB左右</li>\n</ol>\n</li>\n<li><ol>\n<li>Mpeg4 AVC和 MPEG-4 是两种不同的编码，主要是在极低码率下 MPEG-4 表现并不好，而 AVC 更加适合低带宽传输。在高码率上，AVC 的表现也要好过 MPEG-4，所以现在大有取代 MPEG-4 的趋势。下一代 HD DVD 和 Blue Ray Disc 已经正式接纳 AVC 为视频编码方案之一，相信 AVC 的发展前途会非常好。AVC/H.264极有可能成为下一代视频格式，（avs，中国标准）</li>\n</ol>\n</li>\n<li><ol>\n<li>H.261是ITU-T为在综合业务数字网(ISDN)上开展双向声像业务(可视电话、视频会议)而制定的，它是最早的运动图像压缩标准，它详细制定了视频编码的各个部分，包括运动补偿的帧间预测、DCT变换、量化、熵编码，以及与固定速率的信道相适配的速率控制等部分。</li>\n</ol>\n</li>\n<li><ol>\n<li>H.262是由ITU-T的VCEG组织和ISO/IEC的MPEG组织联合制定的，所以制定完成后分别成为了两个组织的标准，正式名称是”ITU-T建议H.262”和”ISO/IEC 13818-2”。这两个标准在所有的文字叙述上都是相同的。</li>\n</ol>\n</li>\n<li><ol>\n<li>H.263是ITU-T为低于64kb/s的窄带通信信道制定的视频编码标准，它是在H.261基础上发展起来的</li>\n</ol>\n</li>\n<li><ol>\n<li>H263+是H.263 的第二个版本，加入了许多新技术来扩展 H.263 的应用范围。</li>\n</ol>\n</li>\n<li><p>10.H.263++是在 H.263+ 上增加了几个选项，来增强码流在恶劣信道上的抗误码性能，同时提高增强编码效率。</p>\n</li>\n<li><p>11.H.264也就是前面提到的 MPEG-4 AVC。H.264是由ISO/IEC与ITU-T组成的联合视频组(JVT)制定的新一代视频压缩编码标准。在ISO/IEC中该标准命名为AVC (Advanced Video Coding)，作为MPEG-4标准的第10个选项；在ITU-T中正式命名为H.264标准。</p>\n</li>\n<li><p>12.Microsoft MPEG-4 v1/v2/v3，最早的 ASF 采用的视频编码，基于 MPEG-4 技术开发，DivX3.11 就是基于 Microsoft MPEG-4 v3 破解出来的，后来才进行了重写。</p>\n</li>\n<li><p>13.Windows Media Video 7，Microsoft 正式开发的第一个 Windows Media Video，开始脱离了 MPEG-4，和 MPEG-4 不兼容，从这一点上可见微软的野心。可惜这个版本压缩效果非常烂，打破了微软一飞冲天的美梦，不过它在压缩速度上非常快，现在网络上有很多采用这种格式压缩的 WMV。</p>\n</li>\n<li><p>14.Windows Media Video 8，在 WMV7 基础上改进的版本，质量上面进不了不少</p>\n</li>\n<li><p>15.Windows Media Video 9，微软的重头戏，不光是这一个编码，V9 系列更是一个平台，让微软有足够的能力挑战 MPEG，ITU 等标准化组织。虽然这个版本并没有微软吹得那么厉害，特别是低码率下比较差，不过跟以前版本相比进步还是非常多的。特别是 WMV HD 的应用，让微软也跻身视频标准领域。</p>\n</li>\n<li><p>16.RealVideo G2，早期的 RealVideo 编码，质量比较糟糕，不过那时在网络上算是很先进了，毕竟当时能用网络看视频的人不多。</p>\n</li>\n<li><p>17.RealVideo 8，随着 RealPlayer 8 推出的视频格式，是现在主流的网络视频编码之一。编码速度较慢，质量也只能算一般。</p>\n</li>\n<li><p>18.RealVideo 9，RealNetworks 开发的新一代编码，质量进步了很多，特别是在底码率下，而且编码速度很快，做到了速与质的很好统一。</p>\n</li>\n<li><p>19.RealVideo 10，在 RealVideo 9 基础上加入了一些参数，如 EHQ 等，更加精确控制码率，和 RealVideo 9 兼容。</p>\n</li>\n<li><p>20.Sorenson Video 3，Sorenson Media 公司随 QuickTime 5 发布的编码器，质量很不错，已经成为 QuickTime 的标准视频编码，网络上大部分电影预告片都采用这种编码。</p>\n</li>\n<li><p>21.Apple MPEG-4，Apple 公司自己开发的 MPEG-4 编码器，随 QuickTime 6 发布，质量很差。</p>\n</li>\n<li><p>22.Apple H.264，Apple 公司自己开发的 H.264 编码器，随 QuickTime 7 发布，支持 HDTV。</p>\n</li>\n<li><p>23.Ogg 是 Xiph.org 基金会发起的一个开放源代码项目，包括视频音频，服务器，传输系统，客户端，硬件支持等，最为大家熟悉的就是音频 Ogg Vorbis，它被认为是迄今为止 128kbps 码率上最好的编码器。</p>\n</li>\n<li><p>24.On2 VPX系列，On2 公司开发了一系列优秀的视频编码，现在应用得最多的恐怕是 Nullsoft Video 的视频，它们就采用了 VP3，VP5，VP6 视频编码。</p>\n</li>\n<li><p>25.Flash Video，Macromedia 公司推出的多媒体格式，主要用于在 Flash 中压缩视频。视频采用 Sorenson 公司的 Spark 编码器，音频采用 MP3，质量比较差。传闻下一代 Flash Video 准备使用 On2 VP6 ，那将让视频质量得到一个量的提升。</p>\n</li>\n<li><p>26.M-JPEG（Motion-JoinPhotographicExpertsGroup）技术即运动静止图像（或逐帧）压缩技术，广泛应用于非线性编辑领域可精确到帧编辑和多层图像处理，把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，此外M-JPEG的压缩和解压缩是对称的，可由相同的硬件和软件实现。</p>\n</li>\n</ul>\n<h2 id=\"各音频编码的应用场合简要：\"><a href=\"#各音频编码的应用场合简要：\" class=\"headerlink\" title=\"各音频编码的应用场合简要：\"></a>各音频编码的应用场合简要：</h2><ol>\n<li><p>MPEG Audio Layer 1典型数据压缩率是1：4，即每个立体声信号为384 kbps</p>\n</li>\n<li><p>MPEG Audio Layer 2典型数据压缩率是1：4—1：8，即每个立体声信号为256到192 kbps。MPEG Audio Layer1/2主要用于vcd，svcd的音频编码</p>\n</li>\n<li><p>MPEG Audio Layer 3，也就是大名鼎鼎的mp3，已经成为网络音频的主流格式，能在128kbps的码率下接近cd音质。典型数据压缩率是1：10—1：12，即每个立体声信号为128到112 kbps</p>\n</li>\n<li><p>MPEG-2 AAC（Advanced Audio Coding）是在1997年由以Bosi、Brandenburg、Johnston等为首的音频编码研究提出的，它总结了MPEG-1、MPEG-2和AC-3等的长处，在MPEG 系统上进一步改进了很多新的功能，大大增强了编码的灵活度，在保证音质的同时更大限度地压缩了码率。它和传统的mpeg audio不兼容，在理论上质量要高于mp3，并且支持多声道，在96kbps的码率范围内能接近cd音质，比mp3更加适合低码率传输；同时，MPEG-2 AAC已经成为MPEG-4标准中高质量音频编码的核心，是下一代音频压缩标准。</p>\n</li>\n<li><p>MPEG-4 AAC：是MPEG-4标准音频编码标准的一部分，apple公司自己开发有这种 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布</p>\n</li>\n<li><p>杜比数字AC-3技术也就是5.1声道技术</p>\n</li>\n<li><p>Windows Media Audio v1/v2，微软最早的音频编码技术，用于 ASF 中，后来被破解也用在 DivX Audio 中，质量比较差。</p>\n</li>\n<li><p>Windows Media Audio 7/8/9，随着各种不同的 WMV 而推出的相应的音频编码，质量节节提升，不过还没有达到 64kbps CD音质的神化</p>\n</li>\n<li><p>Windows Media Audio 9 Professional，WMA9 中出现的新编码，主要用于多声道编码和高采样率音频的编码，质量不错。</p>\n</li>\n<li><p>RealAudio Cook，早期的音频编码，但是在现在看来，仍然质量不错，可惜最高码率 96kbps。应用到了两代音频编码中：RealAudio G2、RealAudio 8。</p>\n</li>\n<li><p>RealAudio Sipro，采用了 Sipro 语音编码技术，主要针对语音编码，应用在更早期的 RealAudio 4.0、RealAudio 5.0 中。</p>\n</li>\n<li><p>RealAudio AAC，AAC 音频编码，用于 RealAudio 10 中。</p>\n</li>\n<li><p>RealAudio aacPlus，aacPlus 音频编码，用于 RealAudio 10 中，不过并没有随 RealProducer 发行，需要单独购买。</p>\n</li>\n<li><p>QDesign Music 2，QDesign Music 的第二个版本，也是最后一个版本，在时下这些先进的音频编码面前，它已经没有生命力了，主要应用于网上的电影预告片。</p>\n</li>\n<li><p>Apple MPEG-4 AAC，Apple 公司自己开发的 AAC 编码器，质量非常好，是最优秀的 AAC 编码器之一，随 QuickTime 6 发布。</p>\n</li>\n</ol>\n<h2 id=\"四种主流的视频压缩编码标准：\"><a href=\"#四种主流的视频压缩编码标准：\" class=\"headerlink\" title=\"四种主流的视频压缩编码标准：\"></a>四种主流的视频压缩编码标准：</h2><p>1、Windows Media Video 9</p>\n<p>　　相比起其他三种图像压缩技术，WMV可能是使用率最高的视频编码格式。原因十分简单，如果想使自己的影片直接给网上其他用户观看到的话，利用微软自身的视频编码标准是最简单的做法。因为只要用户的电脑中有Windows Media Player(媒体播放器)，就能够播放WMV影片，而且不用额外安装Codec（编码），所以兼容性方面完全不用担心。借助Windows Media 9.0 Series的新技术，Windows Media Video 9.0比旧的8.0版有多达15-50%的压缩率提高。而且与MPEG-4画质相比时，其容量大小只需一半即可达到。加上配合Windows Media Service 9.0服务器，在Streaming media（流媒体）方面也有更佳的表现。　　</p>\n<p>官方网站：<a href=\"http://www.microsoft.com\" target=\"_blank\" rel=\"external\">http://www.microsoft.com</a></p>\n<p>2、Real Video 9</p>\n<p>玩电脑时间长的朋友都知道，Real Video是多年前市场上最普及的音乐、图像格式。不过随着MP3、WMV及WMV等的兴起，已经使Real Media格式的普及率大不如前。但现在全世界仍然有许多的电脑玩家是Real Video的支持者，网上供下载的影片很多也是RM或RMVB格式。　RealNetwork新推出了一套名为Helix Producer的工具（也就是Real Producer 9），其中的RealVideo 9在图像压缩编码技术方面作出重大优化，无论在下载或Streaming时都声称比Windows Media 9出色，能够以一半的比特速率（bitrate）达到MPEG-4级图像，在约500 Kbps时达到接近DVD的画质表现。同样地，配合服务器可获得更出色的效果。</p>\n<p>官方网址：<a href=\"http://www.realnetworks.com\" target=\"_blank\" rel=\"external\">http://www.realnetworks.com</a></p>\n<p>3、DivX</p>\n<p>　　历史介绍：</p>\n<p>ISO公布了“超低比特率活动图像和语音压缩标准 ”，排序MPEG－4,1998年10月批准第一版，1994年4月又公布了第二版及其校验模型（VM），MPEG－4正式编号是ISO/IEC国际标准14496，它是一种新型的多媒体标准，它与前标准一个重要区别就在于，是一个基于对象的视编码压缩标准，所定义的码率控制的目标就是获得在给定码率下的最优质量，它为互联网上传输高质量的多媒体视频提供了很好的技术平台。</p>\n<p>1998年微软开发了第一个在PC上使用的MPEG－4编码器，它包括MS MPEG4V1、MS MPEG4V2、MS MPEG4V3的系列编码内码，其中V1和V2用来制作AVI文件，一直到现在它都是作为Windows的默认组件，不过V1和V2的编码质量不是很好，一直到MS　MPEG4V3才开始有好转，画质有了显著的进步，但是不知微软出于什么目的，却将这个MS　MPEGV3的视频编码内核封闭，仅仅使其应用于Windows Media流媒体技术上，也就是我们熟悉的ASF流媒体文件中。ASF文件虽然有一些优势，但是由于过分的封闭不能被编辑，末得到广泛应用，这便惹怒了那些个不怕天不怕地的视频黑客和致力于钻研视频编码的高手，后来，这些小组不仅破解了微软的视频编码，而且经过他们的修改，一种新的视频编码诞生了：那就是广为流传的MPEG编码器－DivX3.11。</p>\n<p>DivX采用了MS的MPEGV3，改良后并加入自己功能称之为DivX3.11，也是目前互联网上普通采用的MPEG－4编码器之一。很快，DivX被传得红得发紫，几乎成了业界的标准，但是，同样很快地出现了，DivX的基础技术是非法盗用微软的，微软声称将对所有推动DivX发展的人、企业进行追究，可是DivX技术的创造者之一罗达（Rota）正全面申请将DivX合法化，这是基于DivX虽然是从Window的发明出来的，但却没有用过任何微软的技术，更组建新公司DivXNetworks全力推广DivX，看来DivX（俗称压缩电影）蓬勃发展的大潮是势不可挡了。</p>\n<p>看来任何吸引眼球的故事在关键时刻都会发生转折，DivX的发展竟也不能脱离这一俗套，就在DivX顺利发展时期，DivX的技术逐渐成熟，商机无限的时候，一台好戏上演了，DivXNetworks成立初衷就是摆脱微软的技术封闭，因而发起一个完全开放源码的项目，名为 “ Projet Mayo ”，目标是开发一套全新的、开放源码的MPEG4编码软件，由于它完全符合ISO　MPEG标准，又是完全开放源代码，OpenDivXCODEC吸引了很多软件，视频高手参与，很快便开发出具有更高性能的编码器Encore2等等，就在DivX最辉煌的时期，DXN公司突然封闭了DivX的源代码，并在Encore2的基础上发布了自有产品DivX4，原来DXN早就给自己留了后门，DivX采取的是LGPL协议，而不是GPL协议，虽说它们都是公共许可证协议，保障自由使用和修改软件或源码的权利，但LGPL允许私有，DXN就是利用这一协议初其不备的耍出了大刀。</p>\n<p>接着，很多被DXN公司狠狠涮了一回的软件、视频团体另起门户，逐渐重新聚拢开发力量，高举复仇大旗，在OpenDivX版本基础上，再次开发出一种新的MPEG－4编码–XviD，名字的顺序和DviX刚好相反，仅仅从名字就可以看出Xvid充满了复仇的力量。</p>\n<p>DivX是近一两年来称霸网络视频的图像压缩编码标准。起初它是以微软MPEG 4视频编码标准为基础修改和开发的，并以免费方式发布。其特点是具有十分不错的压缩比率，可以将一整套DVD质量的影片压缩存放到一张CD-R光盘中。现在的DivX分为普通版和Pro版，其中后者还有收费版和Adware（广告）版两种，自带DivX Player程序进行播放。用户如果安装了免费的DivX Codec后，也可用Windows Media player观看DivX影片。</p>\n<p>官方网站：<a href=\"http://www.divx.com\" target=\"_blank\" rel=\"external\">http://www.divx.com</a></p>\n<p>4、Koepi’s XviD Codec</p>\n<p>相比起前三种视频编码标准来说，Xvid推出市场的时间最迟。从其名字就知道这种标准是针对DivX而来的。原来，DivX由免费转为收费编码后，使部份原有开发人员不满，继而离开并组成一个新的开发小组，设计免费且开放源代码的XviD Codec。当前，Koepi和Nic的XviD都是比较活跃和最多人使用的版本，虽然两者在编译上有所不同，但实际做出的效果相差无几。Xivd与DivX一样，在编译后都是一个.AVI文件，播放时只要安装Xvid codec就能用Windows媒体播放器中播放。</p>\n<p>官方网站：<a href=\"http://roeder.goe.net/~koepi\" target=\"_blank\" rel=\"external\">http://roeder.goe.net/~koepi</a></p>\n<h2 id=\"视频压缩基本概念：\"><a href=\"#视频压缩基本概念：\" class=\"headerlink\" title=\"视频压缩基本概念：\"></a>视频压缩基本概念：</h2><p>一、有损和无损压缩：在视频压缩中有损（Lossy）和无损（Lossless）的概念与静态图像中基本类似。无损压缩也即压缩前和解压缩后的数据完全一致。多数的无损压缩都采用RLE行程编码算法。有损压缩意味着解压缩后的数据与压缩前的数据不一致。在压缩的过程中要丢失一些人眼和人耳所不敏感的图像或音频信息，而且丢失的信息不可恢复。几乎所有高压缩的算法都采用有损压缩，这样才能达到低数据率的目标。丢失的数据率与压缩比有关，压缩比越小，丢失的数据越多，解压缩后的效果一般越差。此外，某些有损压缩算法采用多次重复压缩的方式，这样还会引起额外的数据丢失。</p>\n<p>二、帧内和帧间压缩：帧内（Intraframe）压缩也称为空间压缩（Spatial compression）。当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息，这实际上与静态图像压缩类似。帧内一般采用有损压缩算法，由于帧内压缩时各个帧之间没有相互关系，所以压缩后的视频数据仍可以以帧为单位进行编辑。帧内压缩一般达不到很高的压缩。<br>    采用帧间（Interframe）压缩是基于许多视频或动画的连续前后两帧具有很大的相关性，或者说前后两帧信息变化很小的特点。也即连续的视频其相邻帧之间具有冗余信息，根据这一特性，压缩相邻帧之间的冗余量就可以进一步提高压缩量，减小压缩比。帧间压缩也称为时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的。帧差值（Frame differencing）算法是一种典型的时间压缩法，它通过比较本帧与相邻帧之间的差异，仅记录本帧与其相邻帧的差值，这样可以大大减少数据量。</p>\n<p>三、对称和不对称编码：对称性（symmetric）是压缩编码的一个关键特征。对称意味着压缩和解压缩占用相同的计算处理能力和时间，对称算法适合于实时压缩和传送视频，如视频会议应用就以采用对称的压缩编码算法为好。而在电子出版和其它多媒体应用中，一般是把视频预先压缩处理好，尔后再播放，因此可以采用不对称（asymmetric）编码。不对称或非对称意味着压缩时需要花费大量的处理能力和时间，而解压缩时则能较好地实时回放，也即以不同的速度进行压缩和解压缩。一般地说，压缩一段视频的时间比回放（解压缩）该视频的时间要多得多。例如，压缩一段三分钟的视频片断可能需要10多分钟的时间，而该片断实时回放时间只有三分钟。</p>\n<p>第三部分：音频文件格式</p>\n<h2 id=\"一些音视频的参数含义\"><a href=\"#一些音视频的参数含义\" class=\"headerlink\" title=\"一些音视频的参数含义:\"></a>一些音视频的参数含义:</h2><p>声道：目前人们所使用的各种声场技术规范非常多，但最常见的几乎都来自三家公司，他们是Dolby（杜比）、HTX和DTS。声卡所支持的声道数是衡量声卡档次的重要指标之一，从单声道到最新的环绕立体声，下面一一详细介绍：1.单声道：单声道是比较原始的声音复制形式，早期的声卡采用的比较普遍。当通过两个扬声器回放单声道信息的时候，我们可以明显感觉到声音是从两个音箱中间传递到我们耳朵里的。这种缺乏位置感的录制方式用现在的眼光看自然是很落后的，但在声卡刚刚起步时，已经是非常先进的技术了。2.立体声：单声道缺乏对声音的位置定位，而立体声技术则彻底改变了这一状况。声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果。这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自的方向，从而使音乐更富想象力，更加接近于临场感受。立体声技术广泛运用于自Sound Blaster Pro以后的大量声卡，成为了影响深远的一个音频标准。时至今日，立体声依然是许多产品遵循的技术标准。3.准立体声：准立体声声卡的基本概念就是：在录制声音的时候采用单声道，而放音有时是立体声，有时是单声道。采用这种技术的声卡也曾在市面上流行过一段时间，但现在已经销声匿迹了。4.四声道环绕：人们的欲望是无止境的，立体声虽然满足了人们对左右声道位置感体验的要求，但是随着技术的进一步发展，大家逐渐发现双声道已经越来越不能满足我们的需求。由于PCI声卡的出现带来了许多新的技术，其中发展最为神速的当数三维音效。三维音效的主旨是为人们带来一个虚拟的声音环境，通过特殊的HRTF技术营造一个趋于真实的声场，从而获得更好的游戏听觉效果和声场定位。而要达到好的效果，仅仅依靠两个音箱是远远不够的，所以立体声技术在三维音效面前就显得捉襟见肘了，但四声道环绕音频技术则很好的解决了这一问题。四声道环绕规定了4个发音点：前左、前右，后左、后右，听众则被包围在这中间。同时还建议增加一个低音音箱，以加强对低频信号的回放处理(这也就是如今4.1声道音箱系统广泛流行的原因)。就整体效果而言，四声道系统可以为听众带来来自多个不同方向的声音环绕，可以获得身临各种不同环境的听觉感受，给用户以全新的体验。如今四声道技术已经广泛融入于各类中高档声卡的设计中，成为未来发展的主流趋势。5.5.1声道5.1声道已广泛运用于各类传统影院和家庭影院中，一些比较知名的声音录制压缩格式，譬如杜比AC-3（Dolby Digital）、DTS等都是以5.1声音系统为技术蓝本的。其实5.1声音系统来源于4.1环绕，不同之处在于它增加了一个中置单元。这个中置单元负责传送低于80Hz的声音信号，在欣赏影片时有利于加强人声，把对话集中在整个声场的中部，以增加整体效果。相信每一个真正体验过Dolby AC-3音效的朋友都会为5.1声道所折服。千万不要以为5.1已经是环绕立体声的顶峰了，更强大的7.1系统已经出现了。它在5.1的基础上又增加了中左和中右两个发音点，以求达到更加完美的境界。由于成本比较高，没有广泛普及。</p>\n<p>一.WMA<br>　　WMA的全称是Windows Media Audio，是微软力推的一种音频格式。WMA格式是以减少数据流量但保持音质的方法来达到更高的压缩率目的，其压缩率一般可以达到1:18，生成的文件大小只有相应MP3文件的一半。此外，WMA还可以通过DRM（Digital Rights Management）方案加入防止拷贝，或者加入限制播放时间和播放次数，甚至是播放机器的限制，可有力地防止盗版。</p>\n<p>优点<br>WMA 7之后的WMA支持证书加密，未经许可（即未获得许可证书），即使是非法拷贝到本地，也是无法收听的。同时，微软公司开始时宣称的：同文件比MP3体积小一倍而音质不变，也得到了兑现。事实上，这个说法，仅仅适用于低比特率的情况，另外，微软公司在WMA 9大幅改进了其引擎，实际上几乎可以在同文件同音质下比相同的MP3体积少1/3左右。<br>缺点<br>在高比率的渲染能力低下，同音源的一个320KBPS的MP3与比较192KBPS的WMA相比，音质和渲染力很容易分别出是前者较优。</p>\n<p>　　二.VQF<br>　　VQF即TwinVQ（Transform－domain Weighted Interleave Vector Quantization），是由NTT（Nippon Telegraph and Telephone）与Yamaha共同开发的一种音频压缩技术。VQF的音频压缩率比标准的MPEG音频压缩率高出近一倍，可以达到18:1左右甚至更高。也就是说把一首4分钟的歌曲（WAV文件）压成MP3，大约需要4MB左右的硬盘空间，而同一首歌曲，如果使用VQF音频压缩技术的话，那只需要2MB左右的硬盘空间。因此，在音频压缩率方面，MP3和RA都不是VQF的对手。</p>\n<p>但是VQF不支持”流”，这可能也是为什么现在它完全被WMA压下去的一个主要原因.</p>\n<p>　　三.MP3<br>MP3的全称是Moving Picture Experts Group Audio Layer III。简单的说，MP3就是一种音频压缩技术，由于这种压缩方式的全称叫MPEG Audio Layer3，所以人们把它简称为MP3。MP3是利用MPEG Audio Layer 3的技术，将音乐以1:10甚至1:12 的压缩率，压缩成容量较小的file，换句话说，能够在音质丢失很小的情况下把文件压缩到更小的程度。而且还非常好的保持了原来的音质。正是因为MP3体积小，音质高的特点使得MP3格式几乎成为网上音乐的代名词。每分钟音乐的MP3格式只有1MB左右大小，这样每首歌的大小只有3-4兆字节。使用MP3播放器对MP3文件进行实时的解压缩(解码)，这样，高品质的MP3音乐就播放出来了。　　</p>\n<p>MP3最受争议的就是音质问题(尤其是随着WMA的普及)，其高频损失很大，很多MP3编码器粗糙的编码算法不但导致高频丢失，还丢失了许多细节，类似吉他擦弦的感觉在MP3中是找不到的.在对MP3快要失望时，偶发现了Lame,它支持根据人耳遮蔽效应原理来分析波形，配合VBR技术，可以让音质达到令人吃惊的地步;其独创的心理音响模型技术保证了CD音频还原的真实性，配合VBR(动态比特率)和ABR(平均比特率)参数，编码出来的MP3音色纯厚、空间宽广、低音清晰、细节表现良好,音质几乎可以媲美CD音频，但文件体积却非常小.很多网友在使用LAME后的反映就是：立刻删除硬盘上所有的MP3和其他编码器，全部用Lame重新来过。Lame提供EXE和DLL，其中DLL是作为标准的动态运行库供其他程序调用.EXE是Command Line程序，象DOS程序一样工作，两者彼此独立，互不关联。但大家很快能发现两者编码的质量是不一样的,那是由于dll可控性差，与具备丰富调节参数的EXE版相比，其压缩出来的MP3效果稍逊一筹。但EXE是一个命令行工具，操作很麻烦，幸亏有了WinLAMEr或lameGUIxp这些Shell。只要学会使用这些Shell(是傻瓜型的,一看即会)，就可以用LAME压缩出最最精彩的MP3了。再说说APS,在LAME出现以前，APS就是最好的MP3编码器，它使用的Fraunhofer IIS编码算法，这比LAME使用的编码算法要先进，在192k Bitrate(CBR)下，甚至比LAME编码的曲子要优秀，细节明显要丰富一些，但APS本身不支持VBR，当Bitrate往上提高时，音质就要比LAME编码的要差了，大部分朋友的MP3的一般都是128-192K Bitrate的，因此APS仍旧有推荐的价值。特别是有很多MP3随身听不支持VBR和256K Bitrate以上的MP3，LAME就不一定合适这些朋友了，APS就成了不错的选择，由它编码的曲子，绝对不会辱没你昂贵的PLAYER.</p>\n<p>　　四.MP3PRO<br>　　MP3PRO完全是基于传统MP3编码技术的一种改良，本身最大的技术亮点就在于SBR(Spectral Band Replication频段复制),这是一种新的音频编码增强算法.它提供了改善低位率情况下音频和语音编码的性能的可能.这种方法可在指定的位率下增加音频的带宽或改善编码效率,SBR最大的优势就是在低数据速率下实现非常高效的编码.如果在高数据速率的情况下，SBR将如同虚设.当制作MP3PRO文件时，编码器将音频分为两部分。一部分是将音频数据中的低频段部分分离出来，通过传统的MP3技术而编码得出的正常的MP3音频流，此举可令到MP3编码器可以专注于低频段信号从而获得更好的压缩质量，而且原来的MP3播放器也可播放MP3PRO文件。另一部分则是将分离出来的高频段信号进行编码并嵌入到MP3流中，传统的MP3播放器会将其忽略掉，而新的MP3PRO播放器则可从中还原出高频信号，并将两者进行组合，得到高质量的全带宽的声音.官方宣称通过这样的技术，使得MP3PRO能在64kbps的编码率便可提供与128kbps的mp3相同的质量。低比特率下MP3PRO的性能很明显地比MP3要高,但是它与WMA谁胜谁负就很难说了,根据一些发烧友的评测, MP3PRO似乎略胜一些.高比特率下很少有人用到MP3PRO.</p>\n<p>五.OGG<br>　　OGG格式的全称应该是OGG Vobis。它是一种新的音频压缩格式，类似于MP3等现有的音乐格式。但有一点不同的是，它是完全免费、开放和没有专利限制的。OGG Vobis有一个很出众的特点，就是支持多声道，随着它的流行，以后用随身听来听DTS编码的多声道作品将不会是梦想。OGG Vobis在压缩技术上比MP3好，而且它的多声道，免费，开源这些特点，使它很有可能成为一个流行的趋势，这也正是一些MP3播放器对其支持的原因</p>\n<p>在高音质要求下,有损音频编码世界中是三足项立，分别为MP3、MPC、OGG。　</p>\n<p>Ogg Vorbis中的主要算法还是利用MDCT（修饰离散余弦变换Modified Discrete Cosine Transform ）而不是用现在比较时兴的小波（wavelet）技术。Ogg的多通道编码技术，统称为立体声通道耦合Stereo Channel Coupling。而该技术实际又是由两种不同的技术组成的：channel interleaving 和 square polar mapping，而这也是Ogg能成为免费制式的一个必要条件，以往的“联合立体声Joint Stereo”的编码模式是有专利限制的。据官方声称，与其他会造成立体空间感减弱的编码模型相比，这两种技术都可以在保持编码器的灵活性的同时而不损害本来的立体声空间影像――相信配合iRiver的3d音效会有更好的表现力，而且实现的复杂程度比联合立体声方式要低。<br>　　OGG Vorbis这种编码也远比90年代开发成功的MP3先进，它可以在相对较低的数据速率下实现比MP3更好的音质！――我认为Ogg很象MD的atrac格式，特别象新的lp2编码，它能在低别特率下有着很要的音质。此外，在编码上，Ogg Vorbis是使用了VBR（可变比特率）和ABR（平均比特率）方式进行编码，所以理论上，Ogg Vorbis带来的音乐可以比采用CBR文件有更好的声音表现，当然前提是两者使用同样比特率(Bit Rate)的压缩模式――这里可以知道。Ogg Vorbis的比特率缩放功能可以在不用重新编码的情况下调节文件的相关压缩率，与此同时，Ogg文件的单位编辑能力和超越左右声道的音频流技术可以带来更为奇妙的音乐享受。Vorbis还具有比特率缩放功能，可以不用重新编码便可调节文件的比特率。<br>　　Vorbis文件可以被分成小块并以样本粒度（granularity，专业术语，指数据可以被分割的最小尺寸）进行编辑；Vorbis支持多通道（大于2）音频流并使用了独创性的处理技术；这意味着什么？这意味着Ogg Vorbis在SACD、DTSCD、DVD AUDIO抓轨软件（目前这种软件还没有）的支持下，可以对所有的声道进行编码，而不是MP3只能编码2个声道。多声道音乐的兴起，给音乐欣赏带来了革命性的变化，尤其在欣赏交响时，会带来更多临场感。这场革命性的变化是MP3无法适应的。在以后的播放技术不断提高以后，而且人们对音质要求不断提高，Ogg的优势将更加明显。<br>　　六. MPC<br>　　MusePaCk是由德国人Andree Buschmann开发的一种完全免费的高品质音频格式。在其问世之前，Lame MP3是公认音质最好的有损压缩方案，追求音质的人对它趋之若鹜。但现在这个桂冠无疑该让给MPC了，在中高码率下，MPC可以做到比MP3更好音质。在高码率下，MPC的高频要比MP3细腻不少，可以在节省大量空间的前提下获得最佳音质的音乐欣赏，是目前最适合用于音乐欣赏的有损编码。</p>\n<p>MPC的编码方案是在MP2的基础上改进而来。它同样采用子带编码技术，但相比MP2，它所采用的心理声学模型要优秀得多，并加入了像ANS（Adaptive Noise Shaping）、CVD(ClearVoiceDetection)等技术，甚至改变了压缩时所用的Huffman（哈夫曼）编码，以得到更大的压缩率。另外，MPC采用的是可变码率进行编码。毫无疑问，可变码率的编码效率要高于固定码率，因为前者可以合理地分配数据量，在信号复杂（微弱）时提高（降低）比特率，在得到满意的效果又能确保不错的压缩率。为了保证高音质，MPC的瞬间最大码率甚至高达1.32Mbps，这已经快接近CD的1.41Mbps了</p>\n<p>较高比特率下(250kbps左右),MPC表现非常的出众,甚至超过了MP3，很难分辨它和原始信号有多少区别，无论从频率保留还是细节保留，以及信号强度失真来说，MPC太优秀了.但MPC并非万能的，它无法编码48khz采样率的曲子，所幸的是，这样的曲子来源很少.可惜这种格式并没有像MP3或WMA那样流行.</p>\n<p>　　七.ATRAC<br>　　ATRAC（Adaptive TRansform Acoustic Coding自适应声学转换编码技术）：是Sony的原创音乐压缩技术，主要用于MD Walkman的录音及播放方面。是一项基于听觉心理学领域的研究和不损伤可闻声质量的数码音频译码压缩技术，对音乐资讯有效的进行压缩，压缩的比率为原来的五分之一，因为MD使用了ATRAC压缩技术，这样的压缩大大节省了许多空间，所以 CD的碟片要120mm大小，而MD只需64mm就可以录下74分钟的音乐。</p>\n<p>ATRAC压缩技术主要是利用了人耳的蔽遮效应，在心理声学原理上，在进行音频录入的同时，有许多外部的频段同时也会被录入，当人耳同时听到两个不同频率、不同音量的声音时，音量较小的低频及音量较小的高频连同不为人耳所察觉的频段信号都会被自动减弱或忽略不予记录，因此又可以称为适应性变换声码技术，由于近年來编码压缩技术（ATRAC的版本）越來越成熟，所以经过编码解码过程后的声音仍直逼CD，大家就不必担心音质差啦。</p>\n<p>ATRAC将16比特44.1KHz的数字信号以频率响应轴分成52个区段（在低频时分割较细而在高频时分割较粗），根据声音心理学的原理，将声音信号中人耳听不到和对人的听力影响不大的信息给剔除出去而达到缩小声音文件的目的。利用这种原理，ATRAC可以将录音的资料量压缩为原来的五分之一（即压缩比为1：5）。</p>\n<p>.</p>\n<p>　　八. APE　<br>　　  APE的本质，其实它是一种无损压缩音频格式。庞大的WAV音频文件可以通过Monkey’’s Audio这个软件进行“瘦身”压缩为APE。很时候它被用做网络音频文件传输，因为被压缩后的APE文件容量要比WAV源文件小一半多，可以节约传输所用的时间。更重要的是，通过Monkey’’s Audio解压缩还原以后得到的WAV文件可以做到与压缩前的源文件完全一致。所以APE被誉为“无损音频压缩格式”，Monkey’’s Audio被誉为“无损音频压缩软件”。与采用WinZip或者WinRAR这类专业数据压缩软件来压缩音频文件不同，压缩之后的APE音频文件是可以直接被播放的。 Monkey’’s Audio会向Winamp中安装一个“in_APE.dll”插件，从而使Winamp也具备播放APE文件的能力。 </p>\n<p>和上面介绍的几款编码不同的是，这个编码提供了最好的音质保证(无损压缩)！还提供了Winamp的插件支持,可以直接用Winamp来播放.所谓无损就是指压缩后的格式和源文件在音质上并无差异，而Mp3、WMA等的编码方案是基于有损的，在损失部分音质的前提下节约存贮空间，所以说音质再好的Mp3、WMA也只能是无限接近源文件的音质。APE非常适合来编码讲究细节的独奏曲目和大动态的交响曲。向各位音乐迷们(不是歌迷)作最强烈的推荐！它的压缩比约为2:1.</p>\n<p>　　九. WAV<br>　　WAV是录音时用的标准的windows文件格式，文件的扩展名为“.wav”，WAVE文件作为最经典的Windows多媒体音频格式，应用非常广泛。声道有单声道和立体声之分，采样频率一般有11kHz、22kHz和44kHz三种。</p>\n<p>WAVE文件所占容量=（采样频率×采样位数×声道）×时间/8（1字节=8bit）。</p>\n<p>　　WAV文件与MIDIMP3这类多媒体声音文件比较起来，所占的硬盘空间要大得多，但WAV文件的回放效果是最好的，WAV文件直接反映了一个声音在每个时刻的大小值，1分钟44khz采样率的WAV文件就会占用10M硬盘空间！</p>\n<p>它通常作为制作高质量音乐的中间体<br>　　十.RM<br>　　Real Networks公司所制定的音频视频压缩规范称为Real Media，用户可以使用RealPlayer或RealOne Player对符合RealMedia技术规范的网络音频/视频资源进行实况转播并且RealMedia可以根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。这种格式的另一个特点是用户使用RealPlayer或RealOne Player播放器可以在不下载音频/视频内容的条件下实现在线播放。另外，RM作为目前主流网络视频格式，它还可以通过其Real Server服务器将其它格式的视频转换成RM视频并由Real Server服务器负责对外发布和播放。RM和ASF格式可以说各有千秋，通常RM视频更柔和一些，而ASF视频则相对清晰一些。<br>  RM格式一开始就定位在视频流应用方面，也可以说是视频流技术的始创者。它可以在用56 K Modem拨号上网的条件下实现不间断的视频播放，当然，其图像质量和MPEG2，DIVX等相比有一定差距，毕竟要实现在网上传输不间断的视频是需要很大带宽的。</p>\n<p>RM已经是昨日黄花，没有任何新意，低Bitrate比不过WMA，高Bitrate比不过MP3，虽然新的RM导入了ATRAC3算法，但颓势已定，很难东山再起了。</p>"},{"title":"Python基础知识-字典","date":"2016-04-10T02:55:29.000Z","_content":"字典这种数据结构，我们又称之为映射(mapping)，在java中也是这么称呼的，但是在python中我们称之为字典，与OC中的叫法一致。\n<!--more-->\n## 创建字典\n```\n>>> dicts = {'name':'han','tele':'136'}//直接创建\n\n>>> xiaohan = ('xiaohan',42)//利用dict函数来创建\n>>> xiaoming = ('xiaoming',45)\n>>> items = [xiaohan,xiaoming]\n>>> d = dict(items)\n>>> d\n{'xiaohan': 42, 'xiaoming': 45}\n>>> \n\n>>> d = dict(name='han',age=43)//或者dict函数还可以这样来用\n>>> d\n{'age': 43, 'name': 'han'}\n>>> \n```\n## 基本操作\n- len(d)返回d中键值对的数量\n- d[k]返回关联到k上的值\n- d[k]=v将值v关联到键为k的项上\n- del d[k]删除键为k的项\n- k in d检查d中是否含有键为k的项\n- 键类型可以是任意类型，比如元组，浮点数或者字符串\n- 自动添加，及时键起出在字典中并不存在，也可以赋值，这样字典就会建立起新的项\n- 成员资格:用k in d查找的是键而不是值，而在列表中，v in l是用值在查找，而不是索引\n\n## 字典方法\n### clear\n```\n\n```\n### \n\n","source":"_posts/2017/Python基础知识-字典.md","raw":"---\ntitle: Python基础知识-字典\ndate: 2016-04-10 10:55:29\ntags:\n- Python\ncategories: Python\n---\n字典这种数据结构，我们又称之为映射(mapping)，在java中也是这么称呼的，但是在python中我们称之为字典，与OC中的叫法一致。\n<!--more-->\n## 创建字典\n```\n>>> dicts = {'name':'han','tele':'136'}//直接创建\n\n>>> xiaohan = ('xiaohan',42)//利用dict函数来创建\n>>> xiaoming = ('xiaoming',45)\n>>> items = [xiaohan,xiaoming]\n>>> d = dict(items)\n>>> d\n{'xiaohan': 42, 'xiaoming': 45}\n>>> \n\n>>> d = dict(name='han',age=43)//或者dict函数还可以这样来用\n>>> d\n{'age': 43, 'name': 'han'}\n>>> \n```\n## 基本操作\n- len(d)返回d中键值对的数量\n- d[k]返回关联到k上的值\n- d[k]=v将值v关联到键为k的项上\n- del d[k]删除键为k的项\n- k in d检查d中是否含有键为k的项\n- 键类型可以是任意类型，比如元组，浮点数或者字符串\n- 自动添加，及时键起出在字典中并不存在，也可以赋值，这样字典就会建立起新的项\n- 成员资格:用k in d查找的是键而不是值，而在列表中，v in l是用值在查找，而不是索引\n\n## 字典方法\n### clear\n```\n\n```\n### \n\n","slug":"2017/Python基础知识-字典","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pn6003osauapnwj2mh3","content":"<p>字典这种数据结构，我们又称之为映射(mapping)，在java中也是这么称呼的，但是在python中我们称之为字典，与OC中的叫法一致。<br><a id=\"more\"></a></p>\n<h2 id=\"创建字典\"><a href=\"#创建字典\" class=\"headerlink\" title=\"创建字典\"></a>创建字典</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; dicts = &#123;&apos;name&apos;:&apos;han&apos;,&apos;tele&apos;:&apos;136&apos;&#125;//直接创建</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; xiaohan = (&apos;xiaohan&apos;,42)//利用dict函数来创建</div><div class=\"line\">&gt;&gt;&gt; xiaoming = (&apos;xiaoming&apos;,45)</div><div class=\"line\">&gt;&gt;&gt; items = [xiaohan,xiaoming]</div><div class=\"line\">&gt;&gt;&gt; d = dict(items)</div><div class=\"line\">&gt;&gt;&gt; d</div><div class=\"line\">&#123;&apos;xiaohan&apos;: 42, &apos;xiaoming&apos;: 45&#125;</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; d = dict(name=&apos;han&apos;,age=43)//或者dict函数还可以这样来用</div><div class=\"line\">&gt;&gt;&gt; d</div><div class=\"line\">&#123;&apos;age&apos;: 43, &apos;name&apos;: &apos;han&apos;&#125;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><ul>\n<li>len(d)返回d中键值对的数量</li>\n<li>d[k]返回关联到k上的值</li>\n<li>d[k]=v将值v关联到键为k的项上</li>\n<li>del d[k]删除键为k的项</li>\n<li>k in d检查d中是否含有键为k的项</li>\n<li>键类型可以是任意类型，比如元组，浮点数或者字符串</li>\n<li>自动添加，及时键起出在字典中并不存在，也可以赋值，这样字典就会建立起新的项</li>\n<li>成员资格:用k in d查找的是键而不是值，而在列表中，v in l是用值在查找，而不是索引</li>\n</ul>\n<h2 id=\"字典方法\"><a href=\"#字典方法\" class=\"headerlink\" title=\"字典方法\"></a>字典方法</h2><h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p>### </p>\n","site":{"data":{}},"excerpt":"<p>字典这种数据结构，我们又称之为映射(mapping)，在java中也是这么称呼的，但是在python中我们称之为字典，与OC中的叫法一致。<br>","more":"</p>\n<h2 id=\"创建字典\"><a href=\"#创建字典\" class=\"headerlink\" title=\"创建字典\"></a>创建字典</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; dicts = &#123;&apos;name&apos;:&apos;han&apos;,&apos;tele&apos;:&apos;136&apos;&#125;//直接创建</div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; xiaohan = (&apos;xiaohan&apos;,42)//利用dict函数来创建</div><div class=\"line\">&gt;&gt;&gt; xiaoming = (&apos;xiaoming&apos;,45)</div><div class=\"line\">&gt;&gt;&gt; items = [xiaohan,xiaoming]</div><div class=\"line\">&gt;&gt;&gt; d = dict(items)</div><div class=\"line\">&gt;&gt;&gt; d</div><div class=\"line\">&#123;&apos;xiaohan&apos;: 42, &apos;xiaoming&apos;: 45&#125;</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\"></div><div class=\"line\">&gt;&gt;&gt; d = dict(name=&apos;han&apos;,age=43)//或者dict函数还可以这样来用</div><div class=\"line\">&gt;&gt;&gt; d</div><div class=\"line\">&#123;&apos;age&apos;: 43, &apos;name&apos;: &apos;han&apos;&#125;</div><div class=\"line\">&gt;&gt;&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><ul>\n<li>len(d)返回d中键值对的数量</li>\n<li>d[k]返回关联到k上的值</li>\n<li>d[k]=v将值v关联到键为k的项上</li>\n<li>del d[k]删除键为k的项</li>\n<li>k in d检查d中是否含有键为k的项</li>\n<li>键类型可以是任意类型，比如元组，浮点数或者字符串</li>\n<li>自动添加，及时键起出在字典中并不存在，也可以赋值，这样字典就会建立起新的项</li>\n<li>成员资格:用k in d查找的是键而不是值，而在列表中，v in l是用值在查找，而不是索引</li>\n</ul>\n<h2 id=\"字典方法\"><a href=\"#字典方法\" class=\"headerlink\" title=\"字典方法\"></a>字典方法</h2><h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<p>### </p>"},{"title":"Python基础知识-文件操作","date":"2016-04-16T02:13:01.000Z","_content":"python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。\n<!--more-->\n- 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()\n- 返回指定目录下的所有文件和目录名:os.listdir()\n- 函数用来删除一个文件:os.remove()\n- 删除多个目录：os.removedirs（r“c：\\python”）\n- 检验给出的路径是否是一个文件：os.path.isfile()\n- 检验给出的路径是否是一个目录：os.path.isdir()\n- 判断是否是绝对路径：os.path.isabs()\n- 检验给出的路径是否真地存:os.path.exists()\n- 返回一个路径的目录名和文件名:os.path.split()     \n```\nos.path.split('/home/swaroop/byte/code/poem.txt') 结果：('/home/swaroop/byte/code', 'poem.txt') \n```\n- 分离扩展名：os.path.splitext()\n- 获取路径名：os.path.dirname()\n- 获取文件名：os.path.basename()\n- 运行shell命令: os.system()\n- 读取和设置环境变量:os.getenv() 与os.putenv()\n- 给出当前平台使用的行终止符:os.linesep    Windows使用'\\r\\n'，Linux使用'\\n'而Mac使用'\\r'\n- 指示你正在使用的平台：os.name       对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'\n- 重命名：os.rename（old， new）\n- 创建多级目录：os.makedirs（r“c：\\python\\test”）\n- 创建单个目录：os.mkdir（“test”）\n- 获取文件属性：os.stat（file）\n- 修改文件权限与时间戳：os.chmod（file）\n- 终止当前进程：os.exit（）\n- 获取文件大小：os.path.getsize（filename）\n- os.mknod(\"test.txt\")        创建空文件\n- fp = open(\"test.txt\",w)     直接打开一个文件，如果文件不存在则创建文件\n>关于open 模式:\nw     以写方式打开，\na     以追加模式打开 (从 EOF 开始, 必要时创建新文件)\nr+     以读写模式打开\nw+     以读写模式打开 (参见 w )\na+     以读写模式打开 (参见 a )\nrb     以二进制读模式打开\nwb     以二进制写模式打开 (参见 w )\nab     以二进制追加模式打开 (参见 a )\nrb+    以二进制读写模式打开 (参见 r+ )\nwb+    以二进制读写模式打开 (参见 w+ )\nab+    以二进制读写模式打开 (参见 a+ )\n\n- fp.read([size])                     #size为读取的长度，以byte为单位\n- fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分\n- fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。\n- fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符\n- fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。\n- fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError\n- fp.flush()                                      #把缓冲区的内容写入硬盘\n- fp.fileno()                                      #返回一个长整型的”文件标签“\n- fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）\n- fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点\n- fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。\n- fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。\n\n- fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。\n\n- os.mkdir(\"file\")                   创建目录\n复制文件：\n- shutil.copyfile(\"oldfile\",\"newfile\")       oldfile和newfile都只能是文件\n- shutil.copy(\"oldfile\",\"newfile\")            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录\n复制文件夹：\n- shutil.copytree(\"olddir\",\"newdir\")        olddir和newdir都只能是目录，且newdir必须不存在\n重命名文件（目录）\n- os.rename(\"oldname\",\"newname\")       文件或目录都是使用这条命令\n移动文件（目录）\n- shutil.move(\"oldpos\",\"newpos\")   \n删除文件\n- os.remove(\"file\")\n删除目录\n- os.rmdir(\"dir\")只能删除空目录\nshutil.rmtree(\"dir\")    空目录、有内容的目录都可以删\n转换目录\n- os.chdir(\"path\")   换路径\n","source":"_posts/2017/Python基础知识-文件操作.md","raw":"---\ntitle: Python基础知识-文件操作\ndate: 2016-04-16 10:13:01\ntags:\n- Python\ncategories: Python\n---\npython中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。\n<!--more-->\n- 得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()\n- 返回指定目录下的所有文件和目录名:os.listdir()\n- 函数用来删除一个文件:os.remove()\n- 删除多个目录：os.removedirs（r“c：\\python”）\n- 检验给出的路径是否是一个文件：os.path.isfile()\n- 检验给出的路径是否是一个目录：os.path.isdir()\n- 判断是否是绝对路径：os.path.isabs()\n- 检验给出的路径是否真地存:os.path.exists()\n- 返回一个路径的目录名和文件名:os.path.split()     \n```\nos.path.split('/home/swaroop/byte/code/poem.txt') 结果：('/home/swaroop/byte/code', 'poem.txt') \n```\n- 分离扩展名：os.path.splitext()\n- 获取路径名：os.path.dirname()\n- 获取文件名：os.path.basename()\n- 运行shell命令: os.system()\n- 读取和设置环境变量:os.getenv() 与os.putenv()\n- 给出当前平台使用的行终止符:os.linesep    Windows使用'\\r\\n'，Linux使用'\\n'而Mac使用'\\r'\n- 指示你正在使用的平台：os.name       对于Windows，它是'nt'，而对于Linux/Unix用户，它是'posix'\n- 重命名：os.rename（old， new）\n- 创建多级目录：os.makedirs（r“c：\\python\\test”）\n- 创建单个目录：os.mkdir（“test”）\n- 获取文件属性：os.stat（file）\n- 修改文件权限与时间戳：os.chmod（file）\n- 终止当前进程：os.exit（）\n- 获取文件大小：os.path.getsize（filename）\n- os.mknod(\"test.txt\")        创建空文件\n- fp = open(\"test.txt\",w)     直接打开一个文件，如果文件不存在则创建文件\n>关于open 模式:\nw     以写方式打开，\na     以追加模式打开 (从 EOF 开始, 必要时创建新文件)\nr+     以读写模式打开\nw+     以读写模式打开 (参见 w )\na+     以读写模式打开 (参见 a )\nrb     以二进制读模式打开\nwb     以二进制写模式打开 (参见 w )\nab     以二进制追加模式打开 (参见 a )\nrb+    以二进制读写模式打开 (参见 r+ )\nwb+    以二进制读写模式打开 (参见 w+ )\nab+    以二进制读写模式打开 (参见 a+ )\n\n- fp.read([size])                     #size为读取的长度，以byte为单位\n- fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分\n- fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。\n- fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符\n- fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。\n- fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError\n- fp.flush()                                      #把缓冲区的内容写入硬盘\n- fp.fileno()                                      #返回一个长整型的”文件标签“\n- fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）\n- fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点\n- fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。\n- fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。\n\n- fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。\n\n- os.mkdir(\"file\")                   创建目录\n复制文件：\n- shutil.copyfile(\"oldfile\",\"newfile\")       oldfile和newfile都只能是文件\n- shutil.copy(\"oldfile\",\"newfile\")            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录\n复制文件夹：\n- shutil.copytree(\"olddir\",\"newdir\")        olddir和newdir都只能是目录，且newdir必须不存在\n重命名文件（目录）\n- os.rename(\"oldname\",\"newname\")       文件或目录都是使用这条命令\n移动文件（目录）\n- shutil.move(\"oldpos\",\"newpos\")   \n删除文件\n- os.remove(\"file\")\n删除目录\n- os.rmdir(\"dir\")只能删除空目录\nshutil.rmtree(\"dir\")    空目录、有内容的目录都可以删\n转换目录\n- os.chdir(\"path\")   换路径\n","slug":"2017/Python基础知识-文件操作","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pn9003qsaua9ieteu3r","content":"<p>python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。<br><a id=\"more\"></a></p>\n<ul>\n<li>得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()</li>\n<li>返回指定目录下的所有文件和目录名:os.listdir()</li>\n<li>函数用来删除一个文件:os.remove()</li>\n<li>删除多个目录：os.removedirs（r“c：\\python”）</li>\n<li>检验给出的路径是否是一个文件：os.path.isfile()</li>\n<li>检验给出的路径是否是一个目录：os.path.isdir()</li>\n<li>判断是否是绝对路径：os.path.isabs()</li>\n<li>检验给出的路径是否真地存:os.path.exists()</li>\n<li><p>返回一个路径的目录名和文件名:os.path.split()     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">os.path.split(&apos;/home/swaroop/byte/code/poem.txt&apos;) 结果：(&apos;/home/swaroop/byte/code&apos;, &apos;poem.txt&apos;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>分离扩展名：os.path.splitext()</p>\n</li>\n<li>获取路径名：os.path.dirname()</li>\n<li>获取文件名：os.path.basename()</li>\n<li>运行shell命令: os.system()</li>\n<li>读取和设置环境变量:os.getenv() 与os.putenv()</li>\n<li>给出当前平台使用的行终止符:os.linesep    Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’</li>\n<li>指示你正在使用的平台：os.name       对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’</li>\n<li>重命名：os.rename（old， new）</li>\n<li>创建多级目录：os.makedirs（r“c：\\python\\test”）</li>\n<li>创建单个目录：os.mkdir（“test”）</li>\n<li>获取文件属性：os.stat（file）</li>\n<li>修改文件权限与时间戳：os.chmod（file）</li>\n<li>终止当前进程：os.exit（）</li>\n<li>获取文件大小：os.path.getsize（filename）</li>\n<li>os.mknod(“test.txt”)        创建空文件</li>\n<li><p>fp = open(“test.txt”,w)     直接打开一个文件，如果文件不存在则创建文件</p>\n<blockquote>\n<p>关于open 模式:<br>w     以写方式打开，<br>a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)<br>r+     以读写模式打开<br>w+     以读写模式打开 (参见 w )<br>a+     以读写模式打开 (参见 a )<br>rb     以二进制读模式打开<br>wb     以二进制写模式打开 (参见 w )<br>ab     以二进制追加模式打开 (参见 a )<br>rb+    以二进制读写模式打开 (参见 r+ )<br>wb+    以二进制读写模式打开 (参见 w+ )<br>ab+    以二进制读写模式打开 (参见 a+ )</p>\n</blockquote>\n</li>\n<li><p>fp.read([size])                     #size为读取的长度，以byte为单位</p>\n</li>\n<li>fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分</li>\n<li>fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</li>\n<li>fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符</li>\n<li>fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</li>\n<li>fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError</li>\n<li>fp.flush()                                      #把缓冲区的内容写入硬盘</li>\n<li>fp.fileno()                                      #返回一个长整型的”文件标签“</li>\n<li>fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）</li>\n<li>fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点</li>\n<li>fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</li>\n<li><p>fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</p>\n</li>\n<li><p>fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</p>\n</li>\n<li><p>os.mkdir(“file”)                   创建目录<br>复制文件：</p>\n</li>\n<li>shutil.copyfile(“oldfile”,”newfile”)       oldfile和newfile都只能是文件</li>\n<li>shutil.copy(“oldfile”,”newfile”)            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录<br>复制文件夹：</li>\n<li>shutil.copytree(“olddir”,”newdir”)        olddir和newdir都只能是目录，且newdir必须不存在<br>重命名文件（目录）</li>\n<li>os.rename(“oldname”,”newname”)       文件或目录都是使用这条命令<br>移动文件（目录）</li>\n<li>shutil.move(“oldpos”,”newpos”)<br>删除文件</li>\n<li>os.remove(“file”)<br>删除目录</li>\n<li>os.rmdir(“dir”)只能删除空目录<br>shutil.rmtree(“dir”)    空目录、有内容的目录都可以删<br>转换目录</li>\n<li>os.chdir(“path”)   换路径</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>python中对文件、文件夹（文件操作函数）的操作需要涉及到os模块和shutil模块。<br>","more":"</p>\n<ul>\n<li>得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()</li>\n<li>返回指定目录下的所有文件和目录名:os.listdir()</li>\n<li>函数用来删除一个文件:os.remove()</li>\n<li>删除多个目录：os.removedirs（r“c：\\python”）</li>\n<li>检验给出的路径是否是一个文件：os.path.isfile()</li>\n<li>检验给出的路径是否是一个目录：os.path.isdir()</li>\n<li>判断是否是绝对路径：os.path.isabs()</li>\n<li>检验给出的路径是否真地存:os.path.exists()</li>\n<li><p>返回一个路径的目录名和文件名:os.path.split()     </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">os.path.split(&apos;/home/swaroop/byte/code/poem.txt&apos;) 结果：(&apos;/home/swaroop/byte/code&apos;, &apos;poem.txt&apos;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>分离扩展名：os.path.splitext()</p>\n</li>\n<li>获取路径名：os.path.dirname()</li>\n<li>获取文件名：os.path.basename()</li>\n<li>运行shell命令: os.system()</li>\n<li>读取和设置环境变量:os.getenv() 与os.putenv()</li>\n<li>给出当前平台使用的行终止符:os.linesep    Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’</li>\n<li>指示你正在使用的平台：os.name       对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’</li>\n<li>重命名：os.rename（old， new）</li>\n<li>创建多级目录：os.makedirs（r“c：\\python\\test”）</li>\n<li>创建单个目录：os.mkdir（“test”）</li>\n<li>获取文件属性：os.stat（file）</li>\n<li>修改文件权限与时间戳：os.chmod（file）</li>\n<li>终止当前进程：os.exit（）</li>\n<li>获取文件大小：os.path.getsize（filename）</li>\n<li>os.mknod(“test.txt”)        创建空文件</li>\n<li><p>fp = open(“test.txt”,w)     直接打开一个文件，如果文件不存在则创建文件</p>\n<blockquote>\n<p>关于open 模式:<br>w     以写方式打开，<br>a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)<br>r+     以读写模式打开<br>w+     以读写模式打开 (参见 w )<br>a+     以读写模式打开 (参见 a )<br>rb     以二进制读模式打开<br>wb     以二进制写模式打开 (参见 w )<br>ab     以二进制追加模式打开 (参见 a )<br>rb+    以二进制读写模式打开 (参见 r+ )<br>wb+    以二进制读写模式打开 (参见 w+ )<br>ab+    以二进制读写模式打开 (参见 a+ )</p>\n</blockquote>\n</li>\n<li><p>fp.read([size])                     #size为读取的长度，以byte为单位</p>\n</li>\n<li>fp.readline([size])                 #读一行，如果定义了size，有可能返回的只是一行的一部分</li>\n<li>fp.readlines([size])                #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</li>\n<li>fp.write(str)                      #把str写到文件中，write()并不会在str后加上一个换行符</li>\n<li>fp.writelines(seq)            #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</li>\n<li>fp.close()                        #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError</li>\n<li>fp.flush()                                      #把缓冲区的内容写入硬盘</li>\n<li>fp.fileno()                                      #返回一个长整型的”文件标签“</li>\n<li>fp.isatty()                                      #文件是否是一个终端设备文件（unix系统中的）</li>\n<li>fp.tell()                                         #返回文件操作标记的当前位置，以文件的开头为原点</li>\n<li>fp.next()                                       #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</li>\n<li><p>fp.seek(offset[,whence])              #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</p>\n</li>\n<li><p>fp.truncate([size])                       #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</p>\n</li>\n<li><p>os.mkdir(“file”)                   创建目录<br>复制文件：</p>\n</li>\n<li>shutil.copyfile(“oldfile”,”newfile”)       oldfile和newfile都只能是文件</li>\n<li>shutil.copy(“oldfile”,”newfile”)            oldfile只能是文件夹，newfile可以是文件，也可以是目标目录<br>复制文件夹：</li>\n<li>shutil.copytree(“olddir”,”newdir”)        olddir和newdir都只能是目录，且newdir必须不存在<br>重命名文件（目录）</li>\n<li>os.rename(“oldname”,”newname”)       文件或目录都是使用这条命令<br>移动文件（目录）</li>\n<li>shutil.move(“oldpos”,”newpos”)<br>删除文件</li>\n<li>os.remove(“file”)<br>删除目录</li>\n<li>os.rmdir(“dir”)只能删除空目录<br>shutil.rmtree(“dir”)    空目录、有内容的目录都可以删<br>转换目录</li>\n<li>os.chdir(“path”)   换路径</li>\n</ul>"},{"title":"UIImage","date":"2014-10-16T02:47:43.000Z","_content":"\n### UIImage占用内存大小\n```\nUIImage *image = [UIImage imageNamed:@\"aa\"];\nNSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);\n```\n\n### 获取图片某一点的颜色\n```\n- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image\n{\nUIColor* color = nil;\nCGImageRef inImage = image.CGImage;\nCGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];\nif (cgctx == NULL) {\nreturn nil; /* error */\n}\nsize_t w = CGImageGetWidth(inImage);\nsize_t h = CGImageGetHeight(inImage);\nCGRect rect = {{0,0},{w,h}};\nCGContextDrawImage(cgctx, rect, inImage);\nunsigned char* data = CGBitmapContextGetData (cgctx);\nif (data != NULL) {\nint offset = 4*((w*round(point.y))+round(point.x));\nint alpha =  data[offset];\nint red = data[offset+1];\nint green = data[offset+2];\nint blue = data[offset+3];\ncolor = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:\n(blue/255.0f) alpha:(alpha/255.0f)];\n}\nCGContextRelease(cgctx);\nif (data) {\nfree(data);\n}\nreturn color;\n}\n```\n","source":"_posts/2017/UIImage.md","raw":"---\ntitle: UIImage\ndate: 2014-10-16 10:47:43\ntags:\n- iOS\n---\n\n### UIImage占用内存大小\n```\nUIImage *image = [UIImage imageNamed:@\"aa\"];\nNSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);\n```\n\n### 获取图片某一点的颜色\n```\n- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image\n{\nUIColor* color = nil;\nCGImageRef inImage = image.CGImage;\nCGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];\nif (cgctx == NULL) {\nreturn nil; /* error */\n}\nsize_t w = CGImageGetWidth(inImage);\nsize_t h = CGImageGetHeight(inImage);\nCGRect rect = {{0,0},{w,h}};\nCGContextDrawImage(cgctx, rect, inImage);\nunsigned char* data = CGBitmapContextGetData (cgctx);\nif (data != NULL) {\nint offset = 4*((w*round(point.y))+round(point.x));\nint alpha =  data[offset];\nint red = data[offset+1];\nint green = data[offset+2];\nint blue = data[offset+3];\ncolor = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:\n(blue/255.0f) alpha:(alpha/255.0f)];\n}\nCGContextRelease(cgctx);\nif (data) {\nfree(data);\n}\nreturn color;\n}\n```\n","slug":"2017/UIImage","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnb003tsaua6nrhpr7u","content":"<h3 id=\"UIImage占用内存大小\"><a href=\"#UIImage占用内存大小\" class=\"headerlink\" title=\"UIImage占用内存大小\"></a>UIImage占用内存大小</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImage *image = [UIImage imageNamed:@&quot;aa&quot;];</div><div class=\"line\">NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);</div></pre></td></tr></table></figure>\n<h3 id=\"获取图片某一点的颜色\"><a href=\"#获取图片某一点的颜色\" class=\"headerlink\" title=\"获取图片某一点的颜色\"></a>获取图片某一点的颜色</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image</div><div class=\"line\">&#123;</div><div class=\"line\">UIColor* color = nil;</div><div class=\"line\">CGImageRef inImage = image.CGImage;</div><div class=\"line\">CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];</div><div class=\"line\">if (cgctx == NULL) &#123;</div><div class=\"line\">return nil; /* error */</div><div class=\"line\">&#125;</div><div class=\"line\">size_t w = CGImageGetWidth(inImage);</div><div class=\"line\">size_t h = CGImageGetHeight(inImage);</div><div class=\"line\">CGRect rect = &#123;&#123;0,0&#125;,&#123;w,h&#125;&#125;;</div><div class=\"line\">CGContextDrawImage(cgctx, rect, inImage);</div><div class=\"line\">unsigned char* data = CGBitmapContextGetData (cgctx);</div><div class=\"line\">if (data != NULL) &#123;</div><div class=\"line\">int offset = 4*((w*round(point.y))+round(point.x));</div><div class=\"line\">int alpha =  data[offset];</div><div class=\"line\">int red = data[offset+1];</div><div class=\"line\">int green = data[offset+2];</div><div class=\"line\">int blue = data[offset+3];</div><div class=\"line\">color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:</div><div class=\"line\">(blue/255.0f) alpha:(alpha/255.0f)];</div><div class=\"line\">&#125;</div><div class=\"line\">CGContextRelease(cgctx);</div><div class=\"line\">if (data) &#123;</div><div class=\"line\">free(data);</div><div class=\"line\">&#125;</div><div class=\"line\">return color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"UIImage占用内存大小\"><a href=\"#UIImage占用内存大小\" class=\"headerlink\" title=\"UIImage占用内存大小\"></a>UIImage占用内存大小</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIImage *image = [UIImage imageNamed:@&quot;aa&quot;];</div><div class=\"line\">NSUInteger size  = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage);</div></pre></td></tr></table></figure>\n<h3 id=\"获取图片某一点的颜色\"><a href=\"#获取图片某一点的颜色\" class=\"headerlink\" title=\"获取图片某一点的颜色\"></a>获取图片某一点的颜色</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIColor*) getPixelColorAtLocation:(CGPoint)point inImage:(UIImage *)image</div><div class=\"line\">&#123;</div><div class=\"line\">UIColor* color = nil;</div><div class=\"line\">CGImageRef inImage = image.CGImage;</div><div class=\"line\">CGContextRef cgctx = [self createARGBBitmapContextFromImage:inImage];</div><div class=\"line\">if (cgctx == NULL) &#123;</div><div class=\"line\">return nil; /* error */</div><div class=\"line\">&#125;</div><div class=\"line\">size_t w = CGImageGetWidth(inImage);</div><div class=\"line\">size_t h = CGImageGetHeight(inImage);</div><div class=\"line\">CGRect rect = &#123;&#123;0,0&#125;,&#123;w,h&#125;&#125;;</div><div class=\"line\">CGContextDrawImage(cgctx, rect, inImage);</div><div class=\"line\">unsigned char* data = CGBitmapContextGetData (cgctx);</div><div class=\"line\">if (data != NULL) &#123;</div><div class=\"line\">int offset = 4*((w*round(point.y))+round(point.x));</div><div class=\"line\">int alpha =  data[offset];</div><div class=\"line\">int red = data[offset+1];</div><div class=\"line\">int green = data[offset+2];</div><div class=\"line\">int blue = data[offset+3];</div><div class=\"line\">color = [UIColor colorWithRed:(red/255.0f) green:(green/255.0f) blue:</div><div class=\"line\">(blue/255.0f) alpha:(alpha/255.0f)];</div><div class=\"line\">&#125;</div><div class=\"line\">CGContextRelease(cgctx);</div><div class=\"line\">if (data) &#123;</div><div class=\"line\">free(data);</div><div class=\"line\">&#125;</div><div class=\"line\">return color;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"UIKit-UITableView","date":"2016-11-30T09:30:22.000Z","_content":"\n### 更改cell点击的高亮色\n在具体的Cell中重写函数：\n<!--more-->\n```\n- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated{//重写高亮函数\nif (highlighted) {\nself.textLabel.backgroundColor = [UIColor yellowColor];\nself.textLabel.textColor = [UIColor redColor];\nself.textLabel.text = [NSString stringWithFormat:@\"这是第%ld行  点中我啦哈哈哈\",(long)self.tag];\n}else{\nself.textLabel.backgroundColor = [UIColor clearColor];\nself.textLabel.textColor = [UIColor blackColor];\nself.textLabel.text = [NSString stringWithFormat:@\"这是第%ld行  哈哈哈\",(long)self.tag];\n}\n}\n```\n\n### 如何来写分割线\n你在第一次cell创建的时候去布局，会发现取到的self.height永远是44，是因为后边系统才会根据你设置的高度来确定这个高度，也就是说它会再次赋值，调用layoutsubviews会再次，所以你的布局方法应该写到这个方法里边，才能够保证你的布局和取到的size是正确的，否则一切都是白费\n最佳实践是把布局的方法写到reloadmodel方法里边去，分割线的位置要写到layoutsubviews中去，这样拿到self.height的高度才是准确的，其他的控件是从上到下布局的，所以无所谓，但是从下到上布局的控件就要放倒这个方法中去\n\n### cell的预加载\n一旦调用cellfor，紧接着就会调用willdispaly，这个时候这个cell已经出现在了visiblecells里边了，其实这个时候这个cell已经应该出现在屏幕上了，所以预加载的说法在tableview上是不存在的\n\n\n\n\n\n","source":"_posts/2017/UIKit-UITableView.md","raw":"---\ntitle: UIKit-UITableView\ndate: 2016-11-30 17:30:22\ntags:\n- iOS\n---\n\n### 更改cell点击的高亮色\n在具体的Cell中重写函数：\n<!--more-->\n```\n- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated{//重写高亮函数\nif (highlighted) {\nself.textLabel.backgroundColor = [UIColor yellowColor];\nself.textLabel.textColor = [UIColor redColor];\nself.textLabel.text = [NSString stringWithFormat:@\"这是第%ld行  点中我啦哈哈哈\",(long)self.tag];\n}else{\nself.textLabel.backgroundColor = [UIColor clearColor];\nself.textLabel.textColor = [UIColor blackColor];\nself.textLabel.text = [NSString stringWithFormat:@\"这是第%ld行  哈哈哈\",(long)self.tag];\n}\n}\n```\n\n### 如何来写分割线\n你在第一次cell创建的时候去布局，会发现取到的self.height永远是44，是因为后边系统才会根据你设置的高度来确定这个高度，也就是说它会再次赋值，调用layoutsubviews会再次，所以你的布局方法应该写到这个方法里边，才能够保证你的布局和取到的size是正确的，否则一切都是白费\n最佳实践是把布局的方法写到reloadmodel方法里边去，分割线的位置要写到layoutsubviews中去，这样拿到self.height的高度才是准确的，其他的控件是从上到下布局的，所以无所谓，但是从下到上布局的控件就要放倒这个方法中去\n\n### cell的预加载\n一旦调用cellfor，紧接着就会调用willdispaly，这个时候这个cell已经出现在了visiblecells里边了，其实这个时候这个cell已经应该出现在屏幕上了，所以预加载的说法在tableview上是不存在的\n\n\n\n\n\n","slug":"2017/UIKit-UITableView","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnc003xsauazqkbv806","content":"<h3 id=\"更改cell点击的高亮色\"><a href=\"#更改cell点击的高亮色\" class=\"headerlink\" title=\"更改cell点击的高亮色\"></a>更改cell点击的高亮色</h3><p>在具体的Cell中重写函数：<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123;//重写高亮函数</div><div class=\"line\">if (highlighted) &#123;</div><div class=\"line\">self.textLabel.backgroundColor = [UIColor yellowColor];</div><div class=\"line\">self.textLabel.textColor = [UIColor redColor];</div><div class=\"line\">self.textLabel.text = [NSString stringWithFormat:@&quot;这是第%ld行  点中我啦哈哈哈&quot;,(long)self.tag];</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">self.textLabel.backgroundColor = [UIColor clearColor];</div><div class=\"line\">self.textLabel.textColor = [UIColor blackColor];</div><div class=\"line\">self.textLabel.text = [NSString stringWithFormat:@&quot;这是第%ld行  哈哈哈&quot;,(long)self.tag];</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"如何来写分割线\"><a href=\"#如何来写分割线\" class=\"headerlink\" title=\"如何来写分割线\"></a>如何来写分割线</h3><p>你在第一次cell创建的时候去布局，会发现取到的self.height永远是44，是因为后边系统才会根据你设置的高度来确定这个高度，也就是说它会再次赋值，调用layoutsubviews会再次，所以你的布局方法应该写到这个方法里边，才能够保证你的布局和取到的size是正确的，否则一切都是白费<br>最佳实践是把布局的方法写到reloadmodel方法里边去，分割线的位置要写到layoutsubviews中去，这样拿到self.height的高度才是准确的，其他的控件是从上到下布局的，所以无所谓，但是从下到上布局的控件就要放倒这个方法中去</p>\n<h3 id=\"cell的预加载\"><a href=\"#cell的预加载\" class=\"headerlink\" title=\"cell的预加载\"></a>cell的预加载</h3><p>一旦调用cellfor，紧接着就会调用willdispaly，这个时候这个cell已经出现在了visiblecells里边了，其实这个时候这个cell已经应该出现在屏幕上了，所以预加载的说法在tableview上是不存在的</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"更改cell点击的高亮色\"><a href=\"#更改cell点击的高亮色\" class=\"headerlink\" title=\"更改cell点击的高亮色\"></a>更改cell点击的高亮色</h3><p>在具体的Cell中重写函数：<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated&#123;//重写高亮函数</div><div class=\"line\">if (highlighted) &#123;</div><div class=\"line\">self.textLabel.backgroundColor = [UIColor yellowColor];</div><div class=\"line\">self.textLabel.textColor = [UIColor redColor];</div><div class=\"line\">self.textLabel.text = [NSString stringWithFormat:@&quot;这是第%ld行  点中我啦哈哈哈&quot;,(long)self.tag];</div><div class=\"line\">&#125;else&#123;</div><div class=\"line\">self.textLabel.backgroundColor = [UIColor clearColor];</div><div class=\"line\">self.textLabel.textColor = [UIColor blackColor];</div><div class=\"line\">self.textLabel.text = [NSString stringWithFormat:@&quot;这是第%ld行  哈哈哈&quot;,(long)self.tag];</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"如何来写分割线\"><a href=\"#如何来写分割线\" class=\"headerlink\" title=\"如何来写分割线\"></a>如何来写分割线</h3><p>你在第一次cell创建的时候去布局，会发现取到的self.height永远是44，是因为后边系统才会根据你设置的高度来确定这个高度，也就是说它会再次赋值，调用layoutsubviews会再次，所以你的布局方法应该写到这个方法里边，才能够保证你的布局和取到的size是正确的，否则一切都是白费<br>最佳实践是把布局的方法写到reloadmodel方法里边去，分割线的位置要写到layoutsubviews中去，这样拿到self.height的高度才是准确的，其他的控件是从上到下布局的，所以无所谓，但是从下到上布局的控件就要放倒这个方法中去</p>\n<h3 id=\"cell的预加载\"><a href=\"#cell的预加载\" class=\"headerlink\" title=\"cell的预加载\"></a>cell的预加载</h3><p>一旦调用cellfor，紧接着就会调用willdispaly，这个时候这个cell已经出现在了visiblecells里边了，其实这个时候这个cell已经应该出现在屏幕上了，所以预加载的说法在tableview上是不存在的</p>"},{"title":"iOS工程小知识","date":"2017-02-26T15:02:06.000Z","_content":"### 1:出现（ linker command failed with exit code 1）\n如果具体的错误是这个与第三方.a库重复，那么要更改的是，类名和全局变量的名字\n<!--more-->\n### 2.SEGV_ACCERR错误\n说明对象被过度释放，查看是否有在=nil之后又使用了该对象，比如说这段代码\ncase MessageComposeResultSent:\n        {\n            //信息传送成功\n//            [JRMsgShow showMsg:@\"发送成功\"];\n            if (self.closeBlock) {\n                self.closeBlock();\n            }\n            if (self.messageSuccessBlock) {\n                self.messageSuccessBlock();\n            }\n            [[UIApplication sharedApplication].keyWindow.rootViewController dismissViewControllerAnimated:YES completion:nil];\n        }\n\n很明显前边我们使用了closeblock，这个block之行之后，很快self会死掉，而这个之后我们又使用了self.messageSuccessBlock这样再次使用self，必然导致崩溃，不过这是在iOS8上面，在iOS9和10上就没有这个问题，说明苹果做了系统级的优化\n\n### 3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\n","source":"_posts/2017/iOS工程小知识.md","raw":"---\ntitle: iOS工程小知识\ndate: 2017-02-26 23:02:06\ntags:\n---\n### 1:出现（ linker command failed with exit code 1）\n如果具体的错误是这个与第三方.a库重复，那么要更改的是，类名和全局变量的名字\n<!--more-->\n### 2.SEGV_ACCERR错误\n说明对象被过度释放，查看是否有在=nil之后又使用了该对象，比如说这段代码\ncase MessageComposeResultSent:\n        {\n            //信息传送成功\n//            [JRMsgShow showMsg:@\"发送成功\"];\n            if (self.closeBlock) {\n                self.closeBlock();\n            }\n            if (self.messageSuccessBlock) {\n                self.messageSuccessBlock();\n            }\n            [[UIApplication sharedApplication].keyWindow.rootViewController dismissViewControllerAnimated:YES completion:nil];\n        }\n\n很明显前边我们使用了closeblock，这个block之行之后，很快self会死掉，而这个之后我们又使用了self.messageSuccessBlock这样再次使用self，必然导致崩溃，不过这是在iOS8上面，在iOS9和10上就没有这个问题，说明苹果做了系统级的优化\n\n### 3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\n","slug":"2017/iOS工程小知识","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnd003zsauaj0ve8yo3","content":"<h3 id=\"1-出现（-linker-command-failed-with-exit-code-1）\"><a href=\"#1-出现（-linker-command-failed-with-exit-code-1）\" class=\"headerlink\" title=\"1:出现（ linker command failed with exit code 1）\"></a>1:出现（ linker command failed with exit code 1）</h3><p>如果具体的错误是这个与第三方.a库重复，那么要更改的是，类名和全局变量的名字<br><a id=\"more\"></a></p>\n<h3 id=\"2-SEGV-ACCERR错误\"><a href=\"#2-SEGV-ACCERR错误\" class=\"headerlink\" title=\"2.SEGV_ACCERR错误\"></a>2.SEGV_ACCERR错误</h3><p>说明对象被过度释放，查看是否有在=nil之后又使用了该对象，比如说这段代码<br>case MessageComposeResultSent:<br>        {<br>            //信息传送成功<br>//            [JRMsgShow showMsg:@”发送成功”];<br>            if (self.closeBlock) {<br>                self.closeBlock();<br>            }<br>            if (self.messageSuccessBlock) {<br>                self.messageSuccessBlock();<br>            }<br>            [[UIApplication sharedApplication].keyWindow.rootViewController dismissViewControllerAnimated:YES completion:nil];<br>        }</p>\n<p>很明显前边我们使用了closeblock，这个block之行之后，很快self会死掉，而这个之后我们又使用了self.messageSuccessBlock这样再次使用self，必然导致崩溃，不过这是在iOS8上面，在iOS9和10上就没有这个问题，说明苹果做了系统级的优化</p>\n<h3 id=\"3-参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\"><a href=\"#3-参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\" class=\"headerlink\" title=\"3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\"></a>3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心</h3>","site":{"data":{}},"excerpt":"<h3 id=\"1-出现（-linker-command-failed-with-exit-code-1）\"><a href=\"#1-出现（-linker-command-failed-with-exit-code-1）\" class=\"headerlink\" title=\"1:出现（ linker command failed with exit code 1）\"></a>1:出现（ linker command failed with exit code 1）</h3><p>如果具体的错误是这个与第三方.a库重复，那么要更改的是，类名和全局变量的名字<br>","more":"</p>\n<h3 id=\"2-SEGV-ACCERR错误\"><a href=\"#2-SEGV-ACCERR错误\" class=\"headerlink\" title=\"2.SEGV_ACCERR错误\"></a>2.SEGV_ACCERR错误</h3><p>说明对象被过度释放，查看是否有在=nil之后又使用了该对象，比如说这段代码<br>case MessageComposeResultSent:<br>        {<br>            //信息传送成功<br>//            [JRMsgShow showMsg:@”发送成功”];<br>            if (self.closeBlock) {<br>                self.closeBlock();<br>            }<br>            if (self.messageSuccessBlock) {<br>                self.messageSuccessBlock();<br>            }<br>            [[UIApplication sharedApplication].keyWindow.rootViewController dismissViewControllerAnimated:YES completion:nil];<br>        }</p>\n<p>很明显前边我们使用了closeblock，这个block之行之后，很快self会死掉，而这个之后我们又使用了self.messageSuccessBlock这样再次使用self，必然导致崩溃，不过这是在iOS8上面，在iOS9和10上就没有这个问题，说明苹果做了系统级的优化</p>\n<h3 id=\"3-参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\"><a href=\"#3-参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\" class=\"headerlink\" title=\"3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心\"></a>3.参数传递尽量要用model，哪怕是回调，因为可能后边会增加需求，那么参数传递将会变得很恶心</h3>"},{"title":"mac下使用virtualbox安装win7以及设置共享文件","date":"2017-05-25T02:03:15.000Z","_content":"\n### 安装\n首先进入win7-pe环境，然后进行分区，这里的关键在于c盘要大于10G\n\n### 设置共享文件夹\n要实现mac与windows的文件共享，信息互通，需要有一个都可以访问的文件夹，这里的关键是，要首先安装virtualbox的device下的insert Guest Additions CD image\n","source":"_posts/2017/mac下使用virtualbox安装win7以及设置共享文件.md","raw":"---\ntitle: mac下使用virtualbox安装win7以及设置共享文件\ndate: 2017-05-25 10:03:15\ntags:\n- mac\n---\n\n### 安装\n首先进入win7-pe环境，然后进行分区，这里的关键在于c盘要大于10G\n\n### 设置共享文件夹\n要实现mac与windows的文件共享，信息互通，需要有一个都可以访问的文件夹，这里的关键是，要首先安装virtualbox的device下的insert Guest Additions CD image\n","slug":"2017/mac下使用virtualbox安装win7以及设置共享文件","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pne0042saua8u1icurf","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先进入win7-pe环境，然后进行分区，这里的关键在于c盘要大于10G</p>\n<h3 id=\"设置共享文件夹\"><a href=\"#设置共享文件夹\" class=\"headerlink\" title=\"设置共享文件夹\"></a>设置共享文件夹</h3><p>要实现mac与windows的文件共享，信息互通，需要有一个都可以访问的文件夹，这里的关键是，要首先安装virtualbox的device下的insert Guest Additions CD image</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先进入win7-pe环境，然后进行分区，这里的关键在于c盘要大于10G</p>\n<h3 id=\"设置共享文件夹\"><a href=\"#设置共享文件夹\" class=\"headerlink\" title=\"设置共享文件夹\"></a>设置共享文件夹</h3><p>要实现mac与windows的文件共享，信息互通，需要有一个都可以访问的文件夹，这里的关键是，要首先安装virtualbox的device下的insert Guest Additions CD image</p>\n"},{"title":"基于Django的平台构建笔记(2)","date":"2017-05-18T01:57:42.000Z","_content":"\n### python中Json字符串的创建与javascript中json字符串的转换\n<!--more-->\n```\nimport json\n\ndef getindex(indexname):\n\n    datas = []\n\n    for item in namelist:\n    \n        pes.append(dic) \n        pes = json.dumps(pes)\n        datas.append(pes)\n\n    datas = json.dumps(datas)\n    return datas\n```\n仔细看上边这段python我们能得出来一个结论，我们可以使用json这个功能，将一个python中的列表，转换为一段字符串，然后返回出去，这个字符串就是一段json字符串，我们可以将这段json字符串反过来转换成一个数组\n\n下面我们来瞅瞅，如何将一个json字符串转换为一个json数组\n\n>首先说明基本功能：\n\ndumps是将dict转化成str格式，loads是将str转化成dict格式。\n\ndump和load也是类似的功能，只是与文件操作结合起来了。\n\n\n看代码实例：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang', 'age': 29}\n\nIn [3]: b = json.dumps(a)\n\nIn [4]: print b, type(b)\n{\"age\": 29, \"name\": \"wang\"} <type 'str'>\n\nIn [11]: json.loads(b)\nOut[11]: {u'age': 29, u'name': u'wang'}\n\nIn [12]: print type(json.loads(b))\n<type 'dict'>\n```\n\n然后再看dump和dumps的区别，见代码：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang', 'age': 29}\n\nIn [3]: b = json.dumps(a)\n\nIn [4]: print b, type(b)\n{\"age\": 29, \"name\": \"wang\"} <type 'str'>\n\nIn [5]: c = json.dump(a)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-5-92dc0d929363> in <module>()\n----> 1 c = json.dump(a)\n\nTypeError: dump() takes at least 2 arguments (1 given)\n```\n\n这里提示我们少一个参数，我们看一下帮助文件（iPyhton中可以直接使用help(json.dumps)来查看帮助文件）：\n\n\n\ndumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\nSerialize ``obj`` to a JSON formatted ``str``.\n\n\n\ndump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\nSerialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object).\n\n\n\n简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str然后存入文件中；而dumps直接给的是str，也就是将字典转成str。\n\n例子见代码（注意文件操作的一些小细节）：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang'}\n\nIn [3]: fp = file('test.txt', 'w')\n\nIn [4]: type(fp)\nOut[4]: file\n\nIn [5]: json.dump(a, fp)\n\nIn [6]: cat test.txt\n\nIn [7]: fp.close()\n\nIn [8]: cat test.txt\n{\"name\": \"wang\"}\nIn [9]: json.load(fp)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-9-0064dabedb17> in <module>()\n----> 1 json.load(fp)\n\n/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.pyc in load(fp, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)\n285\n286     \"\"\"\n--> 287     return loads(fp.read(),\n288         encoding=encoding, cls=cls, object_hook=object_hook,\n289         parse_float=parse_float, parse_int=parse_int,\n\nValueError: I/O operation on closed file\n\nIn [10]: fp = file('test.txt', 'r')\n\nIn [11]: json.load(fp)\nOut[11]: {u'name': u'wang'}\n注：实际中dump用的较少。\n\n```\n\n### javascript中如何将一段json字符串转换为json对象\n\n\nvar obj = JSON.parse(data);\n\n### web中上传文件，带进度条的做法\n```\n<div id=\"upload\">\n\n     <form>\n        {% csrf_token %}\n        <input type=\"file\" id='file' class='file' style=\"margin-top: 5px;margin-left: 10px\" name=\"file\"><br>\n        <div id='1' style=\"margin-top: 40px;margin-left: 10px;height:10px;width:200px;border-color: rgba(110,3,120,1);border:1px solid gray;float:left;margin-right:10px;\">\n            <div id='2' style=\"height:100%;width:0px;background:rgba(220,220,220,1);\"></div>\n        </div>\n        <a style=\"position: absolute;top: 72px;;margin-right:25px\" id='3'>0%</a>\n\n        <button type=\"button\" style=\"margin-top: 32px;margin-left: 50px;\" onclick=\"upload();\">上传</button>\n\n    </form>\n</div>\n```\n是要定义一个file,下边是js的代码，我们来实现上传功能\n\n```\nfunction upload() {\n\n            var apktextinput = document.getElementById('apkname')\n            var apkname = apktextinput.value\n\n            if (apkname.length == 0) {\n                alert('请输入证书名称')\n                return\n            }\n\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\tvar file = document.getElementById('file').files[0];   //取得文件数据，而.file对象只是文件信息\n\t\t\tvar form = new FormData();   //FormData是HTML5为实现序列化表单而提供的类，更多细节可自行查询\n            form.append('file',file);   //这里为序列化表单对象form添加一个元素，即file\n\t\t\txhr.upload.addEventListener('progress',on_progress,false);     //xhr对象含有一个upload对象，它有一个progress事件，在文件上传过程中会被不断触发，我们为这个事件对应一个处理函数，每当事件触发就会调用这个函数，于是便可利用这个函数来修改当前进度，更多细节可自行查询\n\t\t\txhr.open('POST','http://10.13.8.12:89/uploadAPK/',true);  //请将url改成上传url\n            xhr.setRequestHeader('X-CSRFTOKEN','{{ request.COOKIES.csrftoken }}');   //此处为Django要求，可无视，或者换成相应后台所要求的CSRF防护，不是django用户请去掉\n\t\t\txhr.send(form);   //发送表单\n\t\t}\n```\n重点是`xhr.upload.addEventListener('progress',on_progress,false);`这个方法会保证上传过程中不断的回调我们来实现on_progress\n\n```\n function on_progress(evt) {       //看这个函数之前先看upload函数。这个函数可以接收一个evt(event)对象(细节自行查询progress)，他有3个属性lengthComputable，loaded，total，第一个属性是个bool类型的，代表是否支持，第二个代表当前上传的大小，第三个为总的大小，由此便可以计算出实时上传的百分比\n\t\t\tif(evt.lengthComputable) {\n\t\t\t\tvar ele = document.getElementById('2');\n\t\t\t\tvar percent = Math.round((evt.loaded) * 100 / evt.total);\n                if (percent == 100 && strongapk == 1) {\n                    strongapk = 0\n                    var textcontent = document.getElementById(\"wating\")\n                    textcontent.style.display = 'block'\n\n                    var apktextinput = document.getElementById('apkname')\n                    var apkname = apktextinput.value\n\n                     $.ajax({\n                        url: \"/startstrongapk/\",    //后台webservice里的方法名称\n                        data:{\"apkname\":apkname},\n                        type: \"post\",\n                        traditional: true,\n                        success: function (data) {\n                            downloadurl = data\n                            alert(data)\n                            $(\"#wating\").css('display','none');\n                            if (confirm(\"你确定要下载文件吗？\")) {\n                                self.location=('downloadsdk?url=' + data)\n                            }\n                        },\n                        error: function (msg) {\n                            alert(msg)\n                            $(\"#wating\").css('display','none');\n                        }\n                   });\n\n                }\n\t\t\t\tele.style.width = percent + '%';\n\t\t\t\tdocument.getElementById('3').innerHTML = percent + '%';\n\t\t\t}\n\t\t}\n```\n这里我们在percent达到100之后，调用ajax做一些事情\n\n### django中接口调用的方式总结\n网络方法调用大致有这么几种\n#### 点击按钮跳转新页面\n这种直接用<a>标签，然后用href就好\n\n```\n<a class=\"button\" id=\"ios\" style=\"position: absolute;top: 50px;\" href=\"jinkensios\" onmouseover=\"showDetailText(this)\" onmouseout=\"clearTest()\">● 打包(iOS)</a>\n```\n#### 点击按钮刷新局部数据\n##### 这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\n\n```\n$(document).ready(function(){\n      $(\"#btn\").click(function(){\n        string = $(\"#textarea1\").val()\n        $.get(\"/ajaxcreateui/\", {'text': string},function(ret){\n            $('#textarea2').html(ret)\n        })\n      });\n    });\n```\n- `$(document).ready(function(){}`预先埋伏的写法要写在这句代码里边\n- `$(\"#btn\").click(function(){}`这个是预先埋伏\n- `$.get(\"/ajaxcreateui/\", {'text': string},function(ret){}`ajax的get调用\n\n##### 直接使用XMLHttpRequest\n\n```\nvar progresshttp;\nfunction getprogress() {\n\n    progresshttp=null;\n    if (window.XMLHttpRequest)\n      {// code for all new browsers\n      progresshttp=new XMLHttpRequest();\n      }\n    else if (window.ActiveXObject)\n      {// code for IE5 and IE6\n      progresshttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n\n    if (progresshttp!=null)\n      {\n          progresshttp.onreadystatechange=progressstate_Change;\n          progresshttp.open(\"POST\",'getpackprogress',false);\n          var formData = new FormData();\n          formData.append('branchname', branchname);\n          progresshttp.send(formData);\n      }\n    else\n      {\n      alert(\"Your browser does not support XMLHTTP.\");\n      }\n}\n\nfunction progressstate_Change()\n{\nif (progresshttp.readyState==4)\n  {// 4 = \"loaded\"\n  if (progresshttp.status==200)\n    {// 200 = OK\n\n      num = this.responseText\n\n      var ele = document.getElementById('12');\n      var percent = num * 100;\n      percent = percent.toFixed(2)\n      if (percent >= 100.00) {\n          percent = 100.00\n      }\n      ele.style.width = percent + '%';\n      document.getElementById('13').innerHTML = percent + '%';\n      if (percent >= 100) {\n          window.clearInterval(waitinterval)\n          ele.style.width = 100 + '%';\n          var text = document.getElementById('building')\n          text.innerHTML = \"\"\n      }\n    }\n  else\n    {\n    alert(\"Problem retrieving XML data\");\n    }\n  }\n}\n```\n\n添加回调的方式\n>- `xhr.upload.addEventListener('progress',on_progress,false);`进度条\n>- `progresshttp.onreadystatechange=progressstate_Change`事件回调\n\n#### 某个事件调用结束刷新局部数据\n直接使用ajax或者XMLHttpRequest就好\n\n### python中调用命令行随时输出的做法\n\n```\np = subprocess.Popen(\"gradle assembleDebug\",shell=True,stdout=subprocess.PIPE)\n\nindexcount = 0\n\nreturncode = p.poll()\n\nwhile returncode is None:\n      text = p.stdout.readline().strip()\n      f = open('/Users/jdjr/Desktop/buildlog.txt','a')#追加打开方式\n      f.write(text)\n      f.close()\n        \n      returncode = p.poll()\n```\n\n\n\n","source":"_posts/2017/基于Django的平台构建笔记(2).md","raw":"---\ntitle: 基于Django的平台构建笔记(2)\ndate: 2017-05-18 09:57:42\ntags:\n- Python\n- Django\n- JS\n---\n\n### python中Json字符串的创建与javascript中json字符串的转换\n<!--more-->\n```\nimport json\n\ndef getindex(indexname):\n\n    datas = []\n\n    for item in namelist:\n    \n        pes.append(dic) \n        pes = json.dumps(pes)\n        datas.append(pes)\n\n    datas = json.dumps(datas)\n    return datas\n```\n仔细看上边这段python我们能得出来一个结论，我们可以使用json这个功能，将一个python中的列表，转换为一段字符串，然后返回出去，这个字符串就是一段json字符串，我们可以将这段json字符串反过来转换成一个数组\n\n下面我们来瞅瞅，如何将一个json字符串转换为一个json数组\n\n>首先说明基本功能：\n\ndumps是将dict转化成str格式，loads是将str转化成dict格式。\n\ndump和load也是类似的功能，只是与文件操作结合起来了。\n\n\n看代码实例：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang', 'age': 29}\n\nIn [3]: b = json.dumps(a)\n\nIn [4]: print b, type(b)\n{\"age\": 29, \"name\": \"wang\"} <type 'str'>\n\nIn [11]: json.loads(b)\nOut[11]: {u'age': 29, u'name': u'wang'}\n\nIn [12]: print type(json.loads(b))\n<type 'dict'>\n```\n\n然后再看dump和dumps的区别，见代码：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang', 'age': 29}\n\nIn [3]: b = json.dumps(a)\n\nIn [4]: print b, type(b)\n{\"age\": 29, \"name\": \"wang\"} <type 'str'>\n\nIn [5]: c = json.dump(a)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-5-92dc0d929363> in <module>()\n----> 1 c = json.dump(a)\n\nTypeError: dump() takes at least 2 arguments (1 given)\n```\n\n这里提示我们少一个参数，我们看一下帮助文件（iPyhton中可以直接使用help(json.dumps)来查看帮助文件）：\n\n\n\ndumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\nSerialize ``obj`` to a JSON formatted ``str``.\n\n\n\ndump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding='utf-8', default=None, sort_keys=False, **kw)\nSerialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object).\n\n\n\n简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str然后存入文件中；而dumps直接给的是str，也就是将字典转成str。\n\n例子见代码（注意文件操作的一些小细节）：\n\n```\nIn [1]: import json\n\nIn [2]: a = {'name': 'wang'}\n\nIn [3]: fp = file('test.txt', 'w')\n\nIn [4]: type(fp)\nOut[4]: file\n\nIn [5]: json.dump(a, fp)\n\nIn [6]: cat test.txt\n\nIn [7]: fp.close()\n\nIn [8]: cat test.txt\n{\"name\": \"wang\"}\nIn [9]: json.load(fp)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-9-0064dabedb17> in <module>()\n----> 1 json.load(fp)\n\n/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.pyc in load(fp, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)\n285\n286     \"\"\"\n--> 287     return loads(fp.read(),\n288         encoding=encoding, cls=cls, object_hook=object_hook,\n289         parse_float=parse_float, parse_int=parse_int,\n\nValueError: I/O operation on closed file\n\nIn [10]: fp = file('test.txt', 'r')\n\nIn [11]: json.load(fp)\nOut[11]: {u'name': u'wang'}\n注：实际中dump用的较少。\n\n```\n\n### javascript中如何将一段json字符串转换为json对象\n\n\nvar obj = JSON.parse(data);\n\n### web中上传文件，带进度条的做法\n```\n<div id=\"upload\">\n\n     <form>\n        {% csrf_token %}\n        <input type=\"file\" id='file' class='file' style=\"margin-top: 5px;margin-left: 10px\" name=\"file\"><br>\n        <div id='1' style=\"margin-top: 40px;margin-left: 10px;height:10px;width:200px;border-color: rgba(110,3,120,1);border:1px solid gray;float:left;margin-right:10px;\">\n            <div id='2' style=\"height:100%;width:0px;background:rgba(220,220,220,1);\"></div>\n        </div>\n        <a style=\"position: absolute;top: 72px;;margin-right:25px\" id='3'>0%</a>\n\n        <button type=\"button\" style=\"margin-top: 32px;margin-left: 50px;\" onclick=\"upload();\">上传</button>\n\n    </form>\n</div>\n```\n是要定义一个file,下边是js的代码，我们来实现上传功能\n\n```\nfunction upload() {\n\n            var apktextinput = document.getElementById('apkname')\n            var apkname = apktextinput.value\n\n            if (apkname.length == 0) {\n                alert('请输入证书名称')\n                return\n            }\n\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\tvar file = document.getElementById('file').files[0];   //取得文件数据，而.file对象只是文件信息\n\t\t\tvar form = new FormData();   //FormData是HTML5为实现序列化表单而提供的类，更多细节可自行查询\n            form.append('file',file);   //这里为序列化表单对象form添加一个元素，即file\n\t\t\txhr.upload.addEventListener('progress',on_progress,false);     //xhr对象含有一个upload对象，它有一个progress事件，在文件上传过程中会被不断触发，我们为这个事件对应一个处理函数，每当事件触发就会调用这个函数，于是便可利用这个函数来修改当前进度，更多细节可自行查询\n\t\t\txhr.open('POST','http://10.13.8.12:89/uploadAPK/',true);  //请将url改成上传url\n            xhr.setRequestHeader('X-CSRFTOKEN','{{ request.COOKIES.csrftoken }}');   //此处为Django要求，可无视，或者换成相应后台所要求的CSRF防护，不是django用户请去掉\n\t\t\txhr.send(form);   //发送表单\n\t\t}\n```\n重点是`xhr.upload.addEventListener('progress',on_progress,false);`这个方法会保证上传过程中不断的回调我们来实现on_progress\n\n```\n function on_progress(evt) {       //看这个函数之前先看upload函数。这个函数可以接收一个evt(event)对象(细节自行查询progress)，他有3个属性lengthComputable，loaded，total，第一个属性是个bool类型的，代表是否支持，第二个代表当前上传的大小，第三个为总的大小，由此便可以计算出实时上传的百分比\n\t\t\tif(evt.lengthComputable) {\n\t\t\t\tvar ele = document.getElementById('2');\n\t\t\t\tvar percent = Math.round((evt.loaded) * 100 / evt.total);\n                if (percent == 100 && strongapk == 1) {\n                    strongapk = 0\n                    var textcontent = document.getElementById(\"wating\")\n                    textcontent.style.display = 'block'\n\n                    var apktextinput = document.getElementById('apkname')\n                    var apkname = apktextinput.value\n\n                     $.ajax({\n                        url: \"/startstrongapk/\",    //后台webservice里的方法名称\n                        data:{\"apkname\":apkname},\n                        type: \"post\",\n                        traditional: true,\n                        success: function (data) {\n                            downloadurl = data\n                            alert(data)\n                            $(\"#wating\").css('display','none');\n                            if (confirm(\"你确定要下载文件吗？\")) {\n                                self.location=('downloadsdk?url=' + data)\n                            }\n                        },\n                        error: function (msg) {\n                            alert(msg)\n                            $(\"#wating\").css('display','none');\n                        }\n                   });\n\n                }\n\t\t\t\tele.style.width = percent + '%';\n\t\t\t\tdocument.getElementById('3').innerHTML = percent + '%';\n\t\t\t}\n\t\t}\n```\n这里我们在percent达到100之后，调用ajax做一些事情\n\n### django中接口调用的方式总结\n网络方法调用大致有这么几种\n#### 点击按钮跳转新页面\n这种直接用<a>标签，然后用href就好\n\n```\n<a class=\"button\" id=\"ios\" style=\"position: absolute;top: 50px;\" href=\"jinkensios\" onmouseover=\"showDetailText(this)\" onmouseout=\"clearTest()\">● 打包(iOS)</a>\n```\n#### 点击按钮刷新局部数据\n##### 这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\n\n```\n$(document).ready(function(){\n      $(\"#btn\").click(function(){\n        string = $(\"#textarea1\").val()\n        $.get(\"/ajaxcreateui/\", {'text': string},function(ret){\n            $('#textarea2').html(ret)\n        })\n      });\n    });\n```\n- `$(document).ready(function(){}`预先埋伏的写法要写在这句代码里边\n- `$(\"#btn\").click(function(){}`这个是预先埋伏\n- `$.get(\"/ajaxcreateui/\", {'text': string},function(ret){}`ajax的get调用\n\n##### 直接使用XMLHttpRequest\n\n```\nvar progresshttp;\nfunction getprogress() {\n\n    progresshttp=null;\n    if (window.XMLHttpRequest)\n      {// code for all new browsers\n      progresshttp=new XMLHttpRequest();\n      }\n    else if (window.ActiveXObject)\n      {// code for IE5 and IE6\n      progresshttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n      }\n\n    if (progresshttp!=null)\n      {\n          progresshttp.onreadystatechange=progressstate_Change;\n          progresshttp.open(\"POST\",'getpackprogress',false);\n          var formData = new FormData();\n          formData.append('branchname', branchname);\n          progresshttp.send(formData);\n      }\n    else\n      {\n      alert(\"Your browser does not support XMLHTTP.\");\n      }\n}\n\nfunction progressstate_Change()\n{\nif (progresshttp.readyState==4)\n  {// 4 = \"loaded\"\n  if (progresshttp.status==200)\n    {// 200 = OK\n\n      num = this.responseText\n\n      var ele = document.getElementById('12');\n      var percent = num * 100;\n      percent = percent.toFixed(2)\n      if (percent >= 100.00) {\n          percent = 100.00\n      }\n      ele.style.width = percent + '%';\n      document.getElementById('13').innerHTML = percent + '%';\n      if (percent >= 100) {\n          window.clearInterval(waitinterval)\n          ele.style.width = 100 + '%';\n          var text = document.getElementById('building')\n          text.innerHTML = \"\"\n      }\n    }\n  else\n    {\n    alert(\"Problem retrieving XML data\");\n    }\n  }\n}\n```\n\n添加回调的方式\n>- `xhr.upload.addEventListener('progress',on_progress,false);`进度条\n>- `progresshttp.onreadystatechange=progressstate_Change`事件回调\n\n#### 某个事件调用结束刷新局部数据\n直接使用ajax或者XMLHttpRequest就好\n\n### python中调用命令行随时输出的做法\n\n```\np = subprocess.Popen(\"gradle assembleDebug\",shell=True,stdout=subprocess.PIPE)\n\nindexcount = 0\n\nreturncode = p.poll()\n\nwhile returncode is None:\n      text = p.stdout.readline().strip()\n      f = open('/Users/jdjr/Desktop/buildlog.txt','a')#追加打开方式\n      f.write(text)\n      f.close()\n        \n      returncode = p.poll()\n```\n\n\n\n","slug":"2017/基于Django的平台构建笔记(2)","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnf0045sauau6zj0vr8","content":"<h3 id=\"python中Json字符串的创建与javascript中json字符串的转换\"><a href=\"#python中Json字符串的创建与javascript中json字符串的转换\" class=\"headerlink\" title=\"python中Json字符串的创建与javascript中json字符串的转换\"></a>python中Json字符串的创建与javascript中json字符串的转换</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">import json</div><div class=\"line\"></div><div class=\"line\">def getindex(indexname):</div><div class=\"line\"></div><div class=\"line\">    datas = []</div><div class=\"line\"></div><div class=\"line\">    for item in namelist:</div><div class=\"line\">    </div><div class=\"line\">        pes.append(dic) </div><div class=\"line\">        pes = json.dumps(pes)</div><div class=\"line\">        datas.append(pes)</div><div class=\"line\"></div><div class=\"line\">    datas = json.dumps(datas)</div><div class=\"line\">    return datas</div></pre></td></tr></table></figure>\n<p>仔细看上边这段python我们能得出来一个结论，我们可以使用json这个功能，将一个python中的列表，转换为一段字符串，然后返回出去，这个字符串就是一段json字符串，我们可以将这段json字符串反过来转换成一个数组</p>\n<p>下面我们来瞅瞅，如何将一个json字符串转换为一个json数组</p>\n<blockquote>\n<p>首先说明基本功能：</p>\n</blockquote>\n<p>dumps是将dict转化成str格式，loads是将str转化成dict格式。</p>\n<p>dump和load也是类似的功能，只是与文件操作结合起来了。</p>\n<p>看代码实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: b = json.dumps(a)</div><div class=\"line\"></div><div class=\"line\">In [4]: print b, type(b)</div><div class=\"line\">&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">In [11]: json.loads(b)</div><div class=\"line\">Out[11]: &#123;u&apos;age&apos;: 29, u&apos;name&apos;: u&apos;wang&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">In [12]: print type(json.loads(b))</div><div class=\"line\">&lt;type &apos;dict&apos;&gt;</div></pre></td></tr></table></figure>\n<p>然后再看dump和dumps的区别，见代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: b = json.dumps(a)</div><div class=\"line\"></div><div class=\"line\">In [4]: print b, type(b)</div><div class=\"line\">&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">In [5]: c = json.dump(a)</div><div class=\"line\">---------------------------------------------------------------------------</div><div class=\"line\">TypeError                                 Traceback (most recent call last)</div><div class=\"line\">&lt;ipython-input-5-92dc0d929363&gt; in &lt;module&gt;()</div><div class=\"line\">----&gt; 1 c = json.dump(a)</div><div class=\"line\"></div><div class=\"line\">TypeError: dump() takes at least 2 arguments (1 given)</div></pre></td></tr></table></figure>\n<p>这里提示我们少一个参数，我们看一下帮助文件（iPyhton中可以直接使用help(json.dumps)来查看帮助文件）：</p>\n<p>dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)<br>Serialize <code>obj</code> to a JSON formatted <code>str</code>.</p>\n<p>dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)<br>Serialize <code>obj</code> as a JSON formatted stream to <code>fp</code> (a<br><code>.write()</code>-supporting file-like object).</p>\n<p>简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str然后存入文件中；而dumps直接给的是str，也就是将字典转成str。</p>\n<p>例子见代码（注意文件操作的一些小细节）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: fp = file(&apos;test.txt&apos;, &apos;w&apos;)</div><div class=\"line\"></div><div class=\"line\">In [4]: type(fp)</div><div class=\"line\">Out[4]: file</div><div class=\"line\"></div><div class=\"line\">In [5]: json.dump(a, fp)</div><div class=\"line\"></div><div class=\"line\">In [6]: cat test.txt</div><div class=\"line\"></div><div class=\"line\">In [7]: fp.close()</div><div class=\"line\"></div><div class=\"line\">In [8]: cat test.txt</div><div class=\"line\">&#123;&quot;name&quot;: &quot;wang&quot;&#125;</div><div class=\"line\">In [9]: json.load(fp)</div><div class=\"line\">---------------------------------------------------------------------------</div><div class=\"line\">ValueError                                Traceback (most recent call last)</div><div class=\"line\">&lt;ipython-input-9-0064dabedb17&gt; in &lt;module&gt;()</div><div class=\"line\">----&gt; 1 json.load(fp)</div><div class=\"line\"></div><div class=\"line\">/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.pyc in load(fp, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)</div><div class=\"line\">285</div><div class=\"line\">286     &quot;&quot;&quot;</div><div class=\"line\">--&gt; 287     return loads(fp.read(),</div><div class=\"line\">288         encoding=encoding, cls=cls, object_hook=object_hook,</div><div class=\"line\">289         parse_float=parse_float, parse_int=parse_int,</div><div class=\"line\"></div><div class=\"line\">ValueError: I/O operation on closed file</div><div class=\"line\"></div><div class=\"line\">In [10]: fp = file(&apos;test.txt&apos;, &apos;r&apos;)</div><div class=\"line\"></div><div class=\"line\">In [11]: json.load(fp)</div><div class=\"line\">Out[11]: &#123;u&apos;name&apos;: u&apos;wang&apos;&#125;</div><div class=\"line\">注：实际中dump用的较少。</div></pre></td></tr></table></figure>\n<h3 id=\"javascript中如何将一段json字符串转换为json对象\"><a href=\"#javascript中如何将一段json字符串转换为json对象\" class=\"headerlink\" title=\"javascript中如何将一段json字符串转换为json对象\"></a>javascript中如何将一段json字符串转换为json对象</h3><p>var obj = JSON.parse(data);</p>\n<h3 id=\"web中上传文件，带进度条的做法\"><a href=\"#web中上传文件，带进度条的做法\" class=\"headerlink\" title=\"web中上传文件，带进度条的做法\"></a>web中上传文件，带进度条的做法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;upload&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">     &lt;form&gt;</div><div class=\"line\">        &#123;% csrf_token %&#125;</div><div class=\"line\">        &lt;input type=&quot;file&quot; id=&apos;file&apos; class=&apos;file&apos; style=&quot;margin-top: 5px;margin-left: 10px&quot; name=&quot;file&quot;&gt;&lt;br&gt;</div><div class=\"line\">        &lt;div id=&apos;1&apos; style=&quot;margin-top: 40px;margin-left: 10px;height:10px;width:200px;border-color: rgba(110,3,120,1);border:1px solid gray;float:left;margin-right:10px;&quot;&gt;</div><div class=\"line\">            &lt;div id=&apos;2&apos; style=&quot;height:100%;width:0px;background:rgba(220,220,220,1);&quot;&gt;&lt;/div&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">        &lt;a style=&quot;position: absolute;top: 72px;;margin-right:25px&quot; id=&apos;3&apos;&gt;0%&lt;/a&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;button type=&quot;button&quot; style=&quot;margin-top: 32px;margin-left: 50px;&quot; onclick=&quot;upload();&quot;&gt;上传&lt;/button&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;/form&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>是要定义一个file,下边是js的代码，我们来实现上传功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function upload() &#123;</div><div class=\"line\"></div><div class=\"line\">            var apktextinput = document.getElementById(&apos;apkname&apos;)</div><div class=\"line\">            var apkname = apktextinput.value</div><div class=\"line\"></div><div class=\"line\">            if (apkname.length == 0) &#123;</div><div class=\"line\">                alert(&apos;请输入证书名称&apos;)</div><div class=\"line\">                return</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvar xhr = new XMLHttpRequest();</div><div class=\"line\">\t\t\tvar file = document.getElementById(&apos;file&apos;).files[0];   //取得文件数据，而.file对象只是文件信息</div><div class=\"line\">\t\t\tvar form = new FormData();   //FormData是HTML5为实现序列化表单而提供的类，更多细节可自行查询</div><div class=\"line\">            form.append(&apos;file&apos;,file);   //这里为序列化表单对象form添加一个元素，即file</div><div class=\"line\">\t\t\txhr.upload.addEventListener(&apos;progress&apos;,on_progress,false);     //xhr对象含有一个upload对象，它有一个progress事件，在文件上传过程中会被不断触发，我们为这个事件对应一个处理函数，每当事件触发就会调用这个函数，于是便可利用这个函数来修改当前进度，更多细节可自行查询</div><div class=\"line\">\t\t\txhr.open(&apos;POST&apos;,&apos;http://10.13.8.12:89/uploadAPK/&apos;,true);  //请将url改成上传url</div><div class=\"line\">            xhr.setRequestHeader(&apos;X-CSRFTOKEN&apos;,&apos;&#123;&#123; request.COOKIES.csrftoken &#125;&#125;&apos;);   //此处为Django要求，可无视，或者换成相应后台所要求的CSRF防护，不是django用户请去掉</div><div class=\"line\">\t\t\txhr.send(form);   //发送表单</div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure>\n<p>重点是<code>xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);</code>这个方法会保证上传过程中不断的回调我们来实现on_progress</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">function on_progress(evt) &#123;       //看这个函数之前先看upload函数。这个函数可以接收一个evt(event)对象(细节自行查询progress)，他有3个属性lengthComputable，loaded，total，第一个属性是个bool类型的，代表是否支持，第二个代表当前上传的大小，第三个为总的大小，由此便可以计算出实时上传的百分比</div><div class=\"line\">\t\tif(evt.lengthComputable) &#123;</div><div class=\"line\">\t\t\tvar ele = document.getElementById(&apos;2&apos;);</div><div class=\"line\">\t\t\tvar percent = Math.round((evt.loaded) * 100 / evt.total);</div><div class=\"line\">               if (percent == 100 &amp;&amp; strongapk == 1) &#123;</div><div class=\"line\">                   strongapk = 0</div><div class=\"line\">                   var textcontent = document.getElementById(&quot;wating&quot;)</div><div class=\"line\">                   textcontent.style.display = &apos;block&apos;</div><div class=\"line\"></div><div class=\"line\">                   var apktextinput = document.getElementById(&apos;apkname&apos;)</div><div class=\"line\">                   var apkname = apktextinput.value</div><div class=\"line\"></div><div class=\"line\">                    $.ajax(&#123;</div><div class=\"line\">                       url: &quot;/startstrongapk/&quot;,    //后台webservice里的方法名称</div><div class=\"line\">                       data:&#123;&quot;apkname&quot;:apkname&#125;,</div><div class=\"line\">                       type: &quot;post&quot;,</div><div class=\"line\">                       traditional: true,</div><div class=\"line\">                       success: function (data) &#123;</div><div class=\"line\">                           downloadurl = data</div><div class=\"line\">                           alert(data)</div><div class=\"line\">                           $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;);</div><div class=\"line\">                           if (confirm(&quot;你确定要下载文件吗？&quot;)) &#123;</div><div class=\"line\">                               self.location=(&apos;downloadsdk?url=&apos; + data)</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;,</div><div class=\"line\">                       error: function (msg) &#123;</div><div class=\"line\">                           alert(msg)</div><div class=\"line\">                           $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                  &#125;);</div><div class=\"line\"></div><div class=\"line\">               &#125;</div><div class=\"line\">\t\t\tele.style.width = percent + &apos;%&apos;;</div><div class=\"line\">\t\t\tdocument.getElementById(&apos;3&apos;).innerHTML = percent + &apos;%&apos;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>这里我们在percent达到100之后，调用ajax做一些事情</p>\n<h3 id=\"django中接口调用的方式总结\"><a href=\"#django中接口调用的方式总结\" class=\"headerlink\" title=\"django中接口调用的方式总结\"></a>django中接口调用的方式总结</h3><p>网络方法调用大致有这么几种</p>\n<h4 id=\"点击按钮跳转新页面\"><a href=\"#点击按钮跳转新页面\" class=\"headerlink\" title=\"点击按钮跳转新页面\"></a>点击按钮跳转新页面</h4><p>这种直接用<a>标签，然后用href就好</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a class=&quot;button&quot; id=&quot;ios&quot; style=&quot;position: absolute;top: 50px;&quot; href=&quot;jinkensios&quot; onmouseover=&quot;showDetailText(this)&quot; onmouseout=&quot;clearTest()&quot;&gt;● 打包(iOS)&lt;/a&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"点击按钮刷新局部数据\"><a href=\"#点击按钮刷新局部数据\" class=\"headerlink\" title=\"点击按钮刷新局部数据\"></a>点击按钮刷新局部数据</h4><h5 id=\"这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\"><a href=\"#这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\" class=\"headerlink\" title=\"这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\"></a>这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">      $(&quot;#btn&quot;).click(function()&#123;</div><div class=\"line\">        string = $(&quot;#textarea1&quot;).val()</div><div class=\"line\">        $.get(&quot;/ajaxcreateui/&quot;, &#123;&apos;text&apos;: string&#125;,function(ret)&#123;</div><div class=\"line\">            $(&apos;#textarea2&apos;).html(ret)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>$(document).ready(function(){}</code>预先埋伏的写法要写在这句代码里边</li>\n<li><code>$(&quot;#btn&quot;).click(function(){}</code>这个是预先埋伏</li>\n<li><code>$.get(&quot;/ajaxcreateui/&quot;, {&#39;text&#39;: string},function(ret){}</code>ajax的get调用</li>\n</ul>\n<h5 id=\"直接使用XMLHttpRequest\"><a href=\"#直接使用XMLHttpRequest\" class=\"headerlink\" title=\"直接使用XMLHttpRequest\"></a>直接使用XMLHttpRequest</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var progresshttp;</div><div class=\"line\">function getprogress() &#123;</div><div class=\"line\"></div><div class=\"line\">    progresshttp=null;</div><div class=\"line\">    if (window.XMLHttpRequest)</div><div class=\"line\">      &#123;// code for all new browsers</div><div class=\"line\">      progresshttp=new XMLHttpRequest();</div><div class=\"line\">      &#125;</div><div class=\"line\">    else if (window.ActiveXObject)</div><div class=\"line\">      &#123;// code for IE5 and IE6</div><div class=\"line\">      progresshttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    if (progresshttp!=null)</div><div class=\"line\">      &#123;</div><div class=\"line\">          progresshttp.onreadystatechange=progressstate_Change;</div><div class=\"line\">          progresshttp.open(&quot;POST&quot;,&apos;getpackprogress&apos;,false);</div><div class=\"line\">          var formData = new FormData();</div><div class=\"line\">          formData.append(&apos;branchname&apos;, branchname);</div><div class=\"line\">          progresshttp.send(formData);</div><div class=\"line\">      &#125;</div><div class=\"line\">    else</div><div class=\"line\">      &#123;</div><div class=\"line\">      alert(&quot;Your browser does not support XMLHTTP.&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function progressstate_Change()</div><div class=\"line\">&#123;</div><div class=\"line\">if (progresshttp.readyState==4)</div><div class=\"line\">  &#123;// 4 = &quot;loaded&quot;</div><div class=\"line\">  if (progresshttp.status==200)</div><div class=\"line\">    &#123;// 200 = OK</div><div class=\"line\"></div><div class=\"line\">      num = this.responseText</div><div class=\"line\"></div><div class=\"line\">      var ele = document.getElementById(&apos;12&apos;);</div><div class=\"line\">      var percent = num * 100;</div><div class=\"line\">      percent = percent.toFixed(2)</div><div class=\"line\">      if (percent &gt;= 100.00) &#123;</div><div class=\"line\">          percent = 100.00</div><div class=\"line\">      &#125;</div><div class=\"line\">      ele.style.width = percent + &apos;%&apos;;</div><div class=\"line\">      document.getElementById(&apos;13&apos;).innerHTML = percent + &apos;%&apos;;</div><div class=\"line\">      if (percent &gt;= 100) &#123;</div><div class=\"line\">          window.clearInterval(waitinterval)</div><div class=\"line\">          ele.style.width = 100 + &apos;%&apos;;</div><div class=\"line\">          var text = document.getElementById(&apos;building&apos;)</div><div class=\"line\">          text.innerHTML = &quot;&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  else</div><div class=\"line\">    &#123;</div><div class=\"line\">    alert(&quot;Problem retrieving XML data&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>添加回调的方式</p>\n<blockquote>\n<ul>\n<li><code>xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);</code>进度条</li>\n<li><code>progresshttp.onreadystatechange=progressstate_Change</code>事件回调</li>\n</ul>\n</blockquote>\n<h4 id=\"某个事件调用结束刷新局部数据\"><a href=\"#某个事件调用结束刷新局部数据\" class=\"headerlink\" title=\"某个事件调用结束刷新局部数据\"></a>某个事件调用结束刷新局部数据</h4><p>直接使用ajax或者XMLHttpRequest就好</p>\n<h3 id=\"python中调用命令行随时输出的做法\"><a href=\"#python中调用命令行随时输出的做法\" class=\"headerlink\" title=\"python中调用命令行随时输出的做法\"></a>python中调用命令行随时输出的做法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE)</div><div class=\"line\"></div><div class=\"line\">indexcount = 0</div><div class=\"line\"></div><div class=\"line\">returncode = p.poll()</div><div class=\"line\"></div><div class=\"line\">while returncode is None:</div><div class=\"line\">      text = p.stdout.readline().strip()</div><div class=\"line\">      f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;)#追加打开方式</div><div class=\"line\">      f.write(text)</div><div class=\"line\">      f.close()</div><div class=\"line\">        </div><div class=\"line\">      returncode = p.poll()</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"python中Json字符串的创建与javascript中json字符串的转换\"><a href=\"#python中Json字符串的创建与javascript中json字符串的转换\" class=\"headerlink\" title=\"python中Json字符串的创建与javascript中json字符串的转换\"></a>python中Json字符串的创建与javascript中json字符串的转换</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">import json</div><div class=\"line\"></div><div class=\"line\">def getindex(indexname):</div><div class=\"line\"></div><div class=\"line\">    datas = []</div><div class=\"line\"></div><div class=\"line\">    for item in namelist:</div><div class=\"line\">    </div><div class=\"line\">        pes.append(dic) </div><div class=\"line\">        pes = json.dumps(pes)</div><div class=\"line\">        datas.append(pes)</div><div class=\"line\"></div><div class=\"line\">    datas = json.dumps(datas)</div><div class=\"line\">    return datas</div></pre></td></tr></table></figure>\n<p>仔细看上边这段python我们能得出来一个结论，我们可以使用json这个功能，将一个python中的列表，转换为一段字符串，然后返回出去，这个字符串就是一段json字符串，我们可以将这段json字符串反过来转换成一个数组</p>\n<p>下面我们来瞅瞅，如何将一个json字符串转换为一个json数组</p>\n<blockquote>\n<p>首先说明基本功能：</p>\n</blockquote>\n<p>dumps是将dict转化成str格式，loads是将str转化成dict格式。</p>\n<p>dump和load也是类似的功能，只是与文件操作结合起来了。</p>\n<p>看代码实例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: b = json.dumps(a)</div><div class=\"line\"></div><div class=\"line\">In [4]: print b, type(b)</div><div class=\"line\">&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">In [11]: json.loads(b)</div><div class=\"line\">Out[11]: &#123;u&apos;age&apos;: 29, u&apos;name&apos;: u&apos;wang&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">In [12]: print type(json.loads(b))</div><div class=\"line\">&lt;type &apos;dict&apos;&gt;</div></pre></td></tr></table></figure>\n<p>然后再看dump和dumps的区别，见代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;, &apos;age&apos;: 29&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: b = json.dumps(a)</div><div class=\"line\"></div><div class=\"line\">In [4]: print b, type(b)</div><div class=\"line\">&#123;&quot;age&quot;: 29, &quot;name&quot;: &quot;wang&quot;&#125; &lt;type &apos;str&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">In [5]: c = json.dump(a)</div><div class=\"line\">---------------------------------------------------------------------------</div><div class=\"line\">TypeError                                 Traceback (most recent call last)</div><div class=\"line\">&lt;ipython-input-5-92dc0d929363&gt; in &lt;module&gt;()</div><div class=\"line\">----&gt; 1 c = json.dump(a)</div><div class=\"line\"></div><div class=\"line\">TypeError: dump() takes at least 2 arguments (1 given)</div></pre></td></tr></table></figure>\n<p>这里提示我们少一个参数，我们看一下帮助文件（iPyhton中可以直接使用help(json.dumps)来查看帮助文件）：</p>\n<p>dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)<br>Serialize <code>obj</code> to a JSON formatted <code>str</code>.</p>\n<p>dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=’utf-8’, default=None, sort_keys=False, **kw)<br>Serialize <code>obj</code> as a JSON formatted stream to <code>fp</code> (a<br><code>.write()</code>-supporting file-like object).</p>\n<p>简单说就是dump需要一个类似于文件指针的参数（并不是真的指针，可称之为类文件对象），可以与文件操作结合，也就是说可以将dict转成str然后存入文件中；而dumps直接给的是str，也就是将字典转成str。</p>\n<p>例子见代码（注意文件操作的一些小细节）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">In [1]: import json</div><div class=\"line\"></div><div class=\"line\">In [2]: a = &#123;&apos;name&apos;: &apos;wang&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">In [3]: fp = file(&apos;test.txt&apos;, &apos;w&apos;)</div><div class=\"line\"></div><div class=\"line\">In [4]: type(fp)</div><div class=\"line\">Out[4]: file</div><div class=\"line\"></div><div class=\"line\">In [5]: json.dump(a, fp)</div><div class=\"line\"></div><div class=\"line\">In [6]: cat test.txt</div><div class=\"line\"></div><div class=\"line\">In [7]: fp.close()</div><div class=\"line\"></div><div class=\"line\">In [8]: cat test.txt</div><div class=\"line\">&#123;&quot;name&quot;: &quot;wang&quot;&#125;</div><div class=\"line\">In [9]: json.load(fp)</div><div class=\"line\">---------------------------------------------------------------------------</div><div class=\"line\">ValueError                                Traceback (most recent call last)</div><div class=\"line\">&lt;ipython-input-9-0064dabedb17&gt; in &lt;module&gt;()</div><div class=\"line\">----&gt; 1 json.load(fp)</div><div class=\"line\"></div><div class=\"line\">/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.pyc in load(fp, encoding, cls, object_hook, parse_float, parse_int, parse_constant, object_pairs_hook, **kw)</div><div class=\"line\">285</div><div class=\"line\">286     &quot;&quot;&quot;</div><div class=\"line\">--&gt; 287     return loads(fp.read(),</div><div class=\"line\">288         encoding=encoding, cls=cls, object_hook=object_hook,</div><div class=\"line\">289         parse_float=parse_float, parse_int=parse_int,</div><div class=\"line\"></div><div class=\"line\">ValueError: I/O operation on closed file</div><div class=\"line\"></div><div class=\"line\">In [10]: fp = file(&apos;test.txt&apos;, &apos;r&apos;)</div><div class=\"line\"></div><div class=\"line\">In [11]: json.load(fp)</div><div class=\"line\">Out[11]: &#123;u&apos;name&apos;: u&apos;wang&apos;&#125;</div><div class=\"line\">注：实际中dump用的较少。</div></pre></td></tr></table></figure>\n<h3 id=\"javascript中如何将一段json字符串转换为json对象\"><a href=\"#javascript中如何将一段json字符串转换为json对象\" class=\"headerlink\" title=\"javascript中如何将一段json字符串转换为json对象\"></a>javascript中如何将一段json字符串转换为json对象</h3><p>var obj = JSON.parse(data);</p>\n<h3 id=\"web中上传文件，带进度条的做法\"><a href=\"#web中上传文件，带进度条的做法\" class=\"headerlink\" title=\"web中上传文件，带进度条的做法\"></a>web中上传文件，带进度条的做法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;upload&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">     &lt;form&gt;</div><div class=\"line\">        &#123;% csrf_token %&#125;</div><div class=\"line\">        &lt;input type=&quot;file&quot; id=&apos;file&apos; class=&apos;file&apos; style=&quot;margin-top: 5px;margin-left: 10px&quot; name=&quot;file&quot;&gt;&lt;br&gt;</div><div class=\"line\">        &lt;div id=&apos;1&apos; style=&quot;margin-top: 40px;margin-left: 10px;height:10px;width:200px;border-color: rgba(110,3,120,1);border:1px solid gray;float:left;margin-right:10px;&quot;&gt;</div><div class=\"line\">            &lt;div id=&apos;2&apos; style=&quot;height:100%;width:0px;background:rgba(220,220,220,1);&quot;&gt;&lt;/div&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">        &lt;a style=&quot;position: absolute;top: 72px;;margin-right:25px&quot; id=&apos;3&apos;&gt;0%&lt;/a&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;button type=&quot;button&quot; style=&quot;margin-top: 32px;margin-left: 50px;&quot; onclick=&quot;upload();&quot;&gt;上传&lt;/button&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;/form&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>是要定义一个file,下边是js的代码，我们来实现上传功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function upload() &#123;</div><div class=\"line\"></div><div class=\"line\">            var apktextinput = document.getElementById(&apos;apkname&apos;)</div><div class=\"line\">            var apkname = apktextinput.value</div><div class=\"line\"></div><div class=\"line\">            if (apkname.length == 0) &#123;</div><div class=\"line\">                alert(&apos;请输入证书名称&apos;)</div><div class=\"line\">                return</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvar xhr = new XMLHttpRequest();</div><div class=\"line\">\t\t\tvar file = document.getElementById(&apos;file&apos;).files[0];   //取得文件数据，而.file对象只是文件信息</div><div class=\"line\">\t\t\tvar form = new FormData();   //FormData是HTML5为实现序列化表单而提供的类，更多细节可自行查询</div><div class=\"line\">            form.append(&apos;file&apos;,file);   //这里为序列化表单对象form添加一个元素，即file</div><div class=\"line\">\t\t\txhr.upload.addEventListener(&apos;progress&apos;,on_progress,false);     //xhr对象含有一个upload对象，它有一个progress事件，在文件上传过程中会被不断触发，我们为这个事件对应一个处理函数，每当事件触发就会调用这个函数，于是便可利用这个函数来修改当前进度，更多细节可自行查询</div><div class=\"line\">\t\t\txhr.open(&apos;POST&apos;,&apos;http://10.13.8.12:89/uploadAPK/&apos;,true);  //请将url改成上传url</div><div class=\"line\">            xhr.setRequestHeader(&apos;X-CSRFTOKEN&apos;,&apos;&#123;&#123; request.COOKIES.csrftoken &#125;&#125;&apos;);   //此处为Django要求，可无视，或者换成相应后台所要求的CSRF防护，不是django用户请去掉</div><div class=\"line\">\t\t\txhr.send(form);   //发送表单</div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure>\n<p>重点是<code>xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);</code>这个方法会保证上传过程中不断的回调我们来实现on_progress</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">function on_progress(evt) &#123;       //看这个函数之前先看upload函数。这个函数可以接收一个evt(event)对象(细节自行查询progress)，他有3个属性lengthComputable，loaded，total，第一个属性是个bool类型的，代表是否支持，第二个代表当前上传的大小，第三个为总的大小，由此便可以计算出实时上传的百分比</div><div class=\"line\">\t\tif(evt.lengthComputable) &#123;</div><div class=\"line\">\t\t\tvar ele = document.getElementById(&apos;2&apos;);</div><div class=\"line\">\t\t\tvar percent = Math.round((evt.loaded) * 100 / evt.total);</div><div class=\"line\">               if (percent == 100 &amp;&amp; strongapk == 1) &#123;</div><div class=\"line\">                   strongapk = 0</div><div class=\"line\">                   var textcontent = document.getElementById(&quot;wating&quot;)</div><div class=\"line\">                   textcontent.style.display = &apos;block&apos;</div><div class=\"line\"></div><div class=\"line\">                   var apktextinput = document.getElementById(&apos;apkname&apos;)</div><div class=\"line\">                   var apkname = apktextinput.value</div><div class=\"line\"></div><div class=\"line\">                    $.ajax(&#123;</div><div class=\"line\">                       url: &quot;/startstrongapk/&quot;,    //后台webservice里的方法名称</div><div class=\"line\">                       data:&#123;&quot;apkname&quot;:apkname&#125;,</div><div class=\"line\">                       type: &quot;post&quot;,</div><div class=\"line\">                       traditional: true,</div><div class=\"line\">                       success: function (data) &#123;</div><div class=\"line\">                           downloadurl = data</div><div class=\"line\">                           alert(data)</div><div class=\"line\">                           $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;);</div><div class=\"line\">                           if (confirm(&quot;你确定要下载文件吗？&quot;)) &#123;</div><div class=\"line\">                               self.location=(&apos;downloadsdk?url=&apos; + data)</div><div class=\"line\">                           &#125;</div><div class=\"line\">                       &#125;,</div><div class=\"line\">                       error: function (msg) &#123;</div><div class=\"line\">                           alert(msg)</div><div class=\"line\">                           $(&quot;#wating&quot;).css(&apos;display&apos;,&apos;none&apos;);</div><div class=\"line\">                       &#125;</div><div class=\"line\">                  &#125;);</div><div class=\"line\"></div><div class=\"line\">               &#125;</div><div class=\"line\">\t\t\tele.style.width = percent + &apos;%&apos;;</div><div class=\"line\">\t\t\tdocument.getElementById(&apos;3&apos;).innerHTML = percent + &apos;%&apos;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n<p>这里我们在percent达到100之后，调用ajax做一些事情</p>\n<h3 id=\"django中接口调用的方式总结\"><a href=\"#django中接口调用的方式总结\" class=\"headerlink\" title=\"django中接口调用的方式总结\"></a>django中接口调用的方式总结</h3><p>网络方法调用大致有这么几种</p>\n<h4 id=\"点击按钮跳转新页面\"><a href=\"#点击按钮跳转新页面\" class=\"headerlink\" title=\"点击按钮跳转新页面\"></a>点击按钮跳转新页面</h4><p>这种直接用<a>标签，然后用href就好</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;a class=&quot;button&quot; id=&quot;ios&quot; style=&quot;position: absolute;top: 50px;&quot; href=&quot;jinkensios&quot; onmouseover=&quot;showDetailText(this)&quot; onmouseout=&quot;clearTest()&quot;&gt;● 打包(iOS)&lt;/a&gt;</div></pre></td></tr></table></figure>\n<h4 id=\"点击按钮刷新局部数据\"><a href=\"#点击按钮刷新局部数据\" class=\"headerlink\" title=\"点击按钮刷新局部数据\"></a>点击按钮刷新局部数据</h4><h5 id=\"这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\"><a href=\"#这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\" class=\"headerlink\" title=\"这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用\"></a>这种最好是预先埋伏好ajax，然后用id绑定，点击之后直接调用</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(document).ready(function()&#123;</div><div class=\"line\">      $(&quot;#btn&quot;).click(function()&#123;</div><div class=\"line\">        string = $(&quot;#textarea1&quot;).val()</div><div class=\"line\">        $.get(&quot;/ajaxcreateui/&quot;, &#123;&apos;text&apos;: string&#125;,function(ret)&#123;</div><div class=\"line\">            $(&apos;#textarea2&apos;).html(ret)</div><div class=\"line\">        &#125;)</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<ul>\n<li><code>$(document).ready(function(){}</code>预先埋伏的写法要写在这句代码里边</li>\n<li><code>$(&quot;#btn&quot;).click(function(){}</code>这个是预先埋伏</li>\n<li><code>$.get(&quot;/ajaxcreateui/&quot;, {&#39;text&#39;: string},function(ret){}</code>ajax的get调用</li>\n</ul>\n<h5 id=\"直接使用XMLHttpRequest\"><a href=\"#直接使用XMLHttpRequest\" class=\"headerlink\" title=\"直接使用XMLHttpRequest\"></a>直接使用XMLHttpRequest</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\">var progresshttp;</div><div class=\"line\">function getprogress() &#123;</div><div class=\"line\"></div><div class=\"line\">    progresshttp=null;</div><div class=\"line\">    if (window.XMLHttpRequest)</div><div class=\"line\">      &#123;// code for all new browsers</div><div class=\"line\">      progresshttp=new XMLHttpRequest();</div><div class=\"line\">      &#125;</div><div class=\"line\">    else if (window.ActiveXObject)</div><div class=\"line\">      &#123;// code for IE5 and IE6</div><div class=\"line\">      progresshttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">    if (progresshttp!=null)</div><div class=\"line\">      &#123;</div><div class=\"line\">          progresshttp.onreadystatechange=progressstate_Change;</div><div class=\"line\">          progresshttp.open(&quot;POST&quot;,&apos;getpackprogress&apos;,false);</div><div class=\"line\">          var formData = new FormData();</div><div class=\"line\">          formData.append(&apos;branchname&apos;, branchname);</div><div class=\"line\">          progresshttp.send(formData);</div><div class=\"line\">      &#125;</div><div class=\"line\">    else</div><div class=\"line\">      &#123;</div><div class=\"line\">      alert(&quot;Your browser does not support XMLHTTP.&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function progressstate_Change()</div><div class=\"line\">&#123;</div><div class=\"line\">if (progresshttp.readyState==4)</div><div class=\"line\">  &#123;// 4 = &quot;loaded&quot;</div><div class=\"line\">  if (progresshttp.status==200)</div><div class=\"line\">    &#123;// 200 = OK</div><div class=\"line\"></div><div class=\"line\">      num = this.responseText</div><div class=\"line\"></div><div class=\"line\">      var ele = document.getElementById(&apos;12&apos;);</div><div class=\"line\">      var percent = num * 100;</div><div class=\"line\">      percent = percent.toFixed(2)</div><div class=\"line\">      if (percent &gt;= 100.00) &#123;</div><div class=\"line\">          percent = 100.00</div><div class=\"line\">      &#125;</div><div class=\"line\">      ele.style.width = percent + &apos;%&apos;;</div><div class=\"line\">      document.getElementById(&apos;13&apos;).innerHTML = percent + &apos;%&apos;;</div><div class=\"line\">      if (percent &gt;= 100) &#123;</div><div class=\"line\">          window.clearInterval(waitinterval)</div><div class=\"line\">          ele.style.width = 100 + &apos;%&apos;;</div><div class=\"line\">          var text = document.getElementById(&apos;building&apos;)</div><div class=\"line\">          text.innerHTML = &quot;&quot;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  else</div><div class=\"line\">    &#123;</div><div class=\"line\">    alert(&quot;Problem retrieving XML data&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>添加回调的方式</p>\n<blockquote>\n<ul>\n<li><code>xhr.upload.addEventListener(&#39;progress&#39;,on_progress,false);</code>进度条</li>\n<li><code>progresshttp.onreadystatechange=progressstate_Change</code>事件回调</li>\n</ul>\n</blockquote>\n<h4 id=\"某个事件调用结束刷新局部数据\"><a href=\"#某个事件调用结束刷新局部数据\" class=\"headerlink\" title=\"某个事件调用结束刷新局部数据\"></a>某个事件调用结束刷新局部数据</h4><p>直接使用ajax或者XMLHttpRequest就好</p>\n<h3 id=\"python中调用命令行随时输出的做法\"><a href=\"#python中调用命令行随时输出的做法\" class=\"headerlink\" title=\"python中调用命令行随时输出的做法\"></a>python中调用命令行随时输出的做法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">p = subprocess.Popen(&quot;gradle assembleDebug&quot;,shell=True,stdout=subprocess.PIPE)</div><div class=\"line\"></div><div class=\"line\">indexcount = 0</div><div class=\"line\"></div><div class=\"line\">returncode = p.poll()</div><div class=\"line\"></div><div class=\"line\">while returncode is None:</div><div class=\"line\">      text = p.stdout.readline().strip()</div><div class=\"line\">      f = open(&apos;/Users/jdjr/Desktop/buildlog.txt&apos;,&apos;a&apos;)#追加打开方式</div><div class=\"line\">      f.write(text)</div><div class=\"line\">      f.close()</div><div class=\"line\">        </div><div class=\"line\">      returncode = p.poll()</div></pre></td></tr></table></figure>"},{"title":"mongodb使用小结","date":"2017-05-17T06:46:54.000Z","_content":"\n### 创建一个mongo数据库\n<!--more-->\n```\nfrom pymongo import MongoClient\nimport json,time\n\nconnection = MongoClient(\"localhost\",27017)\nmydb = connection.mydb # new a database\nmyser = mydb.allindex # new a table\n```\n\n### 查\n\n```\ndicn = {}\ndicn['indexname'] = item\ndicn['date'] = dateString\ndbs = myser.find(dicn)\n\nfor item in dbs:\n\n  dic = {}\n  datestring = item['date']\n  datestring = datestring.encode('utf-8')\n  dic['date'] = datestring\n  dic['earyeild'] = item['earyeild']\n  dic['indexname'] = item['indexname']\n\n\n```\n\n> \n\nMongoDB提供了一组比较操作符：$lt/$lte/$gt/$gte/$ne，依次等价于</<=/>/>=/!=。\n-  下面的示例返回符合条件age >= 18 && age <= 40的文档。\n```\n> db.test.find({\"age\":{\"$gte\":18, \"$lte\":40}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- 下面的示例返回条件符合name != \"stephen1\"\n```\n> db.test.find({\"name\":{\"$ne\":\"stephen1\"}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- $in等同于SQL中的in，下面的示例等同于SQL中的in (\"stephen\",\"stephen1\")\n```\n> db.test.find({\"name\":{\"$in\":[\"stephen\",\"stephen1\"]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }  \n```\n\n- 和SQL不同的是，MongoDB的in list中的数据可以是不同类型。这种情况可用于不同类型的别名场景。\n```\n> db.test.find({\"name\":{\"$in\":[\"stephen\",123]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- $nin等同于SQL中的not in，同时也是$in的取反。如：\n```\n> db.test.find({\"name\":{\"$nin\":[\"stephen2\",\"stephen1\"]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- $or等同于SQL中的or，$or所针对的条件被放到一个数组中，每个数组元素表示or的一个条件。\n下面的示例等同于name = \"stephen1\" or age = 35\n```\n> db.test.find({\"$or\": [{\"name\":\"stephen1\"}, {\"age\":35}]})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- 下面的示例演示了如何混合使用$or和$in。\n```\n> db.test.find({\"$or\": [{\"name\":{\"$in\":[\"stephen\",\"stephen1\"]}}, {\"age\":36}]})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- $not表示取反，等同于SQL中的not。\n```\n> db.test.find({\"name\": {\"$not\": {\"$in\":[\"stephen2\",\"stephen1\"]}}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n\n```\n\n### 增\n```\nmyser.save({'指数名称':item,'市盈率':pe,'盈利收益率':roe,'日期':date,'市净率':pb,'股息率':rate})\n```\n\n### 时间的用法\n```\ncurrent = time.localtime(time.time())\nyear = current.tm_year\nmonth = current.tm_mon\nday = current.tm_mday\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\n```\n","source":"_posts/2017/mongodb使用小结.md","raw":"---\ntitle: mongodb使用小结\ndate: 2017-05-17 14:46:54\ntags:\n- mongo\n---\n\n### 创建一个mongo数据库\n<!--more-->\n```\nfrom pymongo import MongoClient\nimport json,time\n\nconnection = MongoClient(\"localhost\",27017)\nmydb = connection.mydb # new a database\nmyser = mydb.allindex # new a table\n```\n\n### 查\n\n```\ndicn = {}\ndicn['indexname'] = item\ndicn['date'] = dateString\ndbs = myser.find(dicn)\n\nfor item in dbs:\n\n  dic = {}\n  datestring = item['date']\n  datestring = datestring.encode('utf-8')\n  dic['date'] = datestring\n  dic['earyeild'] = item['earyeild']\n  dic['indexname'] = item['indexname']\n\n\n```\n\n> \n\nMongoDB提供了一组比较操作符：$lt/$lte/$gt/$gte/$ne，依次等价于</<=/>/>=/!=。\n-  下面的示例返回符合条件age >= 18 && age <= 40的文档。\n```\n> db.test.find({\"age\":{\"$gte\":18, \"$lte\":40}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- 下面的示例返回条件符合name != \"stephen1\"\n```\n> db.test.find({\"name\":{\"$ne\":\"stephen1\"}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- $in等同于SQL中的in，下面的示例等同于SQL中的in (\"stephen\",\"stephen1\")\n```\n> db.test.find({\"name\":{\"$in\":[\"stephen\",\"stephen1\"]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }  \n```\n\n- 和SQL不同的是，MongoDB的in list中的数据可以是不同类型。这种情况可用于不同类型的别名场景。\n```\n> db.test.find({\"name\":{\"$in\":[\"stephen\",123]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- $nin等同于SQL中的not in，同时也是$in的取反。如：\n```\n> db.test.find({\"name\":{\"$nin\":[\"stephen2\",\"stephen1\"]}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n```\n\n- $or等同于SQL中的or，$or所针对的条件被放到一个数组中，每个数组元素表示or的一个条件。\n下面的示例等同于name = \"stephen1\" or age = 35\n```\n> db.test.find({\"$or\": [{\"name\":\"stephen1\"}, {\"age\":35}]})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- 下面的示例演示了如何混合使用$or和$in。\n```\n> db.test.find({\"$or\": [{\"name\":{\"$in\":[\"stephen\",\"stephen1\"]}}, {\"age\":36}]})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" } \n```\n\n- $not表示取反，等同于SQL中的not。\n```\n> db.test.find({\"name\": {\"$not\": {\"$in\":[\"stephen2\",\"stephen1\"]}}})\n{ \"_id\" : ObjectId(\"4fd58ecbb9ac507e96276f1a\"), \"name\" : \"stephen\", \"age\" : 35,\"genda\" : \"male\", \"email\" : \"stephen@hotmail.com\" }\n\n```\n\n### 增\n```\nmyser.save({'指数名称':item,'市盈率':pe,'盈利收益率':roe,'日期':date,'市净率':pb,'股息率':rate})\n```\n\n### 时间的用法\n```\ncurrent = time.localtime(time.time())\nyear = current.tm_year\nmonth = current.tm_mon\nday = current.tm_mday\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\n```\n","slug":"2017/mongodb使用小结","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnh0049saua97v5d5mj","content":"<h3 id=\"创建一个mongo数据库\"><a href=\"#创建一个mongo数据库\" class=\"headerlink\" title=\"创建一个mongo数据库\"></a>创建一个mongo数据库</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\">import json,time</div><div class=\"line\"></div><div class=\"line\">connection = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">mydb = connection.mydb # new a database</div><div class=\"line\">myser = mydb.allindex # new a table</div></pre></td></tr></table></figure>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">dicn = &#123;&#125;</div><div class=\"line\">dicn[&apos;indexname&apos;] = item</div><div class=\"line\">dicn[&apos;date&apos;] = dateString</div><div class=\"line\">dbs = myser.find(dicn)</div><div class=\"line\"></div><div class=\"line\">for item in dbs:</div><div class=\"line\"></div><div class=\"line\">  dic = &#123;&#125;</div><div class=\"line\">  datestring = item[&apos;date&apos;]</div><div class=\"line\">  datestring = datestring.encode(&apos;utf-8&apos;)</div><div class=\"line\">  dic[&apos;date&apos;] = datestring</div><div class=\"line\">  dic[&apos;earyeild&apos;] = item[&apos;earyeild&apos;]</div><div class=\"line\">  dic[&apos;indexname&apos;] = item[&apos;indexname&apos;]</div></pre></td></tr></table></figure>\n<blockquote>\n</blockquote>\n<p>MongoDB提供了一组比较操作符：$lt/$lte/$gt/$gte/$ne，依次等价于&lt;/&lt;=/&gt;/&gt;=/!=。</p>\n<ul>\n<li><p>下面的示例返回符合条件age &gt;= 18 &amp;&amp; age &lt;= 40的文档。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;age&quot;:&#123;&quot;$gte&quot;:18, &quot;$lte&quot;:40&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面的示例返回条件符合name != “stephen1”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$ne&quot;:&quot;stephen1&quot;&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$in等同于SQL中的in，下面的示例等同于SQL中的in (“stephen”,”stephen1”)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>和SQL不同的是，MongoDB的in list中的数据可以是不同类型。这种情况可用于不同类型的别名场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,123]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$nin等同于SQL中的not in，同时也是$in的取反。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$nin&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$or等同于SQL中的or，$or所针对的条件被放到一个数组中，每个数组元素表示or的一个条件。<br>下面的示例等同于name = “stephen1” or age = 35</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&quot;stephen1&quot;&#125;, &#123;&quot;age&quot;:35&#125;]&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面的示例演示了如何混合使用$or和$in。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;, &#123;&quot;age&quot;:36&#125;]&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$not表示取反，等同于SQL中的not。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;: &#123;&quot;$not&quot;: &#123;&quot;$in&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"时间的用法\"><a href=\"#时间的用法\" class=\"headerlink\" title=\"时间的用法\"></a>时间的用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">current = time.localtime(time.time())</div><div class=\"line\">year = current.tm_year</div><div class=\"line\">month = current.tm_mon</div><div class=\"line\">day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"创建一个mongo数据库\"><a href=\"#创建一个mongo数据库\" class=\"headerlink\" title=\"创建一个mongo数据库\"></a>创建一个mongo数据库</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\">import json,time</div><div class=\"line\"></div><div class=\"line\">connection = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">mydb = connection.mydb # new a database</div><div class=\"line\">myser = mydb.allindex # new a table</div></pre></td></tr></table></figure>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">dicn = &#123;&#125;</div><div class=\"line\">dicn[&apos;indexname&apos;] = item</div><div class=\"line\">dicn[&apos;date&apos;] = dateString</div><div class=\"line\">dbs = myser.find(dicn)</div><div class=\"line\"></div><div class=\"line\">for item in dbs:</div><div class=\"line\"></div><div class=\"line\">  dic = &#123;&#125;</div><div class=\"line\">  datestring = item[&apos;date&apos;]</div><div class=\"line\">  datestring = datestring.encode(&apos;utf-8&apos;)</div><div class=\"line\">  dic[&apos;date&apos;] = datestring</div><div class=\"line\">  dic[&apos;earyeild&apos;] = item[&apos;earyeild&apos;]</div><div class=\"line\">  dic[&apos;indexname&apos;] = item[&apos;indexname&apos;]</div></pre></td></tr></table></figure>\n<blockquote>\n</blockquote>\n<p>MongoDB提供了一组比较操作符：$lt/$lte/$gt/$gte/$ne，依次等价于&lt;/&lt;=/&gt;/&gt;=/!=。</p>\n<ul>\n<li><p>下面的示例返回符合条件age &gt;= 18 &amp;&amp; age &lt;= 40的文档。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;age&quot;:&#123;&quot;$gte&quot;:18, &quot;$lte&quot;:40&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面的示例返回条件符合name != “stephen1”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$ne&quot;:&quot;stephen1&quot;&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$in等同于SQL中的in，下面的示例等同于SQL中的in (“stephen”,”stephen1”)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>和SQL不同的是，MongoDB的in list中的数据可以是不同类型。这种情况可用于不同类型的别名场景。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,123]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$nin等同于SQL中的not in，同时也是$in的取反。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;:&#123;&quot;$nin&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$or等同于SQL中的or，$or所针对的条件被放到一个数组中，每个数组元素表示or的一个条件。<br>下面的示例等同于name = “stephen1” or age = 35</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&quot;stephen1&quot;&#125;, &#123;&quot;age&quot;:35&#125;]&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>下面的示例演示了如何混合使用$or和$in。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;$or&quot;: [&#123;&quot;name&quot;:&#123;&quot;$in&quot;:[&quot;stephen&quot;,&quot;stephen1&quot;]&#125;&#125;, &#123;&quot;age&quot;:36&#125;]&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>$not表示取反，等同于SQL中的not。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; db.test.find(&#123;&quot;name&quot;: &#123;&quot;$not&quot;: &#123;&quot;$in&quot;:[&quot;stephen2&quot;,&quot;stephen1&quot;]&#125;&#125;&#125;)</div><div class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;4fd58ecbb9ac507e96276f1a&quot;), &quot;name&quot; : &quot;stephen&quot;, &quot;age&quot; : 35,&quot;genda&quot; : &quot;male&quot;, &quot;email&quot; : &quot;stephen@hotmail.com&quot; &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"时间的用法\"><a href=\"#时间的用法\" class=\"headerlink\" title=\"时间的用法\"></a>时间的用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">current = time.localtime(time.time())</div><div class=\"line\">year = current.tm_year</div><div class=\"line\">month = current.tm_mon</div><div class=\"line\">day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div></pre></td></tr></table></figure>"},{"title":"定时检查网页更新并发送微信消息","date":"2017-02-16T08:11:20.000Z","_content":"\n```\n# -*- coding: utf-8 -*-\nimport urllib2,time,urllib\n\n    while True:\n    current = time.localtime(time.time())\n\n    year = current.tm_year\n    month = current.tm_mon\n    day = current.tm_mday\n\n    hour = current.tm_hour\n    minite = current.tm_min\n    sec = current.tm_sec\n    if sec == 0:\n\n    downLoadStr = 'http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml'\n    print downLoadStr\n    try:\n        i_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n        \"Referer\": 'http://www.baidu.com'}\n        req = urllib2.Request(downLoadStr, headers=i_headers)\n        f = urllib2.urlopen(req)\n        data = f.read()\n\n        date = ''\n        if month < 10 and day < 10:\n            date = '%i-0%i-0%i' % (year, month, day)\n        elif month > 10 and day < 10:\n            date = '%i-%i-0%i' % (year, month, day)\n        elif month < 10 and day > 10:    \n            date = '%i-0%i-%i' % (year, month, day)\n        else:\n            date = '%i-%i-%i' % (year, month, day)   \n\n        string = 'the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml'\n        print date\n        if date in data:\n            f = open('update.txt','w')\n            f.write(date + string)\n            f.close()\n            print 'yes'\n        else:\n            print 'no'    \n\n    except Exception,ex:\n        print ex\n\n\n#import itchat\n#\n#itchat.auto_login()\n#\n#itchat.send('Hello, filehelper', toUserName='filehelper')\n\n#while True:\n#     f = open('update.txt','r')\n#     text = f.read()\n#     f.close()\n#     if len(text) != 0:\n#        f = open('update.txt','w')\n#        f.write('')\n#        f.close()\n#        itchat.send('the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml', toUserName='Liu647ziqi')\n```\n","source":"_posts/2017/定时检查网页更新并发送微信消息.md","raw":"---\ntitle: 定时检查网页更新并发送微信消息\ndate: 2017-02-16 16:11:20\ntags:\n- python\n---\n\n```\n# -*- coding: utf-8 -*-\nimport urllib2,time,urllib\n\n    while True:\n    current = time.localtime(time.time())\n\n    year = current.tm_year\n    month = current.tm_mon\n    day = current.tm_mday\n\n    hour = current.tm_hour\n    minite = current.tm_min\n    sec = current.tm_sec\n    if sec == 0:\n\n    downLoadStr = 'http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml'\n    print downLoadStr\n    try:\n        i_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n        \"Referer\": 'http://www.baidu.com'}\n        req = urllib2.Request(downLoadStr, headers=i_headers)\n        f = urllib2.urlopen(req)\n        data = f.read()\n\n        date = ''\n        if month < 10 and day < 10:\n            date = '%i-0%i-0%i' % (year, month, day)\n        elif month > 10 and day < 10:\n            date = '%i-%i-0%i' % (year, month, day)\n        elif month < 10 and day > 10:    \n            date = '%i-0%i-%i' % (year, month, day)\n        else:\n            date = '%i-%i-%i' % (year, month, day)   \n\n        string = 'the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml'\n        print date\n        if date in data:\n            f = open('update.txt','w')\n            f.write(date + string)\n            f.close()\n            print 'yes'\n        else:\n            print 'no'    \n\n    except Exception,ex:\n        print ex\n\n\n#import itchat\n#\n#itchat.auto_login()\n#\n#itchat.send('Hello, filehelper', toUserName='filehelper')\n\n#while True:\n#     f = open('update.txt','r')\n#     text = f.read()\n#     f.close()\n#     if len(text) != 0:\n#        f = open('update.txt','w')\n#        f.write('')\n#        f.close()\n#        itchat.send('the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml', toUserName='Liu647ziqi')\n```\n","slug":"2017/定时检查网页更新并发送微信消息","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pni004bsauawx939p87","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import urllib2,time,urllib</div><div class=\"line\"></div><div class=\"line\">    while True:</div><div class=\"line\">    current = time.localtime(time.time())</div><div class=\"line\"></div><div class=\"line\">    year = current.tm_year</div><div class=\"line\">    month = current.tm_mon</div><div class=\"line\">    day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">    hour = current.tm_hour</div><div class=\"line\">    minite = current.tm_min</div><div class=\"line\">    sec = current.tm_sec</div><div class=\"line\">    if sec == 0:</div><div class=\"line\"></div><div class=\"line\">    downLoadStr = &apos;http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;</div><div class=\"line\">    print downLoadStr</div><div class=\"line\">    try:</div><div class=\"line\">        i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">        &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">        req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">        f = urllib2.urlopen(req)</div><div class=\"line\">        data = f.read()</div><div class=\"line\"></div><div class=\"line\">        date = &apos;&apos;</div><div class=\"line\">        if month &lt; 10 and day &lt; 10:</div><div class=\"line\">            date = &apos;%i-0%i-0%i&apos; % (year, month, day)</div><div class=\"line\">        elif month &gt; 10 and day &lt; 10:</div><div class=\"line\">            date = &apos;%i-%i-0%i&apos; % (year, month, day)</div><div class=\"line\">        elif month &lt; 10 and day &gt; 10:    </div><div class=\"line\">            date = &apos;%i-0%i-%i&apos; % (year, month, day)</div><div class=\"line\">        else:</div><div class=\"line\">            date = &apos;%i-%i-%i&apos; % (year, month, day)   </div><div class=\"line\"></div><div class=\"line\">        string = &apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;</div><div class=\"line\">        print date</div><div class=\"line\">        if date in data:</div><div class=\"line\">            f = open(&apos;update.txt&apos;,&apos;w&apos;)</div><div class=\"line\">            f.write(date + string)</div><div class=\"line\">            f.close()</div><div class=\"line\">            print &apos;yes&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            print &apos;no&apos;    </div><div class=\"line\"></div><div class=\"line\">    except Exception,ex:</div><div class=\"line\">        print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import itchat</div><div class=\"line\">#</div><div class=\"line\">#itchat.auto_login()</div><div class=\"line\">#</div><div class=\"line\">#itchat.send(&apos;Hello, filehelper&apos;, toUserName=&apos;filehelper&apos;)</div><div class=\"line\"></div><div class=\"line\">#while True:</div><div class=\"line\">#     f = open(&apos;update.txt&apos;,&apos;r&apos;)</div><div class=\"line\">#     text = f.read()</div><div class=\"line\">#     f.close()</div><div class=\"line\">#     if len(text) != 0:</div><div class=\"line\">#        f = open(&apos;update.txt&apos;,&apos;w&apos;)</div><div class=\"line\">#        f.write(&apos;&apos;)</div><div class=\"line\">#        f.close()</div><div class=\"line\">#        itchat.send(&apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;, toUserName=&apos;Liu647ziqi&apos;)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import urllib2,time,urllib</div><div class=\"line\"></div><div class=\"line\">    while True:</div><div class=\"line\">    current = time.localtime(time.time())</div><div class=\"line\"></div><div class=\"line\">    year = current.tm_year</div><div class=\"line\">    month = current.tm_mon</div><div class=\"line\">    day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">    hour = current.tm_hour</div><div class=\"line\">    minite = current.tm_min</div><div class=\"line\">    sec = current.tm_sec</div><div class=\"line\">    if sec == 0:</div><div class=\"line\"></div><div class=\"line\">    downLoadStr = &apos;http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;</div><div class=\"line\">    print downLoadStr</div><div class=\"line\">    try:</div><div class=\"line\">        i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">        &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">        req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">        f = urllib2.urlopen(req)</div><div class=\"line\">        data = f.read()</div><div class=\"line\"></div><div class=\"line\">        date = &apos;&apos;</div><div class=\"line\">        if month &lt; 10 and day &lt; 10:</div><div class=\"line\">            date = &apos;%i-0%i-0%i&apos; % (year, month, day)</div><div class=\"line\">        elif month &gt; 10 and day &lt; 10:</div><div class=\"line\">            date = &apos;%i-%i-0%i&apos; % (year, month, day)</div><div class=\"line\">        elif month &lt; 10 and day &gt; 10:    </div><div class=\"line\">            date = &apos;%i-0%i-%i&apos; % (year, month, day)</div><div class=\"line\">        else:</div><div class=\"line\">            date = &apos;%i-%i-%i&apos; % (year, month, day)   </div><div class=\"line\"></div><div class=\"line\">        string = &apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;</div><div class=\"line\">        print date</div><div class=\"line\">        if date in data:</div><div class=\"line\">            f = open(&apos;update.txt&apos;,&apos;w&apos;)</div><div class=\"line\">            f.write(date + string)</div><div class=\"line\">            f.close()</div><div class=\"line\">            print &apos;yes&apos;</div><div class=\"line\">        else:</div><div class=\"line\">            print &apos;no&apos;    </div><div class=\"line\"></div><div class=\"line\">    except Exception,ex:</div><div class=\"line\">        print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#import itchat</div><div class=\"line\">#</div><div class=\"line\">#itchat.auto_login()</div><div class=\"line\">#</div><div class=\"line\">#itchat.send(&apos;Hello, filehelper&apos;, toUserName=&apos;filehelper&apos;)</div><div class=\"line\"></div><div class=\"line\">#while True:</div><div class=\"line\">#     f = open(&apos;update.txt&apos;,&apos;r&apos;)</div><div class=\"line\">#     text = f.read()</div><div class=\"line\">#     f.close()</div><div class=\"line\">#     if len(text) != 0:</div><div class=\"line\">#        f = open(&apos;update.txt&apos;,&apos;w&apos;)</div><div class=\"line\">#        f.write(&apos;&apos;)</div><div class=\"line\">#        f.close()</div><div class=\"line\">#        itchat.send(&apos;the web has update http://www.bjjs.gov.cn/bjjs/fwgl/zzxspzf/index.shtml&apos;, toUserName=&apos;Liu647ziqi&apos;)</div></pre></td></tr></table></figure>\n"},{"title":"基于Django的自动化平台构建笔记(1)","date":"2016-12-15T03:30:54.000Z","_content":"现在提供的服务主要有：\n- 根据property创建UI代码\n- JSON自动转模型\n- 自动打包服务\n- 其他效率工具的链接\n<!--more-->\n\n其中最重要的，也是最复杂的应该是自动打包的服务，这套服务用python语言来实现，基于python的django框架，其中django框架主要用来提供web服务，用来给用户访问，而服务的执行者，比如说UI的代码创建，需要用到字符串解析等功能，完全由python在服务器端来完成，我们通过网络将需要解析的数据发送给服务器，然后服务器做完处理之后，再通过网络将数据返回，然后通过django来完成展示。再到打包服务也是这种逻辑，通过web服务来发送指令给服务器，然后服务器调用命令行来完成打包的具体的动作\n\n### Django使用简解\nDjango是一个python的项目，我们可以使用WebStorm来编辑该项目。当运行的时候会生成一个本地的web服务，我们可以通过该地址，在浏览器访问这个服务，当然我们也可以在命令行来达到同样的效果，进入到项目根目录，manager.py的所在目录，执行`python manager.py runserver`，然后点击给出的地址，我们仍然可以查看服务。\n\n对于这个新建的django工程我们主要关注的是两个文件，一个是ProjectName/urls.py，另一个是appName/views.py。\n#### urls.py\n这个文件时整个工程的路由，将url与具体的服务或者要展示的页面相对应。\n```\nfrom django.conf.urls import url\nfrom django.contrib import admin\nfrom learn import views as learn_views  # new\nfrom django.contrib.staticfiles.urls import staticfiles_urlpatterns\n\n\nurlpatterns = [\nurl(r'next', learn_views.nextPage),  # new\nurl(r'^$', learn_views.home,name='home'),  # new\nurl(r'^admin/', admin.site.urls),\nurl(r'callPython', learn_views.compute),  # new\nurl(r'ajaxpack', learn_views.ajaxpack),\nurl(r'ajaxgetbranches', learn_views.ajaxgetbranchesfunc),\nurl(r'add', learn_views.compute),  # new\nurl(r'uicreate', learn_views.uicreate),\nurl(r'ajaxcreateui', learn_views.createui),\nurl(r'package', learn_views.package),\nurl(r'buildlist', learn_views.buildlist),\nurl(r'ajaxsendMail', learn_views.sendMails),\nurl(r'jsonFormatClick1', learn_views.jsonFormat1),\nurl(r'jsonFormatClick2', learn_views.jsonFormat2),\nurl(r'interfaceTestClick', learn_views.interfaceTest),\nurl(r'url1', learn_views.getUrl1),\nurl(r'url2', learn_views.getUrl2),  # new\nurl(r'url3', learn_views.getUrl3),\nurl(r'url4', learn_views.getUrl4),\nurl(r'url5', learn_views.getUrl5),  # new\nurl(r'url6', learn_views.getUrl6),\nurl(r'url7', learn_views.getUrl7)\n]\n\n# ... the rest of your URLconf goes here ...\nurlpatterns += staticfiles_urlpatterns()\n```\n看上边这段代码，新加入的有`from learn import views as learn_views  # new`这个是引入了learn这个app中的views这个文件，然后在这个文件中我们就可以使用这个文件了，我们可以在列表中添加很多的url与服务的对应，url的写法的讲究在于，`next`意味着包含next就跳这个，`^next`意味着以next开头，`next$`意味着以next结尾，`^next$`意味着直邮next才跳这个，完全对应的意思，这个文件的作用主要就这些\n\n#### views.py\n具体的服务我们是由这个文件来提供的\n```\nfrom django.http import HttpResponse\nfrom django.shortcuts import render\nfrom DIY.compute import getModelFromJson\nfrom DIY.createui import getCreatedStringWithProperties\nfrom DIY.packServer import packaged,getbranches\nfrom django.http import HttpResponseRedirect\nfrom DIY.mail import sendMail\n\ndef home(request):\nstring = '这是'\nreturn render(request,'home.html',{'string':string})\n\n\ndef nextPage(request):\nreturn render(request,'next.html')\n\ndef compute(request):\nstring = request.POST['text']\nstring = getModelFromJson(string)\nreturn HttpResponse(string)\n\ndef uicreate(request):\nreturn render(request,'UICreate.html')\n\ndef createui(request):\nstring = request.GET['text']\nstring = getCreatedStringWithProperties(string)\nreturn HttpResponse(string)\n\ndef package(request):\nreturn render(request,'package.html')\n\ndef ajaxpack(request):\n\nf = open('/Users/wxg/Documents/Build/building.txt','r')\ntext = f.read()\nif text == '':\nstring = request.GET['text']\nresurtString = packaged(string)\nreturn HttpResponse('done')\nelse:\nreturn HttpResponse('wait')   \n\ndef ajaxgetbranchesfunc(request):\nreturn HttpResponse(getbranches('string'))\n\ndef buildlist(requets):\nreturn HttpResponseRedirect('http://10.13.80.19:8000/Documents/Build')\n\ndef sendMails(request):\nsendMail('')\nreturn HttpResponse('hi')  \n\ndef jsonFormat1(request):\nreturn HttpResponseRedirect('http://www.jsonparseronline.com')\n\ndef jsonFormat2(request):\nreturn HttpResponseRedirect('http://www.sojson.com')    \n\ndef interfaceTest(request):\nreturn HttpResponseRedirect('http://www.atool.org/httptest.php')\n\ndef getUrl1(request):\nf = open('/Users/han/Desktop/text1.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl2(request):\nf = open('/Users/han/Desktop/text2.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl3(request):\nf = open('/Users/han/Desktop/text3.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl4(request):\nf = open('/Users/han/Desktop/text4.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl5(request):\nf = open('/Users/han/Desktop/text5.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl6(request):\nf = open('/Users/han/Desktop/text6.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl7(request):\nf = open('/Users/han/Desktop/text7.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n```\n我们拿具体的例子来说，上边的这些代码，就是我们能够提供的具体的服务，具体说来我们主要提供三种服务\n##### 返回json\n```\ndef compute(request):\nstring = request.POST['text']\nstring = getModelFromJson(string)\nreturn HttpResponse(string)\n```\n比如这个，需要引入\nfrom django.http import HttpResponse\n\n##### 返回一个html文件\n```\ndef home(request):\nstring = '这是'\nreturn render(request,'home.html',{'string':string})\n```\n中间的参数`home.html`就是一个html的文件，那么问题来了，这个文件是从哪里来的，与views.py同级有个templates文件夹，里边是我们要存放的html文件，这个需要html和css的一些知识来编写\n\n##### 返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\n\n```\ndef jsonFormat1(request):\nreturn HttpResponseRedirect('http://www.jsonparseronline.com')\n```\n\n```\ndef buildlist(requets):\nreturn HttpResponseRedirect('http://10.13.80.19:8000/Documents/Build')\n```\n\n还有个问题需要说明就是，我们这里需要很多python的服务，如何引入呢，直接引入函数的名称就可以了，就像是`from DIY.packServer import packaged,getbranches`\n\nDjango安装和配置具体可以参考[Django部署+apache+mod_wsgi](http://hanson647.com/2016/11/09/2016/Django部署-apache-mod-wsgi/)\n\n### 自动打包服务的构建过程\n这里说两点，第一个是我们实现的一些比较不常见的功能，一个是踩到的坑。\n先来说一下功能点：\n- 线上和预发的切换\n- 清除本分支做的操作\n- .app转换为.ipa\n- xcode XCBuildConfiguration配置文件自动设置\n\n#### .app转换为.ipa\n当我们执行了`xcodebuild build`的命令之后，形成的是一个.app文件，这个时候我们需要做的压缩这个文件，这个是ipa文件生成的原理\n具体步骤：\n- Step1: 新建“Payload”文件夹，注意名字要一字不差；\n- Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；\n- Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可\n具体代码:\n```\nimport os,shutil\n\nos.mkdir('Payload')\n\nshutil.copytree('JDMobile.app','Payload/JDMobile.app')\n\nos.system('zip -r Payload.zip Payload')\n\nfiles=os.listdir(\".\")\n\nfor filename in files:\n    li=os.path.splitext(filename)\n    if li[1]==\".zip\":\n        newname=li[0]+\".ipa\"\n        os.rename(filename,newname)\n\nshutil.rmtree('JDMobile.app')\nshutil.rmtree('Payload')\n```\n\n\n#### xcode XCBuildConfiguration配置文件自动设置\n这里使用mod-pbxproj，这个是一个python解析库，用法如下\n```\nfrom mod_pbxproj import XcodeProject\nimport commands\n\ndef configProject():\n\n    project = XcodeProject.Load('/Users/wxg/Documents/JDMobileNew/JDMobile_2.0/JDMobile.xcodeproj/project.pbxproj')\n\n    for item in project.objects.values():\n        nameIsa = item.get('isa')\n\n        if (nameIsa == 'XCBuildConfiguration'):\n            setting = item.get('buildSettings')\n            nameReference = item.get('baseConfigurationReference')\n            if (nameReference):\n               idStr = setting.get('PRODUCT_BUNDLE_IDENTIFIER')\n               print '---->' + idStr\n               setting.__setitem__('PRODUCT_BUNDLE_IDENTIFIER','com.jd.jinrong2016')\n               setting.__setitem__('PROVISIONING_PROFILE','')\n               setting.__setitem__('PROVISIONING_PROFILE_SPECIFIER','')\n               setting.__setitem__('DEVELOPMENT_TEAM','5TKVHWTT79')\n               setting.__setitem__('CODE_SIGN_IDENTITY[sdk=iphoneos*]','iPhone Developer')\n               item.__setitem__('buildSettings',setting)\n            else:\n               codeSign = setting.get('CODE_SIGN_IDENTITY')\n               profile = setting.get('PROVISIONING_PROFILE')\n               print codeSign\n               print profile\n               setting.__setitem__('CODE_SIGN_IDENTITY','iPhone Distribution: Beijing Jingdong Century Trading Co., Ltd. (TQZTTUQ9ZE)')\n               setting.__setitem__('PROVISIONING_PROFILE','0d8cd55a-c922-4f27-b1aa-df6a2f277ea5')\n               item.__setitem__('buildSettings',setting)\n\n        elif (nameIsa == 'PBXProject'):\n            attributes = item.get('attributes')\n            targetAttributes = attributes.get('TargetAttributes')\n            targets = item.get('targets')\n            tar = targets[0]\n            attr = targetAttributes.get('%s' % tar)\n            developmentTeamName = attr.get('DevelopmentTeamName')\n            developmentTeamName = attr.get('ProvisioningStyle')\n            print developmentTeamName\n            attr.__setitem__('DevelopmentTeamName','Beijing Jingdong Century Information Technology Co., Ltd.')\n            attr.__setitem__('ProvisioningStyle', 'Automatic')\n            attr.__setitem__('DevelopmentTeam', '5TKVHWTT79')\n\n    project.save()\n\n```\n\n\n这里的坑主要是由权限引起的，因为我们从web服务去调用一个命令行的指令的时候，这个时候的并不是登录状态的权限，而是一个非登录状态的权限，这个时候有两个问题，一个是很多服务是没有被加载的，第二个是一些文件没有权限去调用，下面分别来说\n\n- gradle无法调用\n- 苹果的开发者证书不能读取\n- git pull命令需要用户名和密码\n\n#### gradle无法调用\n这里涉及到一个问题是mac的环境变量，通过在终端输入`$PATH`来查看当前用户下加载的路径有哪些，如果返回的路径中包含我们的服务的路径，那么肯定这个服务当前用户是可以调用的，我们在web服务中调用这个命令发现返回的只有`usr/bin`等着几个路径，那么思路就来了，如果gradle想要被使用，那么就需要加到这路径下，解决的办法就是加一个软连接到/usr/bin文件下，sudo ln -s xxxxx xxxxx就可以了，那么如果找到这个服务的安装路径呢？以gradle为例`which gradle`，如果是git的话就是`which git`\n这里还有个问题是mac升级系统后，这个文件是不允许更改的，解决办法:\n\n>对于Mac OS X 10.11 El Capitan用户，由于系统启用了SIP(System Integrity Protection), 导致root用户也没有权限修改/usr/bin目录。按如下方式可恢复权限。\n屏蔽方法：重启Mac，按住command+R,进入recovery模式。选择打开Utilities下的终端，输入：csrutil disable并回车，然后正常重启Mac即可\n\n#### 苹果的开发者证书不能读取\nUser interaction is not allowed这个问题是因为证书不能被读取，这是因为证书在登录下，我们将证书移动到系统下就可以了\n#### git pull命令需要用户名和密码\n这个不能被执行也是因为权限的问题，最后的解决方案，是在登录状态下(命令行)直接开一个新的线程，死循环不断的检测一个文件下是否有对应的文件夹，如果有这个文件夹就执行`git pull`命令，执行完毕之后写入日志，然后删除文件内容，继续进入到下一个循环，这个与iOS的runloop是一个道理\n\n### django中使用ajax的post方法\n```\n $(\"#insert\").click(function(){\n            text =  $('#textarea1').val()\n            $.post(\"/writecontent/\", {'content': text,'foldername':foldername,'filename':filename},function(ret){\n                alert(ret)\n            })\n        });\n```\n之所以使用post这里是因为无法突破apache对于get方法的整体参数长度限制，而使用post方法有个问题就是会强制CSRF校验，解决方法就是关闭django的验证，具体来说是到setting文件中注释一行代码\n>django.middleware.csrf.CsrfViewMiddleware\n\n### 安装pymongo\n首先要安装pip，然后用pip安装pymongo\n```\nsudo easy_install pip\n```\n然后使用pip安装pymongo\n```\nsudo pip install pymongo\n```\n这个时候进入python环境使用命令行去访问pymongo应该是没有问题的，但是你使用web调用的方式去调用不一定能够访问到mongo，这可能是因为你使用的python安装路径的问题\n```\nwhich python\n```\n看一下当前加载的python，不出意外应该是/usr/local/bin/python，这个是登录状态下才能加载的一个环境和路径，而web是非登录的，所以很多功能访问不到正常，我们要做的就是让系统直接加载/usr/bin/python，这就涉及到一个加载优先级的问题\n```\nsudo emacs /etc/paths\n```\n\n>/usr/local/bin\n/usr/bin\n/bin\n/usr/sbin\n/sbin\n\n>tips:\n現在要把 /usr/local/bin 移到上面去\n\ncontrol + k：把一行字剪下來\n\ncontrol + y：把字貼上\n\ncontrol + x + s：存檔\n\ncontrol + x + c：關掉 emacs\n\n然后再执行下边这句\n```\necho $PATH\n```\n这个时候你再打开\n发现已经变成了下边这样\n>/usr/bin\n/usr/local/bin\n/bin\n/usr/sbin\n/sbin\n\n这个时候你再执行\n```\nwhich python\n```\n发现已经变成了`/usr/bin/python`\n现在看来，系统加载某个功能的逻辑，就是直接在这些个加载列表中找这些个功能，如果逐个加载了一遍发现没有这个功能，那么就会报错，如果第一路径下有这个功能，第二路径下也有这个功能，那么就会用第一路径下的，所以我们更改第一路径是有意义的\n","source":"_posts/2017/基于Django的自动化平台构建笔记(1).md","raw":"---\ntitle: 基于Django的自动化平台构建笔记(1)\ndate: 2016-12-15 11:30:54\ntags:\n\n---\n现在提供的服务主要有：\n- 根据property创建UI代码\n- JSON自动转模型\n- 自动打包服务\n- 其他效率工具的链接\n<!--more-->\n\n其中最重要的，也是最复杂的应该是自动打包的服务，这套服务用python语言来实现，基于python的django框架，其中django框架主要用来提供web服务，用来给用户访问，而服务的执行者，比如说UI的代码创建，需要用到字符串解析等功能，完全由python在服务器端来完成，我们通过网络将需要解析的数据发送给服务器，然后服务器做完处理之后，再通过网络将数据返回，然后通过django来完成展示。再到打包服务也是这种逻辑，通过web服务来发送指令给服务器，然后服务器调用命令行来完成打包的具体的动作\n\n### Django使用简解\nDjango是一个python的项目，我们可以使用WebStorm来编辑该项目。当运行的时候会生成一个本地的web服务，我们可以通过该地址，在浏览器访问这个服务，当然我们也可以在命令行来达到同样的效果，进入到项目根目录，manager.py的所在目录，执行`python manager.py runserver`，然后点击给出的地址，我们仍然可以查看服务。\n\n对于这个新建的django工程我们主要关注的是两个文件，一个是ProjectName/urls.py，另一个是appName/views.py。\n#### urls.py\n这个文件时整个工程的路由，将url与具体的服务或者要展示的页面相对应。\n```\nfrom django.conf.urls import url\nfrom django.contrib import admin\nfrom learn import views as learn_views  # new\nfrom django.contrib.staticfiles.urls import staticfiles_urlpatterns\n\n\nurlpatterns = [\nurl(r'next', learn_views.nextPage),  # new\nurl(r'^$', learn_views.home,name='home'),  # new\nurl(r'^admin/', admin.site.urls),\nurl(r'callPython', learn_views.compute),  # new\nurl(r'ajaxpack', learn_views.ajaxpack),\nurl(r'ajaxgetbranches', learn_views.ajaxgetbranchesfunc),\nurl(r'add', learn_views.compute),  # new\nurl(r'uicreate', learn_views.uicreate),\nurl(r'ajaxcreateui', learn_views.createui),\nurl(r'package', learn_views.package),\nurl(r'buildlist', learn_views.buildlist),\nurl(r'ajaxsendMail', learn_views.sendMails),\nurl(r'jsonFormatClick1', learn_views.jsonFormat1),\nurl(r'jsonFormatClick2', learn_views.jsonFormat2),\nurl(r'interfaceTestClick', learn_views.interfaceTest),\nurl(r'url1', learn_views.getUrl1),\nurl(r'url2', learn_views.getUrl2),  # new\nurl(r'url3', learn_views.getUrl3),\nurl(r'url4', learn_views.getUrl4),\nurl(r'url5', learn_views.getUrl5),  # new\nurl(r'url6', learn_views.getUrl6),\nurl(r'url7', learn_views.getUrl7)\n]\n\n# ... the rest of your URLconf goes here ...\nurlpatterns += staticfiles_urlpatterns()\n```\n看上边这段代码，新加入的有`from learn import views as learn_views  # new`这个是引入了learn这个app中的views这个文件，然后在这个文件中我们就可以使用这个文件了，我们可以在列表中添加很多的url与服务的对应，url的写法的讲究在于，`next`意味着包含next就跳这个，`^next`意味着以next开头，`next$`意味着以next结尾，`^next$`意味着直邮next才跳这个，完全对应的意思，这个文件的作用主要就这些\n\n#### views.py\n具体的服务我们是由这个文件来提供的\n```\nfrom django.http import HttpResponse\nfrom django.shortcuts import render\nfrom DIY.compute import getModelFromJson\nfrom DIY.createui import getCreatedStringWithProperties\nfrom DIY.packServer import packaged,getbranches\nfrom django.http import HttpResponseRedirect\nfrom DIY.mail import sendMail\n\ndef home(request):\nstring = '这是'\nreturn render(request,'home.html',{'string':string})\n\n\ndef nextPage(request):\nreturn render(request,'next.html')\n\ndef compute(request):\nstring = request.POST['text']\nstring = getModelFromJson(string)\nreturn HttpResponse(string)\n\ndef uicreate(request):\nreturn render(request,'UICreate.html')\n\ndef createui(request):\nstring = request.GET['text']\nstring = getCreatedStringWithProperties(string)\nreturn HttpResponse(string)\n\ndef package(request):\nreturn render(request,'package.html')\n\ndef ajaxpack(request):\n\nf = open('/Users/wxg/Documents/Build/building.txt','r')\ntext = f.read()\nif text == '':\nstring = request.GET['text']\nresurtString = packaged(string)\nreturn HttpResponse('done')\nelse:\nreturn HttpResponse('wait')   \n\ndef ajaxgetbranchesfunc(request):\nreturn HttpResponse(getbranches('string'))\n\ndef buildlist(requets):\nreturn HttpResponseRedirect('http://10.13.80.19:8000/Documents/Build')\n\ndef sendMails(request):\nsendMail('')\nreturn HttpResponse('hi')  \n\ndef jsonFormat1(request):\nreturn HttpResponseRedirect('http://www.jsonparseronline.com')\n\ndef jsonFormat2(request):\nreturn HttpResponseRedirect('http://www.sojson.com')    \n\ndef interfaceTest(request):\nreturn HttpResponseRedirect('http://www.atool.org/httptest.php')\n\ndef getUrl1(request):\nf = open('/Users/han/Desktop/text1.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl2(request):\nf = open('/Users/han/Desktop/text2.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl3(request):\nf = open('/Users/han/Desktop/text3.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl4(request):\nf = open('/Users/han/Desktop/text4.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl5(request):\nf = open('/Users/han/Desktop/text5.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl6(request):\nf = open('/Users/han/Desktop/text6.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n\ndef getUrl7(request):\nf = open('/Users/han/Desktop/text7.txt', 'r')\ntext = f.read()\nf.close()\nreturn HttpResponse(text)\n```\n我们拿具体的例子来说，上边的这些代码，就是我们能够提供的具体的服务，具体说来我们主要提供三种服务\n##### 返回json\n```\ndef compute(request):\nstring = request.POST['text']\nstring = getModelFromJson(string)\nreturn HttpResponse(string)\n```\n比如这个，需要引入\nfrom django.http import HttpResponse\n\n##### 返回一个html文件\n```\ndef home(request):\nstring = '这是'\nreturn render(request,'home.html',{'string':string})\n```\n中间的参数`home.html`就是一个html的文件，那么问题来了，这个文件是从哪里来的，与views.py同级有个templates文件夹，里边是我们要存放的html文件，这个需要html和css的一些知识来编写\n\n##### 返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\n\n```\ndef jsonFormat1(request):\nreturn HttpResponseRedirect('http://www.jsonparseronline.com')\n```\n\n```\ndef buildlist(requets):\nreturn HttpResponseRedirect('http://10.13.80.19:8000/Documents/Build')\n```\n\n还有个问题需要说明就是，我们这里需要很多python的服务，如何引入呢，直接引入函数的名称就可以了，就像是`from DIY.packServer import packaged,getbranches`\n\nDjango安装和配置具体可以参考[Django部署+apache+mod_wsgi](http://hanson647.com/2016/11/09/2016/Django部署-apache-mod-wsgi/)\n\n### 自动打包服务的构建过程\n这里说两点，第一个是我们实现的一些比较不常见的功能，一个是踩到的坑。\n先来说一下功能点：\n- 线上和预发的切换\n- 清除本分支做的操作\n- .app转换为.ipa\n- xcode XCBuildConfiguration配置文件自动设置\n\n#### .app转换为.ipa\n当我们执行了`xcodebuild build`的命令之后，形成的是一个.app文件，这个时候我们需要做的压缩这个文件，这个是ipa文件生成的原理\n具体步骤：\n- Step1: 新建“Payload”文件夹，注意名字要一字不差；\n- Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；\n- Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可\n具体代码:\n```\nimport os,shutil\n\nos.mkdir('Payload')\n\nshutil.copytree('JDMobile.app','Payload/JDMobile.app')\n\nos.system('zip -r Payload.zip Payload')\n\nfiles=os.listdir(\".\")\n\nfor filename in files:\n    li=os.path.splitext(filename)\n    if li[1]==\".zip\":\n        newname=li[0]+\".ipa\"\n        os.rename(filename,newname)\n\nshutil.rmtree('JDMobile.app')\nshutil.rmtree('Payload')\n```\n\n\n#### xcode XCBuildConfiguration配置文件自动设置\n这里使用mod-pbxproj，这个是一个python解析库，用法如下\n```\nfrom mod_pbxproj import XcodeProject\nimport commands\n\ndef configProject():\n\n    project = XcodeProject.Load('/Users/wxg/Documents/JDMobileNew/JDMobile_2.0/JDMobile.xcodeproj/project.pbxproj')\n\n    for item in project.objects.values():\n        nameIsa = item.get('isa')\n\n        if (nameIsa == 'XCBuildConfiguration'):\n            setting = item.get('buildSettings')\n            nameReference = item.get('baseConfigurationReference')\n            if (nameReference):\n               idStr = setting.get('PRODUCT_BUNDLE_IDENTIFIER')\n               print '---->' + idStr\n               setting.__setitem__('PRODUCT_BUNDLE_IDENTIFIER','com.jd.jinrong2016')\n               setting.__setitem__('PROVISIONING_PROFILE','')\n               setting.__setitem__('PROVISIONING_PROFILE_SPECIFIER','')\n               setting.__setitem__('DEVELOPMENT_TEAM','5TKVHWTT79')\n               setting.__setitem__('CODE_SIGN_IDENTITY[sdk=iphoneos*]','iPhone Developer')\n               item.__setitem__('buildSettings',setting)\n            else:\n               codeSign = setting.get('CODE_SIGN_IDENTITY')\n               profile = setting.get('PROVISIONING_PROFILE')\n               print codeSign\n               print profile\n               setting.__setitem__('CODE_SIGN_IDENTITY','iPhone Distribution: Beijing Jingdong Century Trading Co., Ltd. (TQZTTUQ9ZE)')\n               setting.__setitem__('PROVISIONING_PROFILE','0d8cd55a-c922-4f27-b1aa-df6a2f277ea5')\n               item.__setitem__('buildSettings',setting)\n\n        elif (nameIsa == 'PBXProject'):\n            attributes = item.get('attributes')\n            targetAttributes = attributes.get('TargetAttributes')\n            targets = item.get('targets')\n            tar = targets[0]\n            attr = targetAttributes.get('%s' % tar)\n            developmentTeamName = attr.get('DevelopmentTeamName')\n            developmentTeamName = attr.get('ProvisioningStyle')\n            print developmentTeamName\n            attr.__setitem__('DevelopmentTeamName','Beijing Jingdong Century Information Technology Co., Ltd.')\n            attr.__setitem__('ProvisioningStyle', 'Automatic')\n            attr.__setitem__('DevelopmentTeam', '5TKVHWTT79')\n\n    project.save()\n\n```\n\n\n这里的坑主要是由权限引起的，因为我们从web服务去调用一个命令行的指令的时候，这个时候的并不是登录状态的权限，而是一个非登录状态的权限，这个时候有两个问题，一个是很多服务是没有被加载的，第二个是一些文件没有权限去调用，下面分别来说\n\n- gradle无法调用\n- 苹果的开发者证书不能读取\n- git pull命令需要用户名和密码\n\n#### gradle无法调用\n这里涉及到一个问题是mac的环境变量，通过在终端输入`$PATH`来查看当前用户下加载的路径有哪些，如果返回的路径中包含我们的服务的路径，那么肯定这个服务当前用户是可以调用的，我们在web服务中调用这个命令发现返回的只有`usr/bin`等着几个路径，那么思路就来了，如果gradle想要被使用，那么就需要加到这路径下，解决的办法就是加一个软连接到/usr/bin文件下，sudo ln -s xxxxx xxxxx就可以了，那么如果找到这个服务的安装路径呢？以gradle为例`which gradle`，如果是git的话就是`which git`\n这里还有个问题是mac升级系统后，这个文件是不允许更改的，解决办法:\n\n>对于Mac OS X 10.11 El Capitan用户，由于系统启用了SIP(System Integrity Protection), 导致root用户也没有权限修改/usr/bin目录。按如下方式可恢复权限。\n屏蔽方法：重启Mac，按住command+R,进入recovery模式。选择打开Utilities下的终端，输入：csrutil disable并回车，然后正常重启Mac即可\n\n#### 苹果的开发者证书不能读取\nUser interaction is not allowed这个问题是因为证书不能被读取，这是因为证书在登录下，我们将证书移动到系统下就可以了\n#### git pull命令需要用户名和密码\n这个不能被执行也是因为权限的问题，最后的解决方案，是在登录状态下(命令行)直接开一个新的线程，死循环不断的检测一个文件下是否有对应的文件夹，如果有这个文件夹就执行`git pull`命令，执行完毕之后写入日志，然后删除文件内容，继续进入到下一个循环，这个与iOS的runloop是一个道理\n\n### django中使用ajax的post方法\n```\n $(\"#insert\").click(function(){\n            text =  $('#textarea1').val()\n            $.post(\"/writecontent/\", {'content': text,'foldername':foldername,'filename':filename},function(ret){\n                alert(ret)\n            })\n        });\n```\n之所以使用post这里是因为无法突破apache对于get方法的整体参数长度限制，而使用post方法有个问题就是会强制CSRF校验，解决方法就是关闭django的验证，具体来说是到setting文件中注释一行代码\n>django.middleware.csrf.CsrfViewMiddleware\n\n### 安装pymongo\n首先要安装pip，然后用pip安装pymongo\n```\nsudo easy_install pip\n```\n然后使用pip安装pymongo\n```\nsudo pip install pymongo\n```\n这个时候进入python环境使用命令行去访问pymongo应该是没有问题的，但是你使用web调用的方式去调用不一定能够访问到mongo，这可能是因为你使用的python安装路径的问题\n```\nwhich python\n```\n看一下当前加载的python，不出意外应该是/usr/local/bin/python，这个是登录状态下才能加载的一个环境和路径，而web是非登录的，所以很多功能访问不到正常，我们要做的就是让系统直接加载/usr/bin/python，这就涉及到一个加载优先级的问题\n```\nsudo emacs /etc/paths\n```\n\n>/usr/local/bin\n/usr/bin\n/bin\n/usr/sbin\n/sbin\n\n>tips:\n現在要把 /usr/local/bin 移到上面去\n\ncontrol + k：把一行字剪下來\n\ncontrol + y：把字貼上\n\ncontrol + x + s：存檔\n\ncontrol + x + c：關掉 emacs\n\n然后再执行下边这句\n```\necho $PATH\n```\n这个时候你再打开\n发现已经变成了下边这样\n>/usr/bin\n/usr/local/bin\n/bin\n/usr/sbin\n/sbin\n\n这个时候你再执行\n```\nwhich python\n```\n发现已经变成了`/usr/bin/python`\n现在看来，系统加载某个功能的逻辑，就是直接在这些个加载列表中找这些个功能，如果逐个加载了一遍发现没有这个功能，那么就会报错，如果第一路径下有这个功能，第二路径下也有这个功能，那么就会用第一路径下的，所以我们更改第一路径是有意义的\n","slug":"2017/基于Django的自动化平台构建笔记(1)","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnj004csauapgeel4s5","content":"<p>现在提供的服务主要有：</p>\n<ul>\n<li>根据property创建UI代码</li>\n<li>JSON自动转模型</li>\n<li>自动打包服务</li>\n<li>其他效率工具的链接<a id=\"more\"></a>\n</li>\n</ul>\n<p>其中最重要的，也是最复杂的应该是自动打包的服务，这套服务用python语言来实现，基于python的django框架，其中django框架主要用来提供web服务，用来给用户访问，而服务的执行者，比如说UI的代码创建，需要用到字符串解析等功能，完全由python在服务器端来完成，我们通过网络将需要解析的数据发送给服务器，然后服务器做完处理之后，再通过网络将数据返回，然后通过django来完成展示。再到打包服务也是这种逻辑，通过web服务来发送指令给服务器，然后服务器调用命令行来完成打包的具体的动作</p>\n<h3 id=\"Django使用简解\"><a href=\"#Django使用简解\" class=\"headerlink\" title=\"Django使用简解\"></a>Django使用简解</h3><p>Django是一个python的项目，我们可以使用WebStorm来编辑该项目。当运行的时候会生成一个本地的web服务，我们可以通过该地址，在浏览器访问这个服务，当然我们也可以在命令行来达到同样的效果，进入到项目根目录，manager.py的所在目录，执行<code>python manager.py runserver</code>，然后点击给出的地址，我们仍然可以查看服务。</p>\n<p>对于这个新建的django工程我们主要关注的是两个文件，一个是ProjectName/urls.py，另一个是appName/views.py。</p>\n<h4 id=\"urls-py\"><a href=\"#urls-py\" class=\"headerlink\" title=\"urls.py\"></a>urls.py</h4><p>这个文件时整个工程的路由，将url与具体的服务或者要展示的页面相对应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.conf.urls import url</div><div class=\"line\">from django.contrib import admin</div><div class=\"line\">from learn import views as learn_views  # new</div><div class=\"line\">from django.contrib.staticfiles.urls import staticfiles_urlpatterns</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">urlpatterns = [</div><div class=\"line\">url(r&apos;next&apos;, learn_views.nextPage),  # new</div><div class=\"line\">url(r&apos;^$&apos;, learn_views.home,name=&apos;home&apos;),  # new</div><div class=\"line\">url(r&apos;^admin/&apos;, admin.site.urls),</div><div class=\"line\">url(r&apos;callPython&apos;, learn_views.compute),  # new</div><div class=\"line\">url(r&apos;ajaxpack&apos;, learn_views.ajaxpack),</div><div class=\"line\">url(r&apos;ajaxgetbranches&apos;, learn_views.ajaxgetbranchesfunc),</div><div class=\"line\">url(r&apos;add&apos;, learn_views.compute),  # new</div><div class=\"line\">url(r&apos;uicreate&apos;, learn_views.uicreate),</div><div class=\"line\">url(r&apos;ajaxcreateui&apos;, learn_views.createui),</div><div class=\"line\">url(r&apos;package&apos;, learn_views.package),</div><div class=\"line\">url(r&apos;buildlist&apos;, learn_views.buildlist),</div><div class=\"line\">url(r&apos;ajaxsendMail&apos;, learn_views.sendMails),</div><div class=\"line\">url(r&apos;jsonFormatClick1&apos;, learn_views.jsonFormat1),</div><div class=\"line\">url(r&apos;jsonFormatClick2&apos;, learn_views.jsonFormat2),</div><div class=\"line\">url(r&apos;interfaceTestClick&apos;, learn_views.interfaceTest),</div><div class=\"line\">url(r&apos;url1&apos;, learn_views.getUrl1),</div><div class=\"line\">url(r&apos;url2&apos;, learn_views.getUrl2),  # new</div><div class=\"line\">url(r&apos;url3&apos;, learn_views.getUrl3),</div><div class=\"line\">url(r&apos;url4&apos;, learn_views.getUrl4),</div><div class=\"line\">url(r&apos;url5&apos;, learn_views.getUrl5),  # new</div><div class=\"line\">url(r&apos;url6&apos;, learn_views.getUrl6),</div><div class=\"line\">url(r&apos;url7&apos;, learn_views.getUrl7)</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># ... the rest of your URLconf goes here ...</div><div class=\"line\">urlpatterns += staticfiles_urlpatterns()</div></pre></td></tr></table></figure></p>\n<p>看上边这段代码，新加入的有<code>from learn import views as learn_views  # new</code>这个是引入了learn这个app中的views这个文件，然后在这个文件中我们就可以使用这个文件了，我们可以在列表中添加很多的url与服务的对应，url的写法的讲究在于，<code>next</code>意味着包含next就跳这个，<code>^next</code>意味着以next开头，<code>next$</code>意味着以next结尾，<code>^next$</code>意味着直邮next才跳这个，完全对应的意思，这个文件的作用主要就这些</p>\n<h4 id=\"views-py\"><a href=\"#views-py\" class=\"headerlink\" title=\"views.py\"></a>views.py</h4><p>具体的服务我们是由这个文件来提供的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.http import HttpResponse</div><div class=\"line\">from django.shortcuts import render</div><div class=\"line\">from DIY.compute import getModelFromJson</div><div class=\"line\">from DIY.createui import getCreatedStringWithProperties</div><div class=\"line\">from DIY.packServer import packaged,getbranches</div><div class=\"line\">from django.http import HttpResponseRedirect</div><div class=\"line\">from DIY.mail import sendMail</div><div class=\"line\"></div><div class=\"line\">def home(request):</div><div class=\"line\">string = &apos;这是&apos;</div><div class=\"line\">return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def nextPage(request):</div><div class=\"line\">return render(request,&apos;next.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def compute(request):</div><div class=\"line\">string = request.POST[&apos;text&apos;]</div><div class=\"line\">string = getModelFromJson(string)</div><div class=\"line\">return HttpResponse(string)</div><div class=\"line\"></div><div class=\"line\">def uicreate(request):</div><div class=\"line\">return render(request,&apos;UICreate.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def createui(request):</div><div class=\"line\">string = request.GET[&apos;text&apos;]</div><div class=\"line\">string = getCreatedStringWithProperties(string)</div><div class=\"line\">return HttpResponse(string)</div><div class=\"line\"></div><div class=\"line\">def package(request):</div><div class=\"line\">return render(request,&apos;package.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def ajaxpack(request):</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;/Users/wxg/Documents/Build/building.txt&apos;,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">if text == &apos;&apos;:</div><div class=\"line\">string = request.GET[&apos;text&apos;]</div><div class=\"line\">resurtString = packaged(string)</div><div class=\"line\">return HttpResponse(&apos;done&apos;)</div><div class=\"line\">else:</div><div class=\"line\">return HttpResponse(&apos;wait&apos;)   </div><div class=\"line\"></div><div class=\"line\">def ajaxgetbranchesfunc(request):</div><div class=\"line\">return HttpResponse(getbranches(&apos;string&apos;))</div><div class=\"line\"></div><div class=\"line\">def buildlist(requets):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;)</div><div class=\"line\"></div><div class=\"line\">def sendMails(request):</div><div class=\"line\">sendMail(&apos;&apos;)</div><div class=\"line\">return HttpResponse(&apos;hi&apos;)  </div><div class=\"line\"></div><div class=\"line\">def jsonFormat1(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;)</div><div class=\"line\"></div><div class=\"line\">def jsonFormat2(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.sojson.com&apos;)    </div><div class=\"line\"></div><div class=\"line\">def interfaceTest(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.atool.org/httptest.php&apos;)</div><div class=\"line\"></div><div class=\"line\">def getUrl1(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text1.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl2(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text2.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl3(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text3.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl4(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text4.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl5(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text5.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl6(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text6.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl7(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text7.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div></pre></td></tr></table></figure></p>\n<p>我们拿具体的例子来说，上边的这些代码，就是我们能够提供的具体的服务，具体说来我们主要提供三种服务</p>\n<h5 id=\"返回json\"><a href=\"#返回json\" class=\"headerlink\" title=\"返回json\"></a>返回json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def compute(request):</div><div class=\"line\">string = request.POST[&apos;text&apos;]</div><div class=\"line\">string = getModelFromJson(string)</div><div class=\"line\">return HttpResponse(string)</div></pre></td></tr></table></figure>\n<p>比如这个，需要引入<br>from django.http import HttpResponse</p>\n<h5 id=\"返回一个html文件\"><a href=\"#返回一个html文件\" class=\"headerlink\" title=\"返回一个html文件\"></a>返回一个html文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def home(request):</div><div class=\"line\">string = &apos;这是&apos;</div><div class=\"line\">return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;)</div></pre></td></tr></table></figure>\n<p>中间的参数<code>home.html</code>就是一个html的文件，那么问题来了，这个文件是从哪里来的，与views.py同级有个templates文件夹，里边是我们要存放的html文件，这个需要html和css的一些知识来编写</p>\n<h5 id=\"返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\"><a href=\"#返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\" class=\"headerlink\" title=\"返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\"></a>返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def jsonFormat1(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def buildlist(requets):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;)</div></pre></td></tr></table></figure>\n<p>还有个问题需要说明就是，我们这里需要很多python的服务，如何引入呢，直接引入函数的名称就可以了，就像是<code>from DIY.packServer import packaged,getbranches</code></p>\n<p>Django安装和配置具体可以参考<a href=\"http://hanson647.com/2016/11/09/2016/Django部署-apache-mod-wsgi/\" target=\"_blank\" rel=\"external\">Django部署+apache+mod_wsgi</a></p>\n<h3 id=\"自动打包服务的构建过程\"><a href=\"#自动打包服务的构建过程\" class=\"headerlink\" title=\"自动打包服务的构建过程\"></a>自动打包服务的构建过程</h3><p>这里说两点，第一个是我们实现的一些比较不常见的功能，一个是踩到的坑。<br>先来说一下功能点：</p>\n<ul>\n<li>线上和预发的切换</li>\n<li>清除本分支做的操作</li>\n<li>.app转换为.ipa</li>\n<li>xcode XCBuildConfiguration配置文件自动设置</li>\n</ul>\n<h4 id=\"app转换为-ipa\"><a href=\"#app转换为-ipa\" class=\"headerlink\" title=\".app转换为.ipa\"></a>.app转换为.ipa</h4><p>当我们执行了<code>xcodebuild build</code>的命令之后，形成的是一个.app文件，这个时候我们需要做的压缩这个文件，这个是ipa文件生成的原理<br>具体步骤：</p>\n<ul>\n<li>Step1: 新建“Payload”文件夹，注意名字要一字不差；</li>\n<li>Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；</li>\n<li>Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可<br>具体代码:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os,shutil</div><div class=\"line\"></div><div class=\"line\">os.mkdir(&apos;Payload&apos;)</div><div class=\"line\"></div><div class=\"line\">shutil.copytree(&apos;JDMobile.app&apos;,&apos;Payload/JDMobile.app&apos;)</div><div class=\"line\"></div><div class=\"line\">os.system(&apos;zip -r Payload.zip Payload&apos;)</div><div class=\"line\"></div><div class=\"line\">files=os.listdir(&quot;.&quot;)</div><div class=\"line\"></div><div class=\"line\">for filename in files:</div><div class=\"line\">    li=os.path.splitext(filename)</div><div class=\"line\">    if li[1]==&quot;.zip&quot;:</div><div class=\"line\">        newname=li[0]+&quot;.ipa&quot;</div><div class=\"line\">        os.rename(filename,newname)</div><div class=\"line\"></div><div class=\"line\">shutil.rmtree(&apos;JDMobile.app&apos;)</div><div class=\"line\">shutil.rmtree(&apos;Payload&apos;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"xcode-XCBuildConfiguration配置文件自动设置\"><a href=\"#xcode-XCBuildConfiguration配置文件自动设置\" class=\"headerlink\" title=\"xcode XCBuildConfiguration配置文件自动设置\"></a>xcode XCBuildConfiguration配置文件自动设置</h4><p>这里使用mod-pbxproj，这个是一个python解析库，用法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">from mod_pbxproj import XcodeProject</div><div class=\"line\">import commands</div><div class=\"line\"></div><div class=\"line\">def configProject():</div><div class=\"line\"></div><div class=\"line\">    project = XcodeProject.Load(&apos;/Users/wxg/Documents/JDMobileNew/JDMobile_2.0/JDMobile.xcodeproj/project.pbxproj&apos;)</div><div class=\"line\"></div><div class=\"line\">    for item in project.objects.values():</div><div class=\"line\">        nameIsa = item.get(&apos;isa&apos;)</div><div class=\"line\"></div><div class=\"line\">        if (nameIsa == &apos;XCBuildConfiguration&apos;):</div><div class=\"line\">            setting = item.get(&apos;buildSettings&apos;)</div><div class=\"line\">            nameReference = item.get(&apos;baseConfigurationReference&apos;)</div><div class=\"line\">            if (nameReference):</div><div class=\"line\">               idStr = setting.get(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;)</div><div class=\"line\">               print &apos;----&gt;&apos; + idStr</div><div class=\"line\">               setting.__setitem__(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;,&apos;com.jd.jinrong2016&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE_SPECIFIER&apos;,&apos;&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;DEVELOPMENT_TEAM&apos;,&apos;5TKVHWTT79&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;CODE_SIGN_IDENTITY[sdk=iphoneos*]&apos;,&apos;iPhone Developer&apos;)</div><div class=\"line\">               item.__setitem__(&apos;buildSettings&apos;,setting)</div><div class=\"line\">            else:</div><div class=\"line\">               codeSign = setting.get(&apos;CODE_SIGN_IDENTITY&apos;)</div><div class=\"line\">               profile = setting.get(&apos;PROVISIONING_PROFILE&apos;)</div><div class=\"line\">               print codeSign</div><div class=\"line\">               print profile</div><div class=\"line\">               setting.__setitem__(&apos;CODE_SIGN_IDENTITY&apos;,&apos;iPhone Distribution: Beijing Jingdong Century Trading Co., Ltd. (TQZTTUQ9ZE)&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;0d8cd55a-c922-4f27-b1aa-df6a2f277ea5&apos;)</div><div class=\"line\">               item.__setitem__(&apos;buildSettings&apos;,setting)</div><div class=\"line\"></div><div class=\"line\">        elif (nameIsa == &apos;PBXProject&apos;):</div><div class=\"line\">            attributes = item.get(&apos;attributes&apos;)</div><div class=\"line\">            targetAttributes = attributes.get(&apos;TargetAttributes&apos;)</div><div class=\"line\">            targets = item.get(&apos;targets&apos;)</div><div class=\"line\">            tar = targets[0]</div><div class=\"line\">            attr = targetAttributes.get(&apos;%s&apos; % tar)</div><div class=\"line\">            developmentTeamName = attr.get(&apos;DevelopmentTeamName&apos;)</div><div class=\"line\">            developmentTeamName = attr.get(&apos;ProvisioningStyle&apos;)</div><div class=\"line\">            print developmentTeamName</div><div class=\"line\">            attr.__setitem__(&apos;DevelopmentTeamName&apos;,&apos;Beijing Jingdong Century Information Technology Co., Ltd.&apos;)</div><div class=\"line\">            attr.__setitem__(&apos;ProvisioningStyle&apos;, &apos;Automatic&apos;)</div><div class=\"line\">            attr.__setitem__(&apos;DevelopmentTeam&apos;, &apos;5TKVHWTT79&apos;)</div><div class=\"line\"></div><div class=\"line\">    project.save()</div></pre></td></tr></table></figure></p>\n<p>这里的坑主要是由权限引起的，因为我们从web服务去调用一个命令行的指令的时候，这个时候的并不是登录状态的权限，而是一个非登录状态的权限，这个时候有两个问题，一个是很多服务是没有被加载的，第二个是一些文件没有权限去调用，下面分别来说</p>\n<ul>\n<li>gradle无法调用</li>\n<li>苹果的开发者证书不能读取</li>\n<li>git pull命令需要用户名和密码</li>\n</ul>\n<h4 id=\"gradle无法调用\"><a href=\"#gradle无法调用\" class=\"headerlink\" title=\"gradle无法调用\"></a>gradle无法调用</h4><p>这里涉及到一个问题是mac的环境变量，通过在终端输入<code>$PATH</code>来查看当前用户下加载的路径有哪些，如果返回的路径中包含我们的服务的路径，那么肯定这个服务当前用户是可以调用的，我们在web服务中调用这个命令发现返回的只有<code>usr/bin</code>等着几个路径，那么思路就来了，如果gradle想要被使用，那么就需要加到这路径下，解决的办法就是加一个软连接到/usr/bin文件下，sudo ln -s xxxxx xxxxx就可以了，那么如果找到这个服务的安装路径呢？以gradle为例<code>which gradle</code>，如果是git的话就是<code>which git</code><br>这里还有个问题是mac升级系统后，这个文件是不允许更改的，解决办法:</p>\n<blockquote>\n<p>对于Mac OS X 10.11 El Capitan用户，由于系统启用了SIP(System Integrity Protection), 导致root用户也没有权限修改/usr/bin目录。按如下方式可恢复权限。<br>屏蔽方法：重启Mac，按住command+R,进入recovery模式。选择打开Utilities下的终端，输入：csrutil disable并回车，然后正常重启Mac即可</p>\n</blockquote>\n<h4 id=\"苹果的开发者证书不能读取\"><a href=\"#苹果的开发者证书不能读取\" class=\"headerlink\" title=\"苹果的开发者证书不能读取\"></a>苹果的开发者证书不能读取</h4><p>User interaction is not allowed这个问题是因为证书不能被读取，这是因为证书在登录下，我们将证书移动到系统下就可以了</p>\n<h4 id=\"git-pull命令需要用户名和密码\"><a href=\"#git-pull命令需要用户名和密码\" class=\"headerlink\" title=\"git pull命令需要用户名和密码\"></a>git pull命令需要用户名和密码</h4><p>这个不能被执行也是因为权限的问题，最后的解决方案，是在登录状态下(命令行)直接开一个新的线程，死循环不断的检测一个文件下是否有对应的文件夹，如果有这个文件夹就执行<code>git pull</code>命令，执行完毕之后写入日志，然后删除文件内容，继续进入到下一个循环，这个与iOS的runloop是一个道理</p>\n<h3 id=\"django中使用ajax的post方法\"><a href=\"#django中使用ajax的post方法\" class=\"headerlink\" title=\"django中使用ajax的post方法\"></a>django中使用ajax的post方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&quot;#insert&quot;).click(function()&#123;</div><div class=\"line\">           text =  $(&apos;#textarea1&apos;).val()</div><div class=\"line\">           $.post(&quot;/writecontent/&quot;, &#123;&apos;content&apos;: text,&apos;foldername&apos;:foldername,&apos;filename&apos;:filename&#125;,function(ret)&#123;</div><div class=\"line\">               alert(ret)</div><div class=\"line\">           &#125;)</div><div class=\"line\">       &#125;);</div></pre></td></tr></table></figure>\n<p>之所以使用post这里是因为无法突破apache对于get方法的整体参数长度限制，而使用post方法有个问题就是会强制CSRF校验，解决方法就是关闭django的验证，具体来说是到setting文件中注释一行代码</p>\n<blockquote>\n<p>django.middleware.csrf.CsrfViewMiddleware</p>\n</blockquote>\n<h3 id=\"安装pymongo\"><a href=\"#安装pymongo\" class=\"headerlink\" title=\"安装pymongo\"></a>安装pymongo</h3><p>首先要安装pip，然后用pip安装pymongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo easy_install pip</div></pre></td></tr></table></figure></p>\n<p>然后使用pip安装pymongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install pymongo</div></pre></td></tr></table></figure></p>\n<p>这个时候进入python环境使用命令行去访问pymongo应该是没有问题的，但是你使用web调用的方式去调用不一定能够访问到mongo，这可能是因为你使用的python安装路径的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">which python</div></pre></td></tr></table></figure></p>\n<p>看一下当前加载的python，不出意外应该是/usr/local/bin/python，这个是登录状态下才能加载的一个环境和路径，而web是非登录的，所以很多功能访问不到正常，我们要做的就是让系统直接加载/usr/bin/python，这就涉及到一个加载优先级的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo emacs /etc/paths</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>/usr/local/bin<br>/usr/bin<br>/bin<br>/usr/sbin<br>/sbin</p>\n<p>tips:<br>現在要把 /usr/local/bin 移到上面去</p>\n</blockquote>\n<p>control + k：把一行字剪下來</p>\n<p>control + y：把字貼上</p>\n<p>control + x + s：存檔</p>\n<p>control + x + c：關掉 emacs</p>\n<p>然后再执行下边这句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo $PATH</div></pre></td></tr></table></figure></p>\n<p>这个时候你再打开<br>发现已经变成了下边这样</p>\n<blockquote>\n<p>/usr/bin<br>/usr/local/bin<br>/bin<br>/usr/sbin<br>/sbin</p>\n</blockquote>\n<p>这个时候你再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">which python</div></pre></td></tr></table></figure></p>\n<p>发现已经变成了<code>/usr/bin/python</code><br>现在看来，系统加载某个功能的逻辑，就是直接在这些个加载列表中找这些个功能，如果逐个加载了一遍发现没有这个功能，那么就会报错，如果第一路径下有这个功能，第二路径下也有这个功能，那么就会用第一路径下的，所以我们更改第一路径是有意义的</p>\n","site":{"data":{}},"excerpt":"<p>现在提供的服务主要有：</p>\n<ul>\n<li>根据property创建UI代码</li>\n<li>JSON自动转模型</li>\n<li>自动打包服务</li>\n<li>其他效率工具的链接","more":"</li>\n</ul>\n<p>其中最重要的，也是最复杂的应该是自动打包的服务，这套服务用python语言来实现，基于python的django框架，其中django框架主要用来提供web服务，用来给用户访问，而服务的执行者，比如说UI的代码创建，需要用到字符串解析等功能，完全由python在服务器端来完成，我们通过网络将需要解析的数据发送给服务器，然后服务器做完处理之后，再通过网络将数据返回，然后通过django来完成展示。再到打包服务也是这种逻辑，通过web服务来发送指令给服务器，然后服务器调用命令行来完成打包的具体的动作</p>\n<h3 id=\"Django使用简解\"><a href=\"#Django使用简解\" class=\"headerlink\" title=\"Django使用简解\"></a>Django使用简解</h3><p>Django是一个python的项目，我们可以使用WebStorm来编辑该项目。当运行的时候会生成一个本地的web服务，我们可以通过该地址，在浏览器访问这个服务，当然我们也可以在命令行来达到同样的效果，进入到项目根目录，manager.py的所在目录，执行<code>python manager.py runserver</code>，然后点击给出的地址，我们仍然可以查看服务。</p>\n<p>对于这个新建的django工程我们主要关注的是两个文件，一个是ProjectName/urls.py，另一个是appName/views.py。</p>\n<h4 id=\"urls-py\"><a href=\"#urls-py\" class=\"headerlink\" title=\"urls.py\"></a>urls.py</h4><p>这个文件时整个工程的路由，将url与具体的服务或者要展示的页面相对应。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.conf.urls import url</div><div class=\"line\">from django.contrib import admin</div><div class=\"line\">from learn import views as learn_views  # new</div><div class=\"line\">from django.contrib.staticfiles.urls import staticfiles_urlpatterns</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">urlpatterns = [</div><div class=\"line\">url(r&apos;next&apos;, learn_views.nextPage),  # new</div><div class=\"line\">url(r&apos;^$&apos;, learn_views.home,name=&apos;home&apos;),  # new</div><div class=\"line\">url(r&apos;^admin/&apos;, admin.site.urls),</div><div class=\"line\">url(r&apos;callPython&apos;, learn_views.compute),  # new</div><div class=\"line\">url(r&apos;ajaxpack&apos;, learn_views.ajaxpack),</div><div class=\"line\">url(r&apos;ajaxgetbranches&apos;, learn_views.ajaxgetbranchesfunc),</div><div class=\"line\">url(r&apos;add&apos;, learn_views.compute),  # new</div><div class=\"line\">url(r&apos;uicreate&apos;, learn_views.uicreate),</div><div class=\"line\">url(r&apos;ajaxcreateui&apos;, learn_views.createui),</div><div class=\"line\">url(r&apos;package&apos;, learn_views.package),</div><div class=\"line\">url(r&apos;buildlist&apos;, learn_views.buildlist),</div><div class=\"line\">url(r&apos;ajaxsendMail&apos;, learn_views.sendMails),</div><div class=\"line\">url(r&apos;jsonFormatClick1&apos;, learn_views.jsonFormat1),</div><div class=\"line\">url(r&apos;jsonFormatClick2&apos;, learn_views.jsonFormat2),</div><div class=\"line\">url(r&apos;interfaceTestClick&apos;, learn_views.interfaceTest),</div><div class=\"line\">url(r&apos;url1&apos;, learn_views.getUrl1),</div><div class=\"line\">url(r&apos;url2&apos;, learn_views.getUrl2),  # new</div><div class=\"line\">url(r&apos;url3&apos;, learn_views.getUrl3),</div><div class=\"line\">url(r&apos;url4&apos;, learn_views.getUrl4),</div><div class=\"line\">url(r&apos;url5&apos;, learn_views.getUrl5),  # new</div><div class=\"line\">url(r&apos;url6&apos;, learn_views.getUrl6),</div><div class=\"line\">url(r&apos;url7&apos;, learn_views.getUrl7)</div><div class=\"line\">]</div><div class=\"line\"></div><div class=\"line\"># ... the rest of your URLconf goes here ...</div><div class=\"line\">urlpatterns += staticfiles_urlpatterns()</div></pre></td></tr></table></figure></p>\n<p>看上边这段代码，新加入的有<code>from learn import views as learn_views  # new</code>这个是引入了learn这个app中的views这个文件，然后在这个文件中我们就可以使用这个文件了，我们可以在列表中添加很多的url与服务的对应，url的写法的讲究在于，<code>next</code>意味着包含next就跳这个，<code>^next</code>意味着以next开头，<code>next$</code>意味着以next结尾，<code>^next$</code>意味着直邮next才跳这个，完全对应的意思，这个文件的作用主要就这些</p>\n<h4 id=\"views-py\"><a href=\"#views-py\" class=\"headerlink\" title=\"views.py\"></a>views.py</h4><p>具体的服务我们是由这个文件来提供的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.http import HttpResponse</div><div class=\"line\">from django.shortcuts import render</div><div class=\"line\">from DIY.compute import getModelFromJson</div><div class=\"line\">from DIY.createui import getCreatedStringWithProperties</div><div class=\"line\">from DIY.packServer import packaged,getbranches</div><div class=\"line\">from django.http import HttpResponseRedirect</div><div class=\"line\">from DIY.mail import sendMail</div><div class=\"line\"></div><div class=\"line\">def home(request):</div><div class=\"line\">string = &apos;这是&apos;</div><div class=\"line\">return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def nextPage(request):</div><div class=\"line\">return render(request,&apos;next.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def compute(request):</div><div class=\"line\">string = request.POST[&apos;text&apos;]</div><div class=\"line\">string = getModelFromJson(string)</div><div class=\"line\">return HttpResponse(string)</div><div class=\"line\"></div><div class=\"line\">def uicreate(request):</div><div class=\"line\">return render(request,&apos;UICreate.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def createui(request):</div><div class=\"line\">string = request.GET[&apos;text&apos;]</div><div class=\"line\">string = getCreatedStringWithProperties(string)</div><div class=\"line\">return HttpResponse(string)</div><div class=\"line\"></div><div class=\"line\">def package(request):</div><div class=\"line\">return render(request,&apos;package.html&apos;)</div><div class=\"line\"></div><div class=\"line\">def ajaxpack(request):</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;/Users/wxg/Documents/Build/building.txt&apos;,&apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">if text == &apos;&apos;:</div><div class=\"line\">string = request.GET[&apos;text&apos;]</div><div class=\"line\">resurtString = packaged(string)</div><div class=\"line\">return HttpResponse(&apos;done&apos;)</div><div class=\"line\">else:</div><div class=\"line\">return HttpResponse(&apos;wait&apos;)   </div><div class=\"line\"></div><div class=\"line\">def ajaxgetbranchesfunc(request):</div><div class=\"line\">return HttpResponse(getbranches(&apos;string&apos;))</div><div class=\"line\"></div><div class=\"line\">def buildlist(requets):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;)</div><div class=\"line\"></div><div class=\"line\">def sendMails(request):</div><div class=\"line\">sendMail(&apos;&apos;)</div><div class=\"line\">return HttpResponse(&apos;hi&apos;)  </div><div class=\"line\"></div><div class=\"line\">def jsonFormat1(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;)</div><div class=\"line\"></div><div class=\"line\">def jsonFormat2(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.sojson.com&apos;)    </div><div class=\"line\"></div><div class=\"line\">def interfaceTest(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.atool.org/httptest.php&apos;)</div><div class=\"line\"></div><div class=\"line\">def getUrl1(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text1.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl2(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text2.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl3(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text3.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl4(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text4.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl5(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text5.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl6(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text6.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div><div class=\"line\"></div><div class=\"line\">def getUrl7(request):</div><div class=\"line\">f = open(&apos;/Users/han/Desktop/text7.txt&apos;, &apos;r&apos;)</div><div class=\"line\">text = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\">return HttpResponse(text)</div></pre></td></tr></table></figure></p>\n<p>我们拿具体的例子来说，上边的这些代码，就是我们能够提供的具体的服务，具体说来我们主要提供三种服务</p>\n<h5 id=\"返回json\"><a href=\"#返回json\" class=\"headerlink\" title=\"返回json\"></a>返回json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">def compute(request):</div><div class=\"line\">string = request.POST[&apos;text&apos;]</div><div class=\"line\">string = getModelFromJson(string)</div><div class=\"line\">return HttpResponse(string)</div></pre></td></tr></table></figure>\n<p>比如这个，需要引入<br>from django.http import HttpResponse</p>\n<h5 id=\"返回一个html文件\"><a href=\"#返回一个html文件\" class=\"headerlink\" title=\"返回一个html文件\"></a>返回一个html文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">def home(request):</div><div class=\"line\">string = &apos;这是&apos;</div><div class=\"line\">return render(request,&apos;home.html&apos;,&#123;&apos;string&apos;:string&#125;)</div></pre></td></tr></table></figure>\n<p>中间的参数<code>home.html</code>就是一个html的文件，那么问题来了，这个文件是从哪里来的，与views.py同级有个templates文件夹，里边是我们要存放的html文件，这个需要html和css的一些知识来编写</p>\n<h5 id=\"返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\"><a href=\"#返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\" class=\"headerlink\" title=\"返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的\"></a>返回跳一个其他的url，比如跳baidu或者条服务器的某个文件夹都是可以的</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def jsonFormat1(request):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://www.jsonparseronline.com&apos;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">def buildlist(requets):</div><div class=\"line\">return HttpResponseRedirect(&apos;http://10.13.80.19:8000/Documents/Build&apos;)</div></pre></td></tr></table></figure>\n<p>还有个问题需要说明就是，我们这里需要很多python的服务，如何引入呢，直接引入函数的名称就可以了，就像是<code>from DIY.packServer import packaged,getbranches</code></p>\n<p>Django安装和配置具体可以参考<a href=\"http://hanson647.com/2016/11/09/2016/Django部署-apache-mod-wsgi/\" target=\"_blank\" rel=\"external\">Django部署+apache+mod_wsgi</a></p>\n<h3 id=\"自动打包服务的构建过程\"><a href=\"#自动打包服务的构建过程\" class=\"headerlink\" title=\"自动打包服务的构建过程\"></a>自动打包服务的构建过程</h3><p>这里说两点，第一个是我们实现的一些比较不常见的功能，一个是踩到的坑。<br>先来说一下功能点：</p>\n<ul>\n<li>线上和预发的切换</li>\n<li>清除本分支做的操作</li>\n<li>.app转换为.ipa</li>\n<li>xcode XCBuildConfiguration配置文件自动设置</li>\n</ul>\n<h4 id=\"app转换为-ipa\"><a href=\"#app转换为-ipa\" class=\"headerlink\" title=\".app转换为.ipa\"></a>.app转换为.ipa</h4><p>当我们执行了<code>xcodebuild build</code>的命令之后，形成的是一个.app文件，这个时候我们需要做的压缩这个文件，这个是ipa文件生成的原理<br>具体步骤：</p>\n<ul>\n<li>Step1: 新建“Payload”文件夹，注意名字要一字不差；</li>\n<li>Step2: 将你的.app包放到Payload中，注意app的名字不做任何更改，就用xcode生成的app名称；</li>\n<li>Step3: 在Payload文件夹上右键压缩成zip，然后将生成的.zip文件后缀改成.ipa即可<br>具体代码:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os,shutil</div><div class=\"line\"></div><div class=\"line\">os.mkdir(&apos;Payload&apos;)</div><div class=\"line\"></div><div class=\"line\">shutil.copytree(&apos;JDMobile.app&apos;,&apos;Payload/JDMobile.app&apos;)</div><div class=\"line\"></div><div class=\"line\">os.system(&apos;zip -r Payload.zip Payload&apos;)</div><div class=\"line\"></div><div class=\"line\">files=os.listdir(&quot;.&quot;)</div><div class=\"line\"></div><div class=\"line\">for filename in files:</div><div class=\"line\">    li=os.path.splitext(filename)</div><div class=\"line\">    if li[1]==&quot;.zip&quot;:</div><div class=\"line\">        newname=li[0]+&quot;.ipa&quot;</div><div class=\"line\">        os.rename(filename,newname)</div><div class=\"line\"></div><div class=\"line\">shutil.rmtree(&apos;JDMobile.app&apos;)</div><div class=\"line\">shutil.rmtree(&apos;Payload&apos;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"xcode-XCBuildConfiguration配置文件自动设置\"><a href=\"#xcode-XCBuildConfiguration配置文件自动设置\" class=\"headerlink\" title=\"xcode XCBuildConfiguration配置文件自动设置\"></a>xcode XCBuildConfiguration配置文件自动设置</h4><p>这里使用mod-pbxproj，这个是一个python解析库，用法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">from mod_pbxproj import XcodeProject</div><div class=\"line\">import commands</div><div class=\"line\"></div><div class=\"line\">def configProject():</div><div class=\"line\"></div><div class=\"line\">    project = XcodeProject.Load(&apos;/Users/wxg/Documents/JDMobileNew/JDMobile_2.0/JDMobile.xcodeproj/project.pbxproj&apos;)</div><div class=\"line\"></div><div class=\"line\">    for item in project.objects.values():</div><div class=\"line\">        nameIsa = item.get(&apos;isa&apos;)</div><div class=\"line\"></div><div class=\"line\">        if (nameIsa == &apos;XCBuildConfiguration&apos;):</div><div class=\"line\">            setting = item.get(&apos;buildSettings&apos;)</div><div class=\"line\">            nameReference = item.get(&apos;baseConfigurationReference&apos;)</div><div class=\"line\">            if (nameReference):</div><div class=\"line\">               idStr = setting.get(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;)</div><div class=\"line\">               print &apos;----&gt;&apos; + idStr</div><div class=\"line\">               setting.__setitem__(&apos;PRODUCT_BUNDLE_IDENTIFIER&apos;,&apos;com.jd.jinrong2016&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE_SPECIFIER&apos;,&apos;&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;DEVELOPMENT_TEAM&apos;,&apos;5TKVHWTT79&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;CODE_SIGN_IDENTITY[sdk=iphoneos*]&apos;,&apos;iPhone Developer&apos;)</div><div class=\"line\">               item.__setitem__(&apos;buildSettings&apos;,setting)</div><div class=\"line\">            else:</div><div class=\"line\">               codeSign = setting.get(&apos;CODE_SIGN_IDENTITY&apos;)</div><div class=\"line\">               profile = setting.get(&apos;PROVISIONING_PROFILE&apos;)</div><div class=\"line\">               print codeSign</div><div class=\"line\">               print profile</div><div class=\"line\">               setting.__setitem__(&apos;CODE_SIGN_IDENTITY&apos;,&apos;iPhone Distribution: Beijing Jingdong Century Trading Co., Ltd. (TQZTTUQ9ZE)&apos;)</div><div class=\"line\">               setting.__setitem__(&apos;PROVISIONING_PROFILE&apos;,&apos;0d8cd55a-c922-4f27-b1aa-df6a2f277ea5&apos;)</div><div class=\"line\">               item.__setitem__(&apos;buildSettings&apos;,setting)</div><div class=\"line\"></div><div class=\"line\">        elif (nameIsa == &apos;PBXProject&apos;):</div><div class=\"line\">            attributes = item.get(&apos;attributes&apos;)</div><div class=\"line\">            targetAttributes = attributes.get(&apos;TargetAttributes&apos;)</div><div class=\"line\">            targets = item.get(&apos;targets&apos;)</div><div class=\"line\">            tar = targets[0]</div><div class=\"line\">            attr = targetAttributes.get(&apos;%s&apos; % tar)</div><div class=\"line\">            developmentTeamName = attr.get(&apos;DevelopmentTeamName&apos;)</div><div class=\"line\">            developmentTeamName = attr.get(&apos;ProvisioningStyle&apos;)</div><div class=\"line\">            print developmentTeamName</div><div class=\"line\">            attr.__setitem__(&apos;DevelopmentTeamName&apos;,&apos;Beijing Jingdong Century Information Technology Co., Ltd.&apos;)</div><div class=\"line\">            attr.__setitem__(&apos;ProvisioningStyle&apos;, &apos;Automatic&apos;)</div><div class=\"line\">            attr.__setitem__(&apos;DevelopmentTeam&apos;, &apos;5TKVHWTT79&apos;)</div><div class=\"line\"></div><div class=\"line\">    project.save()</div></pre></td></tr></table></figure></p>\n<p>这里的坑主要是由权限引起的，因为我们从web服务去调用一个命令行的指令的时候，这个时候的并不是登录状态的权限，而是一个非登录状态的权限，这个时候有两个问题，一个是很多服务是没有被加载的，第二个是一些文件没有权限去调用，下面分别来说</p>\n<ul>\n<li>gradle无法调用</li>\n<li>苹果的开发者证书不能读取</li>\n<li>git pull命令需要用户名和密码</li>\n</ul>\n<h4 id=\"gradle无法调用\"><a href=\"#gradle无法调用\" class=\"headerlink\" title=\"gradle无法调用\"></a>gradle无法调用</h4><p>这里涉及到一个问题是mac的环境变量，通过在终端输入<code>$PATH</code>来查看当前用户下加载的路径有哪些，如果返回的路径中包含我们的服务的路径，那么肯定这个服务当前用户是可以调用的，我们在web服务中调用这个命令发现返回的只有<code>usr/bin</code>等着几个路径，那么思路就来了，如果gradle想要被使用，那么就需要加到这路径下，解决的办法就是加一个软连接到/usr/bin文件下，sudo ln -s xxxxx xxxxx就可以了，那么如果找到这个服务的安装路径呢？以gradle为例<code>which gradle</code>，如果是git的话就是<code>which git</code><br>这里还有个问题是mac升级系统后，这个文件是不允许更改的，解决办法:</p>\n<blockquote>\n<p>对于Mac OS X 10.11 El Capitan用户，由于系统启用了SIP(System Integrity Protection), 导致root用户也没有权限修改/usr/bin目录。按如下方式可恢复权限。<br>屏蔽方法：重启Mac，按住command+R,进入recovery模式。选择打开Utilities下的终端，输入：csrutil disable并回车，然后正常重启Mac即可</p>\n</blockquote>\n<h4 id=\"苹果的开发者证书不能读取\"><a href=\"#苹果的开发者证书不能读取\" class=\"headerlink\" title=\"苹果的开发者证书不能读取\"></a>苹果的开发者证书不能读取</h4><p>User interaction is not allowed这个问题是因为证书不能被读取，这是因为证书在登录下，我们将证书移动到系统下就可以了</p>\n<h4 id=\"git-pull命令需要用户名和密码\"><a href=\"#git-pull命令需要用户名和密码\" class=\"headerlink\" title=\"git pull命令需要用户名和密码\"></a>git pull命令需要用户名和密码</h4><p>这个不能被执行也是因为权限的问题，最后的解决方案，是在登录状态下(命令行)直接开一个新的线程，死循环不断的检测一个文件下是否有对应的文件夹，如果有这个文件夹就执行<code>git pull</code>命令，执行完毕之后写入日志，然后删除文件内容，继续进入到下一个循环，这个与iOS的runloop是一个道理</p>\n<h3 id=\"django中使用ajax的post方法\"><a href=\"#django中使用ajax的post方法\" class=\"headerlink\" title=\"django中使用ajax的post方法\"></a>django中使用ajax的post方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$(&quot;#insert&quot;).click(function()&#123;</div><div class=\"line\">           text =  $(&apos;#textarea1&apos;).val()</div><div class=\"line\">           $.post(&quot;/writecontent/&quot;, &#123;&apos;content&apos;: text,&apos;foldername&apos;:foldername,&apos;filename&apos;:filename&#125;,function(ret)&#123;</div><div class=\"line\">               alert(ret)</div><div class=\"line\">           &#125;)</div><div class=\"line\">       &#125;);</div></pre></td></tr></table></figure>\n<p>之所以使用post这里是因为无法突破apache对于get方法的整体参数长度限制，而使用post方法有个问题就是会强制CSRF校验，解决方法就是关闭django的验证，具体来说是到setting文件中注释一行代码</p>\n<blockquote>\n<p>django.middleware.csrf.CsrfViewMiddleware</p>\n</blockquote>\n<h3 id=\"安装pymongo\"><a href=\"#安装pymongo\" class=\"headerlink\" title=\"安装pymongo\"></a>安装pymongo</h3><p>首先要安装pip，然后用pip安装pymongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo easy_install pip</div></pre></td></tr></table></figure></p>\n<p>然后使用pip安装pymongo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo pip install pymongo</div></pre></td></tr></table></figure></p>\n<p>这个时候进入python环境使用命令行去访问pymongo应该是没有问题的，但是你使用web调用的方式去调用不一定能够访问到mongo，这可能是因为你使用的python安装路径的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">which python</div></pre></td></tr></table></figure></p>\n<p>看一下当前加载的python，不出意外应该是/usr/local/bin/python，这个是登录状态下才能加载的一个环境和路径，而web是非登录的，所以很多功能访问不到正常，我们要做的就是让系统直接加载/usr/bin/python，这就涉及到一个加载优先级的问题<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo emacs /etc/paths</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>/usr/local/bin<br>/usr/bin<br>/bin<br>/usr/sbin<br>/sbin</p>\n<p>tips:<br>現在要把 /usr/local/bin 移到上面去</p>\n</blockquote>\n<p>control + k：把一行字剪下來</p>\n<p>control + y：把字貼上</p>\n<p>control + x + s：存檔</p>\n<p>control + x + c：關掉 emacs</p>\n<p>然后再执行下边这句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo $PATH</div></pre></td></tr></table></figure></p>\n<p>这个时候你再打开<br>发现已经变成了下边这样</p>\n<blockquote>\n<p>/usr/bin<br>/usr/local/bin<br>/bin<br>/usr/sbin<br>/sbin</p>\n</blockquote>\n<p>这个时候你再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">which python</div></pre></td></tr></table></figure></p>\n<p>发现已经变成了<code>/usr/bin/python</code><br>现在看来，系统加载某个功能的逻辑，就是直接在这些个加载列表中找这些个功能，如果逐个加载了一遍发现没有这个功能，那么就会报错，如果第一路径下有这个功能，第二路径下也有这个功能，那么就会用第一路径下的，所以我们更改第一路径是有意义的</p>"},{"title":"移动开发流程","date":"2016-12-01T10:13:27.000Z","_content":"","source":"_posts/2017/移动开发流程.md","raw":"---\ntitle: 移动开发流程\ndate: 2016-12-01 18:13:27\ntags:\n---\n","slug":"2017/移动开发流程","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnk004fsaua7uh26znp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"指数自动获取","date":"2017-02-16T06:59:38.000Z","_content":"```\n# -*- coding: utf-8 -*-\nimport urllib2,time,urllib\nimport ast,os,sys,string\nfrom pymongo import MongoClient\n\nmonths = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']\ndicts = {'zsgz00':'no','zsgz10':'上证指数','zsgz20':'上证180','zsgz30':'上证50','zsgz40':'沪深300','zsgz50':'深证成指','zsgz60':'深证100R','zsgz70':'中小板指','zsgz80':'上证380','zsgz90':'红利指数','zsgz100':'中证红利','zsgz110':'中证500'}\n\nconnection = MongoClient(\"localhost\",27017)\nmydb = connection.mydb # new a database\nmyser = mydb.hengsengindex # new a table\n\ndef getindexs():\n\n    downLoadStr = 'http://www.csindex.com.cn/sseportal/ps/zhs/hqjt/csi/show_zsgz.js'\n    print downLoadStr\n    try:\n        i_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n        \"Referer\": 'http://www.baidu.com'}\n        req = urllib2.Request(downLoadStr, headers=i_headers)  \n        f = urllib2.urlopen(req)\n        data = f.read()\n        str = data.decode('gbk')\n        data = str.encode('utf-8')\n        print data\n        listString = data.split('\\n')\n\n        date = ''\n        index = 0\n        for item in listString:\n        if 'zsgz00' in item:\n            date = item[12:-2]\n            datelist = list(date)\n            for s in datelist:\n            if s == '-':\n            datelist.remove(s)\n            date = ''.join(datelist)\n            print date\n        if '0=' in item:\n            pe = listString[index + 1]\n            pb = listString[index + 3]\n            rate = listString[index + 4]\n            indexitem = item.index('=')\n            indexpe = pe.index('=')\n            indexpb = pb.index('=')\n            indexrate = rate.index('=')\n            pe = pe[indexpe+2:-2]\n            pb = pb[indexpe+2:-2]\n            rate = rate[indexpe+2:-2]\n            item = item[indexitem+2:-2]\n            print item\n\n            pe = filter(lambda ch: ch in '.0123456789', pe)\n            pb = filter(lambda ch: ch in '.0123456789', pb)\n            rate = filter(lambda ch: ch in '.0123456789', rate)\n\n            if len(pe) and len(pb) and len(rate):\n                roaf = float(pe)\n                roe = 1/roaf * 100\n                dbs = myser.find({'指数名称':item,'日期':date})\n                count = 0\n                for item in dbs:\n                count = count + 1\n                if count == 0:\n                    myser.save({'指数名称':item,'市盈率':pe,'盈利收益率':roe,'日期':date,'市净率':pb,'股息率':rate})\n\n            index = index + 1\n\n    except Exception,ex:\n    print ex\n\n\ndef gethenghseng(day,month,year):\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\nfileName = '/Users/han/Desktop/index/hengsheng/%i%s%s.txt' % (day,monthStr,yearStr)\n\ndownLoadStr = 'http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hsi/' + targetStr + '.csv'\nprint downLoadStr\ntry:\ni_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n\"Referer\": 'http://www.baidu.com'}\nreq = urllib2.Request(downLoadStr, headers=i_headers)\nf = urllib2.urlopen(req)\ndata = f.read()\nf = open(fileName,'wb')\nf.write(data)\nf.close()\n\nf1 = open(fileName,'rb')\ndataList = f1.readlines()\nitem  = dataList[2]\nlist2 = item.split('\t')\ndate = list2[0]\nindex = list2[5]\nroa = list2[9]\ndate = filter(lambda ch: ch in '0123456789', date)\nindex = filter(lambda ch: ch in '.0123456789', index)\nstring = filter(lambda ch: ch in '.0123456789', roa)\nroaf = float(string)\nroe = 1/roaf * 100\nprint date\nprint index\ndbs = myser.find({'指数名称':'恒生指数','日期':date})\ncount = 0\nfor item in dbs:\ncount = count + 1\nif count == 0:\nmyser.save({'指数名称':'恒生指数','市盈率':roaf,'盈利收益率':roe,'日期':date,'指数':index}) # add a record\n\nsaveStr = '%s  %f' % (date, roe)\n\nf = open('hengseng.txt','r')\ndata = f.read()\nf.close()\n\ndataStr = data + '\\n' + saveStr\nf = open('hengseng.txt','w')\nf.write(dataStr)\nf.close()\nexcept Exception,ex:\nprint ex\n\n\ndef gethenghsengchina(day,month,year):\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\nfileName = '/Users/han/Desktop/index/hengsheng/china%i%s%s.txt' % (day,monthStr,yearStr)\n\ndownLoadStr = 'http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hscei/' + targetStr + '.csv'\nprint downLoadStr\ntry:\ni_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n\"Referer\": 'http://www.baidu.com'}\nreq = urllib2.Request(downLoadStr, headers=i_headers)\nf = urllib2.urlopen(req)\ndata = f.read()\nf = open(fileName,'wb')\nf.write(data)\nf.close()\n\nf1 = open(fileName,'rb')\ndataList = f1.readlines()\nitem  = dataList[2]\nlist2 = item.split('\t')\ndate = list2[0]\nindex = list2[5]\nroa = list2[9]\ndate = filter(lambda ch: ch in '0123456789', date)\nindex = filter(lambda ch: ch in '.0123456789', index)\nstring = filter(lambda ch: ch in '.0123456789', roa)\nroaf = float(string)\nroe = 1/roaf * 100\n\nprint index\ndbs = myser.find({'指数名称':'恒生指H','日期':date})\ncount = 0\nfor item in dbs:\ncount = count + 1\nif count == 0:\nmyser.save({'指数名称':'恒生指数H', '市盈率':roaf,'盈利收益率':roe,'日期':date,'指数':index})\n\nsaveStr = '%s  %f' % (date, roe)\n\nf = open('hengsengchina.txt','r')\ndata = f.read()\nf.close()\n\ndataStr = data + '\\n' + saveStr\nf = open('hengsengchina.txt','w')\nf.write(dataStr)\nf.close()\nexcept Exception,ex:\nprint ex\n\n\ngetindexs()\n\ncurrent = time.localtime(time.time())\nyear = current.tm_year\nmonth = current.tm_mon\nday = current.tm_mday\n\nindex = 0\nif month == 12:\nindex = 1\n\nindex = month - 1\n\nday = day - 1\n\n# gethenghseng(day,month,year)\n\nfor month in xrange(1,3):\nfor day in xrange(1,31):\ngethenghsengchina(day,month,year)\ngethenghseng(day,month,year)\n\n\n```\n","source":"_posts/2017/指数自动获取.md","raw":"---\ntitle: 指数自动获取\ndate: 2017-02-16 14:59:38\ntags:\n- python\n---\n```\n# -*- coding: utf-8 -*-\nimport urllib2,time,urllib\nimport ast,os,sys,string\nfrom pymongo import MongoClient\n\nmonths = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']\ndicts = {'zsgz00':'no','zsgz10':'上证指数','zsgz20':'上证180','zsgz30':'上证50','zsgz40':'沪深300','zsgz50':'深证成指','zsgz60':'深证100R','zsgz70':'中小板指','zsgz80':'上证380','zsgz90':'红利指数','zsgz100':'中证红利','zsgz110':'中证500'}\n\nconnection = MongoClient(\"localhost\",27017)\nmydb = connection.mydb # new a database\nmyser = mydb.hengsengindex # new a table\n\ndef getindexs():\n\n    downLoadStr = 'http://www.csindex.com.cn/sseportal/ps/zhs/hqjt/csi/show_zsgz.js'\n    print downLoadStr\n    try:\n        i_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n        \"Referer\": 'http://www.baidu.com'}\n        req = urllib2.Request(downLoadStr, headers=i_headers)  \n        f = urllib2.urlopen(req)\n        data = f.read()\n        str = data.decode('gbk')\n        data = str.encode('utf-8')\n        print data\n        listString = data.split('\\n')\n\n        date = ''\n        index = 0\n        for item in listString:\n        if 'zsgz00' in item:\n            date = item[12:-2]\n            datelist = list(date)\n            for s in datelist:\n            if s == '-':\n            datelist.remove(s)\n            date = ''.join(datelist)\n            print date\n        if '0=' in item:\n            pe = listString[index + 1]\n            pb = listString[index + 3]\n            rate = listString[index + 4]\n            indexitem = item.index('=')\n            indexpe = pe.index('=')\n            indexpb = pb.index('=')\n            indexrate = rate.index('=')\n            pe = pe[indexpe+2:-2]\n            pb = pb[indexpe+2:-2]\n            rate = rate[indexpe+2:-2]\n            item = item[indexitem+2:-2]\n            print item\n\n            pe = filter(lambda ch: ch in '.0123456789', pe)\n            pb = filter(lambda ch: ch in '.0123456789', pb)\n            rate = filter(lambda ch: ch in '.0123456789', rate)\n\n            if len(pe) and len(pb) and len(rate):\n                roaf = float(pe)\n                roe = 1/roaf * 100\n                dbs = myser.find({'指数名称':item,'日期':date})\n                count = 0\n                for item in dbs:\n                count = count + 1\n                if count == 0:\n                    myser.save({'指数名称':item,'市盈率':pe,'盈利收益率':roe,'日期':date,'市净率':pb,'股息率':rate})\n\n            index = index + 1\n\n    except Exception,ex:\n    print ex\n\n\ndef gethenghseng(day,month,year):\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\nfileName = '/Users/han/Desktop/index/hengsheng/%i%s%s.txt' % (day,monthStr,yearStr)\n\ndownLoadStr = 'http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hsi/' + targetStr + '.csv'\nprint downLoadStr\ntry:\ni_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n\"Referer\": 'http://www.baidu.com'}\nreq = urllib2.Request(downLoadStr, headers=i_headers)\nf = urllib2.urlopen(req)\ndata = f.read()\nf = open(fileName,'wb')\nf.write(data)\nf.close()\n\nf1 = open(fileName,'rb')\ndataList = f1.readlines()\nitem  = dataList[2]\nlist2 = item.split('\t')\ndate = list2[0]\nindex = list2[5]\nroa = list2[9]\ndate = filter(lambda ch: ch in '0123456789', date)\nindex = filter(lambda ch: ch in '.0123456789', index)\nstring = filter(lambda ch: ch in '.0123456789', roa)\nroaf = float(string)\nroe = 1/roaf * 100\nprint date\nprint index\ndbs = myser.find({'指数名称':'恒生指数','日期':date})\ncount = 0\nfor item in dbs:\ncount = count + 1\nif count == 0:\nmyser.save({'指数名称':'恒生指数','市盈率':roaf,'盈利收益率':roe,'日期':date,'指数':index}) # add a record\n\nsaveStr = '%s  %f' % (date, roe)\n\nf = open('hengseng.txt','r')\ndata = f.read()\nf.close()\n\ndataStr = data + '\\n' + saveStr\nf = open('hengseng.txt','w')\nf.write(dataStr)\nf.close()\nexcept Exception,ex:\nprint ex\n\n\ndef gethenghsengchina(day,month,year):\n\nyearStr = '%i' % year\nyearList = list(yearStr)\nyearStr1 = yearList[-1]\nyearStr2 = yearList[-2]\nyearStr = yearStr2 + yearStr1\n\nmonthStr = months[month - 1]\n\ntargetStr = 'idx_%i%s%s' % (day,monthStr,yearStr)\n\nfileName = '/Users/han/Desktop/index/hengsheng/china%i%s%s.txt' % (day,monthStr,yearStr)\n\ndownLoadStr = 'http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hscei/' + targetStr + '.csv'\nprint downLoadStr\ntry:\ni_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5\",\\\n\"Referer\": 'http://www.baidu.com'}\nreq = urllib2.Request(downLoadStr, headers=i_headers)\nf = urllib2.urlopen(req)\ndata = f.read()\nf = open(fileName,'wb')\nf.write(data)\nf.close()\n\nf1 = open(fileName,'rb')\ndataList = f1.readlines()\nitem  = dataList[2]\nlist2 = item.split('\t')\ndate = list2[0]\nindex = list2[5]\nroa = list2[9]\ndate = filter(lambda ch: ch in '0123456789', date)\nindex = filter(lambda ch: ch in '.0123456789', index)\nstring = filter(lambda ch: ch in '.0123456789', roa)\nroaf = float(string)\nroe = 1/roaf * 100\n\nprint index\ndbs = myser.find({'指数名称':'恒生指H','日期':date})\ncount = 0\nfor item in dbs:\ncount = count + 1\nif count == 0:\nmyser.save({'指数名称':'恒生指数H', '市盈率':roaf,'盈利收益率':roe,'日期':date,'指数':index})\n\nsaveStr = '%s  %f' % (date, roe)\n\nf = open('hengsengchina.txt','r')\ndata = f.read()\nf.close()\n\ndataStr = data + '\\n' + saveStr\nf = open('hengsengchina.txt','w')\nf.write(dataStr)\nf.close()\nexcept Exception,ex:\nprint ex\n\n\ngetindexs()\n\ncurrent = time.localtime(time.time())\nyear = current.tm_year\nmonth = current.tm_mon\nday = current.tm_mday\n\nindex = 0\nif month == 12:\nindex = 1\n\nindex = month - 1\n\nday = day - 1\n\n# gethenghseng(day,month,year)\n\nfor month in xrange(1,3):\nfor day in xrange(1,31):\ngethenghsengchina(day,month,year)\ngethenghseng(day,month,year)\n\n\n```\n","slug":"2017/指数自动获取","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnl004hsauabkm9qrlm","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import urllib2,time,urllib</div><div class=\"line\">import ast,os,sys,string</div><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">months = [&apos;Jan&apos;,&apos;Feb&apos;,&apos;Mar&apos;,&apos;Apr&apos;,&apos;May&apos;,&apos;Jun&apos;,&apos;Jul&apos;,&apos;Aug&apos;,&apos;Sep&apos;,&apos;Oct&apos;,&apos;Nov&apos;,&apos;Dec&apos;]</div><div class=\"line\">dicts = &#123;&apos;zsgz00&apos;:&apos;no&apos;,&apos;zsgz10&apos;:&apos;上证指数&apos;,&apos;zsgz20&apos;:&apos;上证180&apos;,&apos;zsgz30&apos;:&apos;上证50&apos;,&apos;zsgz40&apos;:&apos;沪深300&apos;,&apos;zsgz50&apos;:&apos;深证成指&apos;,&apos;zsgz60&apos;:&apos;深证100R&apos;,&apos;zsgz70&apos;:&apos;中小板指&apos;,&apos;zsgz80&apos;:&apos;上证380&apos;,&apos;zsgz90&apos;:&apos;红利指数&apos;,&apos;zsgz100&apos;:&apos;中证红利&apos;,&apos;zsgz110&apos;:&apos;中证500&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">connection = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">mydb = connection.mydb # new a database</div><div class=\"line\">myser = mydb.hengsengindex # new a table</div><div class=\"line\"></div><div class=\"line\">def getindexs():</div><div class=\"line\"></div><div class=\"line\">    downLoadStr = &apos;http://www.csindex.com.cn/sseportal/ps/zhs/hqjt/csi/show_zsgz.js&apos;</div><div class=\"line\">    print downLoadStr</div><div class=\"line\">    try:</div><div class=\"line\">        i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">        &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">        req = urllib2.Request(downLoadStr, headers=i_headers)  </div><div class=\"line\">        f = urllib2.urlopen(req)</div><div class=\"line\">        data = f.read()</div><div class=\"line\">        str = data.decode(&apos;gbk&apos;)</div><div class=\"line\">        data = str.encode(&apos;utf-8&apos;)</div><div class=\"line\">        print data</div><div class=\"line\">        listString = data.split(&apos;\\n&apos;)</div><div class=\"line\"></div><div class=\"line\">        date = &apos;&apos;</div><div class=\"line\">        index = 0</div><div class=\"line\">        for item in listString:</div><div class=\"line\">        if &apos;zsgz00&apos; in item:</div><div class=\"line\">            date = item[12:-2]</div><div class=\"line\">            datelist = list(date)</div><div class=\"line\">            for s in datelist:</div><div class=\"line\">            if s == &apos;-&apos;:</div><div class=\"line\">            datelist.remove(s)</div><div class=\"line\">            date = &apos;&apos;.join(datelist)</div><div class=\"line\">            print date</div><div class=\"line\">        if &apos;0=&apos; in item:</div><div class=\"line\">            pe = listString[index + 1]</div><div class=\"line\">            pb = listString[index + 3]</div><div class=\"line\">            rate = listString[index + 4]</div><div class=\"line\">            indexitem = item.index(&apos;=&apos;)</div><div class=\"line\">            indexpe = pe.index(&apos;=&apos;)</div><div class=\"line\">            indexpb = pb.index(&apos;=&apos;)</div><div class=\"line\">            indexrate = rate.index(&apos;=&apos;)</div><div class=\"line\">            pe = pe[indexpe+2:-2]</div><div class=\"line\">            pb = pb[indexpe+2:-2]</div><div class=\"line\">            rate = rate[indexpe+2:-2]</div><div class=\"line\">            item = item[indexitem+2:-2]</div><div class=\"line\">            print item</div><div class=\"line\"></div><div class=\"line\">            pe = filter(lambda ch: ch in &apos;.0123456789&apos;, pe)</div><div class=\"line\">            pb = filter(lambda ch: ch in &apos;.0123456789&apos;, pb)</div><div class=\"line\">            rate = filter(lambda ch: ch in &apos;.0123456789&apos;, rate)</div><div class=\"line\"></div><div class=\"line\">            if len(pe) and len(pb) and len(rate):</div><div class=\"line\">                roaf = float(pe)</div><div class=\"line\">                roe = 1/roaf * 100</div><div class=\"line\">                dbs = myser.find(&#123;&apos;指数名称&apos;:item,&apos;日期&apos;:date&#125;)</div><div class=\"line\">                count = 0</div><div class=\"line\">                for item in dbs:</div><div class=\"line\">                count = count + 1</div><div class=\"line\">                if count == 0:</div><div class=\"line\">                    myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;)</div><div class=\"line\"></div><div class=\"line\">            index = index + 1</div><div class=\"line\"></div><div class=\"line\">    except Exception,ex:</div><div class=\"line\">    print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def gethenghseng(day,month,year):</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">fileName = &apos;/Users/han/Desktop/index/hengsheng/%i%s%s.txt&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hsi/&apos; + targetStr + &apos;.csv&apos;</div><div class=\"line\">print downLoadStr</div><div class=\"line\">try:</div><div class=\"line\">i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">f = urllib2.urlopen(req)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f = open(fileName,&apos;wb&apos;)</div><div class=\"line\">f.write(data)</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">f1 = open(fileName,&apos;rb&apos;)</div><div class=\"line\">dataList = f1.readlines()</div><div class=\"line\">item  = dataList[2]</div><div class=\"line\">list2 = item.split(&apos;\t&apos;)</div><div class=\"line\">date = list2[0]</div><div class=\"line\">index = list2[5]</div><div class=\"line\">roa = list2[9]</div><div class=\"line\">date = filter(lambda ch: ch in &apos;0123456789&apos;, date)</div><div class=\"line\">index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)</div><div class=\"line\">string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)</div><div class=\"line\">roaf = float(string)</div><div class=\"line\">roe = 1/roaf * 100</div><div class=\"line\">print date</div><div class=\"line\">print index</div><div class=\"line\">dbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;日期&apos;:date&#125;)</div><div class=\"line\">count = 0</div><div class=\"line\">for item in dbs:</div><div class=\"line\">count = count + 1</div><div class=\"line\">if count == 0:</div><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;) # add a record</div><div class=\"line\"></div><div class=\"line\">saveStr = &apos;%s  %f&apos; % (date, roe)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;hengseng.txt&apos;,&apos;r&apos;)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">dataStr = data + &apos;\\n&apos; + saveStr</div><div class=\"line\">f = open(&apos;hengseng.txt&apos;,&apos;w&apos;)</div><div class=\"line\">f.write(dataStr)</div><div class=\"line\">f.close()</div><div class=\"line\">except Exception,ex:</div><div class=\"line\">print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def gethenghsengchina(day,month,year):</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">fileName = &apos;/Users/han/Desktop/index/hengsheng/china%i%s%s.txt&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hscei/&apos; + targetStr + &apos;.csv&apos;</div><div class=\"line\">print downLoadStr</div><div class=\"line\">try:</div><div class=\"line\">i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">f = urllib2.urlopen(req)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f = open(fileName,&apos;wb&apos;)</div><div class=\"line\">f.write(data)</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">f1 = open(fileName,&apos;rb&apos;)</div><div class=\"line\">dataList = f1.readlines()</div><div class=\"line\">item  = dataList[2]</div><div class=\"line\">list2 = item.split(&apos;\t&apos;)</div><div class=\"line\">date = list2[0]</div><div class=\"line\">index = list2[5]</div><div class=\"line\">roa = list2[9]</div><div class=\"line\">date = filter(lambda ch: ch in &apos;0123456789&apos;, date)</div><div class=\"line\">index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)</div><div class=\"line\">string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)</div><div class=\"line\">roaf = float(string)</div><div class=\"line\">roe = 1/roaf * 100</div><div class=\"line\"></div><div class=\"line\">print index</div><div class=\"line\">dbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指H&apos;,&apos;日期&apos;:date&#125;)</div><div class=\"line\">count = 0</div><div class=\"line\">for item in dbs:</div><div class=\"line\">count = count + 1</div><div class=\"line\">if count == 0:</div><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数H&apos;, &apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;)</div><div class=\"line\"></div><div class=\"line\">saveStr = &apos;%s  %f&apos; % (date, roe)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;hengsengchina.txt&apos;,&apos;r&apos;)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">dataStr = data + &apos;\\n&apos; + saveStr</div><div class=\"line\">f = open(&apos;hengsengchina.txt&apos;,&apos;w&apos;)</div><div class=\"line\">f.write(dataStr)</div><div class=\"line\">f.close()</div><div class=\"line\">except Exception,ex:</div><div class=\"line\">print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">getindexs()</div><div class=\"line\"></div><div class=\"line\">current = time.localtime(time.time())</div><div class=\"line\">year = current.tm_year</div><div class=\"line\">month = current.tm_mon</div><div class=\"line\">day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">index = 0</div><div class=\"line\">if month == 12:</div><div class=\"line\">index = 1</div><div class=\"line\"></div><div class=\"line\">index = month - 1</div><div class=\"line\"></div><div class=\"line\">day = day - 1</div><div class=\"line\"></div><div class=\"line\"># gethenghseng(day,month,year)</div><div class=\"line\"></div><div class=\"line\">for month in xrange(1,3):</div><div class=\"line\">for day in xrange(1,31):</div><div class=\"line\">gethenghsengchina(day,month,year)</div><div class=\"line\">gethenghseng(day,month,year)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div></pre></td><td class=\"code\"><pre><div class=\"line\"># -*- coding: utf-8 -*-</div><div class=\"line\">import urllib2,time,urllib</div><div class=\"line\">import ast,os,sys,string</div><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">months = [&apos;Jan&apos;,&apos;Feb&apos;,&apos;Mar&apos;,&apos;Apr&apos;,&apos;May&apos;,&apos;Jun&apos;,&apos;Jul&apos;,&apos;Aug&apos;,&apos;Sep&apos;,&apos;Oct&apos;,&apos;Nov&apos;,&apos;Dec&apos;]</div><div class=\"line\">dicts = &#123;&apos;zsgz00&apos;:&apos;no&apos;,&apos;zsgz10&apos;:&apos;上证指数&apos;,&apos;zsgz20&apos;:&apos;上证180&apos;,&apos;zsgz30&apos;:&apos;上证50&apos;,&apos;zsgz40&apos;:&apos;沪深300&apos;,&apos;zsgz50&apos;:&apos;深证成指&apos;,&apos;zsgz60&apos;:&apos;深证100R&apos;,&apos;zsgz70&apos;:&apos;中小板指&apos;,&apos;zsgz80&apos;:&apos;上证380&apos;,&apos;zsgz90&apos;:&apos;红利指数&apos;,&apos;zsgz100&apos;:&apos;中证红利&apos;,&apos;zsgz110&apos;:&apos;中证500&apos;&#125;</div><div class=\"line\"></div><div class=\"line\">connection = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\">mydb = connection.mydb # new a database</div><div class=\"line\">myser = mydb.hengsengindex # new a table</div><div class=\"line\"></div><div class=\"line\">def getindexs():</div><div class=\"line\"></div><div class=\"line\">    downLoadStr = &apos;http://www.csindex.com.cn/sseportal/ps/zhs/hqjt/csi/show_zsgz.js&apos;</div><div class=\"line\">    print downLoadStr</div><div class=\"line\">    try:</div><div class=\"line\">        i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">        &quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">        req = urllib2.Request(downLoadStr, headers=i_headers)  </div><div class=\"line\">        f = urllib2.urlopen(req)</div><div class=\"line\">        data = f.read()</div><div class=\"line\">        str = data.decode(&apos;gbk&apos;)</div><div class=\"line\">        data = str.encode(&apos;utf-8&apos;)</div><div class=\"line\">        print data</div><div class=\"line\">        listString = data.split(&apos;\\n&apos;)</div><div class=\"line\"></div><div class=\"line\">        date = &apos;&apos;</div><div class=\"line\">        index = 0</div><div class=\"line\">        for item in listString:</div><div class=\"line\">        if &apos;zsgz00&apos; in item:</div><div class=\"line\">            date = item[12:-2]</div><div class=\"line\">            datelist = list(date)</div><div class=\"line\">            for s in datelist:</div><div class=\"line\">            if s == &apos;-&apos;:</div><div class=\"line\">            datelist.remove(s)</div><div class=\"line\">            date = &apos;&apos;.join(datelist)</div><div class=\"line\">            print date</div><div class=\"line\">        if &apos;0=&apos; in item:</div><div class=\"line\">            pe = listString[index + 1]</div><div class=\"line\">            pb = listString[index + 3]</div><div class=\"line\">            rate = listString[index + 4]</div><div class=\"line\">            indexitem = item.index(&apos;=&apos;)</div><div class=\"line\">            indexpe = pe.index(&apos;=&apos;)</div><div class=\"line\">            indexpb = pb.index(&apos;=&apos;)</div><div class=\"line\">            indexrate = rate.index(&apos;=&apos;)</div><div class=\"line\">            pe = pe[indexpe+2:-2]</div><div class=\"line\">            pb = pb[indexpe+2:-2]</div><div class=\"line\">            rate = rate[indexpe+2:-2]</div><div class=\"line\">            item = item[indexitem+2:-2]</div><div class=\"line\">            print item</div><div class=\"line\"></div><div class=\"line\">            pe = filter(lambda ch: ch in &apos;.0123456789&apos;, pe)</div><div class=\"line\">            pb = filter(lambda ch: ch in &apos;.0123456789&apos;, pb)</div><div class=\"line\">            rate = filter(lambda ch: ch in &apos;.0123456789&apos;, rate)</div><div class=\"line\"></div><div class=\"line\">            if len(pe) and len(pb) and len(rate):</div><div class=\"line\">                roaf = float(pe)</div><div class=\"line\">                roe = 1/roaf * 100</div><div class=\"line\">                dbs = myser.find(&#123;&apos;指数名称&apos;:item,&apos;日期&apos;:date&#125;)</div><div class=\"line\">                count = 0</div><div class=\"line\">                for item in dbs:</div><div class=\"line\">                count = count + 1</div><div class=\"line\">                if count == 0:</div><div class=\"line\">                    myser.save(&#123;&apos;指数名称&apos;:item,&apos;市盈率&apos;:pe,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;市净率&apos;:pb,&apos;股息率&apos;:rate&#125;)</div><div class=\"line\"></div><div class=\"line\">            index = index + 1</div><div class=\"line\"></div><div class=\"line\">    except Exception,ex:</div><div class=\"line\">    print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def gethenghseng(day,month,year):</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">fileName = &apos;/Users/han/Desktop/index/hengsheng/%i%s%s.txt&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hsi/&apos; + targetStr + &apos;.csv&apos;</div><div class=\"line\">print downLoadStr</div><div class=\"line\">try:</div><div class=\"line\">i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">f = urllib2.urlopen(req)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f = open(fileName,&apos;wb&apos;)</div><div class=\"line\">f.write(data)</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">f1 = open(fileName,&apos;rb&apos;)</div><div class=\"line\">dataList = f1.readlines()</div><div class=\"line\">item  = dataList[2]</div><div class=\"line\">list2 = item.split(&apos;\t&apos;)</div><div class=\"line\">date = list2[0]</div><div class=\"line\">index = list2[5]</div><div class=\"line\">roa = list2[9]</div><div class=\"line\">date = filter(lambda ch: ch in &apos;0123456789&apos;, date)</div><div class=\"line\">index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)</div><div class=\"line\">string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)</div><div class=\"line\">roaf = float(string)</div><div class=\"line\">roe = 1/roaf * 100</div><div class=\"line\">print date</div><div class=\"line\">print index</div><div class=\"line\">dbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;日期&apos;:date&#125;)</div><div class=\"line\">count = 0</div><div class=\"line\">for item in dbs:</div><div class=\"line\">count = count + 1</div><div class=\"line\">if count == 0:</div><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数&apos;,&apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;) # add a record</div><div class=\"line\"></div><div class=\"line\">saveStr = &apos;%s  %f&apos; % (date, roe)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;hengseng.txt&apos;,&apos;r&apos;)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">dataStr = data + &apos;\\n&apos; + saveStr</div><div class=\"line\">f = open(&apos;hengseng.txt&apos;,&apos;w&apos;)</div><div class=\"line\">f.write(dataStr)</div><div class=\"line\">f.close()</div><div class=\"line\">except Exception,ex:</div><div class=\"line\">print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def gethenghsengchina(day,month,year):</div><div class=\"line\"></div><div class=\"line\">yearStr = &apos;%i&apos; % year</div><div class=\"line\">yearList = list(yearStr)</div><div class=\"line\">yearStr1 = yearList[-1]</div><div class=\"line\">yearStr2 = yearList[-2]</div><div class=\"line\">yearStr = yearStr2 + yearStr1</div><div class=\"line\"></div><div class=\"line\">monthStr = months[month - 1]</div><div class=\"line\"></div><div class=\"line\">targetStr = &apos;idx_%i%s%s&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">fileName = &apos;/Users/han/Desktop/index/hengsheng/china%i%s%s.txt&apos; % (day,monthStr,yearStr)</div><div class=\"line\"></div><div class=\"line\">downLoadStr = &apos;http://sc.hangseng.com/gb/www.hsi.com.hk/HSI-Net/static/revamp/contents/en/indexes/report/hscei/&apos; + targetStr + &apos;.csv&apos;</div><div class=\"line\">print downLoadStr</div><div class=\"line\">try:</div><div class=\"line\">i_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1) Gecko/20090624 Firefox/3.5&quot;,\\</div><div class=\"line\">&quot;Referer&quot;: &apos;http://www.baidu.com&apos;&#125;</div><div class=\"line\">req = urllib2.Request(downLoadStr, headers=i_headers)</div><div class=\"line\">f = urllib2.urlopen(req)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f = open(fileName,&apos;wb&apos;)</div><div class=\"line\">f.write(data)</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">f1 = open(fileName,&apos;rb&apos;)</div><div class=\"line\">dataList = f1.readlines()</div><div class=\"line\">item  = dataList[2]</div><div class=\"line\">list2 = item.split(&apos;\t&apos;)</div><div class=\"line\">date = list2[0]</div><div class=\"line\">index = list2[5]</div><div class=\"line\">roa = list2[9]</div><div class=\"line\">date = filter(lambda ch: ch in &apos;0123456789&apos;, date)</div><div class=\"line\">index = filter(lambda ch: ch in &apos;.0123456789&apos;, index)</div><div class=\"line\">string = filter(lambda ch: ch in &apos;.0123456789&apos;, roa)</div><div class=\"line\">roaf = float(string)</div><div class=\"line\">roe = 1/roaf * 100</div><div class=\"line\"></div><div class=\"line\">print index</div><div class=\"line\">dbs = myser.find(&#123;&apos;指数名称&apos;:&apos;恒生指H&apos;,&apos;日期&apos;:date&#125;)</div><div class=\"line\">count = 0</div><div class=\"line\">for item in dbs:</div><div class=\"line\">count = count + 1</div><div class=\"line\">if count == 0:</div><div class=\"line\">myser.save(&#123;&apos;指数名称&apos;:&apos;恒生指数H&apos;, &apos;市盈率&apos;:roaf,&apos;盈利收益率&apos;:roe,&apos;日期&apos;:date,&apos;指数&apos;:index&#125;)</div><div class=\"line\"></div><div class=\"line\">saveStr = &apos;%s  %f&apos; % (date, roe)</div><div class=\"line\"></div><div class=\"line\">f = open(&apos;hengsengchina.txt&apos;,&apos;r&apos;)</div><div class=\"line\">data = f.read()</div><div class=\"line\">f.close()</div><div class=\"line\"></div><div class=\"line\">dataStr = data + &apos;\\n&apos; + saveStr</div><div class=\"line\">f = open(&apos;hengsengchina.txt&apos;,&apos;w&apos;)</div><div class=\"line\">f.write(dataStr)</div><div class=\"line\">f.close()</div><div class=\"line\">except Exception,ex:</div><div class=\"line\">print ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">getindexs()</div><div class=\"line\"></div><div class=\"line\">current = time.localtime(time.time())</div><div class=\"line\">year = current.tm_year</div><div class=\"line\">month = current.tm_mon</div><div class=\"line\">day = current.tm_mday</div><div class=\"line\"></div><div class=\"line\">index = 0</div><div class=\"line\">if month == 12:</div><div class=\"line\">index = 1</div><div class=\"line\"></div><div class=\"line\">index = month - 1</div><div class=\"line\"></div><div class=\"line\">day = day - 1</div><div class=\"line\"></div><div class=\"line\"># gethenghseng(day,month,year)</div><div class=\"line\"></div><div class=\"line\">for month in xrange(1,3):</div><div class=\"line\">for day in xrange(1,31):</div><div class=\"line\">gethenghsengchina(day,month,year)</div><div class=\"line\">gethenghseng(day,month,year)</div></pre></td></tr></table></figure>\n"},{"title":"爬虫系列","date":"2017-02-10T04:56:37.000Z","_content":"这里主要实现的是利用爬虫来实现对关注指数基金的估值数据的抓取，然后进行估值分析，配合云服务器并且每天进行推送。\n\n爬虫的基本步骤很简单，将该网页的js和html全部下载下来，然后从其中寻找有用的信息，进而将有用的信息进行结构化的存储，其中将网页爬取下来使用的scrapy，而寻找信息我们使用的是xpath，存储我们使用mongo\n<!--more-->\n### 使用scrapy框架\n- 安装\n`sudo pip install scrapy`或者直接下载源码，自己编译*下载0.24版本的scrapyhttp://scrapy.org/download/\n然后cd 进入解压后的文件，然后执行sudo python setup.py install安装scrapy\n>如果在使用命令行过程中发现sudo之后仍然无法获取权限，删除文件时会提示Operation not permitted，那就关机重启，然后按住comman+R，启动之后启动命令行，输入，csrutil disable关闭rootless就可以了\n\n- scrapy startproject tutorial创建爬虫工程\n* scrapy.cfg: 项目的配置文件\n* tutorial/: 该项目的python模块。之后您将在此加入代码。\n* tutorial/items.py: 项目中的item文件.\n* tutorial/pipelines.py: 项目中的pipelines文件.\n* tutorial/settings.py: 项目的设置文件.\n* tutorial/spiders/: 放置spider代码的目录.\n\n>文件作用说明\n\n* items.py：定义后期处理的数据，是一个容器，像一个字典\n* settings.py：配置scrapy，从而修改user-agent,设置爬取时间，设置代理，设置中间件\n* pipelines.py:用于存放执行后去数据处理的功能，从而把爬取与处理分开 \nitem成功获取数据之后，它会送到pipeline，让pipeline对数据进行处理\n\n运行工程：\nscrapy目前只能使用命令行来运行`scrapy crawl demo`这里要注意的是后边的这个demo这个名字不是随便来的，spider这个文件命名要是demo_spider才可以\n\n### xpath的使用\n\n用到的工具：\n\n* 火狐浏览器\n* FirePath插件\n* Firebug插件\n* XPath Checker插件\n\n1.右键选择－Inspect in FirePath\n2.复制xpath \n3.在该页面上右键－>View XPath \n4.把xpath的路径复制进入该页面，查看是否能够找到自己想要的元素\n\n### mongodb的安装以及使用\n\n* 一行代码安装mongodbbrew install mongoDB前提是已经安装了brew工具，一次失败就执行第二次\n*\n如果上边的方法还是不行，那就只能手动下载了\n\n    * https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz\n    * 命令行解压该包tar xzvf mongodb-osx-x86_64-3.2.3.tgz\n    * 将解压后的文件放到一个可以长期放置的地方，然后进入该文件夹\n    * pwd记录当前文件路径，copy一下，一会儿有用\n    * vim ~/.zshrc进入配置目录\n    *\n#mongod config \nMONGODB_HOME=/Users/shenghuihan/Desktop/mongodb-osx-x86_64-3.2.3 \nPATH=$PATH:$MONGODB_HOME/bin添加bin目录文件到系统搜索目录下\n    *\nsource ~/.zshrc使设置生效\n* 查看mongo是否生效mongo，如果显示版本号说明生效，但是没有启动下面我们来启动服务\n* 先在同级目录下创建数据文件和日志文件mkdir data和mkdir log\n* 启动mongodb服务mongod --dbpath data --logpath log/mongod.log --logappend --fork\n* 再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo\n* 将启动命令写入一个启动脚本中echo \"mongod --dbpath data --logpath log/mongod.log --logappend --fork\" >> start.sh\n* 可视化工具安装https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载\n* 安装python操作mongodb的驱动sudo pip install pymongo前提是要安装pip啊，这是一个专门用来安装python各种库的软件\n* 默认端口27017\n* 查看ip的方式，db.getMongo()\n\n#### 使用mongodb命令行\n```\nbogon:mongo shenghuihan$ mongo\nMongoDB shell version: 3.2.3\nconnecting to: test\nServer has startup warnings: \n2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] \n2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000\n> use mydb//创建一个新的库\nswitched to db mydb\n> show collections\n> show dbs\n```\n\n#### 使用以及查看数据\n我们可以使用mongohub查看数据，当然还可以使用我们最喜欢的python\n```\nimport pymongo\n\nconnection = pymongo.MongoClient()\ntdb = connection.jikexueyuan\npost_info = tdb.ceshi\n\njike = {'name':u'哈哈哈'}#插入数据\ngoog = {'name':u'校长'}\n\n# post_info.insert(jike)\n# post_info.insert(goog)\npost_info.remove({'name':u'校长'})\n\nprint u'操作完成'\n```\n\n```\nfrom pymongo import MongoClient\n\nmc = MongoClient(\"localhost\",27017)\n\ndb = mc.users\n\nc = db.users.find()\n\ndb.users.save({\"age\":8})\n\nfor objc in c:\n    print(objc)\n\nmc.close()\n```\n","source":"_posts/2017/爬虫系列.md","raw":"---\ntitle: 爬虫系列\ndate: 2017-02-10 12:56:37\ntags:\n- 爬虫\n- python\n---\n这里主要实现的是利用爬虫来实现对关注指数基金的估值数据的抓取，然后进行估值分析，配合云服务器并且每天进行推送。\n\n爬虫的基本步骤很简单，将该网页的js和html全部下载下来，然后从其中寻找有用的信息，进而将有用的信息进行结构化的存储，其中将网页爬取下来使用的scrapy，而寻找信息我们使用的是xpath，存储我们使用mongo\n<!--more-->\n### 使用scrapy框架\n- 安装\n`sudo pip install scrapy`或者直接下载源码，自己编译*下载0.24版本的scrapyhttp://scrapy.org/download/\n然后cd 进入解压后的文件，然后执行sudo python setup.py install安装scrapy\n>如果在使用命令行过程中发现sudo之后仍然无法获取权限，删除文件时会提示Operation not permitted，那就关机重启，然后按住comman+R，启动之后启动命令行，输入，csrutil disable关闭rootless就可以了\n\n- scrapy startproject tutorial创建爬虫工程\n* scrapy.cfg: 项目的配置文件\n* tutorial/: 该项目的python模块。之后您将在此加入代码。\n* tutorial/items.py: 项目中的item文件.\n* tutorial/pipelines.py: 项目中的pipelines文件.\n* tutorial/settings.py: 项目的设置文件.\n* tutorial/spiders/: 放置spider代码的目录.\n\n>文件作用说明\n\n* items.py：定义后期处理的数据，是一个容器，像一个字典\n* settings.py：配置scrapy，从而修改user-agent,设置爬取时间，设置代理，设置中间件\n* pipelines.py:用于存放执行后去数据处理的功能，从而把爬取与处理分开 \nitem成功获取数据之后，它会送到pipeline，让pipeline对数据进行处理\n\n运行工程：\nscrapy目前只能使用命令行来运行`scrapy crawl demo`这里要注意的是后边的这个demo这个名字不是随便来的，spider这个文件命名要是demo_spider才可以\n\n### xpath的使用\n\n用到的工具：\n\n* 火狐浏览器\n* FirePath插件\n* Firebug插件\n* XPath Checker插件\n\n1.右键选择－Inspect in FirePath\n2.复制xpath \n3.在该页面上右键－>View XPath \n4.把xpath的路径复制进入该页面，查看是否能够找到自己想要的元素\n\n### mongodb的安装以及使用\n\n* 一行代码安装mongodbbrew install mongoDB前提是已经安装了brew工具，一次失败就执行第二次\n*\n如果上边的方法还是不行，那就只能手动下载了\n\n    * https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz\n    * 命令行解压该包tar xzvf mongodb-osx-x86_64-3.2.3.tgz\n    * 将解压后的文件放到一个可以长期放置的地方，然后进入该文件夹\n    * pwd记录当前文件路径，copy一下，一会儿有用\n    * vim ~/.zshrc进入配置目录\n    *\n#mongod config \nMONGODB_HOME=/Users/shenghuihan/Desktop/mongodb-osx-x86_64-3.2.3 \nPATH=$PATH:$MONGODB_HOME/bin添加bin目录文件到系统搜索目录下\n    *\nsource ~/.zshrc使设置生效\n* 查看mongo是否生效mongo，如果显示版本号说明生效，但是没有启动下面我们来启动服务\n* 先在同级目录下创建数据文件和日志文件mkdir data和mkdir log\n* 启动mongodb服务mongod --dbpath data --logpath log/mongod.log --logappend --fork\n* 再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo\n* 将启动命令写入一个启动脚本中echo \"mongod --dbpath data --logpath log/mongod.log --logappend --fork\" >> start.sh\n* 可视化工具安装https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载\n* 安装python操作mongodb的驱动sudo pip install pymongo前提是要安装pip啊，这是一个专门用来安装python各种库的软件\n* 默认端口27017\n* 查看ip的方式，db.getMongo()\n\n#### 使用mongodb命令行\n```\nbogon:mongo shenghuihan$ mongo\nMongoDB shell version: 3.2.3\nconnecting to: test\nServer has startup warnings: \n2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] \n2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000\n> use mydb//创建一个新的库\nswitched to db mydb\n> show collections\n> show dbs\n```\n\n#### 使用以及查看数据\n我们可以使用mongohub查看数据，当然还可以使用我们最喜欢的python\n```\nimport pymongo\n\nconnection = pymongo.MongoClient()\ntdb = connection.jikexueyuan\npost_info = tdb.ceshi\n\njike = {'name':u'哈哈哈'}#插入数据\ngoog = {'name':u'校长'}\n\n# post_info.insert(jike)\n# post_info.insert(goog)\npost_info.remove({'name':u'校长'})\n\nprint u'操作完成'\n```\n\n```\nfrom pymongo import MongoClient\n\nmc = MongoClient(\"localhost\",27017)\n\ndb = mc.users\n\nc = db.users.find()\n\ndb.users.save({\"age\":8})\n\nfor objc in c:\n    print(objc)\n\nmc.close()\n```\n","slug":"2017/爬虫系列","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnm004jsauabm4insud","content":"<p>这里主要实现的是利用爬虫来实现对关注指数基金的估值数据的抓取，然后进行估值分析，配合云服务器并且每天进行推送。</p>\n<p>爬虫的基本步骤很简单，将该网页的js和html全部下载下来，然后从其中寻找有用的信息，进而将有用的信息进行结构化的存储，其中将网页爬取下来使用的scrapy，而寻找信息我们使用的是xpath，存储我们使用mongo<br><a id=\"more\"></a></p>\n<h3 id=\"使用scrapy框架\"><a href=\"#使用scrapy框架\" class=\"headerlink\" title=\"使用scrapy框架\"></a>使用scrapy框架</h3><ul>\n<li><p>安装<br><code>sudo pip install scrapy</code>或者直接下载源码，自己编译*下载0.24版本的scrapy<a href=\"http://scrapy.org/download/\" target=\"_blank\" rel=\"external\">http://scrapy.org/download/</a><br>然后cd 进入解压后的文件，然后执行sudo python setup.py install安装scrapy</p>\n<blockquote>\n<p>如果在使用命令行过程中发现sudo之后仍然无法获取权限，删除文件时会提示Operation not permitted，那就关机重启，然后按住comman+R，启动之后启动命令行，输入，csrutil disable关闭rootless就可以了</p>\n</blockquote>\n</li>\n<li><p>scrapy startproject tutorial创建爬虫工程</p>\n</li>\n</ul>\n<ul>\n<li>scrapy.cfg: 项目的配置文件</li>\n<li>tutorial/: 该项目的python模块。之后您将在此加入代码。</li>\n<li>tutorial/items.py: 项目中的item文件.</li>\n<li>tutorial/pipelines.py: 项目中的pipelines文件.</li>\n<li>tutorial/settings.py: 项目的设置文件.</li>\n<li>tutorial/spiders/: 放置spider代码的目录.</li>\n</ul>\n<blockquote>\n<p>文件作用说明</p>\n</blockquote>\n<ul>\n<li>items.py：定义后期处理的数据，是一个容器，像一个字典</li>\n<li>settings.py：配置scrapy，从而修改user-agent,设置爬取时间，设置代理，设置中间件</li>\n<li>pipelines.py:用于存放执行后去数据处理的功能，从而把爬取与处理分开<br>item成功获取数据之后，它会送到pipeline，让pipeline对数据进行处理</li>\n</ul>\n<p>运行工程：<br>scrapy目前只能使用命令行来运行<code>scrapy crawl demo</code>这里要注意的是后边的这个demo这个名字不是随便来的，spider这个文件命名要是demo_spider才可以</p>\n<h3 id=\"xpath的使用\"><a href=\"#xpath的使用\" class=\"headerlink\" title=\"xpath的使用\"></a>xpath的使用</h3><p>用到的工具：</p>\n<ul>\n<li>火狐浏览器</li>\n<li>FirePath插件</li>\n<li>Firebug插件</li>\n<li>XPath Checker插件</li>\n</ul>\n<p>1.右键选择－Inspect in FirePath<br>2.复制xpath<br>3.在该页面上右键－&gt;View XPath<br>4.把xpath的路径复制进入该页面，查看是否能够找到自己想要的元素</p>\n<h3 id=\"mongodb的安装以及使用\"><a href=\"#mongodb的安装以及使用\" class=\"headerlink\" title=\"mongodb的安装以及使用\"></a>mongodb的安装以及使用</h3><ul>\n<li><p>一行代码安装mongodbbrew install mongoDB前提是已经安装了brew工具，一次失败就执行第二次<br>*<br>如果上边的方法还是不行，那就只能手动下载了</p>\n<ul>\n<li><a href=\"https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz\" target=\"_blank\" rel=\"external\">https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz</a></li>\n<li>命令行解压该包tar xzvf mongodb-osx-x86_64-3.2.3.tgz</li>\n<li>将解压后的文件放到一个可以长期放置的地方，然后进入该文件夹</li>\n<li>pwd记录当前文件路径，copy一下，一会儿有用</li>\n<li>vim ~/.zshrc进入配置目录<br><em><br>#mongod config<br>MONGODB_HOME=/Users/shenghuihan/Desktop/mongodb-osx-x86_64-3.2.3<br>PATH=$PATH:$MONGODB_HOME/bin添加bin目录文件到系统搜索目录下\n</em><br>source ~/.zshrc使设置生效</li>\n</ul>\n</li>\n<li>查看mongo是否生效mongo，如果显示版本号说明生效，但是没有启动下面我们来启动服务</li>\n<li>先在同级目录下创建数据文件和日志文件mkdir data和mkdir log</li>\n<li>启动mongodb服务mongod –dbpath data –logpath log/mongod.log –logappend –fork</li>\n<li>再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo</li>\n<li>将启动命令写入一个启动脚本中echo “mongod –dbpath data –logpath log/mongod.log –logappend –fork” &gt;&gt; start.sh</li>\n<li>可视化工具安装<a href=\"https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载\" target=\"_blank\" rel=\"external\">https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载</a></li>\n<li>安装python操作mongodb的驱动sudo pip install pymongo前提是要安装pip啊，这是一个专门用来安装python各种库的软件</li>\n<li>默认端口27017</li>\n<li>查看ip的方式，db.getMongo()</li>\n</ul>\n<h4 id=\"使用mongodb命令行\"><a href=\"#使用mongodb命令行\" class=\"headerlink\" title=\"使用mongodb命令行\"></a>使用mongodb命令行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bogon:mongo shenghuihan$ mongo</div><div class=\"line\">MongoDB shell version: 3.2.3</div><div class=\"line\">connecting to: test</div><div class=\"line\">Server has startup warnings: </div><div class=\"line\">2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] </div><div class=\"line\">2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000</div><div class=\"line\">&gt; use mydb//创建一个新的库</div><div class=\"line\">switched to db mydb</div><div class=\"line\">&gt; show collections</div><div class=\"line\">&gt; show dbs</div></pre></td></tr></table></figure>\n<h4 id=\"使用以及查看数据\"><a href=\"#使用以及查看数据\" class=\"headerlink\" title=\"使用以及查看数据\"></a>使用以及查看数据</h4><p>我们可以使用mongohub查看数据，当然还可以使用我们最喜欢的python<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">import pymongo</div><div class=\"line\"></div><div class=\"line\">connection = pymongo.MongoClient()</div><div class=\"line\">tdb = connection.jikexueyuan</div><div class=\"line\">post_info = tdb.ceshi</div><div class=\"line\"></div><div class=\"line\">jike = &#123;&apos;name&apos;:u&apos;哈哈哈&apos;&#125;#插入数据</div><div class=\"line\">goog = &#123;&apos;name&apos;:u&apos;校长&apos;&#125;</div><div class=\"line\"></div><div class=\"line\"># post_info.insert(jike)</div><div class=\"line\"># post_info.insert(goog)</div><div class=\"line\">post_info.remove(&#123;&apos;name&apos;:u&apos;校长&apos;&#125;)</div><div class=\"line\"></div><div class=\"line\">print u&apos;操作完成&apos;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\"></div><div class=\"line\">db = mc.users</div><div class=\"line\"></div><div class=\"line\">c = db.users.find()</div><div class=\"line\"></div><div class=\"line\">db.users.save(&#123;&quot;age&quot;:8&#125;)</div><div class=\"line\"></div><div class=\"line\">for objc in c:</div><div class=\"line\">    print(objc)</div><div class=\"line\"></div><div class=\"line\">mc.close()</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这里主要实现的是利用爬虫来实现对关注指数基金的估值数据的抓取，然后进行估值分析，配合云服务器并且每天进行推送。</p>\n<p>爬虫的基本步骤很简单，将该网页的js和html全部下载下来，然后从其中寻找有用的信息，进而将有用的信息进行结构化的存储，其中将网页爬取下来使用的scrapy，而寻找信息我们使用的是xpath，存储我们使用mongo<br>","more":"</p>\n<h3 id=\"使用scrapy框架\"><a href=\"#使用scrapy框架\" class=\"headerlink\" title=\"使用scrapy框架\"></a>使用scrapy框架</h3><ul>\n<li><p>安装<br><code>sudo pip install scrapy</code>或者直接下载源码，自己编译*下载0.24版本的scrapy<a href=\"http://scrapy.org/download/\" target=\"_blank\" rel=\"external\">http://scrapy.org/download/</a><br>然后cd 进入解压后的文件，然后执行sudo python setup.py install安装scrapy</p>\n<blockquote>\n<p>如果在使用命令行过程中发现sudo之后仍然无法获取权限，删除文件时会提示Operation not permitted，那就关机重启，然后按住comman+R，启动之后启动命令行，输入，csrutil disable关闭rootless就可以了</p>\n</blockquote>\n</li>\n<li><p>scrapy startproject tutorial创建爬虫工程</p>\n</li>\n</ul>\n<ul>\n<li>scrapy.cfg: 项目的配置文件</li>\n<li>tutorial/: 该项目的python模块。之后您将在此加入代码。</li>\n<li>tutorial/items.py: 项目中的item文件.</li>\n<li>tutorial/pipelines.py: 项目中的pipelines文件.</li>\n<li>tutorial/settings.py: 项目的设置文件.</li>\n<li>tutorial/spiders/: 放置spider代码的目录.</li>\n</ul>\n<blockquote>\n<p>文件作用说明</p>\n</blockquote>\n<ul>\n<li>items.py：定义后期处理的数据，是一个容器，像一个字典</li>\n<li>settings.py：配置scrapy，从而修改user-agent,设置爬取时间，设置代理，设置中间件</li>\n<li>pipelines.py:用于存放执行后去数据处理的功能，从而把爬取与处理分开<br>item成功获取数据之后，它会送到pipeline，让pipeline对数据进行处理</li>\n</ul>\n<p>运行工程：<br>scrapy目前只能使用命令行来运行<code>scrapy crawl demo</code>这里要注意的是后边的这个demo这个名字不是随便来的，spider这个文件命名要是demo_spider才可以</p>\n<h3 id=\"xpath的使用\"><a href=\"#xpath的使用\" class=\"headerlink\" title=\"xpath的使用\"></a>xpath的使用</h3><p>用到的工具：</p>\n<ul>\n<li>火狐浏览器</li>\n<li>FirePath插件</li>\n<li>Firebug插件</li>\n<li>XPath Checker插件</li>\n</ul>\n<p>1.右键选择－Inspect in FirePath<br>2.复制xpath<br>3.在该页面上右键－&gt;View XPath<br>4.把xpath的路径复制进入该页面，查看是否能够找到自己想要的元素</p>\n<h3 id=\"mongodb的安装以及使用\"><a href=\"#mongodb的安装以及使用\" class=\"headerlink\" title=\"mongodb的安装以及使用\"></a>mongodb的安装以及使用</h3><ul>\n<li><p>一行代码安装mongodbbrew install mongoDB前提是已经安装了brew工具，一次失败就执行第二次<br>*<br>如果上边的方法还是不行，那就只能手动下载了</p>\n<ul>\n<li><a href=\"https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz\" target=\"_blank\" rel=\"external\">https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.2.3.tgz</a></li>\n<li>命令行解压该包tar xzvf mongodb-osx-x86_64-3.2.3.tgz</li>\n<li>将解压后的文件放到一个可以长期放置的地方，然后进入该文件夹</li>\n<li>pwd记录当前文件路径，copy一下，一会儿有用</li>\n<li>vim ~/.zshrc进入配置目录<br><em><br>#mongod config<br>MONGODB_HOME=/Users/shenghuihan/Desktop/mongodb-osx-x86_64-3.2.3<br>PATH=$PATH:$MONGODB_HOME/bin添加bin目录文件到系统搜索目录下\n</em><br>source ~/.zshrc使设置生效</li>\n</ul>\n</li>\n<li>查看mongo是否生效mongo，如果显示版本号说明生效，但是没有启动下面我们来启动服务</li>\n<li>先在同级目录下创建数据文件和日志文件mkdir data和mkdir log</li>\n<li>启动mongodb服务mongod –dbpath data –logpath log/mongod.log –logappend –fork</li>\n<li>再次mongo如果显示connecting to test说明启动成功，输入exit;退出mongo</li>\n<li>将启动命令写入一个启动脚本中echo “mongod –dbpath data –logpath log/mongod.log –logappend –fork” &gt;&gt; start.sh</li>\n<li>可视化工具安装<a href=\"https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载\" target=\"_blank\" rel=\"external\">https://mongohub.s3.amazonaws.com/MongoHub.zip直接去这里下载</a></li>\n<li>安装python操作mongodb的驱动sudo pip install pymongo前提是要安装pip啊，这是一个专门用来安装python各种库的软件</li>\n<li>默认端口27017</li>\n<li>查看ip的方式，db.getMongo()</li>\n</ul>\n<h4 id=\"使用mongodb命令行\"><a href=\"#使用mongodb命令行\" class=\"headerlink\" title=\"使用mongodb命令行\"></a>使用mongodb命令行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">bogon:mongo shenghuihan$ mongo</div><div class=\"line\">MongoDB shell version: 3.2.3</div><div class=\"line\">connecting to: test</div><div class=\"line\">Server has startup warnings: </div><div class=\"line\">2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] </div><div class=\"line\">2016-09-08T17:51:01.057+0800 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000</div><div class=\"line\">&gt; use mydb//创建一个新的库</div><div class=\"line\">switched to db mydb</div><div class=\"line\">&gt; show collections</div><div class=\"line\">&gt; show dbs</div></pre></td></tr></table></figure>\n<h4 id=\"使用以及查看数据\"><a href=\"#使用以及查看数据\" class=\"headerlink\" title=\"使用以及查看数据\"></a>使用以及查看数据</h4><p>我们可以使用mongohub查看数据，当然还可以使用我们最喜欢的python<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">import pymongo</div><div class=\"line\"></div><div class=\"line\">connection = pymongo.MongoClient()</div><div class=\"line\">tdb = connection.jikexueyuan</div><div class=\"line\">post_info = tdb.ceshi</div><div class=\"line\"></div><div class=\"line\">jike = &#123;&apos;name&apos;:u&apos;哈哈哈&apos;&#125;#插入数据</div><div class=\"line\">goog = &#123;&apos;name&apos;:u&apos;校长&apos;&#125;</div><div class=\"line\"></div><div class=\"line\"># post_info.insert(jike)</div><div class=\"line\"># post_info.insert(goog)</div><div class=\"line\">post_info.remove(&#123;&apos;name&apos;:u&apos;校长&apos;&#125;)</div><div class=\"line\"></div><div class=\"line\">print u&apos;操作完成&apos;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">from pymongo import MongoClient</div><div class=\"line\"></div><div class=\"line\">mc = MongoClient(&quot;localhost&quot;,27017)</div><div class=\"line\"></div><div class=\"line\">db = mc.users</div><div class=\"line\"></div><div class=\"line\">c = db.users.find()</div><div class=\"line\"></div><div class=\"line\">db.users.save(&#123;&quot;age&quot;:8&#125;)</div><div class=\"line\"></div><div class=\"line\">for objc in c:</div><div class=\"line\">    print(objc)</div><div class=\"line\"></div><div class=\"line\">mc.close()</div></pre></td></tr></table></figure>"},{"title":"Django部署+apache+mod_wsgi","date":"2016-11-09T06:25:31.000Z","_content":"\n## Django的部署(apache + mod_wsgi)\n\n### 概念解析\n#### Django\nDjango是一个框架，可以用python来开发web应用，但是并不是独立的开发web，在UI放面依然需要依靠html+css+js，用这些来搭建界面，不过我们可以使用django无缝的使用python的逻辑功能，比如使用python来处理数据，然后交给页面来进行展示 \n>Django本身是有web服务器的，但是这个服务器只能在本机提供web服务，其作用主要是用来做测试，如果想其他机器也能访问你的web这个时候你还需要另外一个服务器，提供网络访问的功能\n<!--more-->\n#### apache\nApache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）\n\n#### mod_wsgi\nmod_wsgi的目的是实现一个简单的使用Apache模块可以举办任何Python应用程序支持Python的WSGI接口。该模块将适用于主机的高性能生产的网站，以及一般的自我管理个人网站的网页寄存服务运行。）\n\n#### 虚拟主机\n在apache上配置虚拟主机，这将在你mac上提供一个简单管理多个网站的框架\n\n#### 静态文件\ndjango1.3新加入了一个静态资源管理的app，django.contrib.staticfiles。在以往的django版本中，静态资源的管理一向都是个问题。部分app发布的时候会带上静态资源文件，在部署的时候你必须手动从各个app中将这些静态资源文件复制到同一个static目录。在引入staticfiles后，你只需要执行./manage.py collectstatic就可以很方便的将所用到app中的静态资源复制到同一目录。\nstaticfiles的引入，方便了django静态文件的管理，不过感觉staticfiles的文档写的并不是太清楚，初次使用的时候还是让我有些困惑。\n下面简单的介绍一下staticfiles的主要配置：\n\n-  ` STATIC_ROOT`：运行manage.py collectstatic后静态文件将复制到的目录。注意：不要把你项目的静态文件放到这个目录。这个目录只有在运行collectstatic时才会用到。我最开始想当然的以为这个目录和MEDIA_ROOT的作用是相同的，致使在开发环境下一直无法找到静态文件。\n\n- `STATIC_URL`：设置的static file的起始url，这个只可以在template里面引用到。这个参数和MEDIA_URL的含义差不多。\n\n-  `STATICFILES_DIRS`：除了各个app的static目录以外还需要管理的静态文件位置，比如项目公共的静态文件差不多。和TEMPLATE_DIRS的含义差不多。\n各个APP下static/目录下的静态文件django的开发服务器会自动找到，这点和以前APP下的templates目录差不多。\n在urls.py中加入静态文件处理的代码\n```\nfrom django.contrib.staticfiles.urls import staticfiles_urlpatterns\n# ... the rest of your URLconf goes here ...\nurlpatterns += staticfiles_urlpatterns()\n```\n\n### 各种目录\n- django项目目录\n- 静态文件目录\n- 错误日志目录\n\n### 请求的处理过程\nsitename.conf --> wsgi.py --> settings.py --> urls.py --> views.py\n### 配置的过程\n- python是系统自带不需要安装\n- apache系统自带不需要安装\n#### mod_wsgi安装\n- `brew tap homebrew/apache`\n- `brew install mod_wsgi`\n\n#### django安装及工程创建\n- 安装pip`sudo easy_install pip`\n- 利用pip安装django`（sudo) pip install Django`\n- 检验是否安装成功\n```\n>>> import django\n>>> django.VERSION\n(1, 7, 6, 'final', 0)\n>>> \n>>> django.get_version()\n'1.7.6'\n```\n- 创建工程\n```\ndjango-admin.py startproject project-name\n```\n- 创建app\n到工程的目录下，找到namage.py这个文件\n```\npython manage.py startapp app-name\n```\n#### apache配置\n/etc/apache2/httpd.conf\n这个文内\n- `LoadModule wsgi_module /usr/local/Cellar/mod_wsgi/4.5.6/libexec/mod_wsgi.so`这个目录是安装mod_wsgi这个文件的时候，生成的，找到它\n- `Include /private/etc/apache2/extra/httpd-vhosts.conf`放开这句话，意思是我要使用虚拟主机\n- 配置虚拟主机在httpd-vhosts.conf这个文件内导入文件\n```\ninclude /private/etc/apache2/extra/vhosts/localhost.conf\ninclude /private/etc/apache2/extra/vhosts/dev.mysite.com.conf\n```\n意思是导入这两个文件，作为虚拟主机的配置，但是这两个文件需要自己创建\n- 虚拟主机配置`dev.mysite.com.conf`\n这个是最关键的地方\n```\nListen 89#虚拟主机的监听端口\n<VirtualHost *:89>\n\nLogLevel info\n\nServerName dev.mysite.com#虚拟主机的名字\nServerAdmin my@mysite.com\n\nErrorLog \"/Users/han/Sites/logs/mysite.com-error_log\"\nCustomLog \"/Users/han/Sites/logs/mysite.com-access_log\" common#这两个一定要配置，因为一旦有错误，我们需要依靠这两个文件的内的日志来找到错误\n\n\nWSGIScriptAlias / /Users/han/Documents/mysite/mysite/wsgi.py#这个是整个设置最重要的地方，让apache可以知道使用哪个wsgi\n\n<Directory \"/Users/han/Documents/mysite/mysite\">\n<Files wsgi.py>\nRequire all granted\n</Files>\n</Directory>#设置wsgi的文件权限\n\n#################下边的都不是重点了##################\n# Static files\nDocumentRoot \"/Users/han/Sites/mysite.com\"\n<Directory \"/Users/han/Sites/mysite.com\">\nOptions FollowSymLinks Multiviews\nRequire all granted\n</Directory>\n\nAlias /static/ /Users/han/Sites/mysite.com/static/\n\n<Directory \"/Users/han/Sites/mysite.com/static\">\nRequire all granted\n</Directory>\n\n# WGSI configuration\n#WSGIDaemonProcess dev.mysite.com processes=2 threads=15 display-name=%{GROUP} python-#path=/Users/han/Documents/mysite/:/Users/han/Documents/VirtualEnvs/python2.7-django/lib/python2.7/site-#packages\n\n#WSGIProcessGroup dev.mysite.com\n\n<Directory \"/Users/han/Documents/mysite\">\nOptions FollowSymLinks Multiviews\nRequire all granted\n</Directory>\n\n\n</VirtualHost>\n```\n\n#### django工程配置\n设置wsgi文件，让mod_wsgi知道，使用哪个django项目\n```\nimport os\n\nfrom os.path import join,dirname,abspath\n\nPROJECT_DIR = dirname(dirname(abspath(__file__)))#3\nimport sys # 4\nsys.path.insert(0,PROJECT_DIR) # 5\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"mysite.settings\")\n\napplication = get_wsgi_application()\n```\n最重要的是3，4，5三句，让mod_wsgi知道去哪里找django项目，剩下的就是django的事情了\n\n### 错误说明\n>其实所有的static文件都是非重点，因为我们最终调用的是django的服务，所以没有静态文件，只是不展示而已，不过如果我们需要一些小的icon等等，我们还是需要这个静态文件的，这是后话，先实现服务这是大事\n\n如果我们遇到了权限问题，\n>Permission denied: access to / denied (filesystem path '/Users/han/Documents/mysite use search permissions are missing on a component of the path\n\n像下边这样的，说明我们没有合适的权限，这是所有文档都没有说明白的地方，这里之所以回访问这个是因为在mod_wsgi中进行了设置，mod_wsgi去这个文件中寻找django的服务，但是我们并没有在所有的设置中设置mod_wsgi的访问权限，这是其一，其二我们并不能直接设置mysite的权限，这样到最后我们发现还是一直报这个错误，我们需要设置上层目录的权限，不知道为啥会这么坑爹\n到～目录下，然后\n`chmod o+rx Documents`\n最后我们输入`dev.mysite.com:89`的时候显示的就是django的首页了\n\n### 常用命令行\n- `sudo apachectl restart`重启命令\n- `apachectl confittest`修改配之后测试一下看看哪里有错误，只出现一个OK才是没有问题\n\n","source":"_posts/2016/Django部署-apache-mod-wsgi.md","raw":"---\ntitle: Django部署+apache+mod_wsgi\ndate: 2016-11-09 14:25:31\ntags:\n- Python\ncategories: Python\n---\n\n## Django的部署(apache + mod_wsgi)\n\n### 概念解析\n#### Django\nDjango是一个框架，可以用python来开发web应用，但是并不是独立的开发web，在UI放面依然需要依靠html+css+js，用这些来搭建界面，不过我们可以使用django无缝的使用python的逻辑功能，比如使用python来处理数据，然后交给页面来进行展示 \n>Django本身是有web服务器的，但是这个服务器只能在本机提供web服务，其作用主要是用来做测试，如果想其他机器也能访问你的web这个时候你还需要另外一个服务器，提供网络访问的功能\n<!--more-->\n#### apache\nApache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）\n\n#### mod_wsgi\nmod_wsgi的目的是实现一个简单的使用Apache模块可以举办任何Python应用程序支持Python的WSGI接口。该模块将适用于主机的高性能生产的网站，以及一般的自我管理个人网站的网页寄存服务运行。）\n\n#### 虚拟主机\n在apache上配置虚拟主机，这将在你mac上提供一个简单管理多个网站的框架\n\n#### 静态文件\ndjango1.3新加入了一个静态资源管理的app，django.contrib.staticfiles。在以往的django版本中，静态资源的管理一向都是个问题。部分app发布的时候会带上静态资源文件，在部署的时候你必须手动从各个app中将这些静态资源文件复制到同一个static目录。在引入staticfiles后，你只需要执行./manage.py collectstatic就可以很方便的将所用到app中的静态资源复制到同一目录。\nstaticfiles的引入，方便了django静态文件的管理，不过感觉staticfiles的文档写的并不是太清楚，初次使用的时候还是让我有些困惑。\n下面简单的介绍一下staticfiles的主要配置：\n\n-  ` STATIC_ROOT`：运行manage.py collectstatic后静态文件将复制到的目录。注意：不要把你项目的静态文件放到这个目录。这个目录只有在运行collectstatic时才会用到。我最开始想当然的以为这个目录和MEDIA_ROOT的作用是相同的，致使在开发环境下一直无法找到静态文件。\n\n- `STATIC_URL`：设置的static file的起始url，这个只可以在template里面引用到。这个参数和MEDIA_URL的含义差不多。\n\n-  `STATICFILES_DIRS`：除了各个app的static目录以外还需要管理的静态文件位置，比如项目公共的静态文件差不多。和TEMPLATE_DIRS的含义差不多。\n各个APP下static/目录下的静态文件django的开发服务器会自动找到，这点和以前APP下的templates目录差不多。\n在urls.py中加入静态文件处理的代码\n```\nfrom django.contrib.staticfiles.urls import staticfiles_urlpatterns\n# ... the rest of your URLconf goes here ...\nurlpatterns += staticfiles_urlpatterns()\n```\n\n### 各种目录\n- django项目目录\n- 静态文件目录\n- 错误日志目录\n\n### 请求的处理过程\nsitename.conf --> wsgi.py --> settings.py --> urls.py --> views.py\n### 配置的过程\n- python是系统自带不需要安装\n- apache系统自带不需要安装\n#### mod_wsgi安装\n- `brew tap homebrew/apache`\n- `brew install mod_wsgi`\n\n#### django安装及工程创建\n- 安装pip`sudo easy_install pip`\n- 利用pip安装django`（sudo) pip install Django`\n- 检验是否安装成功\n```\n>>> import django\n>>> django.VERSION\n(1, 7, 6, 'final', 0)\n>>> \n>>> django.get_version()\n'1.7.6'\n```\n- 创建工程\n```\ndjango-admin.py startproject project-name\n```\n- 创建app\n到工程的目录下，找到namage.py这个文件\n```\npython manage.py startapp app-name\n```\n#### apache配置\n/etc/apache2/httpd.conf\n这个文内\n- `LoadModule wsgi_module /usr/local/Cellar/mod_wsgi/4.5.6/libexec/mod_wsgi.so`这个目录是安装mod_wsgi这个文件的时候，生成的，找到它\n- `Include /private/etc/apache2/extra/httpd-vhosts.conf`放开这句话，意思是我要使用虚拟主机\n- 配置虚拟主机在httpd-vhosts.conf这个文件内导入文件\n```\ninclude /private/etc/apache2/extra/vhosts/localhost.conf\ninclude /private/etc/apache2/extra/vhosts/dev.mysite.com.conf\n```\n意思是导入这两个文件，作为虚拟主机的配置，但是这两个文件需要自己创建\n- 虚拟主机配置`dev.mysite.com.conf`\n这个是最关键的地方\n```\nListen 89#虚拟主机的监听端口\n<VirtualHost *:89>\n\nLogLevel info\n\nServerName dev.mysite.com#虚拟主机的名字\nServerAdmin my@mysite.com\n\nErrorLog \"/Users/han/Sites/logs/mysite.com-error_log\"\nCustomLog \"/Users/han/Sites/logs/mysite.com-access_log\" common#这两个一定要配置，因为一旦有错误，我们需要依靠这两个文件的内的日志来找到错误\n\n\nWSGIScriptAlias / /Users/han/Documents/mysite/mysite/wsgi.py#这个是整个设置最重要的地方，让apache可以知道使用哪个wsgi\n\n<Directory \"/Users/han/Documents/mysite/mysite\">\n<Files wsgi.py>\nRequire all granted\n</Files>\n</Directory>#设置wsgi的文件权限\n\n#################下边的都不是重点了##################\n# Static files\nDocumentRoot \"/Users/han/Sites/mysite.com\"\n<Directory \"/Users/han/Sites/mysite.com\">\nOptions FollowSymLinks Multiviews\nRequire all granted\n</Directory>\n\nAlias /static/ /Users/han/Sites/mysite.com/static/\n\n<Directory \"/Users/han/Sites/mysite.com/static\">\nRequire all granted\n</Directory>\n\n# WGSI configuration\n#WSGIDaemonProcess dev.mysite.com processes=2 threads=15 display-name=%{GROUP} python-#path=/Users/han/Documents/mysite/:/Users/han/Documents/VirtualEnvs/python2.7-django/lib/python2.7/site-#packages\n\n#WSGIProcessGroup dev.mysite.com\n\n<Directory \"/Users/han/Documents/mysite\">\nOptions FollowSymLinks Multiviews\nRequire all granted\n</Directory>\n\n\n</VirtualHost>\n```\n\n#### django工程配置\n设置wsgi文件，让mod_wsgi知道，使用哪个django项目\n```\nimport os\n\nfrom os.path import join,dirname,abspath\n\nPROJECT_DIR = dirname(dirname(abspath(__file__)))#3\nimport sys # 4\nsys.path.insert(0,PROJECT_DIR) # 5\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"mysite.settings\")\n\napplication = get_wsgi_application()\n```\n最重要的是3，4，5三句，让mod_wsgi知道去哪里找django项目，剩下的就是django的事情了\n\n### 错误说明\n>其实所有的static文件都是非重点，因为我们最终调用的是django的服务，所以没有静态文件，只是不展示而已，不过如果我们需要一些小的icon等等，我们还是需要这个静态文件的，这是后话，先实现服务这是大事\n\n如果我们遇到了权限问题，\n>Permission denied: access to / denied (filesystem path '/Users/han/Documents/mysite use search permissions are missing on a component of the path\n\n像下边这样的，说明我们没有合适的权限，这是所有文档都没有说明白的地方，这里之所以回访问这个是因为在mod_wsgi中进行了设置，mod_wsgi去这个文件中寻找django的服务，但是我们并没有在所有的设置中设置mod_wsgi的访问权限，这是其一，其二我们并不能直接设置mysite的权限，这样到最后我们发现还是一直报这个错误，我们需要设置上层目录的权限，不知道为啥会这么坑爹\n到～目录下，然后\n`chmod o+rx Documents`\n最后我们输入`dev.mysite.com:89`的时候显示的就是django的首页了\n\n### 常用命令行\n- `sudo apachectl restart`重启命令\n- `apachectl confittest`修改配之后测试一下看看哪里有错误，只出现一个OK才是没有问题\n\n","slug":"2016/Django部署-apache-mod-wsgi","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnn004lsauanyq3sh9f","content":"<h2 id=\"Django的部署-apache-mod-wsgi\"><a href=\"#Django的部署-apache-mod-wsgi\" class=\"headerlink\" title=\"Django的部署(apache + mod_wsgi)\"></a>Django的部署(apache + mod_wsgi)</h2><h3 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h3><h4 id=\"Django\"><a href=\"#Django\" class=\"headerlink\" title=\"Django\"></a>Django</h4><p>Django是一个框架，可以用python来开发web应用，但是并不是独立的开发web，在UI放面依然需要依靠html+css+js，用这些来搭建界面，不过我们可以使用django无缝的使用python的逻辑功能，比如使用python来处理数据，然后交给页面来进行展示 </p>\n<blockquote>\n<p>Django本身是有web服务器的，但是这个服务器只能在本机提供web服务，其作用主要是用来做测试，如果想其他机器也能访问你的web这个时候你还需要另外一个服务器，提供网络访问的功能<br><a id=\"more\"></a></p>\n<h4 id=\"apache\"><a href=\"#apache\" class=\"headerlink\" title=\"apache\"></a>apache</h4><p>Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）</p>\n</blockquote>\n<h4 id=\"mod-wsgi\"><a href=\"#mod-wsgi\" class=\"headerlink\" title=\"mod_wsgi\"></a>mod_wsgi</h4><p>mod_wsgi的目的是实现一个简单的使用Apache模块可以举办任何Python应用程序支持Python的WSGI接口。该模块将适用于主机的高性能生产的网站，以及一般的自我管理个人网站的网页寄存服务运行。）</p>\n<h4 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h4><p>在apache上配置虚拟主机，这将在你mac上提供一个简单管理多个网站的框架</p>\n<h4 id=\"静态文件\"><a href=\"#静态文件\" class=\"headerlink\" title=\"静态文件\"></a>静态文件</h4><p>django1.3新加入了一个静态资源管理的app，django.contrib.staticfiles。在以往的django版本中，静态资源的管理一向都是个问题。部分app发布的时候会带上静态资源文件，在部署的时候你必须手动从各个app中将这些静态资源文件复制到同一个static目录。在引入staticfiles后，你只需要执行./manage.py collectstatic就可以很方便的将所用到app中的静态资源复制到同一目录。<br>staticfiles的引入，方便了django静态文件的管理，不过感觉staticfiles的文档写的并不是太清楚，初次使用的时候还是让我有些困惑。<br>下面简单的介绍一下staticfiles的主要配置：</p>\n<ul>\n<li><p><code>STATIC_ROOT</code>：运行manage.py collectstatic后静态文件将复制到的目录。注意：不要把你项目的静态文件放到这个目录。这个目录只有在运行collectstatic时才会用到。我最开始想当然的以为这个目录和MEDIA_ROOT的作用是相同的，致使在开发环境下一直无法找到静态文件。</p>\n</li>\n<li><p><code>STATIC_URL</code>：设置的static file的起始url，这个只可以在template里面引用到。这个参数和MEDIA_URL的含义差不多。</p>\n</li>\n<li><p><code>STATICFILES_DIRS</code>：除了各个app的static目录以外还需要管理的静态文件位置，比如项目公共的静态文件差不多。和TEMPLATE_DIRS的含义差不多。<br>各个APP下static/目录下的静态文件django的开发服务器会自动找到，这点和以前APP下的templates目录差不多。<br>在urls.py中加入静态文件处理的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.contrib.staticfiles.urls import staticfiles_urlpatterns</div><div class=\"line\"># ... the rest of your URLconf goes here ...</div><div class=\"line\">urlpatterns += staticfiles_urlpatterns()</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"各种目录\"><a href=\"#各种目录\" class=\"headerlink\" title=\"各种目录\"></a>各种目录</h3><ul>\n<li>django项目目录</li>\n<li>静态文件目录</li>\n<li>错误日志目录</li>\n</ul>\n<h3 id=\"请求的处理过程\"><a href=\"#请求的处理过程\" class=\"headerlink\" title=\"请求的处理过程\"></a>请求的处理过程</h3><p>sitename.conf –&gt; wsgi.py –&gt; settings.py –&gt; urls.py –&gt; views.py</p>\n<h3 id=\"配置的过程\"><a href=\"#配置的过程\" class=\"headerlink\" title=\"配置的过程\"></a>配置的过程</h3><ul>\n<li>python是系统自带不需要安装</li>\n<li>apache系统自带不需要安装<h4 id=\"mod-wsgi安装\"><a href=\"#mod-wsgi安装\" class=\"headerlink\" title=\"mod_wsgi安装\"></a>mod_wsgi安装</h4></li>\n<li><code>brew tap homebrew/apache</code></li>\n<li><code>brew install mod_wsgi</code></li>\n</ul>\n<h4 id=\"django安装及工程创建\"><a href=\"#django安装及工程创建\" class=\"headerlink\" title=\"django安装及工程创建\"></a>django安装及工程创建</h4><ul>\n<li>安装pip<code>sudo easy_install pip</code></li>\n<li>利用pip安装django<code>（sudo) pip install Django</code></li>\n<li><p>检验是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import django</div><div class=\"line\">&gt;&gt;&gt; django.VERSION</div><div class=\"line\">(1, 7, 6, &apos;final&apos;, 0)</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\">&gt;&gt;&gt; django.get_version()</div><div class=\"line\">&apos;1.7.6&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建工程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">django-admin.py startproject project-name</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建app<br>到工程的目录下，找到namage.py这个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python manage.py startapp app-name</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"apache配置\"><a href=\"#apache配置\" class=\"headerlink\" title=\"apache配置\"></a>apache配置</h4><p>/etc/apache2/httpd.conf<br>这个文内</p>\n<ul>\n<li><code>LoadModule wsgi_module /usr/local/Cellar/mod_wsgi/4.5.6/libexec/mod_wsgi.so</code>这个目录是安装mod_wsgi这个文件的时候，生成的，找到它</li>\n<li><code>Include /private/etc/apache2/extra/httpd-vhosts.conf</code>放开这句话，意思是我要使用虚拟主机</li>\n<li>配置虚拟主机在httpd-vhosts.conf这个文件内导入文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">include /private/etc/apache2/extra/vhosts/localhost.conf</div><div class=\"line\">include /private/etc/apache2/extra/vhosts/dev.mysite.com.conf</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>意思是导入这两个文件，作为虚拟主机的配置，但是这两个文件需要自己创建</p>\n<ul>\n<li>虚拟主机配置<code>dev.mysite.com.conf</code><br>这个是最关键的地方<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">Listen 89#虚拟主机的监听端口</div><div class=\"line\">&lt;VirtualHost *:89&gt;</div><div class=\"line\"></div><div class=\"line\">LogLevel info</div><div class=\"line\"></div><div class=\"line\">ServerName dev.mysite.com#虚拟主机的名字</div><div class=\"line\">ServerAdmin my@mysite.com</div><div class=\"line\"></div><div class=\"line\">ErrorLog &quot;/Users/han/Sites/logs/mysite.com-error_log&quot;</div><div class=\"line\">CustomLog &quot;/Users/han/Sites/logs/mysite.com-access_log&quot; common#这两个一定要配置，因为一旦有错误，我们需要依靠这两个文件的内的日志来找到错误</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">WSGIScriptAlias / /Users/han/Documents/mysite/mysite/wsgi.py#这个是整个设置最重要的地方，让apache可以知道使用哪个wsgi</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Documents/mysite/mysite&quot;&gt;</div><div class=\"line\">&lt;Files wsgi.py&gt;</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Files&gt;</div><div class=\"line\">&lt;/Directory&gt;#设置wsgi的文件权限</div><div class=\"line\"></div><div class=\"line\">#################下边的都不是重点了##################</div><div class=\"line\"># Static files</div><div class=\"line\">DocumentRoot &quot;/Users/han/Sites/mysite.com&quot;</div><div class=\"line\">&lt;Directory &quot;/Users/han/Sites/mysite.com&quot;&gt;</div><div class=\"line\">Options FollowSymLinks Multiviews</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\">Alias /static/ /Users/han/Sites/mysite.com/static/</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Sites/mysite.com/static&quot;&gt;</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\"># WGSI configuration</div><div class=\"line\">#WSGIDaemonProcess dev.mysite.com processes=2 threads=15 display-name=%&#123;GROUP&#125; python-#path=/Users/han/Documents/mysite/:/Users/han/Documents/VirtualEnvs/python2.7-django/lib/python2.7/site-#packages</div><div class=\"line\"></div><div class=\"line\">#WSGIProcessGroup dev.mysite.com</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Documents/mysite&quot;&gt;</div><div class=\"line\">Options FollowSymLinks Multiviews</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"django工程配置\"><a href=\"#django工程配置\" class=\"headerlink\" title=\"django工程配置\"></a>django工程配置</h4><p>设置wsgi文件，让mod_wsgi知道，使用哪个django项目<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\"></div><div class=\"line\">from os.path import join,dirname,abspath</div><div class=\"line\"></div><div class=\"line\">PROJECT_DIR = dirname(dirname(abspath(__file__)))#3</div><div class=\"line\">import sys # 4</div><div class=\"line\">sys.path.insert(0,PROJECT_DIR) # 5</div><div class=\"line\"></div><div class=\"line\">from django.core.wsgi import get_wsgi_application</div><div class=\"line\"></div><div class=\"line\">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)</div><div class=\"line\"></div><div class=\"line\">application = get_wsgi_application()</div></pre></td></tr></table></figure></p>\n<p>最重要的是3，4，5三句，让mod_wsgi知道去哪里找django项目，剩下的就是django的事情了</p>\n<h3 id=\"错误说明\"><a href=\"#错误说明\" class=\"headerlink\" title=\"错误说明\"></a>错误说明</h3><blockquote>\n<p>其实所有的static文件都是非重点，因为我们最终调用的是django的服务，所以没有静态文件，只是不展示而已，不过如果我们需要一些小的icon等等，我们还是需要这个静态文件的，这是后话，先实现服务这是大事</p>\n</blockquote>\n<p>如果我们遇到了权限问题，</p>\n<blockquote>\n<p>Permission denied: access to / denied (filesystem path ‘/Users/han/Documents/mysite use search permissions are missing on a component of the path</p>\n</blockquote>\n<p>像下边这样的，说明我们没有合适的权限，这是所有文档都没有说明白的地方，这里之所以回访问这个是因为在mod_wsgi中进行了设置，mod_wsgi去这个文件中寻找django的服务，但是我们并没有在所有的设置中设置mod_wsgi的访问权限，这是其一，其二我们并不能直接设置mysite的权限，这样到最后我们发现还是一直报这个错误，我们需要设置上层目录的权限，不知道为啥会这么坑爹<br>到～目录下，然后<br><code>chmod o+rx Documents</code><br>最后我们输入<code>dev.mysite.com:89</code>的时候显示的就是django的首页了</p>\n<h3 id=\"常用命令行\"><a href=\"#常用命令行\" class=\"headerlink\" title=\"常用命令行\"></a>常用命令行</h3><ul>\n<li><code>sudo apachectl restart</code>重启命令</li>\n<li><code>apachectl confittest</code>修改配之后测试一下看看哪里有错误，只出现一个OK才是没有问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Django的部署-apache-mod-wsgi\"><a href=\"#Django的部署-apache-mod-wsgi\" class=\"headerlink\" title=\"Django的部署(apache + mod_wsgi)\"></a>Django的部署(apache + mod_wsgi)</h2><h3 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h3><h4 id=\"Django\"><a href=\"#Django\" class=\"headerlink\" title=\"Django\"></a>Django</h4><p>Django是一个框架，可以用python来开发web应用，但是并不是独立的开发web，在UI放面依然需要依靠html+css+js，用这些来搭建界面，不过我们可以使用django无缝的使用python的逻辑功能，比如使用python来处理数据，然后交给页面来进行展示 </p>\n<blockquote>\n<p>Django本身是有web服务器的，但是这个服务器只能在本机提供web服务，其作用主要是用来做测试，如果想其他机器也能访问你的web这个时候你还需要另外一个服务器，提供网络访问的功能<br>","more":"</p>\n<h4 id=\"apache\"><a href=\"#apache\" class=\"headerlink\" title=\"apache\"></a>apache</h4><p>Apache是专门用了提供HTTP服务的，以及相关配置的（例如虚拟主机、URL转发等等）</p>\n</blockquote>\n<h4 id=\"mod-wsgi\"><a href=\"#mod-wsgi\" class=\"headerlink\" title=\"mod_wsgi\"></a>mod_wsgi</h4><p>mod_wsgi的目的是实现一个简单的使用Apache模块可以举办任何Python应用程序支持Python的WSGI接口。该模块将适用于主机的高性能生产的网站，以及一般的自我管理个人网站的网页寄存服务运行。）</p>\n<h4 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h4><p>在apache上配置虚拟主机，这将在你mac上提供一个简单管理多个网站的框架</p>\n<h4 id=\"静态文件\"><a href=\"#静态文件\" class=\"headerlink\" title=\"静态文件\"></a>静态文件</h4><p>django1.3新加入了一个静态资源管理的app，django.contrib.staticfiles。在以往的django版本中，静态资源的管理一向都是个问题。部分app发布的时候会带上静态资源文件，在部署的时候你必须手动从各个app中将这些静态资源文件复制到同一个static目录。在引入staticfiles后，你只需要执行./manage.py collectstatic就可以很方便的将所用到app中的静态资源复制到同一目录。<br>staticfiles的引入，方便了django静态文件的管理，不过感觉staticfiles的文档写的并不是太清楚，初次使用的时候还是让我有些困惑。<br>下面简单的介绍一下staticfiles的主要配置：</p>\n<ul>\n<li><p><code>STATIC_ROOT</code>：运行manage.py collectstatic后静态文件将复制到的目录。注意：不要把你项目的静态文件放到这个目录。这个目录只有在运行collectstatic时才会用到。我最开始想当然的以为这个目录和MEDIA_ROOT的作用是相同的，致使在开发环境下一直无法找到静态文件。</p>\n</li>\n<li><p><code>STATIC_URL</code>：设置的static file的起始url，这个只可以在template里面引用到。这个参数和MEDIA_URL的含义差不多。</p>\n</li>\n<li><p><code>STATICFILES_DIRS</code>：除了各个app的static目录以外还需要管理的静态文件位置，比如项目公共的静态文件差不多。和TEMPLATE_DIRS的含义差不多。<br>各个APP下static/目录下的静态文件django的开发服务器会自动找到，这点和以前APP下的templates目录差不多。<br>在urls.py中加入静态文件处理的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">from django.contrib.staticfiles.urls import staticfiles_urlpatterns</div><div class=\"line\"># ... the rest of your URLconf goes here ...</div><div class=\"line\">urlpatterns += staticfiles_urlpatterns()</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"各种目录\"><a href=\"#各种目录\" class=\"headerlink\" title=\"各种目录\"></a>各种目录</h3><ul>\n<li>django项目目录</li>\n<li>静态文件目录</li>\n<li>错误日志目录</li>\n</ul>\n<h3 id=\"请求的处理过程\"><a href=\"#请求的处理过程\" class=\"headerlink\" title=\"请求的处理过程\"></a>请求的处理过程</h3><p>sitename.conf –&gt; wsgi.py –&gt; settings.py –&gt; urls.py –&gt; views.py</p>\n<h3 id=\"配置的过程\"><a href=\"#配置的过程\" class=\"headerlink\" title=\"配置的过程\"></a>配置的过程</h3><ul>\n<li>python是系统自带不需要安装</li>\n<li>apache系统自带不需要安装<h4 id=\"mod-wsgi安装\"><a href=\"#mod-wsgi安装\" class=\"headerlink\" title=\"mod_wsgi安装\"></a>mod_wsgi安装</h4></li>\n<li><code>brew tap homebrew/apache</code></li>\n<li><code>brew install mod_wsgi</code></li>\n</ul>\n<h4 id=\"django安装及工程创建\"><a href=\"#django安装及工程创建\" class=\"headerlink\" title=\"django安装及工程创建\"></a>django安装及工程创建</h4><ul>\n<li>安装pip<code>sudo easy_install pip</code></li>\n<li>利用pip安装django<code>（sudo) pip install Django</code></li>\n<li><p>检验是否安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt;&gt;&gt; import django</div><div class=\"line\">&gt;&gt;&gt; django.VERSION</div><div class=\"line\">(1, 7, 6, &apos;final&apos;, 0)</div><div class=\"line\">&gt;&gt;&gt; </div><div class=\"line\">&gt;&gt;&gt; django.get_version()</div><div class=\"line\">&apos;1.7.6&apos;</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建工程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">django-admin.py startproject project-name</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建app<br>到工程的目录下，找到namage.py这个文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">python manage.py startapp app-name</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"apache配置\"><a href=\"#apache配置\" class=\"headerlink\" title=\"apache配置\"></a>apache配置</h4><p>/etc/apache2/httpd.conf<br>这个文内</p>\n<ul>\n<li><code>LoadModule wsgi_module /usr/local/Cellar/mod_wsgi/4.5.6/libexec/mod_wsgi.so</code>这个目录是安装mod_wsgi这个文件的时候，生成的，找到它</li>\n<li><code>Include /private/etc/apache2/extra/httpd-vhosts.conf</code>放开这句话，意思是我要使用虚拟主机</li>\n<li>配置虚拟主机在httpd-vhosts.conf这个文件内导入文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">include /private/etc/apache2/extra/vhosts/localhost.conf</div><div class=\"line\">include /private/etc/apache2/extra/vhosts/dev.mysite.com.conf</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>意思是导入这两个文件，作为虚拟主机的配置，但是这两个文件需要自己创建</p>\n<ul>\n<li>虚拟主机配置<code>dev.mysite.com.conf</code><br>这个是最关键的地方<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">Listen 89#虚拟主机的监听端口</div><div class=\"line\">&lt;VirtualHost *:89&gt;</div><div class=\"line\"></div><div class=\"line\">LogLevel info</div><div class=\"line\"></div><div class=\"line\">ServerName dev.mysite.com#虚拟主机的名字</div><div class=\"line\">ServerAdmin my@mysite.com</div><div class=\"line\"></div><div class=\"line\">ErrorLog &quot;/Users/han/Sites/logs/mysite.com-error_log&quot;</div><div class=\"line\">CustomLog &quot;/Users/han/Sites/logs/mysite.com-access_log&quot; common#这两个一定要配置，因为一旦有错误，我们需要依靠这两个文件的内的日志来找到错误</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">WSGIScriptAlias / /Users/han/Documents/mysite/mysite/wsgi.py#这个是整个设置最重要的地方，让apache可以知道使用哪个wsgi</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Documents/mysite/mysite&quot;&gt;</div><div class=\"line\">&lt;Files wsgi.py&gt;</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Files&gt;</div><div class=\"line\">&lt;/Directory&gt;#设置wsgi的文件权限</div><div class=\"line\"></div><div class=\"line\">#################下边的都不是重点了##################</div><div class=\"line\"># Static files</div><div class=\"line\">DocumentRoot &quot;/Users/han/Sites/mysite.com&quot;</div><div class=\"line\">&lt;Directory &quot;/Users/han/Sites/mysite.com&quot;&gt;</div><div class=\"line\">Options FollowSymLinks Multiviews</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\">Alias /static/ /Users/han/Sites/mysite.com/static/</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Sites/mysite.com/static&quot;&gt;</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\"># WGSI configuration</div><div class=\"line\">#WSGIDaemonProcess dev.mysite.com processes=2 threads=15 display-name=%&#123;GROUP&#125; python-#path=/Users/han/Documents/mysite/:/Users/han/Documents/VirtualEnvs/python2.7-django/lib/python2.7/site-#packages</div><div class=\"line\"></div><div class=\"line\">#WSGIProcessGroup dev.mysite.com</div><div class=\"line\"></div><div class=\"line\">&lt;Directory &quot;/Users/han/Documents/mysite&quot;&gt;</div><div class=\"line\">Options FollowSymLinks Multiviews</div><div class=\"line\">Require all granted</div><div class=\"line\">&lt;/Directory&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"django工程配置\"><a href=\"#django工程配置\" class=\"headerlink\" title=\"django工程配置\"></a>django工程配置</h4><p>设置wsgi文件，让mod_wsgi知道，使用哪个django项目<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">import os</div><div class=\"line\"></div><div class=\"line\">from os.path import join,dirname,abspath</div><div class=\"line\"></div><div class=\"line\">PROJECT_DIR = dirname(dirname(abspath(__file__)))#3</div><div class=\"line\">import sys # 4</div><div class=\"line\">sys.path.insert(0,PROJECT_DIR) # 5</div><div class=\"line\"></div><div class=\"line\">from django.core.wsgi import get_wsgi_application</div><div class=\"line\"></div><div class=\"line\">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;mysite.settings&quot;)</div><div class=\"line\"></div><div class=\"line\">application = get_wsgi_application()</div></pre></td></tr></table></figure></p>\n<p>最重要的是3，4，5三句，让mod_wsgi知道去哪里找django项目，剩下的就是django的事情了</p>\n<h3 id=\"错误说明\"><a href=\"#错误说明\" class=\"headerlink\" title=\"错误说明\"></a>错误说明</h3><blockquote>\n<p>其实所有的static文件都是非重点，因为我们最终调用的是django的服务，所以没有静态文件，只是不展示而已，不过如果我们需要一些小的icon等等，我们还是需要这个静态文件的，这是后话，先实现服务这是大事</p>\n</blockquote>\n<p>如果我们遇到了权限问题，</p>\n<blockquote>\n<p>Permission denied: access to / denied (filesystem path ‘/Users/han/Documents/mysite use search permissions are missing on a component of the path</p>\n</blockquote>\n<p>像下边这样的，说明我们没有合适的权限，这是所有文档都没有说明白的地方，这里之所以回访问这个是因为在mod_wsgi中进行了设置，mod_wsgi去这个文件中寻找django的服务，但是我们并没有在所有的设置中设置mod_wsgi的访问权限，这是其一，其二我们并不能直接设置mysite的权限，这样到最后我们发现还是一直报这个错误，我们需要设置上层目录的权限，不知道为啥会这么坑爹<br>到～目录下，然后<br><code>chmod o+rx Documents</code><br>最后我们输入<code>dev.mysite.com:89</code>的时候显示的就是django的首页了</p>\n<h3 id=\"常用命令行\"><a href=\"#常用命令行\" class=\"headerlink\" title=\"常用命令行\"></a>常用命令行</h3><ul>\n<li><code>sudo apachectl restart</code>重启命令</li>\n<li><code>apachectl confittest</code>修改配之后测试一下看看哪里有错误，只出现一个OK才是没有问题</li>\n</ul>"},{"title":"FLV格式解析","date":"2016-07-30T07:17:30.000Z","_content":"FLV 是 FLASH VIDEO 的简称,，FLV流媒体格式是一种新的视频格式，全称为Flash Video。FLV 压缩与转换非常方便，适合做短片.，并且 FLV 可以很好的保护原始地址，不容易下载到，可以起到保护版权的目的\n<!--more-->\n\n\n最近要用到flv，整理了一些flv格式的资料，供参考。 flv文件主要由两部分组成：header和body。\n\n## 1.header\n\nheader部分记录了flv的类型、版本等信息，是flv的开头，一般都差不多，占9bytes。具体格式如下：\n\n|文件类型\t | 3bytes | “FLV”|\n|-----------|\n|版本\t| 1 byte|\t一般为0x01|\n|流信息\t|1 byte\t|倒数第一位是1表示有视频，倒数第三位是1表示有音频，倒数第二、四位必须为0|\n|header长度|\t4 bytes | 整个header的长度，一般为9；大于9表示下面还有扩展信息|\n\n## 2.body\n\nbody部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图： flv\n![](http://i1.piimg.com/567571/9a6b94bf91e209d3.jpg)\n### 2.1.Tag\n每个Tag由也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息，具体如下：\n\n|名称|\t长度|\t介绍|\n|------|\n|Tag类型 |1 bytes |8：音频 9：视频 18：脚本  其他：保留\n|数据区长度\t|3 bytes|\t在数据区的长度|\n|时间戳\t|3 bytes\t|整数，单位是毫秒。对于脚本型的tag总是0|\n|时间戳扩展|\t1 bytes\t|将时间戳扩展为4bytes，代表高8位。很少用到\n|StreamsID\t|3 bytes\t|总是0|\n\n数据区(data)\t由数据区长度决定\t数据实体\n### 2.2.Tag Data\n数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。\n#### 2.2.1.音频数据\n第一个byte是音频的信息，格式如下。\n\n|名称|长度\t|介绍|\n|------------|\n|音频格式|\t4 bits\t|0 = Linear PCM, platform endian,1 = ADPCM,2 = MP3,3 = Linear PCM, little endian,4 = Nellymoser 16-kHz mono,5 = Nellymoser 8-kHz mono,6 = Nellymoser,7 = G.711 A-law logarithmic PCM,8 = G.711 mu-law logarithmic PCM,9 = reserved,10 = AAC,11 = Speex,14 = MP3 8-Khz,15 = Device-specific sound|\n|采样率\t|2 bits\t|0 = 5.5-kHz,1 = 11-kHz,2 = 22-kHz,3 = 44-kHz,对于AAC总是3|\n|采样的长度\t|1 bit\t|0 = snd8Bit,1 = snd16Bit,压缩过的音频都是16bit\n|音频类型\t|1 bit\t|0 = sndMono,1 = sndStereo,对于AAC总是1|\n第2byte开始就是音频流数据了。\n#### 2.2.2.视频数据\n和音频数据一样，第一个byte是视频信息，格式如下：\n\n|名称\t|长度\t|介绍|\n|----------------|\n|帧类型\t|4 bits\t|1: keyframe (for AVC, a seekable frame)\n2: inter frame (for AVC, a non-seekable frame)\n3: disposable inter frame (H.263 only)\n4: generated keyframe (reserved for server use only)\n5: video info/command frame|\n|编码ID\t|4 bits\t|1: JPEG (currently unused)\n2: Sorenson H.263\n3: Screen video\n4: On2 VP6\n5: On2 VP6 with alpha channel\n6: Screen video version 2\n7: AVC|\n#### 2.2.3脚本数据\n脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。\n首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。\n其中数据类型的种类有：\n\n- 0 = Number type\n- 1 = Boolean type\n- 2 = String type\n- 3 = Object type\n- 4 = MovieClip type\n- 5 = Null type\n- 6 = Undefined type\n- 7 = Reference type\n- 8 = ECMA array type\n- 10 = Strict array type\n- 11 = Date type\n- 12 = Long string type\n\n如果类型为String，后面的2bytes为字符串的长度（Long String是4bytes），再后面才是字符串数据；如果是Number类型，后面的8bytes为Double类型的数据；Boolean类型，后面1byte为Bool类型。\n\n知道了这些后再来看看flv中的脚本，一般开头是0x02，表示String类型，后面的2bytes为字符串长度，一般是0x000a（“onMetaData”的长度），再后面就是字符串“onMetaData”。好像flv格式的文件都有onMetaData标记，在运行ActionScript的时候会用到它。后面跟的是0x08，表示ECMA Array类型，这个和Map比较相似，一个键跟着一个值。键都是String类型的，所以开头的0x02被省略了，直接跟着的是字符串的长度，然后是字符串，再是值的类型，也就是上面介绍的那些了。\n\n## 3.总结\n\nflv的格式还是比较简单的，header部分很简洁，body部分都是由一个个tag，tag的话也就三种，脚本tag一般只有一个的，我想这也是flv能成为在线视频格式的原因吧。只要了解了格式，我们就可以写个程序来解析flv文件了，这也是我下一步要做的。\n最后附上flv官方手册：video_file_format_spec_v10\n","source":"_posts/2016/FLV格式解析.md","raw":"---\ntitle: FLV格式解析\ndate: 2016-07-30 15:17:30\ntags:\n- 流媒体\ncategories: 基础\n\n---\nFLV 是 FLASH VIDEO 的简称,，FLV流媒体格式是一种新的视频格式，全称为Flash Video。FLV 压缩与转换非常方便，适合做短片.，并且 FLV 可以很好的保护原始地址，不容易下载到，可以起到保护版权的目的\n<!--more-->\n\n\n最近要用到flv，整理了一些flv格式的资料，供参考。 flv文件主要由两部分组成：header和body。\n\n## 1.header\n\nheader部分记录了flv的类型、版本等信息，是flv的开头，一般都差不多，占9bytes。具体格式如下：\n\n|文件类型\t | 3bytes | “FLV”|\n|-----------|\n|版本\t| 1 byte|\t一般为0x01|\n|流信息\t|1 byte\t|倒数第一位是1表示有视频，倒数第三位是1表示有音频，倒数第二、四位必须为0|\n|header长度|\t4 bytes | 整个header的长度，一般为9；大于9表示下面还有扩展信息|\n\n## 2.body\n\nbody部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图： flv\n![](http://i1.piimg.com/567571/9a6b94bf91e209d3.jpg)\n### 2.1.Tag\n每个Tag由也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息，具体如下：\n\n|名称|\t长度|\t介绍|\n|------|\n|Tag类型 |1 bytes |8：音频 9：视频 18：脚本  其他：保留\n|数据区长度\t|3 bytes|\t在数据区的长度|\n|时间戳\t|3 bytes\t|整数，单位是毫秒。对于脚本型的tag总是0|\n|时间戳扩展|\t1 bytes\t|将时间戳扩展为4bytes，代表高8位。很少用到\n|StreamsID\t|3 bytes\t|总是0|\n\n数据区(data)\t由数据区长度决定\t数据实体\n### 2.2.Tag Data\n数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。\n#### 2.2.1.音频数据\n第一个byte是音频的信息，格式如下。\n\n|名称|长度\t|介绍|\n|------------|\n|音频格式|\t4 bits\t|0 = Linear PCM, platform endian,1 = ADPCM,2 = MP3,3 = Linear PCM, little endian,4 = Nellymoser 16-kHz mono,5 = Nellymoser 8-kHz mono,6 = Nellymoser,7 = G.711 A-law logarithmic PCM,8 = G.711 mu-law logarithmic PCM,9 = reserved,10 = AAC,11 = Speex,14 = MP3 8-Khz,15 = Device-specific sound|\n|采样率\t|2 bits\t|0 = 5.5-kHz,1 = 11-kHz,2 = 22-kHz,3 = 44-kHz,对于AAC总是3|\n|采样的长度\t|1 bit\t|0 = snd8Bit,1 = snd16Bit,压缩过的音频都是16bit\n|音频类型\t|1 bit\t|0 = sndMono,1 = sndStereo,对于AAC总是1|\n第2byte开始就是音频流数据了。\n#### 2.2.2.视频数据\n和音频数据一样，第一个byte是视频信息，格式如下：\n\n|名称\t|长度\t|介绍|\n|----------------|\n|帧类型\t|4 bits\t|1: keyframe (for AVC, a seekable frame)\n2: inter frame (for AVC, a non-seekable frame)\n3: disposable inter frame (H.263 only)\n4: generated keyframe (reserved for server use only)\n5: video info/command frame|\n|编码ID\t|4 bits\t|1: JPEG (currently unused)\n2: Sorenson H.263\n3: Screen video\n4: On2 VP6\n5: On2 VP6 with alpha channel\n6: Screen video version 2\n7: AVC|\n#### 2.2.3脚本数据\n脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。\n首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。\n其中数据类型的种类有：\n\n- 0 = Number type\n- 1 = Boolean type\n- 2 = String type\n- 3 = Object type\n- 4 = MovieClip type\n- 5 = Null type\n- 6 = Undefined type\n- 7 = Reference type\n- 8 = ECMA array type\n- 10 = Strict array type\n- 11 = Date type\n- 12 = Long string type\n\n如果类型为String，后面的2bytes为字符串的长度（Long String是4bytes），再后面才是字符串数据；如果是Number类型，后面的8bytes为Double类型的数据；Boolean类型，后面1byte为Bool类型。\n\n知道了这些后再来看看flv中的脚本，一般开头是0x02，表示String类型，后面的2bytes为字符串长度，一般是0x000a（“onMetaData”的长度），再后面就是字符串“onMetaData”。好像flv格式的文件都有onMetaData标记，在运行ActionScript的时候会用到它。后面跟的是0x08，表示ECMA Array类型，这个和Map比较相似，一个键跟着一个值。键都是String类型的，所以开头的0x02被省略了，直接跟着的是字符串的长度，然后是字符串，再是值的类型，也就是上面介绍的那些了。\n\n## 3.总结\n\nflv的格式还是比较简单的，header部分很简洁，body部分都是由一个个tag，tag的话也就三种，脚本tag一般只有一个的，我想这也是flv能成为在线视频格式的原因吧。只要了解了格式，我们就可以写个程序来解析flv文件了，这也是我下一步要做的。\n最后附上flv官方手册：video_file_format_spec_v10\n","slug":"2016/FLV格式解析","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pno004nsauaozlkrvbt","content":"<p>FLV 是 FLASH VIDEO 的简称,，FLV流媒体格式是一种新的视频格式，全称为Flash Video。FLV 压缩与转换非常方便，适合做短片.，并且 FLV 可以很好的保护原始地址，不容易下载到，可以起到保护版权的目的<br><a id=\"more\"></a></p>\n<p>最近要用到flv，整理了一些flv格式的资料，供参考。 flv文件主要由两部分组成：header和body。</p>\n<h2 id=\"1-header\"><a href=\"#1-header\" class=\"headerlink\" title=\"1.header\"></a>1.header</h2><p>header部分记录了flv的类型、版本等信息，是flv的开头，一般都差不多，占9bytes。具体格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>3bytes</th>\n<th>“FLV”</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>版本</td>\n<td>1 byte</td>\n<td>一般为0x01</td>\n</tr>\n<tr>\n<td>流信息</td>\n<td>1 byte</td>\n<td>倒数第一位是1表示有视频，倒数第三位是1表示有音频，倒数第二、四位必须为0</td>\n</tr>\n<tr>\n<td>header长度</td>\n<td>4 bytes</td>\n<td>整个header的长度，一般为9；大于9表示下面还有扩展信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-body\"><a href=\"#2-body\" class=\"headerlink\" title=\"2.body\"></a>2.body</h2><p>body部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图： flv<br><img src=\"http://i1.piimg.com/567571/9a6b94bf91e209d3.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-Tag\"><a href=\"#2-1-Tag\" class=\"headerlink\" title=\"2.1.Tag\"></a>2.1.Tag</h3><p>每个Tag由也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息，具体如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Tag类型</td>\n<td>1 bytes</td>\n<td>8：音频 9：视频 18：脚本  其他：保留</td>\n</tr>\n<tr>\n<td>数据区长度</td>\n<td>3 bytes</td>\n<td>在数据区的长度</td>\n</tr>\n<tr>\n<td>时间戳</td>\n<td>3 bytes</td>\n<td>整数，单位是毫秒。对于脚本型的tag总是0</td>\n</tr>\n<tr>\n<td>时间戳扩展</td>\n<td>1 bytes</td>\n<td>将时间戳扩展为4bytes，代表高8位。很少用到</td>\n</tr>\n<tr>\n<td>StreamsID</td>\n<td>3 bytes</td>\n<td>总是0</td>\n</tr>\n</tbody>\n</table>\n<p>数据区(data)    由数据区长度决定    数据实体</p>\n<h3 id=\"2-2-Tag-Data\"><a href=\"#2-2-Tag-Data\" class=\"headerlink\" title=\"2.2.Tag Data\"></a>2.2.Tag Data</h3><p>数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。</p>\n<h4 id=\"2-2-1-音频数据\"><a href=\"#2-2-1-音频数据\" class=\"headerlink\" title=\"2.2.1.音频数据\"></a>2.2.1.音频数据</h4><p>第一个byte是音频的信息，格式如下。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>音频格式</td>\n<td>4 bits</td>\n<td>0 = Linear PCM, platform endian,1 = ADPCM,2 = MP3,3 = Linear PCM, little endian,4 = Nellymoser 16-kHz mono,5 = Nellymoser 8-kHz mono,6 = Nellymoser,7 = G.711 A-law logarithmic PCM,8 = G.711 mu-law logarithmic PCM,9 = reserved,10 = AAC,11 = Speex,14 = MP3 8-Khz,15 = Device-specific sound</td>\n</tr>\n<tr>\n<td>采样率</td>\n<td>2 bits</td>\n<td>0 = 5.5-kHz,1 = 11-kHz,2 = 22-kHz,3 = 44-kHz,对于AAC总是3</td>\n</tr>\n<tr>\n<td>采样的长度</td>\n<td>1 bit</td>\n<td>0 = snd8Bit,1 = snd16Bit,压缩过的音频都是16bit</td>\n</tr>\n<tr>\n<td>音频类型</td>\n<td>1 bit</td>\n<td>0 = sndMono,1 = sndStereo,对于AAC总是1</td>\n</tr>\n</tbody>\n</table>\n<p>第2byte开始就是音频流数据了。</p>\n<h4 id=\"2-2-2-视频数据\"><a href=\"#2-2-2-视频数据\" class=\"headerlink\" title=\"2.2.2.视频数据\"></a>2.2.2.视频数据</h4><p>和音频数据一样，第一个byte是视频信息，格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>帧类型</td>\n<td>4 bits</td>\n<td>1: keyframe (for AVC, a seekable frame)</td>\n</tr>\n</tbody>\n</table>\n<p>2: inter frame (for AVC, a non-seekable frame)<br>3: disposable inter frame (H.263 only)<br>4: generated keyframe (reserved for server use only)<br>5: video info/command frame|<br>|编码ID    |4 bits    |1: JPEG (currently unused)<br>2: Sorenson H.263<br>3: Screen video<br>4: On2 VP6<br>5: On2 VP6 with alpha channel<br>6: Screen video version 2<br>7: AVC|</p>\n<h4 id=\"2-2-3脚本数据\"><a href=\"#2-2-3脚本数据\" class=\"headerlink\" title=\"2.2.3脚本数据\"></a>2.2.3脚本数据</h4><p>脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。<br>首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。<br>其中数据类型的种类有：</p>\n<ul>\n<li>0 = Number type</li>\n<li>1 = Boolean type</li>\n<li>2 = String type</li>\n<li>3 = Object type</li>\n<li>4 = MovieClip type</li>\n<li>5 = Null type</li>\n<li>6 = Undefined type</li>\n<li>7 = Reference type</li>\n<li>8 = ECMA array type</li>\n<li>10 = Strict array type</li>\n<li>11 = Date type</li>\n<li>12 = Long string type</li>\n</ul>\n<p>如果类型为String，后面的2bytes为字符串的长度（Long String是4bytes），再后面才是字符串数据；如果是Number类型，后面的8bytes为Double类型的数据；Boolean类型，后面1byte为Bool类型。</p>\n<p>知道了这些后再来看看flv中的脚本，一般开头是0x02，表示String类型，后面的2bytes为字符串长度，一般是0x000a（“onMetaData”的长度），再后面就是字符串“onMetaData”。好像flv格式的文件都有onMetaData标记，在运行ActionScript的时候会用到它。后面跟的是0x08，表示ECMA Array类型，这个和Map比较相似，一个键跟着一个值。键都是String类型的，所以开头的0x02被省略了，直接跟着的是字符串的长度，然后是字符串，再是值的类型，也就是上面介绍的那些了。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>flv的格式还是比较简单的，header部分很简洁，body部分都是由一个个tag，tag的话也就三种，脚本tag一般只有一个的，我想这也是flv能成为在线视频格式的原因吧。只要了解了格式，我们就可以写个程序来解析flv文件了，这也是我下一步要做的。<br>最后附上flv官方手册：video_file_format_spec_v10</p>\n","site":{"data":{}},"excerpt":"<p>FLV 是 FLASH VIDEO 的简称,，FLV流媒体格式是一种新的视频格式，全称为Flash Video。FLV 压缩与转换非常方便，适合做短片.，并且 FLV 可以很好的保护原始地址，不容易下载到，可以起到保护版权的目的<br>","more":"</p>\n<p>最近要用到flv，整理了一些flv格式的资料，供参考。 flv文件主要由两部分组成：header和body。</p>\n<h2 id=\"1-header\"><a href=\"#1-header\" class=\"headerlink\" title=\"1.header\"></a>1.header</h2><p>header部分记录了flv的类型、版本等信息，是flv的开头，一般都差不多，占9bytes。具体格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>文件类型</th>\n<th>3bytes</th>\n<th>“FLV”</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>版本</td>\n<td>1 byte</td>\n<td>一般为0x01</td>\n</tr>\n<tr>\n<td>流信息</td>\n<td>1 byte</td>\n<td>倒数第一位是1表示有视频，倒数第三位是1表示有音频，倒数第二、四位必须为0</td>\n</tr>\n<tr>\n<td>header长度</td>\n<td>4 bytes</td>\n<td>整个header的长度，一般为9；大于9表示下面还有扩展信息</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"2-body\"><a href=\"#2-body\" class=\"headerlink\" title=\"2.body\"></a>2.body</h2><p>body部分由一个个Tag组成，每个Tag的下面有一块4bytes的空间，用来记录这个tag的长度，这个后置用于逆向读取处理，他们的关系如下图： flv<br><img src=\"http://i1.piimg.com/567571/9a6b94bf91e209d3.jpg\" alt=\"\"></p>\n<h3 id=\"2-1-Tag\"><a href=\"#2-1-Tag\" class=\"headerlink\" title=\"2.1.Tag\"></a>2.1.Tag</h3><p>每个Tag由也是由两部分组成的：Tag Header和Tag Data。Tag Header里存放的是当前Tag的类型、数据区（Tag Data）长度等信息，具体如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Tag类型</td>\n<td>1 bytes</td>\n<td>8：音频 9：视频 18：脚本  其他：保留</td>\n</tr>\n<tr>\n<td>数据区长度</td>\n<td>3 bytes</td>\n<td>在数据区的长度</td>\n</tr>\n<tr>\n<td>时间戳</td>\n<td>3 bytes</td>\n<td>整数，单位是毫秒。对于脚本型的tag总是0</td>\n</tr>\n<tr>\n<td>时间戳扩展</td>\n<td>1 bytes</td>\n<td>将时间戳扩展为4bytes，代表高8位。很少用到</td>\n</tr>\n<tr>\n<td>StreamsID</td>\n<td>3 bytes</td>\n<td>总是0</td>\n</tr>\n</tbody>\n</table>\n<p>数据区(data)    由数据区长度决定    数据实体</p>\n<h3 id=\"2-2-Tag-Data\"><a href=\"#2-2-Tag-Data\" class=\"headerlink\" title=\"2.2.Tag Data\"></a>2.2.Tag Data</h3><p>数据区根据Tag类型的不同可分为三种，音频数据、视频数据和脚本数据。</p>\n<h4 id=\"2-2-1-音频数据\"><a href=\"#2-2-1-音频数据\" class=\"headerlink\" title=\"2.2.1.音频数据\"></a>2.2.1.音频数据</h4><p>第一个byte是音频的信息，格式如下。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>音频格式</td>\n<td>4 bits</td>\n<td>0 = Linear PCM, platform endian,1 = ADPCM,2 = MP3,3 = Linear PCM, little endian,4 = Nellymoser 16-kHz mono,5 = Nellymoser 8-kHz mono,6 = Nellymoser,7 = G.711 A-law logarithmic PCM,8 = G.711 mu-law logarithmic PCM,9 = reserved,10 = AAC,11 = Speex,14 = MP3 8-Khz,15 = Device-specific sound</td>\n</tr>\n<tr>\n<td>采样率</td>\n<td>2 bits</td>\n<td>0 = 5.5-kHz,1 = 11-kHz,2 = 22-kHz,3 = 44-kHz,对于AAC总是3</td>\n</tr>\n<tr>\n<td>采样的长度</td>\n<td>1 bit</td>\n<td>0 = snd8Bit,1 = snd16Bit,压缩过的音频都是16bit</td>\n</tr>\n<tr>\n<td>音频类型</td>\n<td>1 bit</td>\n<td>0 = sndMono,1 = sndStereo,对于AAC总是1</td>\n</tr>\n</tbody>\n</table>\n<p>第2byte开始就是音频流数据了。</p>\n<h4 id=\"2-2-2-视频数据\"><a href=\"#2-2-2-视频数据\" class=\"headerlink\" title=\"2.2.2.视频数据\"></a>2.2.2.视频数据</h4><p>和音频数据一样，第一个byte是视频信息，格式如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>长度</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>帧类型</td>\n<td>4 bits</td>\n<td>1: keyframe (for AVC, a seekable frame)</td>\n</tr>\n</tbody>\n</table>\n<p>2: inter frame (for AVC, a non-seekable frame)<br>3: disposable inter frame (H.263 only)<br>4: generated keyframe (reserved for server use only)<br>5: video info/command frame|<br>|编码ID    |4 bits    |1: JPEG (currently unused)<br>2: Sorenson H.263<br>3: Screen video<br>4: On2 VP6<br>5: On2 VP6 with alpha channel<br>6: Screen video version 2<br>7: AVC|</p>\n<h4 id=\"2-2-3脚本数据\"><a href=\"#2-2-3脚本数据\" class=\"headerlink\" title=\"2.2.3脚本数据\"></a>2.2.3脚本数据</h4><p>脚本Tag一般只有一个，是flv的第一个Tag，用于存放flv的信息，比如duration、audiodatarate、creator、width等。<br>首先介绍下脚本的数据类型。所有数据都是以数据类型+（数据长度）+数据的格式出现的，数据类型占1byte，数据长度看数据类型是否存在，后面才是数据。<br>其中数据类型的种类有：</p>\n<ul>\n<li>0 = Number type</li>\n<li>1 = Boolean type</li>\n<li>2 = String type</li>\n<li>3 = Object type</li>\n<li>4 = MovieClip type</li>\n<li>5 = Null type</li>\n<li>6 = Undefined type</li>\n<li>7 = Reference type</li>\n<li>8 = ECMA array type</li>\n<li>10 = Strict array type</li>\n<li>11 = Date type</li>\n<li>12 = Long string type</li>\n</ul>\n<p>如果类型为String，后面的2bytes为字符串的长度（Long String是4bytes），再后面才是字符串数据；如果是Number类型，后面的8bytes为Double类型的数据；Boolean类型，后面1byte为Bool类型。</p>\n<p>知道了这些后再来看看flv中的脚本，一般开头是0x02，表示String类型，后面的2bytes为字符串长度，一般是0x000a（“onMetaData”的长度），再后面就是字符串“onMetaData”。好像flv格式的文件都有onMetaData标记，在运行ActionScript的时候会用到它。后面跟的是0x08，表示ECMA Array类型，这个和Map比较相似，一个键跟着一个值。键都是String类型的，所以开头的0x02被省略了，直接跟着的是字符串的长度，然后是字符串，再是值的类型，也就是上面介绍的那些了。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3.总结\"></a>3.总结</h2><p>flv的格式还是比较简单的，header部分很简洁，body部分都是由一个个tag，tag的话也就三种，脚本tag一般只有一个的，我想这也是flv能成为在线视频格式的原因吧。只要了解了格式，我们就可以写个程序来解析flv文件了，这也是我下一步要做的。<br>最后附上flv官方手册：video_file_format_spec_v10</p>"},{"title":"iOS中的屏幕旋转","date":"2016-02-12T14:14:43.000Z","_content":"\n- 旋转事件只传递给主window\n- 当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上\n- 屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转\n- 再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制\n\n\n### 详述\n#### 第一层设置\n![Alt text](./1444701872103.png)\n在这里选择是否支持横竖屏\n#### 第二层设置\n```\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {  \n    return UIInterfaceOrientationMaskAll;\n}\n```\n在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置\n\n#### 第三层设置\n在window的`根控制器`中实现这两个方法，来加以控制，是否允许旋转以及支持的方向\n```\n//是否允许旋转\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n//旋转的时候支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n#### 第四层设置\n在你要控制是否旋转的这个控制里边实现上边的这两个方法\n\n\n#### 小结\n>- 当屏幕旋转一次就会调用一次这个方法，来询问支持的方向\n>- 这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响\n>- 一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西\n>  - AppDelegate中的这个方法返回支持的方向\n>  - window的根控制器中是否允许旋转，以及支持的方向\n>  - **取交集**\n\n\n\n\n上边的的四层设置起作用的情况，我们要分三种情况来说\n>- 要控制的控制器间接依附最开始创建的window\n>\t- 该控制器是通过navigationcontroller管理的/直接添加childcontrollers\n>\t- present...\n>- 要控制的控制器依附于新创建的window\n\n##### 原始window\n>- 受到Appdelegate中的方法的影响\n>- 如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则\n>- 如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响\n\n##### 依附于新创建的window\n>- 不受到APPdelegate方法的影响\n>- 其它都一样，但是分析的起点就变成了当前window的根控制器\n\t- 比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了\n\n### demo\n#### 整体是支持横屏，但是某个界面禁止\n根据上边叙述，我们可以得到以下方案：\n- 通过present...来管理控制器\n\n> 在这个控制器中添加控制器代码，禁止旋转或者只支持竖着\n```\n  @implementation HSViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n}\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskPortrait;\n}\n\n@end\n```\n- 不通过present来管理界面\n> 通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向\n```\n - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    \n\n   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;\n    \n    if ([nav.topViewController isKindOfClass:[HSViewController class]]) {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n    \n    return UIInterfaceOrientationMaskAll;\n    \n}\n```\n\n#### 整体是支持竖屏，但是某个界面可以横屏\n这种需求，只能通过加判断代码来做到\n\n#### 控制通过webView加载的视频全屏时的横竖屏\nwebView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断\n```\n#import \"UIViewController+Extension.h\"\n\n@implementation UIViewController (Extension)\n\n#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏\n/**\n * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO\n *\n *  @return 返回是否\n */\n- (BOOL)shouldAutorotate {\n    //拿到当前主窗口的根控制器类型名称\n    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);\n    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转\n    if ([className isEqualToString:@\"UIViewController\"]) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n@end\n\n```\n","source":"_posts/2016/iOS中的屏幕旋转.md","raw":"---\ntitle: iOS中的屏幕旋转\ndate: 2016-02-12 22:14:43\ntags:\n- iOS基础知识\ncategories: iOS\n---\n\n- 旋转事件只传递给主window\n- 当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上\n- 屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转\n- 再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制\n\n\n### 详述\n#### 第一层设置\n![Alt text](./1444701872103.png)\n在这里选择是否支持横竖屏\n#### 第二层设置\n```\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {  \n    return UIInterfaceOrientationMaskAll;\n}\n```\n在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置\n\n#### 第三层设置\n在window的`根控制器`中实现这两个方法，来加以控制，是否允许旋转以及支持的方向\n```\n//是否允许旋转\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n//旋转的时候支持的方向\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n```\n\n#### 第四层设置\n在你要控制是否旋转的这个控制里边实现上边的这两个方法\n\n\n#### 小结\n>- 当屏幕旋转一次就会调用一次这个方法，来询问支持的方向\n>- 这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响\n>- 一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西\n>  - AppDelegate中的这个方法返回支持的方向\n>  - window的根控制器中是否允许旋转，以及支持的方向\n>  - **取交集**\n\n\n\n\n上边的的四层设置起作用的情况，我们要分三种情况来说\n>- 要控制的控制器间接依附最开始创建的window\n>\t- 该控制器是通过navigationcontroller管理的/直接添加childcontrollers\n>\t- present...\n>- 要控制的控制器依附于新创建的window\n\n##### 原始window\n>- 受到Appdelegate中的方法的影响\n>- 如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则\n>- 如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响\n\n##### 依附于新创建的window\n>- 不受到APPdelegate方法的影响\n>- 其它都一样，但是分析的起点就变成了当前window的根控制器\n\t- 比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了\n\n### demo\n#### 整体是支持横屏，但是某个界面禁止\n根据上边叙述，我们可以得到以下方案：\n- 通过present...来管理控制器\n\n> 在这个控制器中添加控制器代码，禁止旋转或者只支持竖着\n```\n  @implementation HSViewController\n\n- (void)viewDidLoad {\n   [super viewDidLoad];\n}\n\n- (BOOL)shouldAutorotate {\n    return YES;\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    return UIInterfaceOrientationMaskPortrait;\n}\n\n@end\n```\n- 不通过present来管理界面\n> 通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向\n```\n - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    \n\n   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;\n    \n    if ([nav.topViewController isKindOfClass:[HSViewController class]]) {\n        return UIInterfaceOrientationMaskPortrait;\n    }\n    \n    return UIInterfaceOrientationMaskAll;\n    \n}\n```\n\n#### 整体是支持竖屏，但是某个界面可以横屏\n这种需求，只能通过加判断代码来做到\n\n#### 控制通过webView加载的视频全屏时的横竖屏\nwebView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断\n```\n#import \"UIViewController+Extension.h\"\n\n@implementation UIViewController (Extension)\n\n#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏\n/**\n * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO\n *\n *  @return 返回是否\n */\n- (BOOL)shouldAutorotate {\n    //拿到当前主窗口的根控制器类型名称\n    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);\n    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转\n    if ([className isEqualToString:@\"UIViewController\"]) {\n        return YES;\n    } else {\n        return NO;\n    }\n}\n\n- (UIInterfaceOrientationMask)supportedInterfaceOrientations {\n    \n    return UIInterfaceOrientationMaskAll;\n}\n@end\n\n```\n","slug":"2016/iOS中的屏幕旋转","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnr004psaua78hrjqmy","content":"<ul>\n<li>旋转事件只传递给主window</li>\n<li>当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上</li>\n<li>屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转</li>\n<li>再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制</li>\n</ul>\n<h3 id=\"详述\"><a href=\"#详述\" class=\"headerlink\" title=\"详述\"></a>详述</h3><h4 id=\"第一层设置\"><a href=\"#第一层设置\" class=\"headerlink\" title=\"第一层设置\"></a>第一层设置</h4><p><img src=\"./1444701872103.png\" alt=\"Alt text\"><br>在这里选择是否支持横竖屏</p>\n<h4 id=\"第二层设置\"><a href=\"#第二层设置\" class=\"headerlink\" title=\"第二层设置\"></a>第二层设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;  </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置</p>\n<h4 id=\"第三层设置\"><a href=\"#第三层设置\" class=\"headerlink\" title=\"第三层设置\"></a>第三层设置</h4><p>在window的<code>根控制器</code>中实现这两个方法，来加以控制，是否允许旋转以及支持的方向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否允许旋转</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\">//旋转的时候支持的方向</div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第四层设置\"><a href=\"#第四层设置\" class=\"headerlink\" title=\"第四层设置\"></a>第四层设置</h4><p>在你要控制是否旋转的这个控制里边实现上边的这两个方法</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><blockquote>\n<ul>\n<li>当屏幕旋转一次就会调用一次这个方法，来询问支持的方向</li>\n<li>这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响</li>\n<li>一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西<ul>\n<li>AppDelegate中的这个方法返回支持的方向</li>\n<li>window的根控制器中是否允许旋转，以及支持的方向</li>\n<li><strong>取交集</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>上边的的四层设置起作用的情况，我们要分三种情况来说</p>\n<blockquote>\n<ul>\n<li>要控制的控制器间接依附最开始创建的window<ul>\n<li>该控制器是通过navigationcontroller管理的/直接添加childcontrollers</li>\n<li>present…</li>\n</ul>\n</li>\n<li>要控制的控制器依附于新创建的window</li>\n</ul>\n</blockquote>\n<h5 id=\"原始window\"><a href=\"#原始window\" class=\"headerlink\" title=\"原始window\"></a>原始window</h5><blockquote>\n<ul>\n<li>受到Appdelegate中的方法的影响</li>\n<li>如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则</li>\n<li>如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响</li>\n</ul>\n</blockquote>\n<h5 id=\"依附于新创建的window\"><a href=\"#依附于新创建的window\" class=\"headerlink\" title=\"依附于新创建的window\"></a>依附于新创建的window</h5><blockquote>\n<ul>\n<li>不受到APPdelegate方法的影响</li>\n<li>其它都一样，但是分析的起点就变成了当前window的根控制器<ul>\n<li>比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><h4 id=\"整体是支持横屏，但是某个界面禁止\"><a href=\"#整体是支持横屏，但是某个界面禁止\" class=\"headerlink\" title=\"整体是支持横屏，但是某个界面禁止\"></a>整体是支持横屏，但是某个界面禁止</h4><p>根据上边叙述，我们可以得到以下方案：</p>\n<ul>\n<li>通过present…来管理控制器</li>\n</ul>\n<blockquote>\n<p>在这个控制器中添加控制器代码，禁止旋转或者只支持竖着<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  @implementation HSViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">   [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>不通过present来管理界面<blockquote>\n<p>通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;</div><div class=\"line\">    </div><div class=\"line\">    if ([nav.topViewController isKindOfClass:[HSViewController class]]) &#123;</div><div class=\"line\">        return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"整体是支持竖屏，但是某个界面可以横屏\"><a href=\"#整体是支持竖屏，但是某个界面可以横屏\" class=\"headerlink\" title=\"整体是支持竖屏，但是某个界面可以横屏\"></a>整体是支持竖屏，但是某个界面可以横屏</h4><p>这种需求，只能通过加判断代码来做到</p>\n<h4 id=\"控制通过webView加载的视频全屏时的横竖屏\"><a href=\"#控制通过webView加载的视频全屏时的横竖屏\" class=\"headerlink\" title=\"控制通过webView加载的视频全屏时的横竖屏\"></a>控制通过webView加载的视频全屏时的横竖屏</h4><p>webView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Extension.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Extension)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏</div><div class=\"line\">/**</div><div class=\"line\"> * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO</div><div class=\"line\"> *</div><div class=\"line\"> *  @return 返回是否</div><div class=\"line\"> */</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    //拿到当前主窗口的根控制器类型名称</div><div class=\"line\">    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);</div><div class=\"line\">    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转</div><div class=\"line\">    if ([className isEqualToString:@&quot;UIViewController&quot;]) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>旋转事件只传递给主window</li>\n<li>当我们使用webView播放视频的时候，它会创建一个UIViewController，然后创建一个window，让这个控制器成为这个window的根控制器，然后再将视频显示的view添加到这个UIViewController的控制器view上</li>\n<li>屏幕选中的本质是当前主控制器的view跟随屏幕的旋转而旋转，并且调整大小至当前的宽高，所以我们要做的就是控制当前控制器要不要旋转</li>\n<li>再本质一些就是，要对当前keywindown的根控制器进行控制＋对你要旋转的界面进行控制</li>\n</ul>\n<h3 id=\"详述\"><a href=\"#详述\" class=\"headerlink\" title=\"详述\"></a>详述</h3><h4 id=\"第一层设置\"><a href=\"#第一层设置\" class=\"headerlink\" title=\"第一层设置\"></a>第一层设置</h4><p><img src=\"./1444701872103.png\" alt=\"Alt text\"><br>在这里选择是否支持横竖屏</p>\n<h4 id=\"第二层设置\"><a href=\"#第二层设置\" class=\"headerlink\" title=\"第二层设置\"></a>第二层设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;  </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在Appdelegate中进行设置，实现这个方法，在这里返回你要支持的方向，这个设置会覆盖上边在general中的设置</p>\n<h4 id=\"第三层设置\"><a href=\"#第三层设置\" class=\"headerlink\" title=\"第三层设置\"></a>第三层设置</h4><p>在window的<code>根控制器</code>中实现这两个方法，来加以控制，是否允许旋转以及支持的方向<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否允许旋转</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\">//旋转的时候支持的方向</div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"第四层设置\"><a href=\"#第四层设置\" class=\"headerlink\" title=\"第四层设置\"></a>第四层设置</h4><p>在你要控制是否旋转的这个控制里边实现上边的这两个方法</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><blockquote>\n<ul>\n<li>当屏幕旋转一次就会调用一次这个方法，来询问支持的方向</li>\n<li>这里返回的window是Appdelegate这个对象持有的window，也就是说，即使中间你换掉了keywindow这里返回的仍然只是最开始创建的那个window，也就是说，对你最后创建的window这个方法并不能影响</li>\n<li>一个控制器到底是否支持横屏，自己说了是不算的，主要看两个东西<ul>\n<li>AppDelegate中的这个方法返回支持的方向</li>\n<li>window的根控制器中是否允许旋转，以及支持的方向</li>\n<li><strong>取交集</strong></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>上边的的四层设置起作用的情况，我们要分三种情况来说</p>\n<blockquote>\n<ul>\n<li>要控制的控制器间接依附最开始创建的window<ul>\n<li>该控制器是通过navigationcontroller管理的/直接添加childcontrollers</li>\n<li>present…</li>\n</ul>\n</li>\n<li>要控制的控制器依附于新创建的window</li>\n</ul>\n</blockquote>\n<h5 id=\"原始window\"><a href=\"#原始window\" class=\"headerlink\" title=\"原始window\"></a>原始window</h5><blockquote>\n<ul>\n<li>受到Appdelegate中的方法的影响</li>\n<li>如果控制器是modal出来的，那么该控制器中实现的这两个方法会生效，但是依然遵循交集的原则</li>\n<li>如果这个控制器是navigationController管理或者直接添加childcontrollers，该控制器中的方法是没有作用的，它只受到appdelegate和window根控制器的影响</li>\n</ul>\n</blockquote>\n<h5 id=\"依附于新创建的window\"><a href=\"#依附于新创建的window\" class=\"headerlink\" title=\"依附于新创建的window\"></a>依附于新创建的window</h5><blockquote>\n<ul>\n<li>不受到APPdelegate方法的影响</li>\n<li>其它都一样，但是分析的起点就变成了当前window的根控制器<ul>\n<li>比如，webView播放视频的时候，它会新创建window，并且以UIViewController为根控制器，所以我们应该在这个控制器中添加控制代码，但是这个是系统的类，我们就只能靠分类来添加代码了</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><h4 id=\"整体是支持横屏，但是某个界面禁止\"><a href=\"#整体是支持横屏，但是某个界面禁止\" class=\"headerlink\" title=\"整体是支持横屏，但是某个界面禁止\"></a>整体是支持横屏，但是某个界面禁止</h4><p>根据上边叙述，我们可以得到以下方案：</p>\n<ul>\n<li>通过present…来管理控制器</li>\n</ul>\n<blockquote>\n<p>在这个控制器中添加控制器代码，禁止旋转或者只支持竖着<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  @implementation HSViewController</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">   [super viewDidLoad];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    return YES;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n</blockquote>\n<ul>\n<li>不通过present来管理界面<blockquote>\n<p>通过在Appdelegate或者根控制器中加判断代码，实现在不同的当前控制器，返回不同的支持的方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"> - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</div><div class=\"line\">    </div><div class=\"line\"></div><div class=\"line\">   HSNavigationContronller *nav = (HSNavigationContronller *)[UIApplication sharedApplication].keyWindow.rootViewController;</div><div class=\"line\">    </div><div class=\"line\">    if ([nav.topViewController isKindOfClass:[HSViewController class]]) &#123;</div><div class=\"line\">        return UIInterfaceOrientationMaskPortrait;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"整体是支持竖屏，但是某个界面可以横屏\"><a href=\"#整体是支持竖屏，但是某个界面可以横屏\" class=\"headerlink\" title=\"整体是支持竖屏，但是某个界面可以横屏\"></a>整体是支持竖屏，但是某个界面可以横屏</h4><p>这种需求，只能通过加判断代码来做到</p>\n<h4 id=\"控制通过webView加载的视频全屏时的横竖屏\"><a href=\"#控制通过webView加载的视频全屏时的横竖屏\" class=\"headerlink\" title=\"控制通过webView加载的视频全屏时的横竖屏\"></a>控制通过webView加载的视频全屏时的横竖屏</h4><p>webView的视频在全屏的时候，会新创建一个window，所以你在Appdelegate或者当前根控制器下的控制代码统统不会生效，并且以UIViewController为根控制器，所以我们要把控制代码加到UIViewController的分类中，又因为其它的控制器全部继承自这个控制器，所以我们要在这个里边加判断<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Extension.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Extension)</div><div class=\"line\"></div><div class=\"line\">#pragma mark - 下面的两个方法主要用于控制webView播放视屏的时候，该是否是否应该横屏</div><div class=\"line\">/**</div><div class=\"line\"> * 如果当前keywindow的rootController类型为UIViewController，就返回YES，否则返回NO</div><div class=\"line\"> *</div><div class=\"line\"> *  @return 返回是否</div><div class=\"line\"> */</div><div class=\"line\">- (BOOL)shouldAutorotate &#123;</div><div class=\"line\">    //拿到当前主窗口的根控制器类型名称</div><div class=\"line\">    NSString *className = NSStringFromClass([[UIApplication sharedApplication].keyWindow.rootViewController class]);</div><div class=\"line\">    //如果是UIViewController就返回YES，让这个控制器view可以跟随屏幕旋转</div><div class=\"line\">    if ([className isEqualToString:@&quot;UIViewController&quot;]) &#123;</div><div class=\"line\">        return YES;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return NO;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</div><div class=\"line\">    </div><div class=\"line\">    return UIInterfaceOrientationMaskAll;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n"},{"title":"iOS技能总结","date":"2016-02-19T05:59:43.000Z","_content":"\n参考--唐巧，iOS技能图谱\n<!--more-->\n### 编程语言\n\n- Swift\n- Objective-C\n- C++/C\n- JavaScript\n- Python\n\n### 操作系统\n\n- Mac OSX\n- iOS\n- watchOS\n- tvOS\n- Linux 常用命令\n\n### 开发基础\n\n- UI 控件\n- Storyboard & Xib\n- Core Data & Sqlite数据持久化CoreData的多线程 了解没?  CoreData 的不同版本的数据迁移怎么做?\n- Core Graphics\n- Animation\n- Block & GCD，GCD ,NSThread ,NSOperation 能不能滔滔不绝的讲出来\n- Test Case 编写\n- Framework\n- Autolayout\n- WebController\n- 手势识别，重力感应\n- 推送\n- 网络加密\n- keyChain 钥匙串存储\n\n### 开发进阶\n\n- 内存管理\n- Runtime，在项目中的应用\n- Runloop，在项目中的应用\n- 对象模型\n- Hybrid\n- 沙盒机制\n- AVFoundation\n- Core Text\n- app瘦身\n- 插件制作\n- 打包.a和framwork\n- 优化\n\t- 电量\n\t- 流量\n\t- 性能\n\t- 网络\n- 逆向与安全\n\n    - class dump\n    - IDA Pro\n    - Hopper\n    - iOS Class Guard\n\n### 设计模式\n\n- MVC\n- MVVM\n- 通知\n- 代理\n- KVO\n- 工厂模式\n- 命令模式\n\n### 开发工具\n\n- IDE\n\n    - Xcode\n    - AppCode\n- 调试工具\n\n    - Charles、Wireshark\n    - Reveal\n    - Instruments\n- 插件\n\n    - Alcatraz\n    - VVDocument\n    - XVim\n    - FuzzyAutocompletePlugin\n    - KSImageNamed-Xcode\n- 辅助工具\n\n    - xScope\n    - ImageOptim\n    - 马克鳗\n    - Dash\n    - Deploymate\n    - FauxPas\n    - PaintCode\n- 命令行工具\n\n    - xcodebuild、xcode-select\n    - nomad\n    - xctool\n    - fastlane\n- 持续集成\n\n    - Jenkins\n    - Travis CI\n    - Bot\n\n### 开源项目\n\n- AFNetworking & Alamofire\n- Masonry\n- SDWebImage\n- SwiftyJSON\n- JSPatch\n- React Native\n\n### App 打包上传与审核\n\n- Apple Developer 网站\n- iTunes Connect 网站\n- IAP\n- 加急审核申请\n- 打包脚本\n\n### 第三方服务\n\n- 崩溃收集\n\n    - Bugly\n    - Crashlytics\n    - BugHD\n    - Fabric\n- 数据统计\n\n    - Google Analytics\n    - 友盟\n    - MTA\n    - Flurry\n    - App Annie\n- 应用分发\n    - TestFlight\n    - 蒲公英\n    - FIR\n\n### 包管理\n\n- CocoaPods\n- Carthage\n- Swift Package Manager\n\n### 函数式编程\n\n- ReactiveCocoa\n- RxSwift\n\n","source":"_posts/2016/iOS技能总结.md","raw":"---\ntitle: iOS技能总结\ndate: 2016-02-19 13:59:43\ntags:\n- iOS进阶\ncategories: iOS\n---\n\n参考--唐巧，iOS技能图谱\n<!--more-->\n### 编程语言\n\n- Swift\n- Objective-C\n- C++/C\n- JavaScript\n- Python\n\n### 操作系统\n\n- Mac OSX\n- iOS\n- watchOS\n- tvOS\n- Linux 常用命令\n\n### 开发基础\n\n- UI 控件\n- Storyboard & Xib\n- Core Data & Sqlite数据持久化CoreData的多线程 了解没?  CoreData 的不同版本的数据迁移怎么做?\n- Core Graphics\n- Animation\n- Block & GCD，GCD ,NSThread ,NSOperation 能不能滔滔不绝的讲出来\n- Test Case 编写\n- Framework\n- Autolayout\n- WebController\n- 手势识别，重力感应\n- 推送\n- 网络加密\n- keyChain 钥匙串存储\n\n### 开发进阶\n\n- 内存管理\n- Runtime，在项目中的应用\n- Runloop，在项目中的应用\n- 对象模型\n- Hybrid\n- 沙盒机制\n- AVFoundation\n- Core Text\n- app瘦身\n- 插件制作\n- 打包.a和framwork\n- 优化\n\t- 电量\n\t- 流量\n\t- 性能\n\t- 网络\n- 逆向与安全\n\n    - class dump\n    - IDA Pro\n    - Hopper\n    - iOS Class Guard\n\n### 设计模式\n\n- MVC\n- MVVM\n- 通知\n- 代理\n- KVO\n- 工厂模式\n- 命令模式\n\n### 开发工具\n\n- IDE\n\n    - Xcode\n    - AppCode\n- 调试工具\n\n    - Charles、Wireshark\n    - Reveal\n    - Instruments\n- 插件\n\n    - Alcatraz\n    - VVDocument\n    - XVim\n    - FuzzyAutocompletePlugin\n    - KSImageNamed-Xcode\n- 辅助工具\n\n    - xScope\n    - ImageOptim\n    - 马克鳗\n    - Dash\n    - Deploymate\n    - FauxPas\n    - PaintCode\n- 命令行工具\n\n    - xcodebuild、xcode-select\n    - nomad\n    - xctool\n    - fastlane\n- 持续集成\n\n    - Jenkins\n    - Travis CI\n    - Bot\n\n### 开源项目\n\n- AFNetworking & Alamofire\n- Masonry\n- SDWebImage\n- SwiftyJSON\n- JSPatch\n- React Native\n\n### App 打包上传与审核\n\n- Apple Developer 网站\n- iTunes Connect 网站\n- IAP\n- 加急审核申请\n- 打包脚本\n\n### 第三方服务\n\n- 崩溃收集\n\n    - Bugly\n    - Crashlytics\n    - BugHD\n    - Fabric\n- 数据统计\n\n    - Google Analytics\n    - 友盟\n    - MTA\n    - Flurry\n    - App Annie\n- 应用分发\n    - TestFlight\n    - 蒲公英\n    - FIR\n\n### 包管理\n\n- CocoaPods\n- Carthage\n- Swift Package Manager\n\n### 函数式编程\n\n- ReactiveCocoa\n- RxSwift\n\n","slug":"2016/iOS技能总结","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pns004ssauasoq1khwz","content":"<p>参考–唐巧，iOS技能图谱<br><a id=\"more\"></a></p>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><ul>\n<li>Swift</li>\n<li>Objective-C</li>\n<li>C++/C</li>\n<li>JavaScript</li>\n<li>Python</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ul>\n<li>Mac OSX</li>\n<li>iOS</li>\n<li>watchOS</li>\n<li>tvOS</li>\n<li>Linux 常用命令</li>\n</ul>\n<h3 id=\"开发基础\"><a href=\"#开发基础\" class=\"headerlink\" title=\"开发基础\"></a>开发基础</h3><ul>\n<li>UI 控件</li>\n<li>Storyboard &amp; Xib</li>\n<li>Core Data &amp; Sqlite数据持久化CoreData的多线程 了解没?  CoreData 的不同版本的数据迁移怎么做?</li>\n<li>Core Graphics</li>\n<li>Animation</li>\n<li>Block &amp; GCD，GCD ,NSThread ,NSOperation 能不能滔滔不绝的讲出来</li>\n<li>Test Case 编写</li>\n<li>Framework</li>\n<li>Autolayout</li>\n<li>WebController</li>\n<li>手势识别，重力感应</li>\n<li>推送</li>\n<li>网络加密</li>\n<li>keyChain 钥匙串存储</li>\n</ul>\n<h3 id=\"开发进阶\"><a href=\"#开发进阶\" class=\"headerlink\" title=\"开发进阶\"></a>开发进阶</h3><ul>\n<li>内存管理</li>\n<li>Runtime，在项目中的应用</li>\n<li>Runloop，在项目中的应用</li>\n<li>对象模型</li>\n<li>Hybrid</li>\n<li>沙盒机制</li>\n<li>AVFoundation</li>\n<li>Core Text</li>\n<li>app瘦身</li>\n<li>插件制作</li>\n<li>打包.a和framwork</li>\n<li>优化<ul>\n<li>电量</li>\n<li>流量</li>\n<li>性能</li>\n<li>网络</li>\n</ul>\n</li>\n<li><p>逆向与安全</p>\n<ul>\n<li>class dump</li>\n<li>IDA Pro</li>\n<li>Hopper</li>\n<li>iOS Class Guard</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><ul>\n<li>MVC</li>\n<li>MVVM</li>\n<li>通知</li>\n<li>代理</li>\n<li>KVO</li>\n<li>工厂模式</li>\n<li>命令模式</li>\n</ul>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><ul>\n<li><p>IDE</p>\n<ul>\n<li>Xcode</li>\n<li>AppCode</li>\n</ul>\n</li>\n<li><p>调试工具</p>\n<ul>\n<li>Charles、Wireshark</li>\n<li>Reveal</li>\n<li>Instruments</li>\n</ul>\n</li>\n<li><p>插件</p>\n<ul>\n<li>Alcatraz</li>\n<li>VVDocument</li>\n<li>XVim</li>\n<li>FuzzyAutocompletePlugin</li>\n<li>KSImageNamed-Xcode</li>\n</ul>\n</li>\n<li><p>辅助工具</p>\n<ul>\n<li>xScope</li>\n<li>ImageOptim</li>\n<li>马克鳗</li>\n<li>Dash</li>\n<li>Deploymate</li>\n<li>FauxPas</li>\n<li>PaintCode</li>\n</ul>\n</li>\n<li><p>命令行工具</p>\n<ul>\n<li>xcodebuild、xcode-select</li>\n<li>nomad</li>\n<li>xctool</li>\n<li>fastlane</li>\n</ul>\n</li>\n<li><p>持续集成</p>\n<ul>\n<li>Jenkins</li>\n<li>Travis CI</li>\n<li>Bot</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h3><ul>\n<li>AFNetworking &amp; Alamofire</li>\n<li>Masonry</li>\n<li>SDWebImage</li>\n<li>SwiftyJSON</li>\n<li>JSPatch</li>\n<li>React Native</li>\n</ul>\n<h3 id=\"App-打包上传与审核\"><a href=\"#App-打包上传与审核\" class=\"headerlink\" title=\"App 打包上传与审核\"></a>App 打包上传与审核</h3><ul>\n<li>Apple Developer 网站</li>\n<li>iTunes Connect 网站</li>\n<li>IAP</li>\n<li>加急审核申请</li>\n<li>打包脚本</li>\n</ul>\n<h3 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h3><ul>\n<li><p>崩溃收集</p>\n<ul>\n<li>Bugly</li>\n<li>Crashlytics</li>\n<li>BugHD</li>\n<li>Fabric</li>\n</ul>\n</li>\n<li><p>数据统计</p>\n<ul>\n<li>Google Analytics</li>\n<li>友盟</li>\n<li>MTA</li>\n<li>Flurry</li>\n<li>App Annie</li>\n</ul>\n</li>\n<li>应用分发<ul>\n<li>TestFlight</li>\n<li>蒲公英</li>\n<li>FIR</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h3><ul>\n<li>CocoaPods</li>\n<li>Carthage</li>\n<li>Swift Package Manager</li>\n</ul>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><ul>\n<li>ReactiveCocoa</li>\n<li>RxSwift</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>参考–唐巧，iOS技能图谱<br>","more":"</p>\n<h3 id=\"编程语言\"><a href=\"#编程语言\" class=\"headerlink\" title=\"编程语言\"></a>编程语言</h3><ul>\n<li>Swift</li>\n<li>Objective-C</li>\n<li>C++/C</li>\n<li>JavaScript</li>\n<li>Python</li>\n</ul>\n<h3 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h3><ul>\n<li>Mac OSX</li>\n<li>iOS</li>\n<li>watchOS</li>\n<li>tvOS</li>\n<li>Linux 常用命令</li>\n</ul>\n<h3 id=\"开发基础\"><a href=\"#开发基础\" class=\"headerlink\" title=\"开发基础\"></a>开发基础</h3><ul>\n<li>UI 控件</li>\n<li>Storyboard &amp; Xib</li>\n<li>Core Data &amp; Sqlite数据持久化CoreData的多线程 了解没?  CoreData 的不同版本的数据迁移怎么做?</li>\n<li>Core Graphics</li>\n<li>Animation</li>\n<li>Block &amp; GCD，GCD ,NSThread ,NSOperation 能不能滔滔不绝的讲出来</li>\n<li>Test Case 编写</li>\n<li>Framework</li>\n<li>Autolayout</li>\n<li>WebController</li>\n<li>手势识别，重力感应</li>\n<li>推送</li>\n<li>网络加密</li>\n<li>keyChain 钥匙串存储</li>\n</ul>\n<h3 id=\"开发进阶\"><a href=\"#开发进阶\" class=\"headerlink\" title=\"开发进阶\"></a>开发进阶</h3><ul>\n<li>内存管理</li>\n<li>Runtime，在项目中的应用</li>\n<li>Runloop，在项目中的应用</li>\n<li>对象模型</li>\n<li>Hybrid</li>\n<li>沙盒机制</li>\n<li>AVFoundation</li>\n<li>Core Text</li>\n<li>app瘦身</li>\n<li>插件制作</li>\n<li>打包.a和framwork</li>\n<li>优化<ul>\n<li>电量</li>\n<li>流量</li>\n<li>性能</li>\n<li>网络</li>\n</ul>\n</li>\n<li><p>逆向与安全</p>\n<ul>\n<li>class dump</li>\n<li>IDA Pro</li>\n<li>Hopper</li>\n<li>iOS Class Guard</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><ul>\n<li>MVC</li>\n<li>MVVM</li>\n<li>通知</li>\n<li>代理</li>\n<li>KVO</li>\n<li>工厂模式</li>\n<li>命令模式</li>\n</ul>\n<h3 id=\"开发工具\"><a href=\"#开发工具\" class=\"headerlink\" title=\"开发工具\"></a>开发工具</h3><ul>\n<li><p>IDE</p>\n<ul>\n<li>Xcode</li>\n<li>AppCode</li>\n</ul>\n</li>\n<li><p>调试工具</p>\n<ul>\n<li>Charles、Wireshark</li>\n<li>Reveal</li>\n<li>Instruments</li>\n</ul>\n</li>\n<li><p>插件</p>\n<ul>\n<li>Alcatraz</li>\n<li>VVDocument</li>\n<li>XVim</li>\n<li>FuzzyAutocompletePlugin</li>\n<li>KSImageNamed-Xcode</li>\n</ul>\n</li>\n<li><p>辅助工具</p>\n<ul>\n<li>xScope</li>\n<li>ImageOptim</li>\n<li>马克鳗</li>\n<li>Dash</li>\n<li>Deploymate</li>\n<li>FauxPas</li>\n<li>PaintCode</li>\n</ul>\n</li>\n<li><p>命令行工具</p>\n<ul>\n<li>xcodebuild、xcode-select</li>\n<li>nomad</li>\n<li>xctool</li>\n<li>fastlane</li>\n</ul>\n</li>\n<li><p>持续集成</p>\n<ul>\n<li>Jenkins</li>\n<li>Travis CI</li>\n<li>Bot</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"开源项目\"><a href=\"#开源项目\" class=\"headerlink\" title=\"开源项目\"></a>开源项目</h3><ul>\n<li>AFNetworking &amp; Alamofire</li>\n<li>Masonry</li>\n<li>SDWebImage</li>\n<li>SwiftyJSON</li>\n<li>JSPatch</li>\n<li>React Native</li>\n</ul>\n<h3 id=\"App-打包上传与审核\"><a href=\"#App-打包上传与审核\" class=\"headerlink\" title=\"App 打包上传与审核\"></a>App 打包上传与审核</h3><ul>\n<li>Apple Developer 网站</li>\n<li>iTunes Connect 网站</li>\n<li>IAP</li>\n<li>加急审核申请</li>\n<li>打包脚本</li>\n</ul>\n<h3 id=\"第三方服务\"><a href=\"#第三方服务\" class=\"headerlink\" title=\"第三方服务\"></a>第三方服务</h3><ul>\n<li><p>崩溃收集</p>\n<ul>\n<li>Bugly</li>\n<li>Crashlytics</li>\n<li>BugHD</li>\n<li>Fabric</li>\n</ul>\n</li>\n<li><p>数据统计</p>\n<ul>\n<li>Google Analytics</li>\n<li>友盟</li>\n<li>MTA</li>\n<li>Flurry</li>\n<li>App Annie</li>\n</ul>\n</li>\n<li>应用分发<ul>\n<li>TestFlight</li>\n<li>蒲公英</li>\n<li>FIR</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h3><ul>\n<li>CocoaPods</li>\n<li>Carthage</li>\n<li>Swift Package Manager</li>\n</ul>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><ul>\n<li>ReactiveCocoa</li>\n<li>RxSwift</li>\n</ul>"},{"title":"iOS性能优化概述","date":"2016-07-21T02:51:58.000Z","_content":"## 响应速度与运行速度\n响应速度和运行速度之间有着微妙的区别，响应速度是指监听用户输入到反馈用户的速度，而运行速度是指处理任务的速度。\n<!--more-->\n用户都讨厌等待，所以你会说让App运行的更快非常重要。确实如此，但是运行速度的提升有一个边界，假如数据要通过网络下载，或者要进行复杂的计算和渲染，那么App不可能立即显示这些内容。这种情况下用户实际上还是愿意等待的，但是你要针对他们的操作给出即时的响应，这种响应可以是简单的按钮状态的改变也可以是复杂的动画效果。让App运行更快很重要，让其迅速响应同样重要。\n使用现实中真实的按钮和开关时会让人感觉靠谱，当按下按钮或者打开开关时你可以百分百确定你进行了操作。但是在触摸屏上你无法感知，所以视觉响应非常重要。如果一个App不能提供这种即时的响应那体验将变得非常糟糕，更具体点说就是响应时间不要超过三分之一秒。当你点击了某个位置但是没有任何事情发生，你会自然而然的认为点击有可能没有被接受。绝大多数人在这时会再点击一次，这可能造成重复的操作。\n\n关于响应速度的三个原则：\n- 迅速回馈用户他的操作已经被接受，然后迅速执行。例如点击按钮时提供一个touch-down状态呈现给用户。\n- 允许用户任意时刻中断\n- 当耗时操作进行时，反馈用户一个进度\n\n针对上边提出的问题，给予状态提示是UI层面的事情，比较容易做到，但是如果保证无论任何时候用户的操作和触摸事件都能得到立刻的响应呢？\n\n### runloop与用户事件响应\n在每次的runloop中，需要处理下边几种事件：\n- handlePort：跨线程通信的一些消息\n- customSrc: 被标记为UI待处理的事件\n- mySelector：本线程方法的调用\n- timerFired：定时器\n\n当我们程序启动完之后，基本上线程就没有什么事情要处理了，这个时候能够做出改变这个状态的事物有下边这几种：\n- 用户手势事件，点一下或者拖一下\n- 系统消息，来电话等\n\n具体的两种如下面所描述：\n\n- 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n- 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n>总的来讲，并不是当用户触发一个事件的时候这个事件就会被马上执行，而是这个事件会被标记，加入被执行的事件队列，然后等待runloop从这个事件队列中取出来事件，然后执行。\n现在假如说，你有一个点击事件，这个时候这个事件被加入到待执行的事件中，如果前边有一系列的事件要做，那么这个事件就要排队，现象就是，你发现你点完之后没有任何的反应。\n`[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];`利用该方法将大段的方法进行拆分，这样可以保证用户事件的响应。\n\n## 性能优化\n### 运行时间\n前边我们保证了响应速度，现在我们来看一下，如何加快执行的速度。\n基本上我们能够依赖的就是Time Profiler，\n\n### 渲染速度 \n不幸的是Time Profiler不能找出所有的性能问题。当你的App的帧率掉到60（帧/秒）以下你的App就感觉运行得不是那么平滑了。低帧率导致滚动视图和动画卡顿。\n　　帧率下降通常意味着iPad的渲染速度跟不上。视觉上较为理想的帧率不低于60（帧/秒），意味着每一帧应该在六十分之一秒内渲染完。\n\n![](http://i2.piimg.com/567571/8a0a7cd7094e8ce0.png)\n基本上我们使用上边这些选项来查找影响渲染的因素。\n#### color blended layers\n我们知道GPU是图形硬件，主要的工作是混合纹理并算出像素的RGB值，这是一个非常复杂的计算过程，计算的过程越复杂，所需要消耗的时间就越长，GPU的使用率就越高，这并不是一个好的现像，而我们需要做的是减少GPU的计算量。\n我们在这个图层上放置一个完全不透明的图层，那么GPU将会把上面的图层合成到下面的图层当中，由于上面的是一个完全不透明的图层，所以上面的图层会部份遮盖掉下面的图层，而在遮盖掉的矩形区域内，GPU会直接使用上面图层的像素来显示。如果我们最底的图层上放置的是一个有透明度的图层，那么在这个矩形区域里，GPU需要混合上下两个图层来计算出在屏幕上显示出来的像素的RGB值。若在同一个区域内，存在着多个有透明度的图层，那么GPU需要更多的计算才能得出最终像素的RGB值。而我们要做的就是避免像素混合，尽可能地为视图设置背景色，且设置opaque为YES，这会大大减少GPU的计算。\n以label为例\n![](http://i2.piimg.com/567571/324a6b489d2c6fa0.png)\n上边为不透明，下边为透明，那么我们得到的结果是下边混合严重\n上边为iOS7的情况，那么iOS8呢\n![](http://i1.piimg.com/567571/10dcf06a1af655ab.png)\n虽然设置了背景色，但在iOS8上用UILabel显示中文却出现了像素混合的情况，这是为什么呢？我们来看看UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变，就像上图所视(在iOS8刚发布的时候，我一度怀疑Apple歧视中文)。\n\n那怎么解决呢？首先我们来观察一下上图，从图中我们可以看到在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，既然发现这了一点，那么解决方案就很明了了。\n\n设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪，我们来看一下修改后的效果。木有问题了。\nmaskTobounds需要与cornerRadius结合才会离屏渲染，所以这里并不会导致离屏渲染。\n可以的话，要求美工在切图的时候，一定不要切出那些留有透明区域的图片，不然在你显示图片的时候，同样会出现像素混合问题。\n\n## tableView的优化\n\niOS平台因为UIKit本身的特性，需要将所有的UI操作都放在主线程执行，所以有时候就习惯将一些线程安全性不确定的逻辑，以及它线程结束后的汇总工作等等放到了主线程，所以主线程包含大量计算、IO、绘制都有可能造成卡顿。\n\n- 可以通过监控runLoop监控监控卡顿，调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n- 使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化\n- 监控后另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n- 监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈\n\n- 当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑\n\n- 设置正确的 reuseidentifer 以重用 cell\n\n- 尽量将 View 设置为不透明,包括 cell 本身（backgroundcolor默认是透明的），图层混合靠GPU去渲染,如果透明度设置为100%，那么GPU就会忽略下面所有的layer，节约了很多不必要的运算。模拟器上点击“Debug”菜单，然后选择“color Blended Layers”，会把所有区域分成绿色和红色,绿色的好,红色的性能差（经过混合渲染的），当然也有一些图片虽然是不透明的，但是也会显示红色，如果检查代码没错的话，一般就是图片自身的性质问题了，直接联系美工或后台解决就好了。除非必须要用GPU加载的，其他最好要用CPU加载，因为CPU一般不会百分百加载，可以通过CoreGraphics画出圆角\n\n- 有时候美工失误，图片大小给错了，引起不必要的图片缩放（可以找美工去改，当然也可以异步去裁剪图片然后缓存下来），还是使用Instrument的Color Misaligned Images，黄色表示图片需要缩放，紫色表示没有像素对齐。当然一般情况下图片格式不会给错，有些图片格式是GPU不支持的，就还要劳烦CPU去进行格式转换。还有可以通过Color Offscreen-Rendered Yellow来检测离屏渲染（就是把渲染结果临时保存，等到用的时候再取出，这样相对于普通渲染更消耗内存，使用maskToBounds、设置shadow，重写drawRect方法都会导致离屏渲染）\n避免渐变，cornerRadius在默认情况下，这个属性只会影响视图的背景颜色和 border，但是不会离屏绘制，不影响性能。不用clipsToBounds（过多调用GPU去离屏渲染），而是让后台加载图片并处理圆角，并将处理过的图片赋值给UIImageView。UIImageView 的圆角通过直接截取图片实现，圆角路径直接用贝塞尔曲线UIBezierPath绘制（人为指定路径之后就不会触发离屏渲染），UIGraphicsBeginImageContextWithOptions。UIView的圆角可以使用CoreGraphics画出圆角矩形，核心是CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回，最后把这个图片插入到视图层级的底部。\n“Flash updated Regions”用于标记发生重绘的区域\n\n- 如果 row 的高度不相同,那么将其缓存下来\n- 如果 cell 显示的内容来自网络,那么确保这些内容是通过异步下载\n- 使用 shadowPath 来设置阴影，图层最好不要使用阴影,阴影会导致离屏渲染(在进入屏幕渲染之前,还看不到的时候会再渲染一次,尽量不要产生离屏渲染)\n- 减少 subview 的数量，不要去添加或移除view，要就显示，不要就隐藏\n- 在 cellForRowAtIndexPath 中尽量做更少的操作,最好是在别的地方算好，这个方法里只做数据的显示，如果需要做一些处理,那么最好做一次之后将结果储存起来.\n- 使用适当的数据结构来保存需要的信息,不同的结构会带来不同的操作代价\n- 使用,rowHeight , sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定高度 , 而不是从代理(delegate)中获取\n- cell做数据绑定的时候，最好在willDisPlayCell里面进行，其他操作在cellForRowAtIndexPath，因为前者是第一页有多少条就执行多少次，后者是第一次加载有多少个cell就执行多少次，而且调用后者的时候cell还没显示\n- 读取文件,写入文件,最好是放到子线程,或先读取好,在让tableView去显示\n- tableView滚动的时候,不要去做动画(微信的聊天界面做的就很好,在滚动的时候,动态图就不让他动,滚动停止的时候才动,不然可能会有点影响流畅度)。在滚动的时候加载图片，停止拖拽后在减速过程中不加载图片，减速停止后加载可见范围内图片\n\n## 代码优化checkList\n### 2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）\n\n如果要在UIImageView中显示一个图片，你应保证图片的大小和UIImageView的大小相同。\n因为在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。\n\n如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。\n\n这个类比到图片和动画的渲染中，是通用的。\n\n具体方法参考上面的GCD操作。\n\n### 2.4 正确使用容器的特性\n\nArrays: 有序的一组值。使用index来查找很快，使用value 查找很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 \n\n### 2.5 大文件传输使用gzip\n\n大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。\n\n问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。\n\n减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。\n\n当然，现在苹果已经自动支持了，你只需要告诉你们服务端的同学，传输大文件的时候记得用gzip就完了。\n\n### 2.6 View的重用和懒加载\n\n更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。\n\n重用就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。\n当需要使用View的时候，去可重用队列里面找一找有没有可以被复用的View。\n这里我的一份框架中曾经使用过类似的方法去创建一个图片浏览器，大家可以稍做参考。View的重用\n\n懒加载就是在程序启动时并不进行加载，只有当用到这个对象的时候，才进行加载。\n这个不仅在属性中可以进行这样的使用，在View上面也是一样，不过实现稍有不同。\n懒加载会消耗更少内存，但是在View的显示上会稍有滞后。\n\n### 2.7 Cache\n\n一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。\n\n我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。\n\nNSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。\n\n下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：\n\n\n+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url { NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];  request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; // this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@\"image/*\" forHTTPHeaderField:@\"Accept\"];  return request; }\n\n\n注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。\n\n如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。\n\n### 2.8 记得处理内存警告\n\n一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:\n\n\n如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.\n\n\n幸运的是，UIKit提供了几种收集低内存警告的方法:\n\n在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知\n\n一旦收到这类通知，你就需要释放任何不必要的内存使用。\n\n\n例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。\n\n\n这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。\n\n然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。\n\n### 2.9 重用大的开销对象\n\n这里的大开销是指一些初始化很慢的objects，如：NSDateFormatter和NSCalendar。但是，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。\n\n想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。\n\n注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。\n\n下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：\n\n\n// in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter *formatter;  // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter *)formatter { if (! _formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @\"EEE MMM dd HH:mm:ss Z yyyy\"; // twitter date format } return _formatter; }\n\n\n还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。\n\n### 2.10 避免反复的处理数据\n\n许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。\n\n比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。\n\n类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。\n\n### 2.11 正确设定背景图片\n\n在View里放背景图片就像很多其它iOS编程一样有很多方法:\n\n使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。\n\n如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：\n\n\n// You could also achieve the same result in Interface Builder UIImageView *backgroundView = [ [UIImageView alloc] initWithImage:[UIImage imageNamed:@\"background\"]]; [self.view addSubview:backgroundView];\n\n\n如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：\n\n\nself.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"background\"]];\n\n\n### 2.12 试试苹果最新的WKWebView来处理web\n\nUIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。\n\n但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。\n\n所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。\n\n另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。\n\n最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。\n\n当然，上面是针对你在使用UIWebView的情况下，需要尽量减少使用web的特性，而苹果最近刚推出的Safari的底层框架WKWebView也许能帮我们规避掉很多这样的性能问题。\n\n### 2.13 优化你的TableView\n\nTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。\n\n为了保证table view平滑滚动，确保你采取了以下的措施:\n\n正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate\n\n### 2.14 选择正确的数据存储方式\n\n当存储大块数据时你会怎么做？\n\n你有很多选择，比如：\n\n使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data\n\nNSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了\n\nXML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。\n\nNSCoding？不幸的是，它也需要读写文件，所以也有以上问题。\n\n在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。\n\n在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。\n\n如果你使用SQLite，你可以用FMDB(https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。\n\n### 2.15 把Xib换成Storyboard吧\n\n当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。\n\nStoryboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.\n\n当加载XIB时，所有图片都被缓存，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：\n\n\n当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的`imageNamed:`方法来获取图片资源。\n\n\n很明显，同样的事情也发生在storyboards中，但我并没有找到任何支持这个结论的文档。\n\n另外，快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。\n\n你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。\n\n还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！\n\n\n注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度\n\n\n### 2.16 学会手动创建Autorelease Pool\n\nNSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。\n\n假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。\n\n好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：\n\n\nNSArray *urls = [@\"url1\",@\"url2\"]; for (NSURL *url in urls) { @autoreleasepool { NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL: url encoding: NSUTF8StringEncoding error: &error]; /* Process the string, creating and autoreleasing more objects. */ } }\n\n\n这段代码在每次遍历后释放所有autorelease对象\n\n### 2.17UIImage初始化\n\nA：imagedNamed初始化\n\nB：imageWithContentsOfFile初始化\n\n二者不同之处在于，imageNamed默认加载图片成功后会内存中缓存图片，这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果缓存中没有找到相应的图片对象，则从指定地方加载图片然后缓存对象，并返回这个图片对象\n\n而imageWithContentsOfFile则仅只加载图片，不缓存\n\n大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事，当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式，这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间\n\n使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显\n\n\n### 2.18列表滚动的时候不要对imageview赋值\n\n```\n// 只在NSDefaultRunLoopMode模式下显示图片\n    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"placeholder\"] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];\n```\n比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片\n\n### 一些第三方的使用\n 当然有时候也会用到一些第三方，比如在使用UICollectionView和UITableView的时候，Facebook有一个框架叫AsyncDisplayKit，这个库就可以很好地提升滚动时流畅性以及图片异步下载功能（不支持sb和autoLayout，需要手动进行约束设置），AsyncDisplayKit用相关node类，替换了UIView和它的子类,而且是线程安全的。它可以异步解码图片，调整图片大小以及对图片和文本进行渲染，把这些操作都放到子线程，滑动的时候就流畅许多。我认为这个库最方便的就是实现图片异步解码。UIImage显示之前必须要先解码完成，而且解码还是同步的。尤其是在UICollectionView/UITableView 中使用 prototype cell显示大图，UIImage的同步解码在滚动的时候会有明显的卡顿。另外一个很吸引人的点是AsyncDisplayKit可以把view层次结构转成layer。因为复杂的view层次结构开销很大，如果不需要view特有的功能（例如点击事件），就可以使用AsyncDisplayKit 的layer backing特性从而获得一些额外的提升。当然这个库还处于开发阶段，还有一些地方地方有待完善，比如不支持缓存，我要使用这个库的时候一般是结合Alamofire和AlamofireImage实现图片的缓存\n\n","source":"_posts/2016/iOS性能优化概述.md","raw":"---\ntitle: iOS性能优化概述\ndate: 2016-07-21 10:51:58\ntags:\n- iOS进阶\ncategories: iOS\n---\n## 响应速度与运行速度\n响应速度和运行速度之间有着微妙的区别，响应速度是指监听用户输入到反馈用户的速度，而运行速度是指处理任务的速度。\n<!--more-->\n用户都讨厌等待，所以你会说让App运行的更快非常重要。确实如此，但是运行速度的提升有一个边界，假如数据要通过网络下载，或者要进行复杂的计算和渲染，那么App不可能立即显示这些内容。这种情况下用户实际上还是愿意等待的，但是你要针对他们的操作给出即时的响应，这种响应可以是简单的按钮状态的改变也可以是复杂的动画效果。让App运行更快很重要，让其迅速响应同样重要。\n使用现实中真实的按钮和开关时会让人感觉靠谱，当按下按钮或者打开开关时你可以百分百确定你进行了操作。但是在触摸屏上你无法感知，所以视觉响应非常重要。如果一个App不能提供这种即时的响应那体验将变得非常糟糕，更具体点说就是响应时间不要超过三分之一秒。当你点击了某个位置但是没有任何事情发生，你会自然而然的认为点击有可能没有被接受。绝大多数人在这时会再点击一次，这可能造成重复的操作。\n\n关于响应速度的三个原则：\n- 迅速回馈用户他的操作已经被接受，然后迅速执行。例如点击按钮时提供一个touch-down状态呈现给用户。\n- 允许用户任意时刻中断\n- 当耗时操作进行时，反馈用户一个进度\n\n针对上边提出的问题，给予状态提示是UI层面的事情，比较容易做到，但是如果保证无论任何时候用户的操作和触摸事件都能得到立刻的响应呢？\n\n### runloop与用户事件响应\n在每次的runloop中，需要处理下边几种事件：\n- handlePort：跨线程通信的一些消息\n- customSrc: 被标记为UI待处理的事件\n- mySelector：本线程方法的调用\n- timerFired：定时器\n\n当我们程序启动完之后，基本上线程就没有什么事情要处理了，这个时候能够做出改变这个状态的事物有下边这几种：\n- 用户手势事件，点一下或者拖一下\n- 系统消息，来电话等\n\n具体的两种如下面所描述：\n\n- 界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。\n\n- 手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。\n\n>总的来讲，并不是当用户触发一个事件的时候这个事件就会被马上执行，而是这个事件会被标记，加入被执行的事件队列，然后等待runloop从这个事件队列中取出来事件，然后执行。\n现在假如说，你有一个点击事件，这个时候这个事件被加入到待执行的事件中，如果前边有一系列的事件要做，那么这个事件就要排队，现象就是，你发现你点完之后没有任何的反应。\n`[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];`利用该方法将大段的方法进行拆分，这样可以保证用户事件的响应。\n\n## 性能优化\n### 运行时间\n前边我们保证了响应速度，现在我们来看一下，如何加快执行的速度。\n基本上我们能够依赖的就是Time Profiler，\n\n### 渲染速度 \n不幸的是Time Profiler不能找出所有的性能问题。当你的App的帧率掉到60（帧/秒）以下你的App就感觉运行得不是那么平滑了。低帧率导致滚动视图和动画卡顿。\n　　帧率下降通常意味着iPad的渲染速度跟不上。视觉上较为理想的帧率不低于60（帧/秒），意味着每一帧应该在六十分之一秒内渲染完。\n\n![](http://i2.piimg.com/567571/8a0a7cd7094e8ce0.png)\n基本上我们使用上边这些选项来查找影响渲染的因素。\n#### color blended layers\n我们知道GPU是图形硬件，主要的工作是混合纹理并算出像素的RGB值，这是一个非常复杂的计算过程，计算的过程越复杂，所需要消耗的时间就越长，GPU的使用率就越高，这并不是一个好的现像，而我们需要做的是减少GPU的计算量。\n我们在这个图层上放置一个完全不透明的图层，那么GPU将会把上面的图层合成到下面的图层当中，由于上面的是一个完全不透明的图层，所以上面的图层会部份遮盖掉下面的图层，而在遮盖掉的矩形区域内，GPU会直接使用上面图层的像素来显示。如果我们最底的图层上放置的是一个有透明度的图层，那么在这个矩形区域里，GPU需要混合上下两个图层来计算出在屏幕上显示出来的像素的RGB值。若在同一个区域内，存在着多个有透明度的图层，那么GPU需要更多的计算才能得出最终像素的RGB值。而我们要做的就是避免像素混合，尽可能地为视图设置背景色，且设置opaque为YES，这会大大减少GPU的计算。\n以label为例\n![](http://i2.piimg.com/567571/324a6b489d2c6fa0.png)\n上边为不透明，下边为透明，那么我们得到的结果是下边混合严重\n上边为iOS7的情况，那么iOS8呢\n![](http://i1.piimg.com/567571/10dcf06a1af655ab.png)\n虽然设置了背景色，但在iOS8上用UILabel显示中文却出现了像素混合的情况，这是为什么呢？我们来看看UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变，就像上图所视(在iOS8刚发布的时候，我一度怀疑Apple歧视中文)。\n\n那怎么解决呢？首先我们来观察一下上图，从图中我们可以看到在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，既然发现这了一点，那么解决方案就很明了了。\n\n设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪，我们来看一下修改后的效果。木有问题了。\nmaskTobounds需要与cornerRadius结合才会离屏渲染，所以这里并不会导致离屏渲染。\n可以的话，要求美工在切图的时候，一定不要切出那些留有透明区域的图片，不然在你显示图片的时候，同样会出现像素混合问题。\n\n## tableView的优化\n\niOS平台因为UIKit本身的特性，需要将所有的UI操作都放在主线程执行，所以有时候就习惯将一些线程安全性不确定的逻辑，以及它线程结束后的汇总工作等等放到了主线程，所以主线程包含大量计算、IO、绘制都有可能造成卡顿。\n\n- 可以通过监控runLoop监控监控卡顿，调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.\n- 使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化\n- 监控后另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.\n- 监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈\n\n- 当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑\n\n- 设置正确的 reuseidentifer 以重用 cell\n\n- 尽量将 View 设置为不透明,包括 cell 本身（backgroundcolor默认是透明的），图层混合靠GPU去渲染,如果透明度设置为100%，那么GPU就会忽略下面所有的layer，节约了很多不必要的运算。模拟器上点击“Debug”菜单，然后选择“color Blended Layers”，会把所有区域分成绿色和红色,绿色的好,红色的性能差（经过混合渲染的），当然也有一些图片虽然是不透明的，但是也会显示红色，如果检查代码没错的话，一般就是图片自身的性质问题了，直接联系美工或后台解决就好了。除非必须要用GPU加载的，其他最好要用CPU加载，因为CPU一般不会百分百加载，可以通过CoreGraphics画出圆角\n\n- 有时候美工失误，图片大小给错了，引起不必要的图片缩放（可以找美工去改，当然也可以异步去裁剪图片然后缓存下来），还是使用Instrument的Color Misaligned Images，黄色表示图片需要缩放，紫色表示没有像素对齐。当然一般情况下图片格式不会给错，有些图片格式是GPU不支持的，就还要劳烦CPU去进行格式转换。还有可以通过Color Offscreen-Rendered Yellow来检测离屏渲染（就是把渲染结果临时保存，等到用的时候再取出，这样相对于普通渲染更消耗内存，使用maskToBounds、设置shadow，重写drawRect方法都会导致离屏渲染）\n避免渐变，cornerRadius在默认情况下，这个属性只会影响视图的背景颜色和 border，但是不会离屏绘制，不影响性能。不用clipsToBounds（过多调用GPU去离屏渲染），而是让后台加载图片并处理圆角，并将处理过的图片赋值给UIImageView。UIImageView 的圆角通过直接截取图片实现，圆角路径直接用贝塞尔曲线UIBezierPath绘制（人为指定路径之后就不会触发离屏渲染），UIGraphicsBeginImageContextWithOptions。UIView的圆角可以使用CoreGraphics画出圆角矩形，核心是CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回，最后把这个图片插入到视图层级的底部。\n“Flash updated Regions”用于标记发生重绘的区域\n\n- 如果 row 的高度不相同,那么将其缓存下来\n- 如果 cell 显示的内容来自网络,那么确保这些内容是通过异步下载\n- 使用 shadowPath 来设置阴影，图层最好不要使用阴影,阴影会导致离屏渲染(在进入屏幕渲染之前,还看不到的时候会再渲染一次,尽量不要产生离屏渲染)\n- 减少 subview 的数量，不要去添加或移除view，要就显示，不要就隐藏\n- 在 cellForRowAtIndexPath 中尽量做更少的操作,最好是在别的地方算好，这个方法里只做数据的显示，如果需要做一些处理,那么最好做一次之后将结果储存起来.\n- 使用适当的数据结构来保存需要的信息,不同的结构会带来不同的操作代价\n- 使用,rowHeight , sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定高度 , 而不是从代理(delegate)中获取\n- cell做数据绑定的时候，最好在willDisPlayCell里面进行，其他操作在cellForRowAtIndexPath，因为前者是第一页有多少条就执行多少次，后者是第一次加载有多少个cell就执行多少次，而且调用后者的时候cell还没显示\n- 读取文件,写入文件,最好是放到子线程,或先读取好,在让tableView去显示\n- tableView滚动的时候,不要去做动画(微信的聊天界面做的就很好,在滚动的时候,动态图就不让他动,滚动停止的时候才动,不然可能会有点影响流畅度)。在滚动的时候加载图片，停止拖拽后在减速过程中不加载图片，减速停止后加载可见范围内图片\n\n## 代码优化checkList\n### 2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）\n\n如果要在UIImageView中显示一个图片，你应保证图片的大小和UIImageView的大小相同。\n因为在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。\n\n如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。\n\n这个类比到图片和动画的渲染中，是通用的。\n\n具体方法参考上面的GCD操作。\n\n### 2.4 正确使用容器的特性\n\nArrays: 有序的一组值。使用index来查找很快，使用value 查找很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 \n\n### 2.5 大文件传输使用gzip\n\n大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。\n\n问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。\n\n减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。\n\n当然，现在苹果已经自动支持了，你只需要告诉你们服务端的同学，传输大文件的时候记得用gzip就完了。\n\n### 2.6 View的重用和懒加载\n\n更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。\n\n重用就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。\n当需要使用View的时候，去可重用队列里面找一找有没有可以被复用的View。\n这里我的一份框架中曾经使用过类似的方法去创建一个图片浏览器，大家可以稍做参考。View的重用\n\n懒加载就是在程序启动时并不进行加载，只有当用到这个对象的时候，才进行加载。\n这个不仅在属性中可以进行这样的使用，在View上面也是一样，不过实现稍有不同。\n懒加载会消耗更少内存，但是在View的显示上会稍有滞后。\n\n### 2.7 Cache\n\n一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。\n\n我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。\n\nNSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。\n\n下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：\n\n\n+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url { NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];  request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; // this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@\"image/*\" forHTTPHeaderField:@\"Accept\"];  return request; }\n\n\n注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。\n\n如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。\n\n### 2.8 记得处理内存警告\n\n一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:\n\n\n如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.\n\n\n幸运的是，UIKit提供了几种收集低内存警告的方法:\n\n在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知\n\n一旦收到这类通知，你就需要释放任何不必要的内存使用。\n\n\n例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。\n\n\n这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。\n\n然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。\n\n### 2.9 重用大的开销对象\n\n这里的大开销是指一些初始化很慢的objects，如：NSDateFormatter和NSCalendar。但是，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。\n\n想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。\n\n注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。\n\n下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：\n\n\n// in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter *formatter;  // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter *)formatter { if (! _formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @\"EEE MMM dd HH:mm:ss Z yyyy\"; // twitter date format } return _formatter; }\n\n\n还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。\n\n### 2.10 避免反复的处理数据\n\n许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。\n\n比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。\n\n类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。\n\n### 2.11 正确设定背景图片\n\n在View里放背景图片就像很多其它iOS编程一样有很多方法:\n\n使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。\n\n如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：\n\n\n// You could also achieve the same result in Interface Builder UIImageView *backgroundView = [ [UIImageView alloc] initWithImage:[UIImage imageNamed:@\"background\"]]; [self.view addSubview:backgroundView];\n\n\n如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：\n\n\nself.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"background\"]];\n\n\n### 2.12 试试苹果最新的WKWebView来处理web\n\nUIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。\n\n但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。\n\n所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。\n\n另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。\n\n最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。\n\n当然，上面是针对你在使用UIWebView的情况下，需要尽量减少使用web的特性，而苹果最近刚推出的Safari的底层框架WKWebView也许能帮我们规避掉很多这样的性能问题。\n\n### 2.13 优化你的TableView\n\nTable view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。\n\n为了保证table view平滑滚动，确保你采取了以下的措施:\n\n正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate\n\n### 2.14 选择正确的数据存储方式\n\n当存储大块数据时你会怎么做？\n\n你有很多选择，比如：\n\n使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data\n\nNSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了\n\nXML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。\n\nNSCoding？不幸的是，它也需要读写文件，所以也有以上问题。\n\n在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。\n\n在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。\n\n如果你使用SQLite，你可以用FMDB(https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。\n\n### 2.15 把Xib换成Storyboard吧\n\n当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。\n\nStoryboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.\n\n当加载XIB时，所有图片都被缓存，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：\n\n\n当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的`imageNamed:`方法来获取图片资源。\n\n\n很明显，同样的事情也发生在storyboards中，但我并没有找到任何支持这个结论的文档。\n\n另外，快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。\n\n你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。\n\n还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！\n\n\n注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度\n\n\n### 2.16 学会手动创建Autorelease Pool\n\nNSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。\n\n假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。\n\n好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：\n\n\nNSArray *urls = [@\"url1\",@\"url2\"]; for (NSURL *url in urls) { @autoreleasepool { NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL: url encoding: NSUTF8StringEncoding error: &error]; /* Process the string, creating and autoreleasing more objects. */ } }\n\n\n这段代码在每次遍历后释放所有autorelease对象\n\n### 2.17UIImage初始化\n\nA：imagedNamed初始化\n\nB：imageWithContentsOfFile初始化\n\n二者不同之处在于，imageNamed默认加载图片成功后会内存中缓存图片，这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果缓存中没有找到相应的图片对象，则从指定地方加载图片然后缓存对象，并返回这个图片对象\n\n而imageWithContentsOfFile则仅只加载图片，不缓存\n\n大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事，当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式，这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间\n\n使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显\n\n\n### 2.18列表滚动的时候不要对imageview赋值\n\n```\n// 只在NSDefaultRunLoopMode模式下显示图片\n    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"placeholder\"] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];\n```\n比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片\n\n### 一些第三方的使用\n 当然有时候也会用到一些第三方，比如在使用UICollectionView和UITableView的时候，Facebook有一个框架叫AsyncDisplayKit，这个库就可以很好地提升滚动时流畅性以及图片异步下载功能（不支持sb和autoLayout，需要手动进行约束设置），AsyncDisplayKit用相关node类，替换了UIView和它的子类,而且是线程安全的。它可以异步解码图片，调整图片大小以及对图片和文本进行渲染，把这些操作都放到子线程，滑动的时候就流畅许多。我认为这个库最方便的就是实现图片异步解码。UIImage显示之前必须要先解码完成，而且解码还是同步的。尤其是在UICollectionView/UITableView 中使用 prototype cell显示大图，UIImage的同步解码在滚动的时候会有明显的卡顿。另外一个很吸引人的点是AsyncDisplayKit可以把view层次结构转成layer。因为复杂的view层次结构开销很大，如果不需要view特有的功能（例如点击事件），就可以使用AsyncDisplayKit 的layer backing特性从而获得一些额外的提升。当然这个库还处于开发阶段，还有一些地方地方有待完善，比如不支持缓存，我要使用这个库的时候一般是结合Alamofire和AlamofireImage实现图片的缓存\n\n","slug":"2016/iOS性能优化概述","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnu004vsaua94az9zzn","content":"<h2 id=\"响应速度与运行速度\"><a href=\"#响应速度与运行速度\" class=\"headerlink\" title=\"响应速度与运行速度\"></a>响应速度与运行速度</h2><p>响应速度和运行速度之间有着微妙的区别，响应速度是指监听用户输入到反馈用户的速度，而运行速度是指处理任务的速度。<br><a id=\"more\"></a><br>用户都讨厌等待，所以你会说让App运行的更快非常重要。确实如此，但是运行速度的提升有一个边界，假如数据要通过网络下载，或者要进行复杂的计算和渲染，那么App不可能立即显示这些内容。这种情况下用户实际上还是愿意等待的，但是你要针对他们的操作给出即时的响应，这种响应可以是简单的按钮状态的改变也可以是复杂的动画效果。让App运行更快很重要，让其迅速响应同样重要。<br>使用现实中真实的按钮和开关时会让人感觉靠谱，当按下按钮或者打开开关时你可以百分百确定你进行了操作。但是在触摸屏上你无法感知，所以视觉响应非常重要。如果一个App不能提供这种即时的响应那体验将变得非常糟糕，更具体点说就是响应时间不要超过三分之一秒。当你点击了某个位置但是没有任何事情发生，你会自然而然的认为点击有可能没有被接受。绝大多数人在这时会再点击一次，这可能造成重复的操作。</p>\n<p>关于响应速度的三个原则：</p>\n<ul>\n<li>迅速回馈用户他的操作已经被接受，然后迅速执行。例如点击按钮时提供一个touch-down状态呈现给用户。</li>\n<li>允许用户任意时刻中断</li>\n<li>当耗时操作进行时，反馈用户一个进度</li>\n</ul>\n<p>针对上边提出的问题，给予状态提示是UI层面的事情，比较容易做到，但是如果保证无论任何时候用户的操作和触摸事件都能得到立刻的响应呢？</p>\n<h3 id=\"runloop与用户事件响应\"><a href=\"#runloop与用户事件响应\" class=\"headerlink\" title=\"runloop与用户事件响应\"></a>runloop与用户事件响应</h3><p>在每次的runloop中，需要处理下边几种事件：</p>\n<ul>\n<li>handlePort：跨线程通信的一些消息</li>\n<li>customSrc: 被标记为UI待处理的事件</li>\n<li>mySelector：本线程方法的调用</li>\n<li>timerFired：定时器</li>\n</ul>\n<p>当我们程序启动完之后，基本上线程就没有什么事情要处理了，这个时候能够做出改变这个状态的事物有下边这几种：</p>\n<ul>\n<li>用户手势事件，点一下或者拖一下</li>\n<li>系统消息，来电话等</li>\n</ul>\n<p>具体的两种如下面所描述：</p>\n<ul>\n<li><p>界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n</li>\n<li><p>手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</li>\n</ul>\n<blockquote>\n<p>总的来讲，并不是当用户触发一个事件的时候这个事件就会被马上执行，而是这个事件会被标记，加入被执行的事件队列，然后等待runloop从这个事件队列中取出来事件，然后执行。<br>现在假如说，你有一个点击事件，这个时候这个事件被加入到待执行的事件中，如果前边有一系列的事件要做，那么这个事件就要排队，现象就是，你发现你点完之后没有任何的反应。<br><code>[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</code>利用该方法将大段的方法进行拆分，这样可以保证用户事件的响应。</p>\n</blockquote>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"运行时间\"><a href=\"#运行时间\" class=\"headerlink\" title=\"运行时间\"></a>运行时间</h3><p>前边我们保证了响应速度，现在我们来看一下，如何加快执行的速度。<br>基本上我们能够依赖的就是Time Profiler，</p>\n<h3 id=\"渲染速度\"><a href=\"#渲染速度\" class=\"headerlink\" title=\"渲染速度\"></a>渲染速度</h3><p>不幸的是Time Profiler不能找出所有的性能问题。当你的App的帧率掉到60（帧/秒）以下你的App就感觉运行得不是那么平滑了。低帧率导致滚动视图和动画卡顿。<br>　　帧率下降通常意味着iPad的渲染速度跟不上。视觉上较为理想的帧率不低于60（帧/秒），意味着每一帧应该在六十分之一秒内渲染完。</p>\n<p><img src=\"http://i2.piimg.com/567571/8a0a7cd7094e8ce0.png\" alt=\"\"><br>基本上我们使用上边这些选项来查找影响渲染的因素。</p>\n<h4 id=\"color-blended-layers\"><a href=\"#color-blended-layers\" class=\"headerlink\" title=\"color blended layers\"></a>color blended layers</h4><p>我们知道GPU是图形硬件，主要的工作是混合纹理并算出像素的RGB值，这是一个非常复杂的计算过程，计算的过程越复杂，所需要消耗的时间就越长，GPU的使用率就越高，这并不是一个好的现像，而我们需要做的是减少GPU的计算量。<br>我们在这个图层上放置一个完全不透明的图层，那么GPU将会把上面的图层合成到下面的图层当中，由于上面的是一个完全不透明的图层，所以上面的图层会部份遮盖掉下面的图层，而在遮盖掉的矩形区域内，GPU会直接使用上面图层的像素来显示。如果我们最底的图层上放置的是一个有透明度的图层，那么在这个矩形区域里，GPU需要混合上下两个图层来计算出在屏幕上显示出来的像素的RGB值。若在同一个区域内，存在着多个有透明度的图层，那么GPU需要更多的计算才能得出最终像素的RGB值。而我们要做的就是避免像素混合，尽可能地为视图设置背景色，且设置opaque为YES，这会大大减少GPU的计算。<br>以label为例<br><img src=\"http://i2.piimg.com/567571/324a6b489d2c6fa0.png\" alt=\"\"><br>上边为不透明，下边为透明，那么我们得到的结果是下边混合严重<br>上边为iOS7的情况，那么iOS8呢<br><img src=\"http://i1.piimg.com/567571/10dcf06a1af655ab.png\" alt=\"\"><br>虽然设置了背景色，但在iOS8上用UILabel显示中文却出现了像素混合的情况，这是为什么呢？我们来看看UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变，就像上图所视(在iOS8刚发布的时候，我一度怀疑Apple歧视中文)。</p>\n<p>那怎么解决呢？首先我们来观察一下上图，从图中我们可以看到在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，既然发现这了一点，那么解决方案就很明了了。</p>\n<p>设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪，我们来看一下修改后的效果。木有问题了。<br>maskTobounds需要与cornerRadius结合才会离屏渲染，所以这里并不会导致离屏渲染。<br>可以的话，要求美工在切图的时候，一定不要切出那些留有透明区域的图片，不然在你显示图片的时候，同样会出现像素混合问题。</p>\n<h2 id=\"tableView的优化\"><a href=\"#tableView的优化\" class=\"headerlink\" title=\"tableView的优化\"></a>tableView的优化</h2><p>iOS平台因为UIKit本身的特性，需要将所有的UI操作都放在主线程执行，所以有时候就习惯将一些线程安全性不确定的逻辑，以及它线程结束后的汇总工作等等放到了主线程，所以主线程包含大量计算、IO、绘制都有可能造成卡顿。</p>\n<ul>\n<li>可以通过监控runLoop监控监控卡顿，调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</li>\n<li>使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化</li>\n<li>监控后另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.</li>\n<li><p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈</p>\n</li>\n<li><p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑</p>\n</li>\n<li><p>设置正确的 reuseidentifer 以重用 cell</p>\n</li>\n<li><p>尽量将 View 设置为不透明,包括 cell 本身（backgroundcolor默认是透明的），图层混合靠GPU去渲染,如果透明度设置为100%，那么GPU就会忽略下面所有的layer，节约了很多不必要的运算。模拟器上点击“Debug”菜单，然后选择“color Blended Layers”，会把所有区域分成绿色和红色,绿色的好,红色的性能差（经过混合渲染的），当然也有一些图片虽然是不透明的，但是也会显示红色，如果检查代码没错的话，一般就是图片自身的性质问题了，直接联系美工或后台解决就好了。除非必须要用GPU加载的，其他最好要用CPU加载，因为CPU一般不会百分百加载，可以通过CoreGraphics画出圆角</p>\n</li>\n<li><p>有时候美工失误，图片大小给错了，引起不必要的图片缩放（可以找美工去改，当然也可以异步去裁剪图片然后缓存下来），还是使用Instrument的Color Misaligned Images，黄色表示图片需要缩放，紫色表示没有像素对齐。当然一般情况下图片格式不会给错，有些图片格式是GPU不支持的，就还要劳烦CPU去进行格式转换。还有可以通过Color Offscreen-Rendered Yellow来检测离屏渲染（就是把渲染结果临时保存，等到用的时候再取出，这样相对于普通渲染更消耗内存，使用maskToBounds、设置shadow，重写drawRect方法都会导致离屏渲染）<br>避免渐变，cornerRadius在默认情况下，这个属性只会影响视图的背景颜色和 border，但是不会离屏绘制，不影响性能。不用clipsToBounds（过多调用GPU去离屏渲染），而是让后台加载图片并处理圆角，并将处理过的图片赋值给UIImageView。UIImageView 的圆角通过直接截取图片实现，圆角路径直接用贝塞尔曲线UIBezierPath绘制（人为指定路径之后就不会触发离屏渲染），UIGraphicsBeginImageContextWithOptions。UIView的圆角可以使用CoreGraphics画出圆角矩形，核心是CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回，最后把这个图片插入到视图层级的底部。<br>“Flash updated Regions”用于标记发生重绘的区域</p>\n</li>\n<li><p>如果 row 的高度不相同,那么将其缓存下来</p>\n</li>\n<li>如果 cell 显示的内容来自网络,那么确保这些内容是通过异步下载</li>\n<li>使用 shadowPath 来设置阴影，图层最好不要使用阴影,阴影会导致离屏渲染(在进入屏幕渲染之前,还看不到的时候会再渲染一次,尽量不要产生离屏渲染)</li>\n<li>减少 subview 的数量，不要去添加或移除view，要就显示，不要就隐藏</li>\n<li>在 cellForRowAtIndexPath 中尽量做更少的操作,最好是在别的地方算好，这个方法里只做数据的显示，如果需要做一些处理,那么最好做一次之后将结果储存起来.</li>\n<li>使用适当的数据结构来保存需要的信息,不同的结构会带来不同的操作代价</li>\n<li>使用,rowHeight , sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定高度 , 而不是从代理(delegate)中获取</li>\n<li>cell做数据绑定的时候，最好在willDisPlayCell里面进行，其他操作在cellForRowAtIndexPath，因为前者是第一页有多少条就执行多少次，后者是第一次加载有多少个cell就执行多少次，而且调用后者的时候cell还没显示</li>\n<li>读取文件,写入文件,最好是放到子线程,或先读取好,在让tableView去显示</li>\n<li>tableView滚动的时候,不要去做动画(微信的聊天界面做的就很好,在滚动的时候,动态图就不让他动,滚动停止的时候才动,不然可能会有点影响流畅度)。在滚动的时候加载图片，停止拖拽后在减速过程中不加载图片，减速停止后加载可见范围内图片</li>\n</ul>\n<h2 id=\"代码优化checkList\"><a href=\"#代码优化checkList\" class=\"headerlink\" title=\"代码优化checkList\"></a>代码优化checkList</h2><h3 id=\"2-3-提前调整ImageView中的图片大小（同图片和动画的渲染）\"><a href=\"#2-3-提前调整ImageView中的图片大小（同图片和动画的渲染）\" class=\"headerlink\" title=\"2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）\"></a>2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）</h3><p>如果要在UIImageView中显示一个图片，你应保证图片的大小和UIImageView的大小相同。<br>因为在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</p>\n<p>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p>\n<p>这个类比到图片和动画的渲染中，是通用的。</p>\n<p>具体方法参考上面的GCD操作。</p>\n<h3 id=\"2-4-正确使用容器的特性\"><a href=\"#2-4-正确使用容器的特性\" class=\"headerlink\" title=\"2.4 正确使用容器的特性\"></a>2.4 正确使用容器的特性</h3><p>Arrays: 有序的一组值。使用index来查找很快，使用value 查找很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 </p>\n<h3 id=\"2-5-大文件传输使用gzip\"><a href=\"#2-5-大文件传输使用gzip\" class=\"headerlink\" title=\"2.5 大文件传输使用gzip\"></a>2.5 大文件传输使用gzip</h3><p>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</p>\n<p>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。</p>\n<p>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。</p>\n<p>当然，现在苹果已经自动支持了，你只需要告诉你们服务端的同学，传输大文件的时候记得用gzip就完了。</p>\n<h3 id=\"2-6-View的重用和懒加载\"><a href=\"#2-6-View的重用和懒加载\" class=\"headerlink\" title=\"2.6 View的重用和懒加载\"></a>2.6 View的重用和懒加载</h3><p>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</p>\n<p>重用就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。<br>当需要使用View的时候，去可重用队列里面找一找有没有可以被复用的View。<br>这里我的一份框架中曾经使用过类似的方法去创建一个图片浏览器，大家可以稍做参考。View的重用</p>\n<p>懒加载就是在程序启动时并不进行加载，只有当用到这个对象的时候，才进行加载。<br>这个不仅在属性中可以进行这样的使用，在View上面也是一样，不过实现稍有不同。<br>懒加载会消耗更少内存，但是在View的显示上会稍有滞后。</p>\n<h3 id=\"2-7-Cache\"><a href=\"#2-7-Cache\" class=\"headerlink\" title=\"2.7 Cache\"></a>2.7 Cache</h3><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</p>\n<p>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p>\n<p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。</p>\n<p>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p>\n<ul>\n<li>(NSMutableURLRequest <em>)imageRequestWithURL:(NSURL </em>)url { NSMutableURLRequest <em>request = [NSMutableURLRequest requestWithURL:url];  request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; // this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@”image/</em>“ forHTTPHeaderField:@”Accept”];  return request; }</li>\n</ul>\n<p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p>\n<p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。</p>\n<h3 id=\"2-8-记得处理内存警告\"><a href=\"#2-8-记得处理内存警告\" class=\"headerlink\" title=\"2.8 记得处理内存警告\"></a>2.8 记得处理内存警告</h3><p>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:</p>\n<p>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.</p>\n<p>幸运的是，UIKit提供了几种收集低内存警告的方法:</p>\n<p>在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</p>\n<p>一旦收到这类通知，你就需要释放任何不必要的内存使用。</p>\n<p>例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>\n<p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p>\n<p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>\n<h3 id=\"2-9-重用大的开销对象\"><a href=\"#2-9-重用大的开销对象\" class=\"headerlink\" title=\"2.9 重用大的开销对象\"></a>2.9 重用大的开销对象</h3><p>这里的大开销是指一些初始化很慢的objects，如：NSDateFormatter和NSCalendar。但是，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。</p>\n<p>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p>\n<p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。</p>\n<p>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p>\n<p>// in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter <em>formatter;  // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter </em>)formatter { if (! _formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @”EEE MMM dd HH:mm:ss Z yyyy”; // twitter date format } return _formatter; }</p>\n<p>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</p>\n<h3 id=\"2-10-避免反复的处理数据\"><a href=\"#2-10-避免反复的处理数据\" class=\"headerlink\" title=\"2.10 避免反复的处理数据\"></a>2.10 避免反复的处理数据</h3><p>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。</p>\n<p>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</p>\n<p>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</p>\n<h3 id=\"2-11-正确设定背景图片\"><a href=\"#2-11-正确设定背景图片\" class=\"headerlink\" title=\"2.11 正确设定背景图片\"></a>2.11 正确设定背景图片</h3><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p>\n<p>使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。</p>\n<p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>\n<p>// You could also achieve the same result in Interface Builder UIImageView *backgroundView = [ [UIImageView alloc] initWithImage:[UIImage imageNamed:@”background”]]; [self.view addSubview:backgroundView];</p>\n<p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>\n<p>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”background”]];</p>\n<h3 id=\"2-12-试试苹果最新的WKWebView来处理web\"><a href=\"#2-12-试试苹果最新的WKWebView来处理web\" class=\"headerlink\" title=\"2.12 试试苹果最新的WKWebView来处理web\"></a>2.12 试试苹果最新的WKWebView来处理web</h3><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。</p>\n<p>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。</p>\n<p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。</p>\n<p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。</p>\n<p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>\n<p>当然，上面是针对你在使用UIWebView的情况下，需要尽量减少使用web的特性，而苹果最近刚推出的Safari的底层框架WKWebView也许能帮我们规避掉很多这样的性能问题。</p>\n<h3 id=\"2-13-优化你的TableView\"><a href=\"#2-13-优化你的TableView\" class=\"headerlink\" title=\"2.13 优化你的TableView\"></a>2.13 优化你的TableView</h3><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。</p>\n<p>为了保证table view平滑滚动，确保你采取了以下的措施:</p>\n<p>正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate</p>\n<h3 id=\"2-14-选择正确的数据存储方式\"><a href=\"#2-14-选择正确的数据存储方式\" class=\"headerlink\" title=\"2.14 选择正确的数据存储方式\"></a>2.14 选择正确的数据存储方式</h3><p>当存储大块数据时你会怎么做？</p>\n<p>你有很多选择，比如：</p>\n<p>使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data</p>\n<p>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>\n<p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>\n<p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>\n<p>在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</p>\n<p>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>\n<p>如果你使用SQLite，你可以用FMDB(<a href=\"https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C\" target=\"_blank\" rel=\"external\">https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C</a> API了。</p>\n<h3 id=\"2-15-把Xib换成Storyboard吧\"><a href=\"#2-15-把Xib换成Storyboard吧\" class=\"headerlink\" title=\"2.15 把Xib换成Storyboard吧\"></a>2.15 把Xib换成Storyboard吧</h3><p>当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。</p>\n<p>Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>\n<p>当加载XIB时，所有图片都被缓存，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：</p>\n<p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的<code>imageNamed:</code>方法来获取图片资源。</p>\n<p>很明显，同样的事情也发生在storyboards中，但我并没有找到任何支持这个结论的文档。</p>\n<p>另外，快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。</p>\n<p>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</p>\n<p>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！</p>\n<p>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</p>\n<h3 id=\"2-16-学会手动创建Autorelease-Pool\"><a href=\"#2-16-学会手动创建Autorelease-Pool\" class=\"headerlink\" title=\"2.16 学会手动创建Autorelease Pool\"></a>2.16 学会手动创建Autorelease Pool</h3><p>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</p>\n<p>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。</p>\n<p>好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</p>\n<p>NSArray <em>urls = [@”url1”,@”url2”]; for (NSURL </em>url in urls) { @autoreleasepool { NSError <em>error; NSString </em>fileContents = [NSString stringWithContentsOfURL: url encoding: NSUTF8StringEncoding error: &amp;error]; /<em> Process the string, creating and autoreleasing more objects. </em>/ } }</p>\n<p>这段代码在每次遍历后释放所有autorelease对象</p>\n<h3 id=\"2-17UIImage初始化\"><a href=\"#2-17UIImage初始化\" class=\"headerlink\" title=\"2.17UIImage初始化\"></a>2.17UIImage初始化</h3><p>A：imagedNamed初始化</p>\n<p>B：imageWithContentsOfFile初始化</p>\n<p>二者不同之处在于，imageNamed默认加载图片成功后会内存中缓存图片，这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果缓存中没有找到相应的图片对象，则从指定地方加载图片然后缓存对象，并返回这个图片对象</p>\n<p>而imageWithContentsOfFile则仅只加载图片，不缓存</p>\n<p>大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事，当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式，这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间</p>\n<p>使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显</p>\n<h3 id=\"2-18列表滚动的时候不要对imageview赋值\"><a href=\"#2-18列表滚动的时候不要对imageview赋值\" class=\"headerlink\" title=\"2.18列表滚动的时候不要对imageview赋值\"></a>2.18列表滚动的时候不要对imageview赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只在NSDefaultRunLoopMode模式下显示图片</div><div class=\"line\">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>\n<p>比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片</p>\n<h3 id=\"一些第三方的使用\"><a href=\"#一些第三方的使用\" class=\"headerlink\" title=\"一些第三方的使用\"></a>一些第三方的使用</h3><p> 当然有时候也会用到一些第三方，比如在使用UICollectionView和UITableView的时候，Facebook有一个框架叫AsyncDisplayKit，这个库就可以很好地提升滚动时流畅性以及图片异步下载功能（不支持sb和autoLayout，需要手动进行约束设置），AsyncDisplayKit用相关node类，替换了UIView和它的子类,而且是线程安全的。它可以异步解码图片，调整图片大小以及对图片和文本进行渲染，把这些操作都放到子线程，滑动的时候就流畅许多。我认为这个库最方便的就是实现图片异步解码。UIImage显示之前必须要先解码完成，而且解码还是同步的。尤其是在UICollectionView/UITableView 中使用 prototype cell显示大图，UIImage的同步解码在滚动的时候会有明显的卡顿。另外一个很吸引人的点是AsyncDisplayKit可以把view层次结构转成layer。因为复杂的view层次结构开销很大，如果不需要view特有的功能（例如点击事件），就可以使用AsyncDisplayKit 的layer backing特性从而获得一些额外的提升。当然这个库还处于开发阶段，还有一些地方地方有待完善，比如不支持缓存，我要使用这个库的时候一般是结合Alamofire和AlamofireImage实现图片的缓存</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"响应速度与运行速度\"><a href=\"#响应速度与运行速度\" class=\"headerlink\" title=\"响应速度与运行速度\"></a>响应速度与运行速度</h2><p>响应速度和运行速度之间有着微妙的区别，响应速度是指监听用户输入到反馈用户的速度，而运行速度是指处理任务的速度。<br>","more":"<br>用户都讨厌等待，所以你会说让App运行的更快非常重要。确实如此，但是运行速度的提升有一个边界，假如数据要通过网络下载，或者要进行复杂的计算和渲染，那么App不可能立即显示这些内容。这种情况下用户实际上还是愿意等待的，但是你要针对他们的操作给出即时的响应，这种响应可以是简单的按钮状态的改变也可以是复杂的动画效果。让App运行更快很重要，让其迅速响应同样重要。<br>使用现实中真实的按钮和开关时会让人感觉靠谱，当按下按钮或者打开开关时你可以百分百确定你进行了操作。但是在触摸屏上你无法感知，所以视觉响应非常重要。如果一个App不能提供这种即时的响应那体验将变得非常糟糕，更具体点说就是响应时间不要超过三分之一秒。当你点击了某个位置但是没有任何事情发生，你会自然而然的认为点击有可能没有被接受。绝大多数人在这时会再点击一次，这可能造成重复的操作。</p>\n<p>关于响应速度的三个原则：</p>\n<ul>\n<li>迅速回馈用户他的操作已经被接受，然后迅速执行。例如点击按钮时提供一个touch-down状态呈现给用户。</li>\n<li>允许用户任意时刻中断</li>\n<li>当耗时操作进行时，反馈用户一个进度</li>\n</ul>\n<p>针对上边提出的问题，给予状态提示是UI层面的事情，比较容易做到，但是如果保证无论任何时候用户的操作和触摸事件都能得到立刻的响应呢？</p>\n<h3 id=\"runloop与用户事件响应\"><a href=\"#runloop与用户事件响应\" class=\"headerlink\" title=\"runloop与用户事件响应\"></a>runloop与用户事件响应</h3><p>在每次的runloop中，需要处理下边几种事件：</p>\n<ul>\n<li>handlePort：跨线程通信的一些消息</li>\n<li>customSrc: 被标记为UI待处理的事件</li>\n<li>mySelector：本线程方法的调用</li>\n<li>timerFired：定时器</li>\n</ul>\n<p>当我们程序启动完之后，基本上线程就没有什么事情要处理了，这个时候能够做出改变这个状态的事物有下边这几种：</p>\n<ul>\n<li>用户手势事件，点一下或者拖一下</li>\n<li>系统消息，来电话等</li>\n</ul>\n<p>具体的两种如下面所描述：</p>\n<ul>\n<li><p>界面刷新： 当UI改变（ Frame变化、 UIView/CALayer 的继承结构变化等）时，或手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理。 苹果注册了一个用来监听BeforeWaiting和Exit的Observer，在它的回调函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>\n</li>\n<li><p>手势识别： 如果上一步的 _UIApplicationHandleEventQueue() 识别到是一个guesture手势，会调用Cancel方法将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，其回调函数为 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>\n</li>\n</ul>\n<blockquote>\n<p>总的来讲，并不是当用户触发一个事件的时候这个事件就会被马上执行，而是这个事件会被标记，加入被执行的事件队列，然后等待runloop从这个事件队列中取出来事件，然后执行。<br>现在假如说，你有一个点击事件，这个时候这个事件被加入到待执行的事件中，如果前边有一系列的事件要做，那么这个事件就要排队，现象就是，你发现你点完之后没有任何的反应。<br><code>[self performSelector:@selector(perform4) withObject:nil afterDelay:0.005];</code>利用该方法将大段的方法进行拆分，这样可以保证用户事件的响应。</p>\n</blockquote>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h3 id=\"运行时间\"><a href=\"#运行时间\" class=\"headerlink\" title=\"运行时间\"></a>运行时间</h3><p>前边我们保证了响应速度，现在我们来看一下，如何加快执行的速度。<br>基本上我们能够依赖的就是Time Profiler，</p>\n<h3 id=\"渲染速度\"><a href=\"#渲染速度\" class=\"headerlink\" title=\"渲染速度\"></a>渲染速度</h3><p>不幸的是Time Profiler不能找出所有的性能问题。当你的App的帧率掉到60（帧/秒）以下你的App就感觉运行得不是那么平滑了。低帧率导致滚动视图和动画卡顿。<br>　　帧率下降通常意味着iPad的渲染速度跟不上。视觉上较为理想的帧率不低于60（帧/秒），意味着每一帧应该在六十分之一秒内渲染完。</p>\n<p><img src=\"http://i2.piimg.com/567571/8a0a7cd7094e8ce0.png\" alt=\"\"><br>基本上我们使用上边这些选项来查找影响渲染的因素。</p>\n<h4 id=\"color-blended-layers\"><a href=\"#color-blended-layers\" class=\"headerlink\" title=\"color blended layers\"></a>color blended layers</h4><p>我们知道GPU是图形硬件，主要的工作是混合纹理并算出像素的RGB值，这是一个非常复杂的计算过程，计算的过程越复杂，所需要消耗的时间就越长，GPU的使用率就越高，这并不是一个好的现像，而我们需要做的是减少GPU的计算量。<br>我们在这个图层上放置一个完全不透明的图层，那么GPU将会把上面的图层合成到下面的图层当中，由于上面的是一个完全不透明的图层，所以上面的图层会部份遮盖掉下面的图层，而在遮盖掉的矩形区域内，GPU会直接使用上面图层的像素来显示。如果我们最底的图层上放置的是一个有透明度的图层，那么在这个矩形区域里，GPU需要混合上下两个图层来计算出在屏幕上显示出来的像素的RGB值。若在同一个区域内，存在着多个有透明度的图层，那么GPU需要更多的计算才能得出最终像素的RGB值。而我们要做的就是避免像素混合，尽可能地为视图设置背景色，且设置opaque为YES，这会大大减少GPU的计算。<br>以label为例<br><img src=\"http://i2.piimg.com/567571/324a6b489d2c6fa0.png\" alt=\"\"><br>上边为不透明，下边为透明，那么我们得到的结果是下边混合严重<br>上边为iOS7的情况，那么iOS8呢<br><img src=\"http://i1.piimg.com/567571/10dcf06a1af655ab.png\" alt=\"\"><br>虽然设置了背景色，但在iOS8上用UILabel显示中文却出现了像素混合的情况，这是为什么呢？我们来看看UILabel在iOS8前后的变化，在iOS8以前，UILabel使用的是CALayer作为底图层，而在iOS8开始，UILabel的底图层变成了_UILabelLayer，绘制文本也有所改变，就像上图所视(在iOS8刚发布的时候，我一度怀疑Apple歧视中文)。</p>\n<p>那怎么解决呢？首先我们来观察一下上图，从图中我们可以看到在背景色的四周多了一圈透明的边，而这一圈透明的边明显超出了图层的矩形区域，既然发现这了一点，那么解决方案就很明了了。</p>\n<p>设置图层的masksToBounds为YES时，图层将会沿着Bounds进行裁剪，我们来看一下修改后的效果。木有问题了。<br>maskTobounds需要与cornerRadius结合才会离屏渲染，所以这里并不会导致离屏渲染。<br>可以的话，要求美工在切图的时候，一定不要切出那些留有透明区域的图片，不然在你显示图片的时候，同样会出现像素混合问题。</p>\n<h2 id=\"tableView的优化\"><a href=\"#tableView的优化\" class=\"headerlink\" title=\"tableView的优化\"></a>tableView的优化</h2><p>iOS平台因为UIKit本身的特性，需要将所有的UI操作都放在主线程执行，所以有时候就习惯将一些线程安全性不确定的逻辑，以及它线程结束后的汇总工作等等放到了主线程，所以主线程包含大量计算、IO、绘制都有可能造成卡顿。</p>\n<ul>\n<li>可以通过监控runLoop监控监控卡顿，调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.</li>\n<li>使用到CFRunLoopObserverRef,通过它可以实时获得这些状态值的变化</li>\n<li>监控后另外再开启一个线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手.</li>\n<li><p>监控到了卡顿现场,当然下一步便是记录此时的函数调用信息,此处可以使用一个第三方Crash收集组件PLCrashReporter,它不仅可以收集Crash信息也可用于实时获取各线程的调用堆栈</p>\n</li>\n<li><p>当检测到卡顿时,抓取堆栈信息,然后在客户端做一些过滤处理,便可以上报到服务器,通过收集一定量的卡顿数据后经过分析便能准确定位需要优化的逻辑</p>\n</li>\n<li><p>设置正确的 reuseidentifer 以重用 cell</p>\n</li>\n<li><p>尽量将 View 设置为不透明,包括 cell 本身（backgroundcolor默认是透明的），图层混合靠GPU去渲染,如果透明度设置为100%，那么GPU就会忽略下面所有的layer，节约了很多不必要的运算。模拟器上点击“Debug”菜单，然后选择“color Blended Layers”，会把所有区域分成绿色和红色,绿色的好,红色的性能差（经过混合渲染的），当然也有一些图片虽然是不透明的，但是也会显示红色，如果检查代码没错的话，一般就是图片自身的性质问题了，直接联系美工或后台解决就好了。除非必须要用GPU加载的，其他最好要用CPU加载，因为CPU一般不会百分百加载，可以通过CoreGraphics画出圆角</p>\n</li>\n<li><p>有时候美工失误，图片大小给错了，引起不必要的图片缩放（可以找美工去改，当然也可以异步去裁剪图片然后缓存下来），还是使用Instrument的Color Misaligned Images，黄色表示图片需要缩放，紫色表示没有像素对齐。当然一般情况下图片格式不会给错，有些图片格式是GPU不支持的，就还要劳烦CPU去进行格式转换。还有可以通过Color Offscreen-Rendered Yellow来检测离屏渲染（就是把渲染结果临时保存，等到用的时候再取出，这样相对于普通渲染更消耗内存，使用maskToBounds、设置shadow，重写drawRect方法都会导致离屏渲染）<br>避免渐变，cornerRadius在默认情况下，这个属性只会影响视图的背景颜色和 border，但是不会离屏绘制，不影响性能。不用clipsToBounds（过多调用GPU去离屏渲染），而是让后台加载图片并处理圆角，并将处理过的图片赋值给UIImageView。UIImageView 的圆角通过直接截取图片实现，圆角路径直接用贝塞尔曲线UIBezierPath绘制（人为指定路径之后就不会触发离屏渲染），UIGraphicsBeginImageContextWithOptions。UIView的圆角可以使用CoreGraphics画出圆角矩形，核心是CGContextAddArcToPoint 函数。它中间的四个参数表示曲线的起点和终点坐标，最后一个参数表示半径。调用了四次函数后，就可以画出圆角矩形。最后再从当前的绘图上下文中获取图片并返回，最后把这个图片插入到视图层级的底部。<br>“Flash updated Regions”用于标记发生重绘的区域</p>\n</li>\n<li><p>如果 row 的高度不相同,那么将其缓存下来</p>\n</li>\n<li>如果 cell 显示的内容来自网络,那么确保这些内容是通过异步下载</li>\n<li>使用 shadowPath 来设置阴影，图层最好不要使用阴影,阴影会导致离屏渲染(在进入屏幕渲染之前,还看不到的时候会再渲染一次,尽量不要产生离屏渲染)</li>\n<li>减少 subview 的数量，不要去添加或移除view，要就显示，不要就隐藏</li>\n<li>在 cellForRowAtIndexPath 中尽量做更少的操作,最好是在别的地方算好，这个方法里只做数据的显示，如果需要做一些处理,那么最好做一次之后将结果储存起来.</li>\n<li>使用适当的数据结构来保存需要的信息,不同的结构会带来不同的操作代价</li>\n<li>使用,rowHeight , sectionFooterHeight 和 sectionHeaderHeight 来设置一个恒定高度 , 而不是从代理(delegate)中获取</li>\n<li>cell做数据绑定的时候，最好在willDisPlayCell里面进行，其他操作在cellForRowAtIndexPath，因为前者是第一页有多少条就执行多少次，后者是第一次加载有多少个cell就执行多少次，而且调用后者的时候cell还没显示</li>\n<li>读取文件,写入文件,最好是放到子线程,或先读取好,在让tableView去显示</li>\n<li>tableView滚动的时候,不要去做动画(微信的聊天界面做的就很好,在滚动的时候,动态图就不让他动,滚动停止的时候才动,不然可能会有点影响流畅度)。在滚动的时候加载图片，停止拖拽后在减速过程中不加载图片，减速停止后加载可见范围内图片</li>\n</ul>\n<h2 id=\"代码优化checkList\"><a href=\"#代码优化checkList\" class=\"headerlink\" title=\"代码优化checkList\"></a>代码优化checkList</h2><h3 id=\"2-3-提前调整ImageView中的图片大小（同图片和动画的渲染）\"><a href=\"#2-3-提前调整ImageView中的图片大小（同图片和动画的渲染）\" class=\"headerlink\" title=\"2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）\"></a>2.3 提前调整ImageView中的图片大小（同图片和动画的渲染）</h3><p>如果要在UIImageView中显示一个图片，你应保证图片的大小和UIImageView的大小相同。<br>因为在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。</p>\n<p>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p>\n<p>这个类比到图片和动画的渲染中，是通用的。</p>\n<p>具体方法参考上面的GCD操作。</p>\n<h3 id=\"2-4-正确使用容器的特性\"><a href=\"#2-4-正确使用容器的特性\" class=\"headerlink\" title=\"2.4 正确使用容器的特性\"></a>2.4 正确使用容器的特性</h3><p>Arrays: 有序的一组值。使用index来查找很快，使用value 查找很慢， 插入/删除很慢。 Dictionaries: 存储键值对。 用键来查找比较快。 Sets: 无序的一组值。用值来查找很快，插入/删除很快。 </p>\n<h3 id=\"2-5-大文件传输使用gzip\"><a href=\"#2-5-大文件传输使用gzip\" class=\"headerlink\" title=\"2.5 大文件传输使用gzip\"></a>2.5 大文件传输使用gzip</h3><p>大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。</p>\n<p>问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。</p>\n<p>减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。</p>\n<p>当然，现在苹果已经自动支持了，你只需要告诉你们服务端的同学，传输大文件的时候记得用gzip就完了。</p>\n<h3 id=\"2-6-View的重用和懒加载\"><a href=\"#2-6-View的重用和懒加载\" class=\"headerlink\" title=\"2.6 View的重用和懒加载\"></a>2.6 View的重用和懒加载</h3><p>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</p>\n<p>重用就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。<br>当需要使用View的时候，去可重用队列里面找一找有没有可以被复用的View。<br>这里我的一份框架中曾经使用过类似的方法去创建一个图片浏览器，大家可以稍做参考。View的重用</p>\n<p>懒加载就是在程序启动时并不进行加载，只有当用到这个对象的时候，才进行加载。<br>这个不仅在属性中可以进行这样的使用，在View上面也是一样，不过实现稍有不同。<br>懒加载会消耗更少内存，但是在View的显示上会稍有滞后。</p>\n<h3 id=\"2-7-Cache\"><a href=\"#2-7-Cache\" class=\"headerlink\" title=\"2.7 Cache\"></a>2.7 Cache</h3><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</p>\n<p>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</p>\n<p>NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。</p>\n<p>下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它：</p>\n<ul>\n<li>(NSMutableURLRequest <em>)imageRequestWithURL:(NSURL </em>)url { NSMutableURLRequest <em>request = [NSMutableURLRequest requestWithURL:url];  request.cachePolicy = NSURLRequestReturnCacheDataElseLoad; // this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@”image/</em>“ forHTTPHeaderField:@”Accept”];  return request; }</li>\n</ul>\n<p>注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。</p>\n<p>如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。</p>\n<h3 id=\"2-8-记得处理内存警告\"><a href=\"#2-8-记得处理内存警告\" class=\"headerlink\" title=\"2.8 记得处理内存警告\"></a>2.8 记得处理内存警告</h3><p>一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述:</p>\n<p>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.</p>\n<p>幸运的是，UIKit提供了几种收集低内存警告的方法:</p>\n<p>在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</p>\n<p>一旦收到这类通知，你就需要释放任何不必要的内存使用。</p>\n<p>例如，UIViewController的默认行为是移除一些不可见的view， 它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p>\n<p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p>\n<p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p>\n<h3 id=\"2-9-重用大的开销对象\"><a href=\"#2-9-重用大的开销对象\" class=\"headerlink\" title=\"2.9 重用大的开销对象\"></a>2.9 重用大的开销对象</h3><p>这里的大开销是指一些初始化很慢的objects，如：NSDateFormatter和NSCalendar。但是，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。</p>\n<p>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p>\n<p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。</p>\n<p>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p>\n<p>// in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter <em>formatter;  // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter </em>)formatter { if (! _formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @”EEE MMM dd HH:mm:ss Z yyyy”; // twitter date format } return _formatter; }</p>\n<p>还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</p>\n<h3 id=\"2-10-避免反复的处理数据\"><a href=\"#2-10-避免反复的处理数据\" class=\"headerlink\" title=\"2.10 避免反复的处理数据\"></a>2.10 避免反复的处理数据</h3><p>许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。</p>\n<p>比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。</p>\n<p>类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。</p>\n<h3 id=\"2-11-正确设定背景图片\"><a href=\"#2-11-正确设定背景图片\" class=\"headerlink\" title=\"2.11 正确设定背景图片\"></a>2.11 正确设定背景图片</h3><p>在View里放背景图片就像很多其它iOS编程一样有很多方法:</p>\n<p>使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。</p>\n<p>如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背景的。这种情形下使用UIImageView可以节约不少的内存：</p>\n<p>// You could also achieve the same result in Interface Builder UIImageView *backgroundView = [ [UIImageView alloc] initWithImage:[UIImage imageNamed:@”background”]]; [self.view addSubview:backgroundView];</p>\n<p>如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</p>\n<p>self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@”background”]];</p>\n<h3 id=\"2-12-试试苹果最新的WKWebView来处理web\"><a href=\"#2-12-试试苹果最新的WKWebView来处理web\" class=\"headerlink\" title=\"2.12 试试苹果最新的WKWebView来处理web\"></a>2.12 试试苹果最新的WKWebView来处理web</h3><p>UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。</p>\n<p>但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation 为特色的Webkit的Nitro Engine的限制。</p>\n<p>所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。</p>\n<p>另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。</p>\n<p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。</p>\n<p>当然，上面是针对你在使用UIWebView的情况下，需要尽量减少使用web的特性，而苹果最近刚推出的Safari的底层框架WKWebView也许能帮我们规避掉很多这样的性能问题。</p>\n<h3 id=\"2-13-优化你的TableView\"><a href=\"#2-13-优化你的TableView\" class=\"headerlink\" title=\"2.13 优化你的TableView\"></a>2.13 优化你的TableView</h3><p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。</p>\n<p>为了保证table view平滑滚动，确保你采取了以下的措施:</p>\n<p>正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate</p>\n<h3 id=\"2-14-选择正确的数据存储方式\"><a href=\"#2-14-选择正确的数据存储方式\" class=\"headerlink\" title=\"2.14 选择正确的数据存储方式\"></a>2.14 选择正确的数据存储方式</h3><p>当存储大块数据时你会怎么做？</p>\n<p>你有很多选择，比如：</p>\n<p>使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data</p>\n<p>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p>\n<p>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</p>\n<p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p>\n<p>在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</p>\n<p>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</p>\n<p>如果你使用SQLite，你可以用FMDB(<a href=\"https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C\" target=\"_blank\" rel=\"external\">https://github.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C</a> API了。</p>\n<h3 id=\"2-15-把Xib换成Storyboard吧\"><a href=\"#2-15-把Xib换成Storyboard吧\" class=\"headerlink\" title=\"2.15 把Xib换成Storyboard吧\"></a>2.15 把Xib换成Storyboard吧</h3><p>当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。</p>\n<p>Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller.</p>\n<p>当加载XIB时，所有图片都被缓存，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是：</p>\n<p>当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage 的<code>imageNamed:</code>方法来获取图片资源。</p>\n<p>很明显，同样的事情也发生在storyboards中，但我并没有找到任何支持这个结论的文档。</p>\n<p>另外，快速打开app是很重要的，特别是用户第一次打开它时，对app来讲，第一印象太太太重要了。</p>\n<p>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</p>\n<p>还是那句话，避免过于庞大的XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的Storyboards吧！</p>\n<p>注意，用Xcode debug时watchdog并不运行，一定要把设备从Xcode断开来测试启动速度</p>\n<h3 id=\"2-16-学会手动创建Autorelease-Pool\"><a href=\"#2-16-学会手动创建Autorelease-Pool\" class=\"headerlink\" title=\"2.16 学会手动创建Autorelease Pool\"></a>2.16 学会手动创建Autorelease Pool</h3><p>NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。</p>\n<p>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。</p>\n<p>好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为：</p>\n<p>NSArray <em>urls = [@”url1”,@”url2”]; for (NSURL </em>url in urls) { @autoreleasepool { NSError <em>error; NSString </em>fileContents = [NSString stringWithContentsOfURL: url encoding: NSUTF8StringEncoding error: &amp;error]; /<em> Process the string, creating and autoreleasing more objects. </em>/ } }</p>\n<p>这段代码在每次遍历后释放所有autorelease对象</p>\n<h3 id=\"2-17UIImage初始化\"><a href=\"#2-17UIImage初始化\" class=\"headerlink\" title=\"2.17UIImage初始化\"></a>2.17UIImage初始化</h3><p>A：imagedNamed初始化</p>\n<p>B：imageWithContentsOfFile初始化</p>\n<p>二者不同之处在于，imageNamed默认加载图片成功后会内存中缓存图片，这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象，如果缓存中没有找到相应的图片对象，则从指定地方加载图片然后缓存对象，并返回这个图片对象</p>\n<p>而imageWithContentsOfFile则仅只加载图片，不缓存</p>\n<p>大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间来做这件事，当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式，这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间</p>\n<p>使用场景需要编程时，应该根据实际应用场景加以区分，UIimage虽小，但使用元素较多问题会有所凸显</p>\n<h3 id=\"2-18列表滚动的时候不要对imageview赋值\"><a href=\"#2-18列表滚动的时候不要对imageview赋值\" class=\"headerlink\" title=\"2.18列表滚动的时候不要对imageview赋值\"></a>2.18列表滚动的时候不要对imageview赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 只在NSDefaultRunLoopMode模式下显示图片</div><div class=\"line\">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;placeholder&quot;] afterDelay:3.0 inModes:@[NSDefaultRunLoopMode]];</div></pre></td></tr></table></figure>\n<p>比如修改sdwebimage中的方法，如果设置imageview为滚动列表模式，则加入该方法，当列表停止滚动模式的时候才加载图片</p>\n<h3 id=\"一些第三方的使用\"><a href=\"#一些第三方的使用\" class=\"headerlink\" title=\"一些第三方的使用\"></a>一些第三方的使用</h3><p> 当然有时候也会用到一些第三方，比如在使用UICollectionView和UITableView的时候，Facebook有一个框架叫AsyncDisplayKit，这个库就可以很好地提升滚动时流畅性以及图片异步下载功能（不支持sb和autoLayout，需要手动进行约束设置），AsyncDisplayKit用相关node类，替换了UIView和它的子类,而且是线程安全的。它可以异步解码图片，调整图片大小以及对图片和文本进行渲染，把这些操作都放到子线程，滑动的时候就流畅许多。我认为这个库最方便的就是实现图片异步解码。UIImage显示之前必须要先解码完成，而且解码还是同步的。尤其是在UICollectionView/UITableView 中使用 prototype cell显示大图，UIImage的同步解码在滚动的时候会有明显的卡顿。另外一个很吸引人的点是AsyncDisplayKit可以把view层次结构转成layer。因为复杂的view层次结构开销很大，如果不需要view特有的功能（例如点击事件），就可以使用AsyncDisplayKit 的layer backing特性从而获得一些额外的提升。当然这个库还处于开发阶段，还有一些地方地方有待完善，比如不支持缓存，我要使用这个库的时候一般是结合Alamofire和AlamofireImage实现图片的缓存</p>"},{"title":"iOS知识小集合","date":"2016-11-15T06:34:32.000Z","_content":"\n- 1.dealloc方法是不能被覆盖的的，我们在子类中写的dealloc会被调用，同时父类的dealloc也会被调用，无需在子类中写上[super dealloc]\n\n### 获取实际的启动图\n```\n- (NSString *)getLaunchImageName\n{\nCGSize viewSize = self.window.bounds.size;\n// 竖屏\nNSString *viewOrientation = @\"Portrait\";\nNSString *launchImageName = nil;\nNSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@\"UILaunchImages\"];\nfor (NSDictionary* dict in imagesDict)\n{\nCGSize imageSize = CGSizeFromString(dict[@\"UILaunchImageSize\"]);\nif (CGSizeEqualToSize(imageSize, viewSize) && [viewOrientation isEqualToString:dict[@\"UILaunchImageOrientation\"]])\n{\nlaunchImageName = dict[@\"UILaunchImageName\"];\n}\n}\nreturn launchImageName;\n}\n\n```\n\n### 手动更改状态栏颜色\n```\n- (void)setStatusBarBackgroundColor:(UIColor *)color\n{\nUIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@\"statusBarWindow\"] valueForKey:@\"statusBar\"];\nif ([statusBar respondsToSelector:@selector(setBackgroundColor:)])\n{\nstatusBar.backgroundColor = color;\n}\n}\n```\n\n### 禁止锁屏\n默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。\n\n[UIApplication sharedApplication].idleTimerDisabled = YES;\n或\n[[UIApplication sharedApplication] setIdleTimerDisabled:YES];\n\n","source":"_posts/2016/iOS知识小集.md","raw":"---\ntitle: iOS知识小集合\ndate: 2016-11-15 14:34:32\ntags:\n- IOS\n---\n\n- 1.dealloc方法是不能被覆盖的的，我们在子类中写的dealloc会被调用，同时父类的dealloc也会被调用，无需在子类中写上[super dealloc]\n\n### 获取实际的启动图\n```\n- (NSString *)getLaunchImageName\n{\nCGSize viewSize = self.window.bounds.size;\n// 竖屏\nNSString *viewOrientation = @\"Portrait\";\nNSString *launchImageName = nil;\nNSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@\"UILaunchImages\"];\nfor (NSDictionary* dict in imagesDict)\n{\nCGSize imageSize = CGSizeFromString(dict[@\"UILaunchImageSize\"]);\nif (CGSizeEqualToSize(imageSize, viewSize) && [viewOrientation isEqualToString:dict[@\"UILaunchImageOrientation\"]])\n{\nlaunchImageName = dict[@\"UILaunchImageName\"];\n}\n}\nreturn launchImageName;\n}\n\n```\n\n### 手动更改状态栏颜色\n```\n- (void)setStatusBarBackgroundColor:(UIColor *)color\n{\nUIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@\"statusBarWindow\"] valueForKey:@\"statusBar\"];\nif ([statusBar respondsToSelector:@selector(setBackgroundColor:)])\n{\nstatusBar.backgroundColor = color;\n}\n}\n```\n\n### 禁止锁屏\n默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。\n\n[UIApplication sharedApplication].idleTimerDisabled = YES;\n或\n[[UIApplication sharedApplication] setIdleTimerDisabled:YES];\n\n","slug":"2016/iOS知识小集","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnv004ysauam5jn0qay","content":"<ul>\n<li>1.dealloc方法是不能被覆盖的的，我们在子类中写的dealloc会被调用，同时父类的dealloc也会被调用，无需在子类中写上[super dealloc]</li>\n</ul>\n<h3 id=\"获取实际的启动图\"><a href=\"#获取实际的启动图\" class=\"headerlink\" title=\"获取实际的启动图\"></a>获取实际的启动图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)getLaunchImageName</div><div class=\"line\">&#123;</div><div class=\"line\">CGSize viewSize = self.window.bounds.size;</div><div class=\"line\">// 竖屏</div><div class=\"line\">NSString *viewOrientation = @&quot;Portrait&quot;;</div><div class=\"line\">NSString *launchImageName = nil;</div><div class=\"line\">NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];</div><div class=\"line\">for (NSDictionary* dict in imagesDict)</div><div class=\"line\">&#123;</div><div class=\"line\">CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]);</div><div class=\"line\">if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]])</div><div class=\"line\">&#123;</div><div class=\"line\">launchImageName = dict[@&quot;UILaunchImageName&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return launchImageName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"手动更改状态栏颜色\"><a href=\"#手动更改状态栏颜色\" class=\"headerlink\" title=\"手动更改状态栏颜色\"></a>手动更改状态栏颜色</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setStatusBarBackgroundColor:(UIColor *)color</div><div class=\"line\">&#123;</div><div class=\"line\">UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;] valueForKey:@&quot;statusBar&quot;];</div><div class=\"line\">if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])</div><div class=\"line\">&#123;</div><div class=\"line\">statusBar.backgroundColor = color;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"禁止锁屏\"><a href=\"#禁止锁屏\" class=\"headerlink\" title=\"禁止锁屏\"></a>禁止锁屏</h3><p>默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。</p>\n<p>[UIApplication sharedApplication].idleTimerDisabled = YES;<br>或<br>[[UIApplication sharedApplication] setIdleTimerDisabled:YES];</p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>1.dealloc方法是不能被覆盖的的，我们在子类中写的dealloc会被调用，同时父类的dealloc也会被调用，无需在子类中写上[super dealloc]</li>\n</ul>\n<h3 id=\"获取实际的启动图\"><a href=\"#获取实际的启动图\" class=\"headerlink\" title=\"获取实际的启动图\"></a>获取实际的启动图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (NSString *)getLaunchImageName</div><div class=\"line\">&#123;</div><div class=\"line\">CGSize viewSize = self.window.bounds.size;</div><div class=\"line\">// 竖屏</div><div class=\"line\">NSString *viewOrientation = @&quot;Portrait&quot;;</div><div class=\"line\">NSString *launchImageName = nil;</div><div class=\"line\">NSArray* imagesDict = [[[NSBundle mainBundle] infoDictionary] valueForKey:@&quot;UILaunchImages&quot;];</div><div class=\"line\">for (NSDictionary* dict in imagesDict)</div><div class=\"line\">&#123;</div><div class=\"line\">CGSize imageSize = CGSizeFromString(dict[@&quot;UILaunchImageSize&quot;]);</div><div class=\"line\">if (CGSizeEqualToSize(imageSize, viewSize) &amp;&amp; [viewOrientation isEqualToString:dict[@&quot;UILaunchImageOrientation&quot;]])</div><div class=\"line\">&#123;</div><div class=\"line\">launchImageName = dict[@&quot;UILaunchImageName&quot;];</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">return launchImageName;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"手动更改状态栏颜色\"><a href=\"#手动更改状态栏颜色\" class=\"headerlink\" title=\"手动更改状态栏颜色\"></a>手动更改状态栏颜色</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)setStatusBarBackgroundColor:(UIColor *)color</div><div class=\"line\">&#123;</div><div class=\"line\">UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;] valueForKey:@&quot;statusBar&quot;];</div><div class=\"line\">if ([statusBar respondsToSelector:@selector(setBackgroundColor:)])</div><div class=\"line\">&#123;</div><div class=\"line\">statusBar.backgroundColor = color;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"禁止锁屏\"><a href=\"#禁止锁屏\" class=\"headerlink\" title=\"禁止锁屏\"></a>禁止锁屏</h3><p>默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。</p>\n<p>[UIApplication sharedApplication].idleTimerDisabled = YES;<br>或<br>[[UIApplication sharedApplication] setIdleTimerDisabled:YES];</p>\n"},{"title":"多线程技术--GCD","date":"2016-07-19T07:12:21.000Z","_content":"\n## 什么是GCD\n\n<!--more-->\n## GCD的API\n- Dipatch是调度的意思\n- serial连续\n- concurrent同时发生\n### Dispatch Queue\n>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue\n源码表示如下：\n```\ndispatch_async (queue, ^{\n  //想执行的任务\n}\n)\n```\nDispatch Queue是执行处理的等待队列，是先入先出的顺序(FIFO)\n\n另外存在两种Dispatch Queue：\n- Serial Dispatch Queue，等待现在执行中处理结束\n- Concurrent Dispatch Queue，不需要现在执行中处理结束\n\n如下边的代码，追加多个处理\n```\ndispatch_async(queue, blk0);\ndispatch_async(queue, blk1);\ndispatch_async(queue, blk2);\ndispatch_async(queue, blk3);\ndispatch_async(queue, blk4);\n```\nConcurrent Dispatch Queue之所以不需要等待执行结束，是因为它是使用了多个线程并发执行的，但是并不是有多少个任务就会开多少个线程，线程个数是由系统决定的。\n\n>小结:想要顺序执行就用serial queue,否则使用另外一种\n\n我们现在知道了有queue的存在，那么怎么得到这个queue呢？\n### dispatch_queue_create\n```\ndispatch_queue_t myQueueC = dispatch_queue_create(\"com.kugou.gcd.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_queue_t myQueueS = dispatch_queue_create(\"com.kugou.gcd.myQueue\", NULL);\n\n```\n>第一个参数为名字，一定要设置这个参数，因为发生崩溃的时候，这个将是一个很重要的指引，这个名字会出现在崩溃信息中，第二个参数如果要创建serial queue就设置为NULL，代表空的c指针，如果是另外一种就设置为DISPATCH_QUEUE_CONCURRENT\n\n我们可以创建多个Serial Queue，但是这个时候如果追加任务这些任务是并发执行的，也即是说会创建于queue等数量的线程，那么如果有过多的queue就会有过多的线程，就会消耗不必要的资源，并且会造成线程竞争，这种情况我们要使用`concurrent dispatch queue`\n\n另外要注意的是，虽然我们已经步入了ARC时代，但是Dispatch Queue必须由开发人员来释放，接着上班的代码\n```\ndispatch_async(myQueueS, ^{NSLog(@\"123\")});\ndispatch_release(myQueueS);\n```\n在调用async之后立刻释放queue，这样并不会有问题，因为此时block已经对齐有一个引用了。当block结束之后就会释放这个queue。\n凡是由create创建的对象都要记得手动释放。\n### Main Dispatch Queue/Global Dispatch Queue\n第二种获得queue的方法是使用系统标准提供的Dispatch Queue:\n- Main Dispatch Queue，主线程中执行，只有一个所以自然是serial dispatch queue\n- Global Dispatch Queue，是concurrent dispatch queue，四个优先级\n\n```\n//Main Dispatch Queue\ndispatch_queue_t mianQueue = dispatch_get_main_queue();\n\n//Global Dispatch Queue高\ndispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//其他优先级一样的做法\n```\n对这两种queue使用retaiin和release方法不会产生任何变化，所以这种做法比concurrent dispatch queue更加轻松。\n\n所以我们可以像下边这样直接使用\n```\ndispatch_asyn(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n  //code\n})\n```\n\n### dispatch_set_target_queue\ndispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，多使用与默认优先级Global Dispatch Queue相同执行优先级的线程，变更执行优先级使用dispatch_set_target_queue函数\n```\ndispatch_queue_t mySerialQueue = dispatch_queue_create(\"com.kugou.mySerQueue\", NULL);\ndispatch_queue_t myGlobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);\ndispatch_set_target_queue(mySerialQueue, myGlobalQueue);\n```\n指定第一个参数与第二个参数优先级相同\n\n### dispatch_after\n用于延时执行\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ULL * NSEC_PER_SEC);\ndispatch_after(time, dispatch_get_main_queue(),^{\n NSLog(@\"123\");\n})\n```\n注意，dispatch_after函数并不是在指定时间后执行，而只是在指定时间追加处理到dispatch_queue，此源码在3秒后用dispatch_async函数追加block到main dispatch queue相同。在严格时间要求下这个函数的使用会出问题。\n\n### Dispatch Group\n很多情况下我们都需要做结束操作，这个操作肯定是在最后的，如果是serial queue肯定没有问题，把代码放在最后就好了，可是concurrent queue怎么办呢？这个时候我们可以考虑dispatch_grounp\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\n\ndispatch_group_async(group, queue, ^{NSLog(@\"1\")});\ndispatch_group_async(group, queue, ^{NSLog(@\"2\")});\ndispatch_group_async(group, queue, ^{NSLog(@\"3\")});\n\ndispatch_group_notify(group dispatch_get_main_queue(),^{NSLog(@\"done\")});\n\ndispatch_release(group);\n```\n另外，除了使用`dispatch_group_notify`还可以使用`dispatch_group_wait`函数等待全部处理执行结束。\n```\nlong result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER)];\n```\n第一个参数表示要等待哪个group，第二个参数是等待的时间，这里也可以设置一个dispatch_time，如果这个函数返回值为0，则表示你全部处理完毕，否则代表还有函数没有返回。\n等待的含义是，一旦调用wait函数，调用这个函数的线程就会停止，在经过指定的时间或者是group中的全部执行都结束之后，该函数返回。\n如果有结束操作这种需求推荐第一种实现方案。\n\n### dispatch_barrier_async\n如果现在我们是10个读取的操作，然后并发执行并没有问题，但是如果有一个写入的操作掺杂在其中，这个时候就有点问题了，读写同时进行，就会出问题。\n\n该函数与Concurrent Dispatch Queue同时使用\n```\ndispatch_queue_t queueC = dispatch_queue_create(\"com.kugou.gcd.myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_async(queue, blk0_reading);\ndispatch_async(queue, blk1_reading);\ndispatch_async(queue, blk2_reading);\ndispatch_barrier_async(queue, blk3_writing);\ndispatch_async(queue, blk4_reading);\ndispatch_async(queue, blk5_reading);\ndispatch_async(queue, blk6_reading);\n```\n这样写系统会等0，1，2并发执行完，执行blk3，等blk3执行完再并发执行4，5，6\n\n### dispatch_sync\n\n### dispatch_apply\n\n### dispatch_suspend/dispatch_resume\n\n### Dispatch Sempaphore\n\n### dispatch_noce\n\n### Dispatch I/O\n\n\n## GCD实现\n\n### Dispatch Queue\n\n\n### Dispatch Source\n\n## GCD经典面试题\n在主线程中的某个函数里调用了异步函数，怎么样 block 当前线程 , 且还能响应当前线程的 timer 事件， touch 事件等\n\n>思路便是：利用wait函数，不断地检测是否完成异步操作，然后同时开启一个类死循环，不过这函数的互相调用要用performafter为了给事件和timer调用留出机会和时间。\n```\n@interface ViewController ()\n{\n    dispatch_group_t group;\n}\n@property (nonatomic, strong) RedView *redView;\n@property (nonatomic, assign) NSInteger result;\n@property (nonatomic, strong) UIButton *btn;\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation ViewController\n\n- (UIButton *)btn {\n    if (!_btn) {\n        _btn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn setTitle:@\"点击我啊\" forState:UIControlStateNormal];\n        [_btn sizeToFit];\n        _btn.frame = CGRectMake(100, 100, _btn.bounds.size.width, _btn.bounds.size.height);\n        [_btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n        [_btn addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside];\n    }\n    return _btn;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.btn];\n    \n    self.timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(chang1) userInfo:nil repeats:YES];\n    \n    group = dispatch_group_create();\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\n    dispatch_group_async(group, queue, ^{\n        for (int i = 0; i < 10000; i++) {\n            NSLog(@\"%d\", i);\n        }\n    });\n    \n    [self wait];\n    \n}\n\n- (void)wait {\n    \n    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);\n    if (self.result == 0) {\n        NSLog(@\"结束\");\n    }else {\n        NSLog(@\"rsout--%ld\", self.result);\n        [self performSelector:@selector(wait1) withObject:nil afterDelay:0];\n    }\n    \n}\n\n- (void)wait1 {\n    \n    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);\n    if (self.result == 0) {\n        NSLog(@\"结束\");\n    }else {\n        NSLog(@\"rsout--%ld\", self.result);\n        [self performSelector:@selector(wait) withObject:nil afterDelay:0];\n    }\n    \n}\n\n- (void)next {\n    NSLog(@\"1234567\");\n}\n\n- (void)change {\n    self.view.backgroundColor = [UIColor redColor];\n}\n\n- (void)chang1 {\n    NSLog(@\"哇哈哈哈哈\");\n}\n```","source":"_posts/2016/多线程技术-GCD.md","raw":"---\ntitle: 多线程技术--GCD\ndate: 2016-07-19 15:12:21\ntags:\n- iOS进阶\ncategories: iOS\n---\n\n## 什么是GCD\n\n<!--more-->\n## GCD的API\n- Dipatch是调度的意思\n- serial连续\n- concurrent同时发生\n### Dispatch Queue\n>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue\n源码表示如下：\n```\ndispatch_async (queue, ^{\n  //想执行的任务\n}\n)\n```\nDispatch Queue是执行处理的等待队列，是先入先出的顺序(FIFO)\n\n另外存在两种Dispatch Queue：\n- Serial Dispatch Queue，等待现在执行中处理结束\n- Concurrent Dispatch Queue，不需要现在执行中处理结束\n\n如下边的代码，追加多个处理\n```\ndispatch_async(queue, blk0);\ndispatch_async(queue, blk1);\ndispatch_async(queue, blk2);\ndispatch_async(queue, blk3);\ndispatch_async(queue, blk4);\n```\nConcurrent Dispatch Queue之所以不需要等待执行结束，是因为它是使用了多个线程并发执行的，但是并不是有多少个任务就会开多少个线程，线程个数是由系统决定的。\n\n>小结:想要顺序执行就用serial queue,否则使用另外一种\n\n我们现在知道了有queue的存在，那么怎么得到这个queue呢？\n### dispatch_queue_create\n```\ndispatch_queue_t myQueueC = dispatch_queue_create(\"com.kugou.gcd.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n\ndispatch_queue_t myQueueS = dispatch_queue_create(\"com.kugou.gcd.myQueue\", NULL);\n\n```\n>第一个参数为名字，一定要设置这个参数，因为发生崩溃的时候，这个将是一个很重要的指引，这个名字会出现在崩溃信息中，第二个参数如果要创建serial queue就设置为NULL，代表空的c指针，如果是另外一种就设置为DISPATCH_QUEUE_CONCURRENT\n\n我们可以创建多个Serial Queue，但是这个时候如果追加任务这些任务是并发执行的，也即是说会创建于queue等数量的线程，那么如果有过多的queue就会有过多的线程，就会消耗不必要的资源，并且会造成线程竞争，这种情况我们要使用`concurrent dispatch queue`\n\n另外要注意的是，虽然我们已经步入了ARC时代，但是Dispatch Queue必须由开发人员来释放，接着上班的代码\n```\ndispatch_async(myQueueS, ^{NSLog(@\"123\")});\ndispatch_release(myQueueS);\n```\n在调用async之后立刻释放queue，这样并不会有问题，因为此时block已经对齐有一个引用了。当block结束之后就会释放这个queue。\n凡是由create创建的对象都要记得手动释放。\n### Main Dispatch Queue/Global Dispatch Queue\n第二种获得queue的方法是使用系统标准提供的Dispatch Queue:\n- Main Dispatch Queue，主线程中执行，只有一个所以自然是serial dispatch queue\n- Global Dispatch Queue，是concurrent dispatch queue，四个优先级\n\n```\n//Main Dispatch Queue\ndispatch_queue_t mianQueue = dispatch_get_main_queue();\n\n//Global Dispatch Queue高\ndispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);\n\n//其他优先级一样的做法\n```\n对这两种queue使用retaiin和release方法不会产生任何变化，所以这种做法比concurrent dispatch queue更加轻松。\n\n所以我们可以像下边这样直接使用\n```\ndispatch_asyn(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n  //code\n})\n```\n\n### dispatch_set_target_queue\ndispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，多使用与默认优先级Global Dispatch Queue相同执行优先级的线程，变更执行优先级使用dispatch_set_target_queue函数\n```\ndispatch_queue_t mySerialQueue = dispatch_queue_create(\"com.kugou.mySerQueue\", NULL);\ndispatch_queue_t myGlobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);\ndispatch_set_target_queue(mySerialQueue, myGlobalQueue);\n```\n指定第一个参数与第二个参数优先级相同\n\n### dispatch_after\n用于延时执行\n```\ndispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ULL * NSEC_PER_SEC);\ndispatch_after(time, dispatch_get_main_queue(),^{\n NSLog(@\"123\");\n})\n```\n注意，dispatch_after函数并不是在指定时间后执行，而只是在指定时间追加处理到dispatch_queue，此源码在3秒后用dispatch_async函数追加block到main dispatch queue相同。在严格时间要求下这个函数的使用会出问题。\n\n### Dispatch Group\n很多情况下我们都需要做结束操作，这个操作肯定是在最后的，如果是serial queue肯定没有问题，把代码放在最后就好了，可是concurrent queue怎么办呢？这个时候我们可以考虑dispatch_grounp\n```\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\n\ndispatch_group_async(group, queue, ^{NSLog(@\"1\")});\ndispatch_group_async(group, queue, ^{NSLog(@\"2\")});\ndispatch_group_async(group, queue, ^{NSLog(@\"3\")});\n\ndispatch_group_notify(group dispatch_get_main_queue(),^{NSLog(@\"done\")});\n\ndispatch_release(group);\n```\n另外，除了使用`dispatch_group_notify`还可以使用`dispatch_group_wait`函数等待全部处理执行结束。\n```\nlong result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER)];\n```\n第一个参数表示要等待哪个group，第二个参数是等待的时间，这里也可以设置一个dispatch_time，如果这个函数返回值为0，则表示你全部处理完毕，否则代表还有函数没有返回。\n等待的含义是，一旦调用wait函数，调用这个函数的线程就会停止，在经过指定的时间或者是group中的全部执行都结束之后，该函数返回。\n如果有结束操作这种需求推荐第一种实现方案。\n\n### dispatch_barrier_async\n如果现在我们是10个读取的操作，然后并发执行并没有问题，但是如果有一个写入的操作掺杂在其中，这个时候就有点问题了，读写同时进行，就会出问题。\n\n该函数与Concurrent Dispatch Queue同时使用\n```\ndispatch_queue_t queueC = dispatch_queue_create(\"com.kugou.gcd.myQueue\", DISPATCH_QUEUE_CONCURRENT);\ndispatch_async(queue, blk0_reading);\ndispatch_async(queue, blk1_reading);\ndispatch_async(queue, blk2_reading);\ndispatch_barrier_async(queue, blk3_writing);\ndispatch_async(queue, blk4_reading);\ndispatch_async(queue, blk5_reading);\ndispatch_async(queue, blk6_reading);\n```\n这样写系统会等0，1，2并发执行完，执行blk3，等blk3执行完再并发执行4，5，6\n\n### dispatch_sync\n\n### dispatch_apply\n\n### dispatch_suspend/dispatch_resume\n\n### Dispatch Sempaphore\n\n### dispatch_noce\n\n### Dispatch I/O\n\n\n## GCD实现\n\n### Dispatch Queue\n\n\n### Dispatch Source\n\n## GCD经典面试题\n在主线程中的某个函数里调用了异步函数，怎么样 block 当前线程 , 且还能响应当前线程的 timer 事件， touch 事件等\n\n>思路便是：利用wait函数，不断地检测是否完成异步操作，然后同时开启一个类死循环，不过这函数的互相调用要用performafter为了给事件和timer调用留出机会和时间。\n```\n@interface ViewController ()\n{\n    dispatch_group_t group;\n}\n@property (nonatomic, strong) RedView *redView;\n@property (nonatomic, assign) NSInteger result;\n@property (nonatomic, strong) UIButton *btn;\n@property (nonatomic, strong) NSTimer *timer;\n@end\n\n@implementation ViewController\n\n- (UIButton *)btn {\n    if (!_btn) {\n        _btn = [UIButton buttonWithType:UIButtonTypeCustom];\n        [_btn setTitle:@\"点击我啊\" forState:UIControlStateNormal];\n        [_btn sizeToFit];\n        _btn.frame = CGRectMake(100, 100, _btn.bounds.size.width, _btn.bounds.size.height);\n        [_btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];\n        [_btn addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside];\n    }\n    return _btn;\n}\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [self.view addSubview:self.btn];\n    \n    self.timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(chang1) userInfo:nil repeats:YES];\n    \n    group = dispatch_group_create();\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);\n    dispatch_group_async(group, queue, ^{\n        for (int i = 0; i < 10000; i++) {\n            NSLog(@\"%d\", i);\n        }\n    });\n    \n    [self wait];\n    \n}\n\n- (void)wait {\n    \n    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);\n    if (self.result == 0) {\n        NSLog(@\"结束\");\n    }else {\n        NSLog(@\"rsout--%ld\", self.result);\n        [self performSelector:@selector(wait1) withObject:nil afterDelay:0];\n    }\n    \n}\n\n- (void)wait1 {\n    \n    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);\n    if (self.result == 0) {\n        NSLog(@\"结束\");\n    }else {\n        NSLog(@\"rsout--%ld\", self.result);\n        [self performSelector:@selector(wait) withObject:nil afterDelay:0];\n    }\n    \n}\n\n- (void)next {\n    NSLog(@\"1234567\");\n}\n\n- (void)change {\n    self.view.backgroundColor = [UIColor redColor];\n}\n\n- (void)chang1 {\n    NSLog(@\"哇哈哈哈哈\");\n}\n```","slug":"2016/多线程技术-GCD","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnx0051saua7klf3s3q","content":"<h2 id=\"什么是GCD\"><a href=\"#什么是GCD\" class=\"headerlink\" title=\"什么是GCD\"></a>什么是GCD</h2><a id=\"more\"></a>\n<h2 id=\"GCD的API\"><a href=\"#GCD的API\" class=\"headerlink\" title=\"GCD的API\"></a>GCD的API</h2><ul>\n<li>Dipatch是调度的意思</li>\n<li>serial连续</li>\n<li>concurrent同时发生<h3 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h3><blockquote>\n<p>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue<br>源码表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async (queue, ^&#123;</div><div class=\"line\">  //想执行的任务</div><div class=\"line\">&#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>Dispatch Queue是执行处理的等待队列，是先入先出的顺序(FIFO)</p>\n<p>另外存在两种Dispatch Queue：</p>\n<ul>\n<li>Serial Dispatch Queue，等待现在执行中处理结束</li>\n<li>Concurrent Dispatch Queue，不需要现在执行中处理结束</li>\n</ul>\n<p>如下边的代码，追加多个处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(queue, blk0);</div><div class=\"line\">dispatch_async(queue, blk1);</div><div class=\"line\">dispatch_async(queue, blk2);</div><div class=\"line\">dispatch_async(queue, blk3);</div><div class=\"line\">dispatch_async(queue, blk4);</div></pre></td></tr></table></figure></p>\n<p>Concurrent Dispatch Queue之所以不需要等待执行结束，是因为它是使用了多个线程并发执行的，但是并不是有多少个任务就会开多少个线程，线程个数是由系统决定的。</p>\n<blockquote>\n<p>小结:想要顺序执行就用serial queue,否则使用另外一种</p>\n</blockquote>\n<p>我们现在知道了有queue的存在，那么怎么得到这个queue呢？</p>\n<h3 id=\"dispatch-queue-create\"><a href=\"#dispatch-queue-create\" class=\"headerlink\" title=\"dispatch_queue_create\"></a>dispatch_queue_create</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t myQueueC = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\"></div><div class=\"line\">dispatch_queue_t myQueueS = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, NULL);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>第一个参数为名字，一定要设置这个参数，因为发生崩溃的时候，这个将是一个很重要的指引，这个名字会出现在崩溃信息中，第二个参数如果要创建serial queue就设置为NULL，代表空的c指针，如果是另外一种就设置为DISPATCH_QUEUE_CONCURRENT</p>\n</blockquote>\n<p>我们可以创建多个Serial Queue，但是这个时候如果追加任务这些任务是并发执行的，也即是说会创建于queue等数量的线程，那么如果有过多的queue就会有过多的线程，就会消耗不必要的资源，并且会造成线程竞争，这种情况我们要使用<code>concurrent dispatch queue</code></p>\n<p>另外要注意的是，虽然我们已经步入了ARC时代，但是Dispatch Queue必须由开发人员来释放，接着上班的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(myQueueS, ^&#123;NSLog(@&quot;123&quot;)&#125;);</div><div class=\"line\">dispatch_release(myQueueS);</div></pre></td></tr></table></figure></p>\n<p>在调用async之后立刻释放queue，这样并不会有问题，因为此时block已经对齐有一个引用了。当block结束之后就会释放这个queue。<br>凡是由create创建的对象都要记得手动释放。</p>\n<h3 id=\"Main-Dispatch-Queue-Global-Dispatch-Queue\"><a href=\"#Main-Dispatch-Queue-Global-Dispatch-Queue\" class=\"headerlink\" title=\"Main Dispatch Queue/Global Dispatch Queue\"></a>Main Dispatch Queue/Global Dispatch Queue</h3><p>第二种获得queue的方法是使用系统标准提供的Dispatch Queue:</p>\n<ul>\n<li>Main Dispatch Queue，主线程中执行，只有一个所以自然是serial dispatch queue</li>\n<li>Global Dispatch Queue，是concurrent dispatch queue，四个优先级</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Main Dispatch Queue</div><div class=\"line\">dispatch_queue_t mianQueue = dispatch_get_main_queue();</div><div class=\"line\"></div><div class=\"line\">//Global Dispatch Queue高</div><div class=\"line\">dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class=\"line\"></div><div class=\"line\">//其他优先级一样的做法</div></pre></td></tr></table></figure>\n<p>对这两种queue使用retaiin和release方法不会产生任何变化，所以这种做法比concurrent dispatch queue更加轻松。</p>\n<p>所以我们可以像下边这样直接使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_asyn(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">  //code</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"dispatch-set-target-queue\"><a href=\"#dispatch-set-target-queue\" class=\"headerlink\" title=\"dispatch_set_target_queue\"></a>dispatch_set_target_queue</h3><p>dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，多使用与默认优先级Global Dispatch Queue相同执行优先级的线程，变更执行优先级使用dispatch_set_target_queue函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.kugou.mySerQueue&quot;, NULL);</div><div class=\"line\">dispatch_queue_t myGlobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</div><div class=\"line\">dispatch_set_target_queue(mySerialQueue, myGlobalQueue);</div></pre></td></tr></table></figure></p>\n<p>指定第一个参数与第二个参数优先级相同</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>用于延时执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ULL * NSEC_PER_SEC);</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(),^&#123;</div><div class=\"line\"> NSLog(@&quot;123&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>注意，dispatch_after函数并不是在指定时间后执行，而只是在指定时间追加处理到dispatch_queue，此源码在3秒后用dispatch_async函数追加block到main dispatch queue相同。在严格时间要求下这个函数的使用会出问题。</p>\n<h3 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h3><p>很多情况下我们都需要做结束操作，这个操作肯定是在最后的，如果是serial queue肯定没有问题，把代码放在最后就好了，可是concurrent queue怎么办呢？这个时候我们可以考虑dispatch_grounp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;1&quot;)&#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;2&quot;)&#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;3&quot;)&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_notify(group dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;)&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_release(group);</div></pre></td></tr></table></figure></p>\n<p>另外，除了使用<code>dispatch_group_notify</code>还可以使用<code>dispatch_group_wait</code>函数等待全部处理执行结束。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER)];</div></pre></td></tr></table></figure></p>\n<p>第一个参数表示要等待哪个group，第二个参数是等待的时间，这里也可以设置一个dispatch_time，如果这个函数返回值为0，则表示你全部处理完毕，否则代表还有函数没有返回。<br>等待的含义是，一旦调用wait函数，调用这个函数的线程就会停止，在经过指定的时间或者是group中的全部执行都结束之后，该函数返回。<br>如果有结束操作这种需求推荐第一种实现方案。</p>\n<h3 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h3><p>如果现在我们是10个读取的操作，然后并发执行并没有问题，但是如果有一个写入的操作掺杂在其中，这个时候就有点问题了，读写同时进行，就会出问题。</p>\n<p>该函数与Concurrent Dispatch Queue同时使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queueC = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_async(queue, blk0_reading);</div><div class=\"line\">dispatch_async(queue, blk1_reading);</div><div class=\"line\">dispatch_async(queue, blk2_reading);</div><div class=\"line\">dispatch_barrier_async(queue, blk3_writing);</div><div class=\"line\">dispatch_async(queue, blk4_reading);</div><div class=\"line\">dispatch_async(queue, blk5_reading);</div><div class=\"line\">dispatch_async(queue, blk6_reading);</div></pre></td></tr></table></figure></p>\n<p>这样写系统会等0，1，2并发执行完，执行blk3，等blk3执行完再并发执行4，5，6</p>\n<h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><h3 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend/dispatch_resume\"></a>dispatch_suspend/dispatch_resume</h3><h3 id=\"Dispatch-Sempaphore\"><a href=\"#Dispatch-Sempaphore\" class=\"headerlink\" title=\"Dispatch Sempaphore\"></a>Dispatch Sempaphore</h3><h3 id=\"dispatch-noce\"><a href=\"#dispatch-noce\" class=\"headerlink\" title=\"dispatch_noce\"></a>dispatch_noce</h3><h3 id=\"Dispatch-I-O\"><a href=\"#Dispatch-I-O\" class=\"headerlink\" title=\"Dispatch I/O\"></a>Dispatch I/O</h3><h2 id=\"GCD实现\"><a href=\"#GCD实现\" class=\"headerlink\" title=\"GCD实现\"></a>GCD实现</h2><h3 id=\"Dispatch-Queue-1\"><a href=\"#Dispatch-Queue-1\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h3><h3 id=\"Dispatch-Source\"><a href=\"#Dispatch-Source\" class=\"headerlink\" title=\"Dispatch Source\"></a>Dispatch Source</h3><h2 id=\"GCD经典面试题\"><a href=\"#GCD经典面试题\" class=\"headerlink\" title=\"GCD经典面试题\"></a>GCD经典面试题</h2><p>在主线程中的某个函数里调用了异步函数，怎么样 block 当前线程 , 且还能响应当前线程的 timer 事件， touch 事件等</p>\n<blockquote>\n<p>思路便是：利用wait函数，不断地检测是否完成异步操作，然后同时开启一个类死循环，不过这函数的互相调用要用performafter为了给事件和timer调用留出机会和时间。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">&#123;</div><div class=\"line\">    dispatch_group_t group;</div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic, strong) RedView *redView;</div><div class=\"line\">@property (nonatomic, assign) NSInteger result;</div><div class=\"line\">@property (nonatomic, strong) UIButton *btn;</div><div class=\"line\">@property (nonatomic, strong) NSTimer *timer;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn &#123;</div><div class=\"line\">    if (!_btn) &#123;</div><div class=\"line\">        _btn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn setTitle:@&quot;点击我啊&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn sizeToFit];</div><div class=\"line\">        _btn.frame = CGRectMake(100, 100, _btn.bounds.size.width, _btn.bounds.size.height);</div><div class=\"line\">        [_btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">        [_btn addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.btn];</div><div class=\"line\">    </div><div class=\"line\">    self.timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(chang1) userInfo:nil repeats:YES];</div><div class=\"line\">    </div><div class=\"line\">    group = dispatch_group_create();</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class=\"line\">            NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    [self wait];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)wait &#123;</div><div class=\"line\">    </div><div class=\"line\">    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);</div><div class=\"line\">    if (self.result == 0) &#123;</div><div class=\"line\">        NSLog(@&quot;结束&quot;);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;rsout--%ld&quot;, self.result);</div><div class=\"line\">        [self performSelector:@selector(wait1) withObject:nil afterDelay:0];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)wait1 &#123;</div><div class=\"line\">    </div><div class=\"line\">    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);</div><div class=\"line\">    if (self.result == 0) &#123;</div><div class=\"line\">        NSLog(@&quot;结束&quot;);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;rsout--%ld&quot;, self.result);</div><div class=\"line\">        [self performSelector:@selector(wait) withObject:nil afterDelay:0];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)next &#123;</div><div class=\"line\">    NSLog(@&quot;1234567&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)change &#123;</div><div class=\"line\">    self.view.backgroundColor = [UIColor redColor];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)chang1 &#123;</div><div class=\"line\">    NSLog(@&quot;哇哈哈哈哈&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是GCD\"><a href=\"#什么是GCD\" class=\"headerlink\" title=\"什么是GCD\"></a>什么是GCD</h2>","more":"<h2 id=\"GCD的API\"><a href=\"#GCD的API\" class=\"headerlink\" title=\"GCD的API\"></a>GCD的API</h2><ul>\n<li>Dipatch是调度的意思</li>\n<li>serial连续</li>\n<li>concurrent同时发生<h3 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h3><blockquote>\n<p>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue<br>源码表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async (queue, ^&#123;</div><div class=\"line\">  //想执行的任务</div><div class=\"line\">&#125;</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>Dispatch Queue是执行处理的等待队列，是先入先出的顺序(FIFO)</p>\n<p>另外存在两种Dispatch Queue：</p>\n<ul>\n<li>Serial Dispatch Queue，等待现在执行中处理结束</li>\n<li>Concurrent Dispatch Queue，不需要现在执行中处理结束</li>\n</ul>\n<p>如下边的代码，追加多个处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(queue, blk0);</div><div class=\"line\">dispatch_async(queue, blk1);</div><div class=\"line\">dispatch_async(queue, blk2);</div><div class=\"line\">dispatch_async(queue, blk3);</div><div class=\"line\">dispatch_async(queue, blk4);</div></pre></td></tr></table></figure></p>\n<p>Concurrent Dispatch Queue之所以不需要等待执行结束，是因为它是使用了多个线程并发执行的，但是并不是有多少个任务就会开多少个线程，线程个数是由系统决定的。</p>\n<blockquote>\n<p>小结:想要顺序执行就用serial queue,否则使用另外一种</p>\n</blockquote>\n<p>我们现在知道了有queue的存在，那么怎么得到这个queue呢？</p>\n<h3 id=\"dispatch-queue-create\"><a href=\"#dispatch-queue-create\" class=\"headerlink\" title=\"dispatch_queue_create\"></a>dispatch_queue_create</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t myQueueC = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\"></div><div class=\"line\">dispatch_queue_t myQueueS = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, NULL);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>第一个参数为名字，一定要设置这个参数，因为发生崩溃的时候，这个将是一个很重要的指引，这个名字会出现在崩溃信息中，第二个参数如果要创建serial queue就设置为NULL，代表空的c指针，如果是另外一种就设置为DISPATCH_QUEUE_CONCURRENT</p>\n</blockquote>\n<p>我们可以创建多个Serial Queue，但是这个时候如果追加任务这些任务是并发执行的，也即是说会创建于queue等数量的线程，那么如果有过多的queue就会有过多的线程，就会消耗不必要的资源，并且会造成线程竞争，这种情况我们要使用<code>concurrent dispatch queue</code></p>\n<p>另外要注意的是，虽然我们已经步入了ARC时代，但是Dispatch Queue必须由开发人员来释放，接着上班的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_async(myQueueS, ^&#123;NSLog(@&quot;123&quot;)&#125;);</div><div class=\"line\">dispatch_release(myQueueS);</div></pre></td></tr></table></figure></p>\n<p>在调用async之后立刻释放queue，这样并不会有问题，因为此时block已经对齐有一个引用了。当block结束之后就会释放这个queue。<br>凡是由create创建的对象都要记得手动释放。</p>\n<h3 id=\"Main-Dispatch-Queue-Global-Dispatch-Queue\"><a href=\"#Main-Dispatch-Queue-Global-Dispatch-Queue\" class=\"headerlink\" title=\"Main Dispatch Queue/Global Dispatch Queue\"></a>Main Dispatch Queue/Global Dispatch Queue</h3><p>第二种获得queue的方法是使用系统标准提供的Dispatch Queue:</p>\n<ul>\n<li>Main Dispatch Queue，主线程中执行，只有一个所以自然是serial dispatch queue</li>\n<li>Global Dispatch Queue，是concurrent dispatch queue，四个优先级</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Main Dispatch Queue</div><div class=\"line\">dispatch_queue_t mianQueue = dispatch_get_main_queue();</div><div class=\"line\"></div><div class=\"line\">//Global Dispatch Queue高</div><div class=\"line\">dispatch_queue_t highQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</div><div class=\"line\"></div><div class=\"line\">//其他优先级一样的做法</div></pre></td></tr></table></figure>\n<p>对这两种queue使用retaiin和release方法不会产生任何变化，所以这种做法比concurrent dispatch queue更加轻松。</p>\n<p>所以我们可以像下边这样直接使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_asyn(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class=\"line\">  //code</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h3 id=\"dispatch-set-target-queue\"><a href=\"#dispatch-set-target-queue\" class=\"headerlink\" title=\"dispatch_set_target_queue\"></a>dispatch_set_target_queue</h3><p>dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue，多使用与默认优先级Global Dispatch Queue相同执行优先级的线程，变更执行优先级使用dispatch_set_target_queue函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t mySerialQueue = dispatch_queue_create(&quot;com.kugou.mySerQueue&quot;, NULL);</div><div class=\"line\">dispatch_queue_t myGlobalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</div><div class=\"line\">dispatch_set_target_queue(mySerialQueue, myGlobalQueue);</div></pre></td></tr></table></figure></p>\n<p>指定第一个参数与第二个参数优先级相同</p>\n<h3 id=\"dispatch-after\"><a href=\"#dispatch-after\" class=\"headerlink\" title=\"dispatch_after\"></a>dispatch_after</h3><p>用于延时执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ULL * NSEC_PER_SEC);</div><div class=\"line\">dispatch_after(time, dispatch_get_main_queue(),^&#123;</div><div class=\"line\"> NSLog(@&quot;123&quot;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>注意，dispatch_after函数并不是在指定时间后执行，而只是在指定时间追加处理到dispatch_queue，此源码在3秒后用dispatch_async函数追加block到main dispatch queue相同。在严格时间要求下这个函数的使用会出问题。</p>\n<h3 id=\"Dispatch-Group\"><a href=\"#Dispatch-Group\" class=\"headerlink\" title=\"Dispatch Group\"></a>Dispatch Group</h3><p>很多情况下我们都需要做结束操作，这个操作肯定是在最后的，如果是serial queue肯定没有问题，把代码放在最后就好了，可是concurrent queue怎么办呢？这个时候我们可以考虑dispatch_grounp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;1&quot;)&#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;2&quot;)&#125;);</div><div class=\"line\">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;3&quot;)&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_group_notify(group dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;)&#125;);</div><div class=\"line\"></div><div class=\"line\">dispatch_release(group);</div></pre></td></tr></table></figure></p>\n<p>另外，除了使用<code>dispatch_group_notify</code>还可以使用<code>dispatch_group_wait</code>函数等待全部处理执行结束。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER)];</div></pre></td></tr></table></figure></p>\n<p>第一个参数表示要等待哪个group，第二个参数是等待的时间，这里也可以设置一个dispatch_time，如果这个函数返回值为0，则表示你全部处理完毕，否则代表还有函数没有返回。<br>等待的含义是，一旦调用wait函数，调用这个函数的线程就会停止，在经过指定的时间或者是group中的全部执行都结束之后，该函数返回。<br>如果有结束操作这种需求推荐第一种实现方案。</p>\n<h3 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h3><p>如果现在我们是10个读取的操作，然后并发执行并没有问题，但是如果有一个写入的操作掺杂在其中，这个时候就有点问题了，读写同时进行，就会出问题。</p>\n<p>该函数与Concurrent Dispatch Queue同时使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">dispatch_queue_t queueC = dispatch_queue_create(&quot;com.kugou.gcd.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class=\"line\">dispatch_async(queue, blk0_reading);</div><div class=\"line\">dispatch_async(queue, blk1_reading);</div><div class=\"line\">dispatch_async(queue, blk2_reading);</div><div class=\"line\">dispatch_barrier_async(queue, blk3_writing);</div><div class=\"line\">dispatch_async(queue, blk4_reading);</div><div class=\"line\">dispatch_async(queue, blk5_reading);</div><div class=\"line\">dispatch_async(queue, blk6_reading);</div></pre></td></tr></table></figure></p>\n<p>这样写系统会等0，1，2并发执行完，执行blk3，等blk3执行完再并发执行4，5，6</p>\n<h3 id=\"dispatch-sync\"><a href=\"#dispatch-sync\" class=\"headerlink\" title=\"dispatch_sync\"></a>dispatch_sync</h3><h3 id=\"dispatch-apply\"><a href=\"#dispatch-apply\" class=\"headerlink\" title=\"dispatch_apply\"></a>dispatch_apply</h3><h3 id=\"dispatch-suspend-dispatch-resume\"><a href=\"#dispatch-suspend-dispatch-resume\" class=\"headerlink\" title=\"dispatch_suspend/dispatch_resume\"></a>dispatch_suspend/dispatch_resume</h3><h3 id=\"Dispatch-Sempaphore\"><a href=\"#Dispatch-Sempaphore\" class=\"headerlink\" title=\"Dispatch Sempaphore\"></a>Dispatch Sempaphore</h3><h3 id=\"dispatch-noce\"><a href=\"#dispatch-noce\" class=\"headerlink\" title=\"dispatch_noce\"></a>dispatch_noce</h3><h3 id=\"Dispatch-I-O\"><a href=\"#Dispatch-I-O\" class=\"headerlink\" title=\"Dispatch I/O\"></a>Dispatch I/O</h3><h2 id=\"GCD实现\"><a href=\"#GCD实现\" class=\"headerlink\" title=\"GCD实现\"></a>GCD实现</h2><h3 id=\"Dispatch-Queue-1\"><a href=\"#Dispatch-Queue-1\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h3><h3 id=\"Dispatch-Source\"><a href=\"#Dispatch-Source\" class=\"headerlink\" title=\"Dispatch Source\"></a>Dispatch Source</h3><h2 id=\"GCD经典面试题\"><a href=\"#GCD经典面试题\" class=\"headerlink\" title=\"GCD经典面试题\"></a>GCD经典面试题</h2><p>在主线程中的某个函数里调用了异步函数，怎么样 block 当前线程 , 且还能响应当前线程的 timer 事件， touch 事件等</p>\n<blockquote>\n<p>思路便是：利用wait函数，不断地检测是否完成异步操作，然后同时开启一个类死循环，不过这函数的互相调用要用performafter为了给事件和timer调用留出机会和时间。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface ViewController ()</div><div class=\"line\">&#123;</div><div class=\"line\">    dispatch_group_t group;</div><div class=\"line\">&#125;</div><div class=\"line\">@property (nonatomic, strong) RedView *redView;</div><div class=\"line\">@property (nonatomic, assign) NSInteger result;</div><div class=\"line\">@property (nonatomic, strong) UIButton *btn;</div><div class=\"line\">@property (nonatomic, strong) NSTimer *timer;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">- (UIButton *)btn &#123;</div><div class=\"line\">    if (!_btn) &#123;</div><div class=\"line\">        _btn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">        [_btn setTitle:@&quot;点击我啊&quot; forState:UIControlStateNormal];</div><div class=\"line\">        [_btn sizeToFit];</div><div class=\"line\">        _btn.frame = CGRectMake(100, 100, _btn.bounds.size.width, _btn.bounds.size.height);</div><div class=\"line\">        [_btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];</div><div class=\"line\">        [_btn addTarget:self action:@selector(change) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return _btn;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    [self.view addSubview:self.btn];</div><div class=\"line\">    </div><div class=\"line\">    self.timer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(chang1) userInfo:nil repeats:YES];</div><div class=\"line\">    </div><div class=\"line\">    group = dispatch_group_create();</div><div class=\"line\">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div><div class=\"line\">    dispatch_group_async(group, queue, ^&#123;</div><div class=\"line\">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class=\"line\">            NSLog(@&quot;%d&quot;, i);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    [self wait];</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)wait &#123;</div><div class=\"line\">    </div><div class=\"line\">    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);</div><div class=\"line\">    if (self.result == 0) &#123;</div><div class=\"line\">        NSLog(@&quot;结束&quot;);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;rsout--%ld&quot;, self.result);</div><div class=\"line\">        [self performSelector:@selector(wait1) withObject:nil afterDelay:0];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)wait1 &#123;</div><div class=\"line\">    </div><div class=\"line\">    self.result = dispatch_group_wait(group, 10 * NSEC_PER_SEC);</div><div class=\"line\">    if (self.result == 0) &#123;</div><div class=\"line\">        NSLog(@&quot;结束&quot;);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        NSLog(@&quot;rsout--%ld&quot;, self.result);</div><div class=\"line\">        [self performSelector:@selector(wait) withObject:nil afterDelay:0];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)next &#123;</div><div class=\"line\">    NSLog(@&quot;1234567&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)change &#123;</div><div class=\"line\">    self.view.backgroundColor = [UIColor redColor];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)chang1 &#123;</div><div class=\"line\">    NSLog(@&quot;哇哈哈哈哈&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>"},{"title":"热修复技术在移动端的应用","date":"2016-01-12T10:07:04.000Z","_content":"\n### 热修复技术概述\n移动应用的部署方式，即发布->下载->安装->运行，决定了他不具备Web的高灵活性，尤其新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。\n<!--more-->\n热修复技术(HotfixPatch)，是一种基于原生应用开发的灵活性解决方案，可以在不改变开发人员技能要求和已有的开发方式的前提下，给于应用在发布后改变程序行为的能力。\n热补丁的主要优势是不会使设备当前正在运行的业务中断，即在不重启设备的情况下可以对设备当前软件版本的缺陷进行修复。一般用于某个函数导致的bug，如果是某个类导致的bug，或者增减业务模块，不建议使用热修复，而使用Reactive Native。\n#### 市场中的热修复技术方案对比\n- WaxPatch(阿里在维护)\n- JSPatch(个人项目)\n\n两者相比，JSPatch的优势：\n- 1.JS语言: JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。\n- 2.符合Apple规则: JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。\n- 3.小巧: 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。\n- 4.支持block: wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。\n\nJSPatch的劣势：\n- 相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。\n\n#### 问题与风险\nJSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：\n1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。\n2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。\n3.由于主要的应用方式是对函数的替换，所以如果某个函数包含几千行的代码，修复的时候工作量会相对较大\n\n\n### JSPatch\n#### 简介\n- 作者bang(腾讯)[个人博客](http://blog.cnbang.net)，[github](https://github.com/bang590/JSPatch)\n- 项目创建于2015-5\n- [JSPatch接入平台](http://jspatch.com)\n- 淘宝，美团等都有使用，SDK后台接入统计数据超过1200个应用\n- JSPatch交流群(207283178)\n\n#### 需要的基础知识\n-` JavaScriptCore的使用`\n-` runtime`\n#### JSPatch原理\n- 运行时修复不用等待App重新启动，iOS 利用运行时特性修改函数的IMP，从而达到修复目的。\n- 所谓的脚本执行其实只是增加了内存中的类以及新增的IMP，以及对OC中的IMP的组合。\n- jspatch脚本只是一套规则，jspatch内部对其进行了字符串截取的转换，为类名，方法名，以及参数，然后利用运行时的方法进行调用。\n- evaluateScript方法只是让脚本去调用js方法域中的方法，然后iOS会去调用对应IMP，所以JSPatch文件的作用是增加js方法域中的方法。\n- 能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，具体来说能做的有：\n\t- 通过类名和方法名得到具体的类以及方法\n\t- 替换某个类的方法的实现\n\t- 注册一个新的类并且为该类添加方法实现\n\n#### JSPatch具体实现\n>- 最外层需要的是js的调用能力，所以需要定义js函数，提供脚本调用的接口\n>- 又因为我们需要用到运行时的函数，所以需要利用js来调用OC中的方法，所以我们需要生成一系列的IMP\n\n- require\n- JS接口(.alloc().init())/(NSInvocation)[invocation对消息的直接调用](http://mobile.9sssd.com/ios/art/915)\n- 消息传递(JSContext)\n- `对象持有/转换`\n- 类型转换\n- `方法替换`\n- `新增方法`\n- property\n\n`参考`:[bang-JSPatch原理详解](http://blog.cnbang.net/tech/2808/)\n\n#### JSPatch使用流程\n- 开发热修复脚本\n- 压缩为zip(节省空间)\n- 上传脚本到服务器\n- app每次启动判断本地脚本是否超过一天，如果超过一天向服务器请求新的，否则检查该脚本是否合法如果不合法就删除\n- 获取到脚本文件后，调用JSPatch引擎，执行脚本文件进行修复\n\n>补充:终端获取脚本文件是需要一个策略的，最简单的就是，终端根据版本号，获取与该版本号有关的脚本文件：\n如：本次终端发布的版本是：1.0.3，那在上传脚本文件时，就可以将脚本文件的名称定义为：patch1_0_3.js\n这样终端就可以根据版本号，动态组织脚本的下载地址，而且一个版本对应一个脚本文件，简单明了～～\n![Alt text](./20151127111300698.jpeg)\n\n#### JSPatch的引入\n- 引入SDK\n\t- 原版SDK\n\t- 酷狗SDK\n\t- 自定义：源文件+版本管理规则\n- 项目启动函数中添加JSPatch引擎启动命令\n- 脚本分发平台接入\n\t- 官方平台(http://jspatch.com/Docs/price)\n\t- 酷狗后台：秘钥生成，url传入\n\n#### JSPatch中的js语法\n[1.https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法#常量枚举](https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE)\n\n[2.语法转译工具](http://bang590.github.io/JSPatchConvertor/)\n\n3.一些踩过的坑\n```\n tmpLitterImg.length  不能写成   tmpLitterImg.length()\n infoModel.kugouId()  不能写成  infoModel.kugouId\n self.headerView().sd__setImageWithURL//单下划线要用双下划线\n self.locationIconView().right()//left/right后要加()\n UIScreen.mainScreen().bounds().width//CGrect这种结构取值不用加()\n //宏要直接用具体的值\n //枚举要用具体的数字\n //int类型转string类型要用下面的方法\n self.viewerNumLbl().setText('' + info.viewerNum());\n```\n#### 问题\n- swift因为没有OC的动态性，所以暂时没有成熟的只是针对swift的热修复技术方案\n- 当发布了新版，原来下发的脚本怎么办？\n\t- 根据版本号进行js文件的读取，新版本情况下旧版本文件不会再被执行\n- 关于实时推送的实现？\n\t- 现在的技术方案是使用长连接进行推送，单台服务器暂时能够能够支撑200万的链接量\n- 服务器需要做的\n\t- 上传功能\n\t- MD5唯一性验证\n\t- CDN缓存，加速(待定)\n\t- 对文件进行RSA加密同时生成MD5签名\n\t- http接口1\n\t\t- 参数：appversion\n\t\t- 返回\n\t\t\t- patchId\n\t\t\t- appversion\n\t\t\t- fileHash\n\t\t\t- downloadUrl\n\t- http接口2返回加密后的文件\n\t\n------\n\n\t- 在最开始增加参数，配置是否在主线程执行，主要解决假如首页崩溃，可以堵塞。\n\t- 唤醒的时候进行下载，24小时执行一次\n\n\n### Demo\n- javascriptCore的使用\n- JSPatchDemo\n- 在繁星中的使用\n\n---------\n- 启动崩溃两次判断\n- 本地回滚\n\t- js文件的版本号，如果这个版本号本地已经有了，那就不再下发了\n\t- 本地保存的上一次的这个文件是加密呢还是明文呢？\n- MD5两次加密\n\n\n","source":"_posts/2016/热修复技术在移动端的应用.md","raw":"---\ntitle: 热修复技术在移动端的应用\ndate: 2016-01-12 18:07:04\ntags:\ncategories: iOS\n---\n\n### 热修复技术概述\n移动应用的部署方式，即发布->下载->安装->运行，决定了他不具备Web的高灵活性，尤其新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。\n<!--more-->\n热修复技术(HotfixPatch)，是一种基于原生应用开发的灵活性解决方案，可以在不改变开发人员技能要求和已有的开发方式的前提下，给于应用在发布后改变程序行为的能力。\n热补丁的主要优势是不会使设备当前正在运行的业务中断，即在不重启设备的情况下可以对设备当前软件版本的缺陷进行修复。一般用于某个函数导致的bug，如果是某个类导致的bug，或者增减业务模块，不建议使用热修复，而使用Reactive Native。\n#### 市场中的热修复技术方案对比\n- WaxPatch(阿里在维护)\n- JSPatch(个人项目)\n\n两者相比，JSPatch的优势：\n- 1.JS语言: JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。\n- 2.符合Apple规则: JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。\n- 3.小巧: 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。\n- 4.支持block: wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。\n\nJSPatch的劣势：\n- 相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。\n\n#### 问题与风险\nJSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：\n1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。\n2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。\n3.由于主要的应用方式是对函数的替换，所以如果某个函数包含几千行的代码，修复的时候工作量会相对较大\n\n\n### JSPatch\n#### 简介\n- 作者bang(腾讯)[个人博客](http://blog.cnbang.net)，[github](https://github.com/bang590/JSPatch)\n- 项目创建于2015-5\n- [JSPatch接入平台](http://jspatch.com)\n- 淘宝，美团等都有使用，SDK后台接入统计数据超过1200个应用\n- JSPatch交流群(207283178)\n\n#### 需要的基础知识\n-` JavaScriptCore的使用`\n-` runtime`\n#### JSPatch原理\n- 运行时修复不用等待App重新启动，iOS 利用运行时特性修改函数的IMP，从而达到修复目的。\n- 所谓的脚本执行其实只是增加了内存中的类以及新增的IMP，以及对OC中的IMP的组合。\n- jspatch脚本只是一套规则，jspatch内部对其进行了字符串截取的转换，为类名，方法名，以及参数，然后利用运行时的方法进行调用。\n- evaluateScript方法只是让脚本去调用js方法域中的方法，然后iOS会去调用对应IMP，所以JSPatch文件的作用是增加js方法域中的方法。\n- 能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，具体来说能做的有：\n\t- 通过类名和方法名得到具体的类以及方法\n\t- 替换某个类的方法的实现\n\t- 注册一个新的类并且为该类添加方法实现\n\n#### JSPatch具体实现\n>- 最外层需要的是js的调用能力，所以需要定义js函数，提供脚本调用的接口\n>- 又因为我们需要用到运行时的函数，所以需要利用js来调用OC中的方法，所以我们需要生成一系列的IMP\n\n- require\n- JS接口(.alloc().init())/(NSInvocation)[invocation对消息的直接调用](http://mobile.9sssd.com/ios/art/915)\n- 消息传递(JSContext)\n- `对象持有/转换`\n- 类型转换\n- `方法替换`\n- `新增方法`\n- property\n\n`参考`:[bang-JSPatch原理详解](http://blog.cnbang.net/tech/2808/)\n\n#### JSPatch使用流程\n- 开发热修复脚本\n- 压缩为zip(节省空间)\n- 上传脚本到服务器\n- app每次启动判断本地脚本是否超过一天，如果超过一天向服务器请求新的，否则检查该脚本是否合法如果不合法就删除\n- 获取到脚本文件后，调用JSPatch引擎，执行脚本文件进行修复\n\n>补充:终端获取脚本文件是需要一个策略的，最简单的就是，终端根据版本号，获取与该版本号有关的脚本文件：\n如：本次终端发布的版本是：1.0.3，那在上传脚本文件时，就可以将脚本文件的名称定义为：patch1_0_3.js\n这样终端就可以根据版本号，动态组织脚本的下载地址，而且一个版本对应一个脚本文件，简单明了～～\n![Alt text](./20151127111300698.jpeg)\n\n#### JSPatch的引入\n- 引入SDK\n\t- 原版SDK\n\t- 酷狗SDK\n\t- 自定义：源文件+版本管理规则\n- 项目启动函数中添加JSPatch引擎启动命令\n- 脚本分发平台接入\n\t- 官方平台(http://jspatch.com/Docs/price)\n\t- 酷狗后台：秘钥生成，url传入\n\n#### JSPatch中的js语法\n[1.https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法#常量枚举](https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE)\n\n[2.语法转译工具](http://bang590.github.io/JSPatchConvertor/)\n\n3.一些踩过的坑\n```\n tmpLitterImg.length  不能写成   tmpLitterImg.length()\n infoModel.kugouId()  不能写成  infoModel.kugouId\n self.headerView().sd__setImageWithURL//单下划线要用双下划线\n self.locationIconView().right()//left/right后要加()\n UIScreen.mainScreen().bounds().width//CGrect这种结构取值不用加()\n //宏要直接用具体的值\n //枚举要用具体的数字\n //int类型转string类型要用下面的方法\n self.viewerNumLbl().setText('' + info.viewerNum());\n```\n#### 问题\n- swift因为没有OC的动态性，所以暂时没有成熟的只是针对swift的热修复技术方案\n- 当发布了新版，原来下发的脚本怎么办？\n\t- 根据版本号进行js文件的读取，新版本情况下旧版本文件不会再被执行\n- 关于实时推送的实现？\n\t- 现在的技术方案是使用长连接进行推送，单台服务器暂时能够能够支撑200万的链接量\n- 服务器需要做的\n\t- 上传功能\n\t- MD5唯一性验证\n\t- CDN缓存，加速(待定)\n\t- 对文件进行RSA加密同时生成MD5签名\n\t- http接口1\n\t\t- 参数：appversion\n\t\t- 返回\n\t\t\t- patchId\n\t\t\t- appversion\n\t\t\t- fileHash\n\t\t\t- downloadUrl\n\t- http接口2返回加密后的文件\n\t\n------\n\n\t- 在最开始增加参数，配置是否在主线程执行，主要解决假如首页崩溃，可以堵塞。\n\t- 唤醒的时候进行下载，24小时执行一次\n\n\n### Demo\n- javascriptCore的使用\n- JSPatchDemo\n- 在繁星中的使用\n\n---------\n- 启动崩溃两次判断\n- 本地回滚\n\t- js文件的版本号，如果这个版本号本地已经有了，那就不再下发了\n\t- 本地保存的上一次的这个文件是加密呢还是明文呢？\n- MD5两次加密\n\n\n","slug":"2016/热修复技术在移动端的应用","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pny0054sauaesbvozi8","content":"<h3 id=\"热修复技术概述\"><a href=\"#热修复技术概述\" class=\"headerlink\" title=\"热修复技术概述\"></a>热修复技术概述</h3><p>移动应用的部署方式，即发布-&gt;下载-&gt;安装-&gt;运行，决定了他不具备Web的高灵活性，尤其新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。<br><a id=\"more\"></a><br>热修复技术(HotfixPatch)，是一种基于原生应用开发的灵活性解决方案，可以在不改变开发人员技能要求和已有的开发方式的前提下，给于应用在发布后改变程序行为的能力。<br>热补丁的主要优势是不会使设备当前正在运行的业务中断，即在不重启设备的情况下可以对设备当前软件版本的缺陷进行修复。一般用于某个函数导致的bug，如果是某个类导致的bug，或者增减业务模块，不建议使用热修复，而使用Reactive Native。</p>\n<h4 id=\"市场中的热修复技术方案对比\"><a href=\"#市场中的热修复技术方案对比\" class=\"headerlink\" title=\"市场中的热修复技术方案对比\"></a>市场中的热修复技术方案对比</h4><ul>\n<li>WaxPatch(阿里在维护)</li>\n<li>JSPatch(个人项目)</li>\n</ul>\n<p>两者相比，JSPatch的优势：</p>\n<ul>\n<li>1.JS语言: JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</li>\n<li>2.符合Apple规则: JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</li>\n<li>3.小巧: 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</li>\n<li>4.支持block: wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</li>\n</ul>\n<p>JSPatch的劣势：</p>\n<ul>\n<li>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</li>\n</ul>\n<h4 id=\"问题与风险\"><a href=\"#问题与风险\" class=\"headerlink\" title=\"问题与风险\"></a>问题与风险</h4><p>JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：<br>1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。<br>2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。<br>3.由于主要的应用方式是对函数的替换，所以如果某个函数包含几千行的代码，修复的时候工作量会相对较大</p>\n<h3 id=\"JSPatch\"><a href=\"#JSPatch\" class=\"headerlink\" title=\"JSPatch\"></a>JSPatch</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><ul>\n<li>作者bang(腾讯)<a href=\"http://blog.cnbang.net\" target=\"_blank\" rel=\"external\">个人博客</a>，<a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"external\">github</a></li>\n<li>项目创建于2015-5</li>\n<li><a href=\"http://jspatch.com\" target=\"_blank\" rel=\"external\">JSPatch接入平台</a></li>\n<li>淘宝，美团等都有使用，SDK后台接入统计数据超过1200个应用</li>\n<li>JSPatch交流群(207283178)</li>\n</ul>\n<h4 id=\"需要的基础知识\"><a href=\"#需要的基础知识\" class=\"headerlink\" title=\"需要的基础知识\"></a>需要的基础知识</h4><p>-<code>JavaScriptCore的使用</code><br>-<code>runtime</code></p>\n<h4 id=\"JSPatch原理\"><a href=\"#JSPatch原理\" class=\"headerlink\" title=\"JSPatch原理\"></a>JSPatch原理</h4><ul>\n<li>运行时修复不用等待App重新启动，iOS 利用运行时特性修改函数的IMP，从而达到修复目的。</li>\n<li>所谓的脚本执行其实只是增加了内存中的类以及新增的IMP，以及对OC中的IMP的组合。</li>\n<li>jspatch脚本只是一套规则，jspatch内部对其进行了字符串截取的转换，为类名，方法名，以及参数，然后利用运行时的方法进行调用。</li>\n<li>evaluateScript方法只是让脚本去调用js方法域中的方法，然后iOS会去调用对应IMP，所以JSPatch文件的作用是增加js方法域中的方法。</li>\n<li>能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，具体来说能做的有：<ul>\n<li>通过类名和方法名得到具体的类以及方法</li>\n<li>替换某个类的方法的实现</li>\n<li>注册一个新的类并且为该类添加方法实现</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSPatch具体实现\"><a href=\"#JSPatch具体实现\" class=\"headerlink\" title=\"JSPatch具体实现\"></a>JSPatch具体实现</h4><blockquote>\n<ul>\n<li>最外层需要的是js的调用能力，所以需要定义js函数，提供脚本调用的接口</li>\n<li>又因为我们需要用到运行时的函数，所以需要利用js来调用OC中的方法，所以我们需要生成一系列的IMP</li>\n</ul>\n</blockquote>\n<ul>\n<li>require</li>\n<li>JS接口(.alloc().init())/(NSInvocation)<a href=\"http://mobile.9sssd.com/ios/art/915\" target=\"_blank\" rel=\"external\">invocation对消息的直接调用</a></li>\n<li>消息传递(JSContext)</li>\n<li><code>对象持有/转换</code></li>\n<li>类型转换</li>\n<li><code>方法替换</code></li>\n<li><code>新增方法</code></li>\n<li>property</li>\n</ul>\n<p><code>参考</code>:<a href=\"http://blog.cnbang.net/tech/2808/\" target=\"_blank\" rel=\"external\">bang-JSPatch原理详解</a></p>\n<h4 id=\"JSPatch使用流程\"><a href=\"#JSPatch使用流程\" class=\"headerlink\" title=\"JSPatch使用流程\"></a>JSPatch使用流程</h4><ul>\n<li>开发热修复脚本</li>\n<li>压缩为zip(节省空间)</li>\n<li>上传脚本到服务器</li>\n<li>app每次启动判断本地脚本是否超过一天，如果超过一天向服务器请求新的，否则检查该脚本是否合法如果不合法就删除</li>\n<li>获取到脚本文件后，调用JSPatch引擎，执行脚本文件进行修复</li>\n</ul>\n<blockquote>\n<p>补充:终端获取脚本文件是需要一个策略的，最简单的就是，终端根据版本号，获取与该版本号有关的脚本文件：<br>如：本次终端发布的版本是：1.0.3，那在上传脚本文件时，就可以将脚本文件的名称定义为：patch1_0_3.js<br>这样终端就可以根据版本号，动态组织脚本的下载地址，而且一个版本对应一个脚本文件，简单明了～～<br><img src=\"./20151127111300698.jpeg\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"JSPatch的引入\"><a href=\"#JSPatch的引入\" class=\"headerlink\" title=\"JSPatch的引入\"></a>JSPatch的引入</h4><ul>\n<li>引入SDK<ul>\n<li>原版SDK</li>\n<li>酷狗SDK</li>\n<li>自定义：源文件+版本管理规则</li>\n</ul>\n</li>\n<li>项目启动函数中添加JSPatch引擎启动命令</li>\n<li>脚本分发平台接入<ul>\n<li>官方平台(<a href=\"http://jspatch.com/Docs/price\" target=\"_blank\" rel=\"external\">http://jspatch.com/Docs/price</a>)</li>\n<li>酷狗后台：秘钥生成，url传入</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSPatch中的js语法\"><a href=\"#JSPatch中的js语法\" class=\"headerlink\" title=\"JSPatch中的js语法\"></a>JSPatch中的js语法</h4><p><a href=\"https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE\" target=\"_blank\" rel=\"external\">1.https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法#常量枚举</a></p>\n<p><a href=\"http://bang590.github.io/JSPatchConvertor/\" target=\"_blank\" rel=\"external\">2.语法转译工具</a></p>\n<p>3.一些踩过的坑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">tmpLitterImg.length  不能写成   tmpLitterImg.length()</div><div class=\"line\">infoModel.kugouId()  不能写成  infoModel.kugouId</div><div class=\"line\">self.headerView().sd__setImageWithURL//单下划线要用双下划线</div><div class=\"line\">self.locationIconView().right()//left/right后要加()</div><div class=\"line\">UIScreen.mainScreen().bounds().width//CGrect这种结构取值不用加()</div><div class=\"line\">//宏要直接用具体的值</div><div class=\"line\">//枚举要用具体的数字</div><div class=\"line\">//int类型转string类型要用下面的方法</div><div class=\"line\">self.viewerNumLbl().setText(&apos;&apos; + info.viewerNum());</div></pre></td></tr></table></figure></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ul>\n<li>swift因为没有OC的动态性，所以暂时没有成熟的只是针对swift的热修复技术方案</li>\n<li>当发布了新版，原来下发的脚本怎么办？<ul>\n<li>根据版本号进行js文件的读取，新版本情况下旧版本文件不会再被执行</li>\n</ul>\n</li>\n<li>关于实时推送的实现？<ul>\n<li>现在的技术方案是使用长连接进行推送，单台服务器暂时能够能够支撑200万的链接量</li>\n</ul>\n</li>\n<li>服务器需要做的<ul>\n<li>上传功能</li>\n<li>MD5唯一性验证</li>\n<li>CDN缓存，加速(待定)</li>\n<li>对文件进行RSA加密同时生成MD5签名</li>\n<li>http接口1<ul>\n<li>参数：appversion</li>\n<li>返回<ul>\n<li>patchId</li>\n<li>appversion</li>\n<li>fileHash</li>\n<li>downloadUrl</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>http接口2返回加密后的文件</li>\n</ul>\n</li>\n</ul>\n<hr>\n<pre><code>- 在最开始增加参数，配置是否在主线程执行，主要解决假如首页崩溃，可以堵塞。\n- 唤醒的时候进行下载，24小时执行一次\n</code></pre><h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><ul>\n<li>javascriptCore的使用</li>\n<li>JSPatchDemo</li>\n<li>在繁星中的使用</li>\n</ul>\n<hr>\n<ul>\n<li>启动崩溃两次判断</li>\n<li>本地回滚<ul>\n<li>js文件的版本号，如果这个版本号本地已经有了，那就不再下发了</li>\n<li>本地保存的上一次的这个文件是加密呢还是明文呢？</li>\n</ul>\n</li>\n<li>MD5两次加密</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"热修复技术概述\"><a href=\"#热修复技术概述\" class=\"headerlink\" title=\"热修复技术概述\"></a>热修复技术概述</h3><p>移动应用的部署方式，即发布-&gt;下载-&gt;安装-&gt;运行，决定了他不具备Web的高灵活性，尤其新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。<br>","more":"<br>热修复技术(HotfixPatch)，是一种基于原生应用开发的灵活性解决方案，可以在不改变开发人员技能要求和已有的开发方式的前提下，给于应用在发布后改变程序行为的能力。<br>热补丁的主要优势是不会使设备当前正在运行的业务中断，即在不重启设备的情况下可以对设备当前软件版本的缺陷进行修复。一般用于某个函数导致的bug，如果是某个类导致的bug，或者增减业务模块，不建议使用热修复，而使用Reactive Native。</p>\n<h4 id=\"市场中的热修复技术方案对比\"><a href=\"#市场中的热修复技术方案对比\" class=\"headerlink\" title=\"市场中的热修复技术方案对比\"></a>市场中的热修复技术方案对比</h4><ul>\n<li>WaxPatch(阿里在维护)</li>\n<li>JSPatch(个人项目)</li>\n</ul>\n<p>两者相比，JSPatch的优势：</p>\n<ul>\n<li>1.JS语言: JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</li>\n<li>2.符合Apple规则: JSPatch更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</li>\n<li>3.小巧: 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</li>\n<li>4.支持block: wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</li>\n</ul>\n<p>JSPatch的劣势：</p>\n<ul>\n<li>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</li>\n</ul>\n<h4 id=\"问题与风险\"><a href=\"#问题与风险\" class=\"headerlink\" title=\"问题与风险\"></a>问题与风险</h4><p>JSPatch让脚本语言获得调用所有原生OC方法的能力，不像web前端把能力局限在浏览器，使用上会有一些安全风险：<br>1.若在网络传输过程中下发明文JS，可能会被中间人篡改JS脚本，执行任意方法，盗取APP里的相关信息。可以对传输过程进行加密，或用直接使用https解决。<br>2.若下载完后的JS保存在本地没有加密，在未越狱的机器上用户也可以手动替换或篡改脚本。这点危害没有第一点大，因为操作者是手机拥有者，不存在APP内相关信息被盗用的风险。若要避免用户修改代码影响APP运行，可以选择简单的加密存储。<br>3.由于主要的应用方式是对函数的替换，所以如果某个函数包含几千行的代码，修复的时候工作量会相对较大</p>\n<h3 id=\"JSPatch\"><a href=\"#JSPatch\" class=\"headerlink\" title=\"JSPatch\"></a>JSPatch</h3><h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><ul>\n<li>作者bang(腾讯)<a href=\"http://blog.cnbang.net\" target=\"_blank\" rel=\"external\">个人博客</a>，<a href=\"https://github.com/bang590/JSPatch\" target=\"_blank\" rel=\"external\">github</a></li>\n<li>项目创建于2015-5</li>\n<li><a href=\"http://jspatch.com\" target=\"_blank\" rel=\"external\">JSPatch接入平台</a></li>\n<li>淘宝，美团等都有使用，SDK后台接入统计数据超过1200个应用</li>\n<li>JSPatch交流群(207283178)</li>\n</ul>\n<h4 id=\"需要的基础知识\"><a href=\"#需要的基础知识\" class=\"headerlink\" title=\"需要的基础知识\"></a>需要的基础知识</h4><p>-<code>JavaScriptCore的使用</code><br>-<code>runtime</code></p>\n<h4 id=\"JSPatch原理\"><a href=\"#JSPatch原理\" class=\"headerlink\" title=\"JSPatch原理\"></a>JSPatch原理</h4><ul>\n<li>运行时修复不用等待App重新启动，iOS 利用运行时特性修改函数的IMP，从而达到修复目的。</li>\n<li>所谓的脚本执行其实只是增加了内存中的类以及新增的IMP，以及对OC中的IMP的组合。</li>\n<li>jspatch脚本只是一套规则，jspatch内部对其进行了字符串截取的转换，为类名，方法名，以及参数，然后利用运行时的方法进行调用。</li>\n<li>evaluateScript方法只是让脚本去调用js方法域中的方法，然后iOS会去调用对应IMP，所以JSPatch文件的作用是增加js方法域中的方法。</li>\n<li>能做到通过JS调用和改写OC方法最根本的原因是 Objective-C 是动态语言，OC上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，具体来说能做的有：<ul>\n<li>通过类名和方法名得到具体的类以及方法</li>\n<li>替换某个类的方法的实现</li>\n<li>注册一个新的类并且为该类添加方法实现</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSPatch具体实现\"><a href=\"#JSPatch具体实现\" class=\"headerlink\" title=\"JSPatch具体实现\"></a>JSPatch具体实现</h4><blockquote>\n<ul>\n<li>最外层需要的是js的调用能力，所以需要定义js函数，提供脚本调用的接口</li>\n<li>又因为我们需要用到运行时的函数，所以需要利用js来调用OC中的方法，所以我们需要生成一系列的IMP</li>\n</ul>\n</blockquote>\n<ul>\n<li>require</li>\n<li>JS接口(.alloc().init())/(NSInvocation)<a href=\"http://mobile.9sssd.com/ios/art/915\" target=\"_blank\" rel=\"external\">invocation对消息的直接调用</a></li>\n<li>消息传递(JSContext)</li>\n<li><code>对象持有/转换</code></li>\n<li>类型转换</li>\n<li><code>方法替换</code></li>\n<li><code>新增方法</code></li>\n<li>property</li>\n</ul>\n<p><code>参考</code>:<a href=\"http://blog.cnbang.net/tech/2808/\" target=\"_blank\" rel=\"external\">bang-JSPatch原理详解</a></p>\n<h4 id=\"JSPatch使用流程\"><a href=\"#JSPatch使用流程\" class=\"headerlink\" title=\"JSPatch使用流程\"></a>JSPatch使用流程</h4><ul>\n<li>开发热修复脚本</li>\n<li>压缩为zip(节省空间)</li>\n<li>上传脚本到服务器</li>\n<li>app每次启动判断本地脚本是否超过一天，如果超过一天向服务器请求新的，否则检查该脚本是否合法如果不合法就删除</li>\n<li>获取到脚本文件后，调用JSPatch引擎，执行脚本文件进行修复</li>\n</ul>\n<blockquote>\n<p>补充:终端获取脚本文件是需要一个策略的，最简单的就是，终端根据版本号，获取与该版本号有关的脚本文件：<br>如：本次终端发布的版本是：1.0.3，那在上传脚本文件时，就可以将脚本文件的名称定义为：patch1_0_3.js<br>这样终端就可以根据版本号，动态组织脚本的下载地址，而且一个版本对应一个脚本文件，简单明了～～<br><img src=\"./20151127111300698.jpeg\" alt=\"Alt text\"></p>\n</blockquote>\n<h4 id=\"JSPatch的引入\"><a href=\"#JSPatch的引入\" class=\"headerlink\" title=\"JSPatch的引入\"></a>JSPatch的引入</h4><ul>\n<li>引入SDK<ul>\n<li>原版SDK</li>\n<li>酷狗SDK</li>\n<li>自定义：源文件+版本管理规则</li>\n</ul>\n</li>\n<li>项目启动函数中添加JSPatch引擎启动命令</li>\n<li>脚本分发平台接入<ul>\n<li>官方平台(<a href=\"http://jspatch.com/Docs/price\" target=\"_blank\" rel=\"external\">http://jspatch.com/Docs/price</a>)</li>\n<li>酷狗后台：秘钥生成，url传入</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"JSPatch中的js语法\"><a href=\"#JSPatch中的js语法\" class=\"headerlink\" title=\"JSPatch中的js语法\"></a>JSPatch中的js语法</h4><p><a href=\"https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95#%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE\" target=\"_blank\" rel=\"external\">1.https://github.com/bang590/JSPatch/wiki/JSPatch-基础用法#常量枚举</a></p>\n<p><a href=\"http://bang590.github.io/JSPatchConvertor/\" target=\"_blank\" rel=\"external\">2.语法转译工具</a></p>\n<p>3.一些踩过的坑<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">tmpLitterImg.length  不能写成   tmpLitterImg.length()</div><div class=\"line\">infoModel.kugouId()  不能写成  infoModel.kugouId</div><div class=\"line\">self.headerView().sd__setImageWithURL//单下划线要用双下划线</div><div class=\"line\">self.locationIconView().right()//left/right后要加()</div><div class=\"line\">UIScreen.mainScreen().bounds().width//CGrect这种结构取值不用加()</div><div class=\"line\">//宏要直接用具体的值</div><div class=\"line\">//枚举要用具体的数字</div><div class=\"line\">//int类型转string类型要用下面的方法</div><div class=\"line\">self.viewerNumLbl().setText(&apos;&apos; + info.viewerNum());</div></pre></td></tr></table></figure></p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ul>\n<li>swift因为没有OC的动态性，所以暂时没有成熟的只是针对swift的热修复技术方案</li>\n<li>当发布了新版，原来下发的脚本怎么办？<ul>\n<li>根据版本号进行js文件的读取，新版本情况下旧版本文件不会再被执行</li>\n</ul>\n</li>\n<li>关于实时推送的实现？<ul>\n<li>现在的技术方案是使用长连接进行推送，单台服务器暂时能够能够支撑200万的链接量</li>\n</ul>\n</li>\n<li>服务器需要做的<ul>\n<li>上传功能</li>\n<li>MD5唯一性验证</li>\n<li>CDN缓存，加速(待定)</li>\n<li>对文件进行RSA加密同时生成MD5签名</li>\n<li>http接口1<ul>\n<li>参数：appversion</li>\n<li>返回<ul>\n<li>patchId</li>\n<li>appversion</li>\n<li>fileHash</li>\n<li>downloadUrl</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>http接口2返回加密后的文件</li>\n</ul>\n</li>\n</ul>\n<hr>\n<pre><code>- 在最开始增加参数，配置是否在主线程执行，主要解决假如首页崩溃，可以堵塞。\n- 唤醒的时候进行下载，24小时执行一次\n</code></pre><h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h3><ul>\n<li>javascriptCore的使用</li>\n<li>JSPatchDemo</li>\n<li>在繁星中的使用</li>\n</ul>\n<hr>\n<ul>\n<li>启动崩溃两次判断</li>\n<li>本地回滚<ul>\n<li>js文件的版本号，如果这个版本号本地已经有了，那就不再下发了</li>\n<li>本地保存的上一次的这个文件是加密呢还是明文呢？</li>\n</ul>\n</li>\n<li>MD5两次加密</li>\n</ul>"},{"_content":"---\ntitle: (转)block进阶1--block实现\ndate: 2016-06-29 14:15:20\ntags:\n- iOS进阶\ncategories: iOS\n-----\n本系列博文总结自《Pro Multithreading and Memory Management for iOS and OS X with ARC》\n\n<!--more-->\nblock 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。\n\n需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。\n\n>以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。\n\n所以，切勿将过程代码当做block的实际实现，切记切记！！！\n\n将下面的 `test.m` 代码用 clang 工具翻译 `test.cpp` 代码\n>clang -rewrite-objc test.m\n\n`test.m 代码`\n```\n/************* Objective-C 源码 *************/\nint main()\n{\n    void (^blk)(void) = ^{ printf(\"Block\\n\"); }; \n    blk();\n    return 0;\n}\n\n```\n\n`test.cpp`\n```\n/************* 使用 clang 翻译后如下 *************/\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    printf(\"Block\\n\");\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };\nint main()\n{\n    void (*blk)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA);\n    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);\n    return 0;\n}\n```\n\n接着，我们逐一来看下这些函数和结构体\n\n## block 结构体信息详解\n\n### struct __block_impl\n```\n// __block_impl 是 block 实现的结构体\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n```\n- `isa `\n```\nimpl.isa = &_NSConcreteStackBlock; \nimpl.isa = &_NSConcreteMallocBlock; \nimpl.isa = &_NSConcreteGlobalBlock;\n```\n\n- Flags \n按位承载 block 的附加信息；\n\n- Reserved \n保留变量；\n\n- FuncPtr \n函数指针，指向 Block 要执行的函数，即{ printf(\"Block\\n\") };\n\n### struct __main_block_impl_0\n```\n// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n- impl \nblock 实现的结构体变量，该结构体前面已说明；\n\n- Desc \n描述 block 的结构体变量；\n\n- __main_block_impl_0 \n结构体的构造函数，初始化结构体变量 impl、Desc；\n\n### static void __main_block_func_0\n```\n// __main_block_func_0 是 block 要最终要执行的函数代码\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    printf(\"Block\\n\");\n}\n```\n\n### static struct __main_block_desc_0\n```\n// __main_block_desc_0 是 block 的描述信息结构体\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };\n```\n- reserved \n结构体信息保留字段\n\n- Block_size \n结构体大小\n\n此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA\n>![block执行过程](http://i4.piimg.com/567571/75ff5f7241b14097.png)\n\n接着再看 block 获取外部变量\n\n## block 获取外部变量\n\n运行下面的代码\n```\nint main()\n{\n    int intValue = 1;\n    void (^blk)(void) = ^{ printf(\"intValue = %d\\n\", intValue); };\n    blk();\n    return 0;\n}\n```\n打印结果\n\nintValue = 1\n和第一段源码不同的是，这里多了个局部变量 intValue，而且还在 block 里面获取到了。\n\n通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码\n```\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int intValue;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    int intValue = __cself->intValue; // bound by copy\n    printf(\"intValue = %d\\n\", intValue);\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main()\n{\n    int intValue = 1;\n    void (*blk)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, intValue);\n    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);\n    return 0;\n}\n```\n原来 block 通过参数值传递获取到 intValue 变量，通过函数\n```\n__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)\n保存到 __main_block_impl_0 结构体的同名变量 intValue，通过代码 int intValue = __cself->intValue; 取出 intValue，打印出来。\n\n构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。\n```\n有四种情况下应该使用初始化表达式来初始化成员： \n1：初始化const成员 \n2：初始化引用成员 \n3：当调用基类的构造函数，而它拥有一组参数时 \n4：当调用成员类的构造函数，而它拥有一组参数时\n\n\n至此，我们已经了解了block 的实现，以及获取外部变量的原理。但是，我们还不能在 block 内修改 intValue 变量。如果你有心试下，在 block 内部修改 intValue 的值，会报编译错误\n\nVariable is not assignable(missing __block type specifier)\n","source":"_posts/2016/转-block进阶1-block实现.md","raw":"---\ntitle: (转)block进阶1--block实现\ndate: 2016-06-29 14:15:20\ntags:\n- iOS进阶\ncategories: iOS\n-----\n本系列博文总结自《Pro Multithreading and Memory Management for iOS and OS X with ARC》\n\n<!--more-->\nblock 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。\n\n需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。\n\n>以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。\n\n所以，切勿将过程代码当做block的实际实现，切记切记！！！\n\n将下面的 `test.m` 代码用 clang 工具翻译 `test.cpp` 代码\n>clang -rewrite-objc test.m\n\n`test.m 代码`\n```\n/************* Objective-C 源码 *************/\nint main()\n{\n    void (^blk)(void) = ^{ printf(\"Block\\n\"); }; \n    blk();\n    return 0;\n}\n\n```\n\n`test.cpp`\n```\n/************* 使用 clang 翻译后如下 *************/\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    printf(\"Block\\n\");\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };\nint main()\n{\n    void (*blk)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA);\n    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);\n    return 0;\n}\n```\n\n接着，我们逐一来看下这些函数和结构体\n\n## block 结构体信息详解\n\n### struct __block_impl\n```\n// __block_impl 是 block 实现的结构体\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n```\n- `isa `\n```\nimpl.isa = &_NSConcreteStackBlock; \nimpl.isa = &_NSConcreteMallocBlock; \nimpl.isa = &_NSConcreteGlobalBlock;\n```\n\n- Flags \n按位承载 block 的附加信息；\n\n- Reserved \n保留变量；\n\n- FuncPtr \n函数指针，指向 Block 要执行的函数，即{ printf(\"Block\\n\") };\n\n### struct __main_block_impl_0\n```\n// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n```\n\n- impl \nblock 实现的结构体变量，该结构体前面已说明；\n\n- Desc \n描述 block 的结构体变量；\n\n- __main_block_impl_0 \n结构体的构造函数，初始化结构体变量 impl、Desc；\n\n### static void __main_block_func_0\n```\n// __main_block_func_0 是 block 要最终要执行的函数代码\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    printf(\"Block\\n\");\n}\n```\n\n### static struct __main_block_desc_0\n```\n// __main_block_desc_0 是 block 的描述信息结构体\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) };\n```\n- reserved \n结构体信息保留字段\n\n- Block_size \n结构体大小\n\n此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA\n>![block执行过程](http://i4.piimg.com/567571/75ff5f7241b14097.png)\n\n接着再看 block 获取外部变量\n\n## block 获取外部变量\n\n运行下面的代码\n```\nint main()\n{\n    int intValue = 1;\n    void (^blk)(void) = ^{ printf(\"intValue = %d\\n\", intValue); };\n    blk();\n    return 0;\n}\n```\n打印结果\n\nintValue = 1\n和第一段源码不同的是，这里多了个局部变量 intValue，而且还在 block 里面获取到了。\n\n通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码\n```\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int intValue;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    int intValue = __cself->intValue; // bound by copy\n    printf(\"intValue = %d\\n\", intValue);\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\nint main()\n{\n    int intValue = 1;\n    void (*blk)(void) = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, intValue);\n    ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);\n    return 0;\n}\n```\n原来 block 通过参数值传递获取到 intValue 变量，通过函数\n```\n__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)\n保存到 __main_block_impl_0 结构体的同名变量 intValue，通过代码 int intValue = __cself->intValue; 取出 intValue，打印出来。\n\n构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。\n```\n有四种情况下应该使用初始化表达式来初始化成员： \n1：初始化const成员 \n2：初始化引用成员 \n3：当调用基类的构造函数，而它拥有一组参数时 \n4：当调用成员类的构造函数，而它拥有一组参数时\n\n\n至此，我们已经了解了block 的实现，以及获取外部变量的原理。但是，我们还不能在 block 内修改 intValue 变量。如果你有心试下，在 block 内部修改 intValue 的值，会报编译错误\n\nVariable is not assignable(missing __block type specifier)\n","slug":"2016/转-block进阶1-block实现","published":1,"date":"2017-10-11T10:13:43.000Z","updated":"2017-10-11T10:13:43.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4pnz0057saua6ybn4m5u","content":"<hr>\n<p>title: (转)block进阶1–block实现<br>date: 2016-06-29 14:15:20<br>tags:</p>\n<ul>\n<li>iOS进阶<br>categories: iOS</li>\n</ul>\n<hr>\n<p>本系列博文总结自《Pro Multithreading and Memory Management for iOS and OS X with ARC》</p>\n<a id=\"more\"></a>\n<p>block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。</p>\n<p>需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。</p>\n<blockquote>\n<p>以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。</p>\n</blockquote>\n<p>所以，切勿将过程代码当做block的实际实现，切记切记！！！</p>\n<p>将下面的 <code>test.m</code> 代码用 clang 工具翻译 <code>test.cpp</code> 代码</p>\n<blockquote>\n<p>clang -rewrite-objc test.m</p>\n</blockquote>\n<p><code>test.m 代码</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* Objective-C 源码 *************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^blk)(void) = ^&#123; printf(&quot;Block\\n&quot;); &#125;; </div><div class=\"line\">    blk();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>test.cpp</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 clang 翻译后如下 *************/</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Block\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着，我们逐一来看下这些函数和结构体</p>\n<h2 id=\"block-结构体信息详解\"><a href=\"#block-结构体信息详解\" class=\"headerlink\" title=\"block 结构体信息详解\"></a>block 结构体信息详解</h2><h3 id=\"struct-block-impl\"><a href=\"#struct-block-impl\" class=\"headerlink\" title=\"struct __block_impl\"></a>struct __block_impl</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __block_impl 是 block 实现的结构体</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p><code>isa</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">impl.isa = &amp;_NSConcreteStackBlock; </div><div class=\"line\">impl.isa = &amp;_NSConcreteMallocBlock; </div><div class=\"line\">impl.isa = &amp;_NSConcreteGlobalBlock;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Flags<br>按位承载 block 的附加信息；</p>\n</li>\n<li><p>Reserved<br>保留变量；</p>\n</li>\n<li><p>FuncPtr<br>函数指针，指向 Block 要执行的函数，即{ printf(“Block\\n”) };</p>\n</li>\n</ul>\n<h3 id=\"struct-main-block-impl-0\"><a href=\"#struct-main-block-impl-0\" class=\"headerlink\" title=\"struct __main_block_impl_0\"></a>struct __main_block_impl_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>impl<br>block 实现的结构体变量，该结构体前面已说明；</p>\n</li>\n<li><p>Desc<br>描述 block 的结构体变量；</p>\n</li>\n<li><p>__main_block_impl_0<br>结构体的构造函数，初始化结构体变量 impl、Desc；</p>\n</li>\n</ul>\n<h3 id=\"static-void-main-block-func-0\"><a href=\"#static-void-main-block-func-0\" class=\"headerlink\" title=\"static void __main_block_func_0\"></a>static void __main_block_func_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_func_0 是 block 要最终要执行的函数代码</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Block\\n&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"static-struct-main-block-desc-0\"><a href=\"#static-struct-main-block-desc-0\" class=\"headerlink\" title=\"static struct __main_block_desc_0\"></a>static struct __main_block_desc_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_desc_0 是 block 的描述信息结构体</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>reserved<br>结构体信息保留字段</p>\n</li>\n<li><p>Block_size<br>结构体大小</p>\n</li>\n</ul>\n<p>此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA</p>\n<blockquote>\n<p><img src=\"http://i4.piimg.com/567571/75ff5f7241b14097.png\" alt=\"block执行过程\"></p>\n</blockquote>\n<p>接着再看 block 获取外部变量</p>\n<h2 id=\"block-获取外部变量\"><a href=\"#block-获取外部变量\" class=\"headerlink\" title=\"block 获取外部变量\"></a>block 获取外部变量</h2><p>运行下面的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = 1;</div><div class=\"line\">    void (^blk)(void) = ^&#123; printf(&quot;intValue = %d\\n&quot;, intValue); &#125;;</div><div class=\"line\">    blk();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果</p>\n<p>intValue = 1<br>和第一段源码不同的是，这里多了个局部变量 intValue，而且还在 block 里面获取到了。</p>\n<p>通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int intValue;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = __cself-&gt;intValue; // bound by copy</div><div class=\"line\">    printf(&quot;intValue = %d\\n&quot;, intValue);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = 1;</div><div class=\"line\">    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, intValue);</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原来 block 通过参数值传递获取到 intValue 变量，通过函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</div><div class=\"line\">保存到 __main_block_impl_0 结构体的同名变量 intValue，通过代码 int intValue = __cself-&gt;intValue; 取出 intValue，打印出来。</div><div class=\"line\"></div><div class=\"line\">构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。</div></pre></td></tr></table></figure></p>\n<p>有四种情况下应该使用初始化表达式来初始化成员：<br>1：初始化const成员<br>2：初始化引用成员<br>3：当调用基类的构造函数，而它拥有一组参数时<br>4：当调用成员类的构造函数，而它拥有一组参数时</p>\n<p>至此，我们已经了解了block 的实现，以及获取外部变量的原理。但是，我们还不能在 block 内修改 intValue 变量。如果你有心试下，在 block 内部修改 intValue 的值，会报编译错误</p>\n<p>Variable is not assignable(missing __block type specifier)</p>\n","site":{"data":{}},"excerpt":"<hr>\n<p>title: (转)block进阶1–block实现<br>date: 2016-06-29 14:15:20<br>tags:</p>\n<ul>\n<li>iOS进阶<br>categories: iOS</li>\n</ul>\n<hr>\n<p>本系列博文总结自《Pro Multithreading and Memory Management for iOS and OS X with ARC》</p>","more":"<p>block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。</p>\n<p>需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。</p>\n<blockquote>\n<p>以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。</p>\n</blockquote>\n<p>所以，切勿将过程代码当做block的实际实现，切记切记！！！</p>\n<p>将下面的 <code>test.m</code> 代码用 clang 工具翻译 <code>test.cpp</code> 代码</p>\n<blockquote>\n<p>clang -rewrite-objc test.m</p>\n</blockquote>\n<p><code>test.m 代码</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* Objective-C 源码 *************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    void (^blk)(void) = ^&#123; printf(&quot;Block\\n&quot;); &#125;; </div><div class=\"line\">    blk();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>test.cpp</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 clang 翻译后如下 *************/</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Block\\n&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着，我们逐一来看下这些函数和结构体</p>\n<h2 id=\"block-结构体信息详解\"><a href=\"#block-结构体信息详解\" class=\"headerlink\" title=\"block 结构体信息详解\"></a>block 结构体信息详解</h2><h3 id=\"struct-block-impl\"><a href=\"#struct-block-impl\" class=\"headerlink\" title=\"struct __block_impl\"></a>struct __block_impl</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __block_impl 是 block 实现的结构体</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p><code>isa</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">impl.isa = &amp;_NSConcreteStackBlock; </div><div class=\"line\">impl.isa = &amp;_NSConcreteMallocBlock; </div><div class=\"line\">impl.isa = &amp;_NSConcreteGlobalBlock;</div></pre></td></tr></table></figure>\n</li>\n<li><p>Flags<br>按位承载 block 的附加信息；</p>\n</li>\n<li><p>Reserved<br>保留变量；</p>\n</li>\n<li><p>FuncPtr<br>函数指针，指向 Block 要执行的函数，即{ printf(“Block\\n”) };</p>\n</li>\n</ul>\n<h3 id=\"struct-main-block-impl-0\"><a href=\"#struct-main-block-impl-0\" class=\"headerlink\" title=\"struct __main_block_impl_0\"></a>struct __main_block_impl_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>impl<br>block 实现的结构体变量，该结构体前面已说明；</p>\n</li>\n<li><p>Desc<br>描述 block 的结构体变量；</p>\n</li>\n<li><p>__main_block_impl_0<br>结构体的构造函数，初始化结构体变量 impl、Desc；</p>\n</li>\n</ul>\n<h3 id=\"static-void-main-block-func-0\"><a href=\"#static-void-main-block-func-0\" class=\"headerlink\" title=\"static void __main_block_func_0\"></a>static void __main_block_func_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_func_0 是 block 要最终要执行的函数代码</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Block\\n&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"static-struct-main-block-desc-0\"><a href=\"#static-struct-main-block-desc-0\" class=\"headerlink\" title=\"static struct __main_block_desc_0\"></a>static struct __main_block_desc_0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// __main_block_desc_0 是 block 的描述信息结构体</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>reserved<br>结构体信息保留字段</p>\n</li>\n<li><p>Block_size<br>结构体大小</p>\n</li>\n</ul>\n<p>此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA</p>\n<blockquote>\n<p><img src=\"http://i4.piimg.com/567571/75ff5f7241b14097.png\" alt=\"block执行过程\"></p>\n</blockquote>\n<p>接着再看 block 获取外部变量</p>\n<h2 id=\"block-获取外部变量\"><a href=\"#block-获取外部变量\" class=\"headerlink\" title=\"block 获取外部变量\"></a>block 获取外部变量</h2><p>运行下面的代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = 1;</div><div class=\"line\">    void (^blk)(void) = ^&#123; printf(&quot;intValue = %d\\n&quot;, intValue); &#125;;</div><div class=\"line\">    blk();</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印结果</p>\n<p>intValue = 1<br>和第一段源码不同的是，这里多了个局部变量 intValue，而且还在 block 里面获取到了。</p>\n<p>通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    int intValue;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = __cself-&gt;intValue; // bound by copy</div><div class=\"line\">    printf(&quot;intValue = %d\\n&quot;, intValue);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    int intValue = 1;</div><div class=\"line\">    void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, intValue);</div><div class=\"line\">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>原来 block 通过参数值传递获取到 intValue 变量，通过函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</div><div class=\"line\">保存到 __main_block_impl_0 结构体的同名变量 intValue，通过代码 int intValue = __cself-&gt;intValue; 取出 intValue，打印出来。</div><div class=\"line\"></div><div class=\"line\">构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。</div></pre></td></tr></table></figure></p>\n<p>有四种情况下应该使用初始化表达式来初始化成员：<br>1：初始化const成员<br>2：初始化引用成员<br>3：当调用基类的构造函数，而它拥有一组参数时<br>4：当调用成员类的构造函数，而它拥有一组参数时</p>\n<p>至此，我们已经了解了block 的实现，以及获取外部变量的原理。但是，我们还不能在 block 内修改 intValue 变量。如果你有心试下，在 block 内部修改 intValue 的值，会报编译错误</p>\n<p>Variable is not assignable(missing __block type specifier)</p>"},{"title":"(转)block进阶2--block和变量内存管理","date":"2016-06-25T06:15:48.000Z","_content":"了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。本文将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。\n<!--more-->\n上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作\n\n>- 全局变量\n- 全局静态变量\n- 静态变量\n\n全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？\n\nApple 早就为我们准备了这么一个东西 —— “__block”\n\n## __block 说明符\n按照惯例，重写一小段代码看看 __block 的真身\n```\n/************* 使用 __block 的源码 *************/\nint main()\n{\n    __block int intValue = 0;\n    void (^blk)(void) = ^{\n        intValue = 1;\n    };\n    return 0;\n}\n```\n\n```\n/************* 使用 clang 翻译后如下 *************/\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __Block_byref_intValue_0\n{\n    void *__isa;\n    __Block_byref_intValue_0 *__forwarding;\n    int __flags;\n    int __size;\n    int intValue;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __Block_byref_intValue_0 *intValue; // by ref\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue->__forwarding)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    __Block_byref_intValue_0 *intValue = __cself->intValue; // bound by ref\n    (intValue->__forwarding->intValue) = 1;\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)\n{\n    _Block_object_assign((void*)&dst->intValue, (void*)src->intValue, 8/*BLOCK_FIELD_IS_BYREF*/);\n}\nstatic void __main_block_dispose_0(struct __main_block_impl_0 *src)\n{\n    _Block_object_dispose((void*)src->intValue, 8/*BLOCK_FIELD_IS_BYREF*/);\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = {  0, \n                                sizeof(struct __main_block_impl_0), \n                                __main_block_copy_0, \n                                __main_block_dispose_0\n                             };\nint main()\n{\n    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \\\n    intValue = \n    {\n        (void*)0,\n        (__Block_byref_intValue_0 *)&intValue, \n        0, \n        sizeof(__Block_byref_intValue_0), \n        0\n    };\n    void (*blk)(void) = (void (*)()) &__main_block_impl_0   \\\n                (\n                    (void *)__main_block_func_0,            \\\n                    &__main_block_desc_0_DATA,              \\\n                    (__Block_byref_intValue_0 *)&intValue,  \\\n                    570425344                               \\\n                );\n    return 0;\n}\n```\n在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了\n> -__Block_byref_intValue_0 结构体：用于封装 __block 修饰的外部变量。\n- _Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。\n- _Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。\n\nOC源码中的 __block intValue 翻译后变成了 __Block_byref_intValue_0 结构体指针变量 intValue，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。除此之外，整体的执行流程与不加 __block 基本一致，不再赘述。但 __Block_byref_intValue_0 这个结构体需特别注意下\n\n```\n// 存储 __block 外部变量的结构体\nstruct __Block_byref_intValue_0\n{\n    void *__isa; // 对象指针\n    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针\n    int __flags; // 标志位变量\n    int __size; // 结构体大小\n    int intValue; // 外部变量\n};\n```\n![](http://i4.piimg.com/567571/edba9eda9e760d13.png)\n在已有结构体指针指向 `__Block_byref_intValue_0` 时，结构体里面还多了个 __forwarding 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。\n\n## block 的内存管理\n\n在前文中，已经提到了 block 的三种类型 `NSConcreteGlobalBlock`、`_NSConcreteStackBlock`、`_NSConcreteMallocBlock`，见名知意，可以看出三种 block 在内存中的分布\n![](http://i4.piimg.com/567571/ab4b00f9b39f146a.png)\n\n### _NSConcreteGlobalBlock\n>- 1、当 block 字面量写在全局作用域时，即为 global block； \n- 2、当 block 字面量不获取任何外部变量时，即为 global block；\n\n除了上述描述的两种情况，其他形式创建的 block 均为 stack block。\n\n```\n// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block\ntypedef int (^blk_t)(int);\nfor (int rate = 0; rate < 10; ++rate) \n{\n    blk_t blk = ^(int count){return rate * count;}; \n}\n```\n_NSConcreteGlobalBlock 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。\n\n### _NSConcreteStackBlock\n_NSConcreteStackBlock 类型的 block 处于内存的栈区。global block 由于处在 data 段，可以通过指针安全访问，但 stack block 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。\n![](http://i4.piimg.com/567571/eb42780701d9dfdd.png)\n\n为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 _NSConcreteMallocBlock。\n\n### _NSConcreteMallocBlock\n当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block\n![](http://i4.piimg.com/567571/a4cf5bfee64c0faf.png)\n此时，堆上的 block 类型为 _NSConcreteMallocBlock，所以会将 _NSConcreteMallocBlock 写入 isa\n\n```\nimpl.isa = &_NSConcreteMallocBlock;\n```\n如果你细心的观察上面的转换后的代码，会发现访问结构体 __Block_byref_intValue_0 内部的成员变量都是通过访问 __forwarding 指针完成的。为了保证能正确访问栈上的 __block 变量，进行 copy 操作时，会将栈上的 __forwarding 指针指向了堆上的 block 结构体实例。\n\n## block 的自动拷贝和手动拷贝\n在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当\n>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；\n\n但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：\n>- 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;\n\n让我们看个 block 自动拷贝的例子\n```\n/************ ARC下编译器自动拷贝block ************/\ntypedef int (^blk_t)(int);\nblk_t func(int rate)\n{\n    return ^(int count){return rate * count;};\n}\n```\n上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下\n```\nblk_t func(int rate)\n{\n    blk_t tmp = &__func_block_impl_0(__func_block_func_0, &__func_block_desc_0_DATA, rate);\n    tmp = objc_retainBlock(tmp);\n    return objc_autoreleaseReturnValue(tmp); \n}\n```\n转换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。如果你看过runtime 库（点此下载） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现：\n\n```\n/*********** objc_retainBlock() 的实现 ***********/\nid objc_retainBlock(id x) \n{\n#if ARR_LOGGING\n    objc_arr_log(\"objc_retain_block\", x);\n    ++CompilerGenerated.blockCopies;\n#endif\n    return (id)_Block_copy(x);\n}\n// Create a heap based copy of a Block or simply add a reference to an existing one.\n// This must be paired with Block_release to recover memory, even when running\n// under Objective-C Garbage Collection.\nBLOCK_EXPORT void *_Block_copy(const void *aBlock)\n    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);\n    \n ```\n \n ```\n    /*********** objc_autoreleaseReturnValue() 的实现 ***********/\nid objc_autoreleaseReturnValue(id obj)\n{\n#if SUPPORT_RETURN_AUTORELEASE\n    assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);\n    if (callerAcceptsFastAutorelease(__builtin_return_address(0))) {\n        _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);\n        return obj;\n    }\n#endif\n    return objc_autorelease(obj);\n}\n```\n\n通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。\n\n看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子\n\n```\n/************ ARC下编译器手动拷贝block ************/\n- (id)getBlockArray\n{\n    int val = 10;\n    return [[NSArray alloc] initWithObjects: \n                            ^{NSLog(@\"blk0:%d\", val);}, \n                            ^{NSLog(@\"blk1:%d\", val);}, nil];\n}\n```\n一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。\n\n关于 block 的拷贝操作可以用一张表总结下\n\n![](http://i4.piimg.com/567571/82a9a9d7492f431e.png)\n\nblock 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。\n\n```\nblock的多次拷贝：下面的例子在 ARC 下并不会产生内存泄露哦\n\n// block 多次拷贝源码\nblk = [[[[blk copy] copy] copy] copy]; \n// 翻译后的代码\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp;\n}\n```\n\n## __block 变量的内存管理\n\n上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。\n\n- 当 block 从栈内存被拷贝到堆内存时，__block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 __block 变量已经没有影响了。\n\n![](http://i4.piimg.com/567571/c6c5e220ca09511e.png)\n\n- 当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时\n![](http://i4.piimg.com/567571/5e7b1f767a1526f8.png)\n\n- 当 block 被废弃时，__block 变量被释放\n![](http://i4.piimg.com/567571/f6c64412dfaed0f4.png)\n\n- __forwarding \n\n前文已经说过，当 block 从栈被拷贝到堆时，__forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 __forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 __forwarding 指针指向堆上结构体。后面如果要想使用 __block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。\n```\n/*************** __forwarding 的作用 ***************/\n//猜猜下面代码的打印结果？\n{\n    __block int val = 0;\n    void (^blk)(void) = [^{++val;} copy];\n    ++val;\n    blk();\n    NSLog(@\"%d\", val);\n}\n```\n一定有很多人会猜 1，其实打印 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 __forwarding 也会指向堆上的 __block 变量的结构体。\n\n上面的代码中 ^{++val;} 和 ++val; 都会被转换成 ++(val.__forwarding->val);，堆上的 val 被加了两次，最后打印堆上的 val 为 2。\n\n![](http://i4.piimg.com/567571/ae21fcf6a92ab9ee.png)","source":"_posts/2016/转-block进阶2-block和变量内存管理.md","raw":"---\ntitle: (转)block进阶2--block和变量内存管理\ndate: 2016-06-25 14:15:48\ntags:\n- iOS进阶\n---\n了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。本文将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。\n<!--more-->\n上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作\n\n>- 全局变量\n- 全局静态变量\n- 静态变量\n\n全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？\n\nApple 早就为我们准备了这么一个东西 —— “__block”\n\n## __block 说明符\n按照惯例，重写一小段代码看看 __block 的真身\n```\n/************* 使用 __block 的源码 *************/\nint main()\n{\n    __block int intValue = 0;\n    void (^blk)(void) = ^{\n        intValue = 1;\n    };\n    return 0;\n}\n```\n\n```\n/************* 使用 clang 翻译后如下 *************/\nstruct __block_impl\n{\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\nstruct __Block_byref_intValue_0\n{\n    void *__isa;\n    __Block_byref_intValue_0 *__forwarding;\n    int __flags;\n    int __size;\n    int intValue;\n};\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __Block_byref_intValue_0 *intValue; // by ref\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue->__forwarding)\n    {\n        impl.isa = &_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself)\n{\n    __Block_byref_intValue_0 *intValue = __cself->intValue; // bound by ref\n    (intValue->__forwarding->intValue) = 1;\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)\n{\n    _Block_object_assign((void*)&dst->intValue, (void*)src->intValue, 8/*BLOCK_FIELD_IS_BYREF*/);\n}\nstatic void __main_block_dispose_0(struct __main_block_impl_0 *src)\n{\n    _Block_object_dispose((void*)src->intValue, 8/*BLOCK_FIELD_IS_BYREF*/);\n}\nstatic struct __main_block_desc_0\n{\n    size_t reserved;\n    size_t Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = {  0, \n                                sizeof(struct __main_block_impl_0), \n                                __main_block_copy_0, \n                                __main_block_dispose_0\n                             };\nint main()\n{\n    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \\\n    intValue = \n    {\n        (void*)0,\n        (__Block_byref_intValue_0 *)&intValue, \n        0, \n        sizeof(__Block_byref_intValue_0), \n        0\n    };\n    void (*blk)(void) = (void (*)()) &__main_block_impl_0   \\\n                (\n                    (void *)__main_block_func_0,            \\\n                    &__main_block_desc_0_DATA,              \\\n                    (__Block_byref_intValue_0 *)&intValue,  \\\n                    570425344                               \\\n                );\n    return 0;\n}\n```\n在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了\n> -__Block_byref_intValue_0 结构体：用于封装 __block 修饰的外部变量。\n- _Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。\n- _Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。\n\nOC源码中的 __block intValue 翻译后变成了 __Block_byref_intValue_0 结构体指针变量 intValue，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。除此之外，整体的执行流程与不加 __block 基本一致，不再赘述。但 __Block_byref_intValue_0 这个结构体需特别注意下\n\n```\n// 存储 __block 外部变量的结构体\nstruct __Block_byref_intValue_0\n{\n    void *__isa; // 对象指针\n    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针\n    int __flags; // 标志位变量\n    int __size; // 结构体大小\n    int intValue; // 外部变量\n};\n```\n![](http://i4.piimg.com/567571/edba9eda9e760d13.png)\n在已有结构体指针指向 `__Block_byref_intValue_0` 时，结构体里面还多了个 __forwarding 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。\n\n## block 的内存管理\n\n在前文中，已经提到了 block 的三种类型 `NSConcreteGlobalBlock`、`_NSConcreteStackBlock`、`_NSConcreteMallocBlock`，见名知意，可以看出三种 block 在内存中的分布\n![](http://i4.piimg.com/567571/ab4b00f9b39f146a.png)\n\n### _NSConcreteGlobalBlock\n>- 1、当 block 字面量写在全局作用域时，即为 global block； \n- 2、当 block 字面量不获取任何外部变量时，即为 global block；\n\n除了上述描述的两种情况，其他形式创建的 block 均为 stack block。\n\n```\n// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block\ntypedef int (^blk_t)(int);\nfor (int rate = 0; rate < 10; ++rate) \n{\n    blk_t blk = ^(int count){return rate * count;}; \n}\n```\n_NSConcreteGlobalBlock 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。\n\n### _NSConcreteStackBlock\n_NSConcreteStackBlock 类型的 block 处于内存的栈区。global block 由于处在 data 段，可以通过指针安全访问，但 stack block 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。\n![](http://i4.piimg.com/567571/eb42780701d9dfdd.png)\n\n为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 _NSConcreteMallocBlock。\n\n### _NSConcreteMallocBlock\n当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block\n![](http://i4.piimg.com/567571/a4cf5bfee64c0faf.png)\n此时，堆上的 block 类型为 _NSConcreteMallocBlock，所以会将 _NSConcreteMallocBlock 写入 isa\n\n```\nimpl.isa = &_NSConcreteMallocBlock;\n```\n如果你细心的观察上面的转换后的代码，会发现访问结构体 __Block_byref_intValue_0 内部的成员变量都是通过访问 __forwarding 指针完成的。为了保证能正确访问栈上的 __block 变量，进行 copy 操作时，会将栈上的 __forwarding 指针指向了堆上的 block 结构体实例。\n\n## block 的自动拷贝和手动拷贝\n在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当\n>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；\n\n但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：\n>- 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;\n\n让我们看个 block 自动拷贝的例子\n```\n/************ ARC下编译器自动拷贝block ************/\ntypedef int (^blk_t)(int);\nblk_t func(int rate)\n{\n    return ^(int count){return rate * count;};\n}\n```\n上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下\n```\nblk_t func(int rate)\n{\n    blk_t tmp = &__func_block_impl_0(__func_block_func_0, &__func_block_desc_0_DATA, rate);\n    tmp = objc_retainBlock(tmp);\n    return objc_autoreleaseReturnValue(tmp); \n}\n```\n转换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。如果你看过runtime 库（点此下载） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现：\n\n```\n/*********** objc_retainBlock() 的实现 ***********/\nid objc_retainBlock(id x) \n{\n#if ARR_LOGGING\n    objc_arr_log(\"objc_retain_block\", x);\n    ++CompilerGenerated.blockCopies;\n#endif\n    return (id)_Block_copy(x);\n}\n// Create a heap based copy of a Block or simply add a reference to an existing one.\n// This must be paired with Block_release to recover memory, even when running\n// under Objective-C Garbage Collection.\nBLOCK_EXPORT void *_Block_copy(const void *aBlock)\n    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);\n    \n ```\n \n ```\n    /*********** objc_autoreleaseReturnValue() 的实现 ***********/\nid objc_autoreleaseReturnValue(id obj)\n{\n#if SUPPORT_RETURN_AUTORELEASE\n    assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);\n    if (callerAcceptsFastAutorelease(__builtin_return_address(0))) {\n        _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);\n        return obj;\n    }\n#endif\n    return objc_autorelease(obj);\n}\n```\n\n通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。\n\n看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子\n\n```\n/************ ARC下编译器手动拷贝block ************/\n- (id)getBlockArray\n{\n    int val = 10;\n    return [[NSArray alloc] initWithObjects: \n                            ^{NSLog(@\"blk0:%d\", val);}, \n                            ^{NSLog(@\"blk1:%d\", val);}, nil];\n}\n```\n一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。\n\n关于 block 的拷贝操作可以用一张表总结下\n\n![](http://i4.piimg.com/567571/82a9a9d7492f431e.png)\n\nblock 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。\n\n```\nblock的多次拷贝：下面的例子在 ARC 下并不会产生内存泄露哦\n\n// block 多次拷贝源码\nblk = [[[[blk copy] copy] copy] copy]; \n// 翻译后的代码\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp; \n}\n{\n    blk_t tmp = [blk copy];\n    blk = tmp;\n}\n```\n\n## __block 变量的内存管理\n\n上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。\n\n- 当 block 从栈内存被拷贝到堆内存时，__block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 __block 变量已经没有影响了。\n\n![](http://i4.piimg.com/567571/c6c5e220ca09511e.png)\n\n- 当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时\n![](http://i4.piimg.com/567571/5e7b1f767a1526f8.png)\n\n- 当 block 被废弃时，__block 变量被释放\n![](http://i4.piimg.com/567571/f6c64412dfaed0f4.png)\n\n- __forwarding \n\n前文已经说过，当 block 从栈被拷贝到堆时，__forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 __forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 __forwarding 指针指向堆上结构体。后面如果要想使用 __block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。\n```\n/*************** __forwarding 的作用 ***************/\n//猜猜下面代码的打印结果？\n{\n    __block int val = 0;\n    void (^blk)(void) = [^{++val;} copy];\n    ++val;\n    blk();\n    NSLog(@\"%d\", val);\n}\n```\n一定有很多人会猜 1，其实打印 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 __forwarding 也会指向堆上的 __block 变量的结构体。\n\n上面的代码中 ^{++val;} 和 ++val; 都会被转换成 ++(val.__forwarding->val);，堆上的 val 被加了两次，最后打印堆上的 val 为 2。\n\n![](http://i4.piimg.com/567571/ae21fcf6a92ab9ee.png)","slug":"2016/转-block进阶2-block和变量内存管理","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4po00059saua00ez5awk","content":"<p>了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。本文将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。<br><a id=\"more\"></a><br>上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作</p>\n<blockquote>\n<ul>\n<li>全局变量</li>\n<li>全局静态变量</li>\n<li>静态变量</li>\n</ul>\n</blockquote>\n<p>全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？</p>\n<p>Apple 早就为我们准备了这么一个东西 —— “__block”</p>\n<h2 id=\"block-说明符\"><a href=\"#block-说明符\" class=\"headerlink\" title=\"__block 说明符\"></a>__block 说明符</h2><p>按照惯例，重写一小段代码看看 __block 的真身<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 __block 的源码 *************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    __block int intValue = 0;</div><div class=\"line\">    void (^blk)(void) = ^&#123;</div><div class=\"line\">        intValue = 1;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 clang 翻译后如下 *************/</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __Block_byref_intValue_0</div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_intValue_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int intValue;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __Block_byref_intValue_0 *intValue; // by ref</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue-&gt;__forwarding)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    __Block_byref_intValue_0 *intValue = __cself-&gt;intValue; // bound by ref</div><div class=\"line\">    (intValue-&gt;__forwarding-&gt;intValue) = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign((void*)&amp;dst-&gt;intValue, (void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose((void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123;  0, </div><div class=\"line\">                                sizeof(struct __main_block_impl_0), </div><div class=\"line\">                                __main_block_copy_0, </div><div class=\"line\">                                __main_block_dispose_0</div><div class=\"line\">                             &#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \\</div><div class=\"line\">    intValue = </div><div class=\"line\">    &#123;</div><div class=\"line\">        (void*)0,</div><div class=\"line\">        (__Block_byref_intValue_0 *)&amp;intValue, </div><div class=\"line\">        0, </div><div class=\"line\">        sizeof(__Block_byref_intValue_0), </div><div class=\"line\">        0</div><div class=\"line\">    &#125;;</div><div class=\"line\">    void (*blk)(void) = (void (*)()) &amp;__main_block_impl_0   \\</div><div class=\"line\">                (</div><div class=\"line\">                    (void *)__main_block_func_0,            \\</div><div class=\"line\">                    &amp;__main_block_desc_0_DATA,              \\</div><div class=\"line\">                    (__Block_byref_intValue_0 *)&amp;intValue,  \\</div><div class=\"line\">                    570425344                               \\</div><div class=\"line\">                );</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了</p>\n<blockquote>\n<p>-<strong>Block_byref_intValue_0 结构体：用于封装 </strong>block 修饰的外部变量。</p>\n<ul>\n<li>_Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。</li>\n<li>_Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。</li>\n</ul>\n</blockquote>\n<p>OC源码中的 <strong>block intValue 翻译后变成了 </strong>Block_byref_intValue_0 结构体指针变量 intValue，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。除此之外，整体的执行流程与不加 <strong>block 基本一致，不再赘述。但 </strong>Block_byref_intValue_0 这个结构体需特别注意下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 存储 __block 外部变量的结构体</div><div class=\"line\">struct __Block_byref_intValue_0</div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa; // 对象指针</div><div class=\"line\">    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针</div><div class=\"line\">    int __flags; // 标志位变量</div><div class=\"line\">    int __size; // 结构体大小</div><div class=\"line\">    int intValue; // 外部变量</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><img src=\"http://i4.piimg.com/567571/edba9eda9e760d13.png\" alt=\"\"><br>在已有结构体指针指向 <code>__Block_byref_intValue_0</code> 时，结构体里面还多了个 __forwarding 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。</p>\n<h2 id=\"block-的内存管理\"><a href=\"#block-的内存管理\" class=\"headerlink\" title=\"block 的内存管理\"></a>block 的内存管理</h2><p>在前文中，已经提到了 block 的三种类型 <code>NSConcreteGlobalBlock</code>、<code>_NSConcreteStackBlock</code>、<code>_NSConcreteMallocBlock</code>，见名知意，可以看出三种 block 在内存中的分布<br><img src=\"http://i4.piimg.com/567571/ab4b00f9b39f146a.png\" alt=\"\"></p>\n<h3 id=\"NSConcreteGlobalBlock\"><a href=\"#NSConcreteGlobalBlock\" class=\"headerlink\" title=\"_NSConcreteGlobalBlock\"></a>_NSConcreteGlobalBlock</h3><blockquote>\n<ul>\n<li>1、当 block 字面量写在全局作用域时，即为 global block； </li>\n<li>2、当 block 字面量不获取任何外部变量时，即为 global block；</li>\n</ul>\n</blockquote>\n<p>除了上述描述的两种情况，其他形式创建的 block 均为 stack block。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block</div><div class=\"line\">typedef int (^blk_t)(int);</div><div class=\"line\">for (int rate = 0; rate &lt; 10; ++rate) </div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t blk = ^(int count)&#123;return rate * count;&#125;; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>_NSConcreteGlobalBlock 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。</p>\n<h3 id=\"NSConcreteStackBlock\"><a href=\"#NSConcreteStackBlock\" class=\"headerlink\" title=\"_NSConcreteStackBlock\"></a>_NSConcreteStackBlock</h3><p>_NSConcreteStackBlock 类型的 block 处于内存的栈区。global block 由于处在 data 段，可以通过指针安全访问，但 stack block 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。<br><img src=\"http://i4.piimg.com/567571/eb42780701d9dfdd.png\" alt=\"\"></p>\n<p>为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 _NSConcreteMallocBlock。</p>\n<h3 id=\"NSConcreteMallocBlock\"><a href=\"#NSConcreteMallocBlock\" class=\"headerlink\" title=\"_NSConcreteMallocBlock\"></a>_NSConcreteMallocBlock</h3><p>当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block<br><img src=\"http://i4.piimg.com/567571/a4cf5bfee64c0faf.png\" alt=\"\"><br>此时，堆上的 block 类型为 _NSConcreteMallocBlock，所以会将 _NSConcreteMallocBlock 写入 isa</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">impl.isa = &amp;_NSConcreteMallocBlock;</div></pre></td></tr></table></figure>\n<p>如果你细心的观察上面的转换后的代码，会发现访问结构体 <strong>Block_byref_intValue_0 内部的成员变量都是通过访问 </strong>forwarding 指针完成的。为了保证能正确访问栈上的 <strong>block 变量，进行 copy 操作时，会将栈上的 </strong>forwarding 指针指向了堆上的 block 结构体实例。</p>\n<h2 id=\"block-的自动拷贝和手动拷贝\"><a href=\"#block-的自动拷贝和手动拷贝\" class=\"headerlink\" title=\"block 的自动拷贝和手动拷贝\"></a>block 的自动拷贝和手动拷贝</h2><p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当</p>\n<blockquote>\n<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p>\n</blockquote>\n<p>但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p>\n<blockquote>\n<ul>\n<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li>\n</ul>\n</blockquote>\n<p>让我们看个 block 自动拷贝的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************ ARC下编译器自动拷贝block ************/</div><div class=\"line\">typedef int (^blk_t)(int);</div><div class=\"line\">blk_t func(int rate)</div><div class=\"line\">&#123;</div><div class=\"line\">    return ^(int count)&#123;return rate * count;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">blk_t func(int rate)</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</div><div class=\"line\">    tmp = objc_retainBlock(tmp);</div><div class=\"line\">    return objc_autoreleaseReturnValue(tmp); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>转换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。如果你看过runtime 库（点此下载） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*********** objc_retainBlock() 的实现 ***********/</div><div class=\"line\">id objc_retainBlock(id x) </div><div class=\"line\">&#123;</div><div class=\"line\">#if ARR_LOGGING</div><div class=\"line\">    objc_arr_log(&quot;objc_retain_block&quot;, x);</div><div class=\"line\">    ++CompilerGenerated.blockCopies;</div><div class=\"line\">#endif</div><div class=\"line\">    return (id)_Block_copy(x);</div><div class=\"line\">&#125;</div><div class=\"line\">// Create a heap based copy of a Block or simply add a reference to an existing one.</div><div class=\"line\">// This must be paired with Block_release to recover memory, even when running</div><div class=\"line\">// under Objective-C Garbage Collection.</div><div class=\"line\">BLOCK_EXPORT void *_Block_copy(const void *aBlock)</div><div class=\"line\">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    /*********** objc_autoreleaseReturnValue() 的实现 ***********/</div><div class=\"line\">id objc_autoreleaseReturnValue(id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">#if SUPPORT_RETURN_AUTORELEASE</div><div class=\"line\">    assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);</div><div class=\"line\">    if (callerAcceptsFastAutorelease(__builtin_return_address(0))) &#123;</div><div class=\"line\">        _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);</div><div class=\"line\">        return obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    return objc_autorelease(obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。</p>\n<p>看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************ ARC下编译器手动拷贝block ************/</div><div class=\"line\">- (id)getBlockArray</div><div class=\"line\">&#123;</div><div class=\"line\">    int val = 10;</div><div class=\"line\">    return [[NSArray alloc] initWithObjects: </div><div class=\"line\">                            ^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125;, </div><div class=\"line\">                            ^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125;, nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。</p>\n<p>关于 block 的拷贝操作可以用一张表总结下</p>\n<p><img src=\"http://i4.piimg.com/567571/82a9a9d7492f431e.png\" alt=\"\"></p>\n<p>block 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">block的多次拷贝：下面的例子在 ARC 下并不会产生内存泄露哦</div><div class=\"line\"></div><div class=\"line\">// block 多次拷贝源码</div><div class=\"line\">blk = [[[[blk copy] copy] copy] copy]; </div><div class=\"line\">// 翻译后的代码</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"block-变量的内存管理\"><a href=\"#block-变量的内存管理\" class=\"headerlink\" title=\"__block 变量的内存管理\"></a>__block 变量的内存管理</h2><p>上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。</p>\n<ul>\n<li>当 block 从栈内存被拷贝到堆内存时，<strong>block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 </strong>block 变量已经没有影响了。</li>\n</ul>\n<p><img src=\"http://i4.piimg.com/567571/c6c5e220ca09511e.png\" alt=\"\"></p>\n<ul>\n<li><p>当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时<br><img src=\"http://i4.piimg.com/567571/5e7b1f767a1526f8.png\" alt=\"\"></p>\n</li>\n<li><p>当 block 被废弃时，__block 变量被释放<br><img src=\"http://i4.piimg.com/567571/f6c64412dfaed0f4.png\" alt=\"\"></p>\n</li>\n<li><p>__forwarding </p>\n</li>\n</ul>\n<p>前文已经说过，当 block 从栈被拷贝到堆时，<strong>forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 </strong>forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 <strong>forwarding 指针指向堆上结构体。后面如果要想使用 </strong>block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*************** __forwarding 的作用 ***************/</div><div class=\"line\">//猜猜下面代码的打印结果？</div><div class=\"line\">&#123;</div><div class=\"line\">    __block int val = 0;</div><div class=\"line\">    void (^blk)(void) = [^&#123;++val;&#125; copy];</div><div class=\"line\">    ++val;</div><div class=\"line\">    blk();</div><div class=\"line\">    NSLog(@&quot;%d&quot;, val);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定有很多人会猜 1，其实打印 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 <strong>forwarding 也会指向堆上的 </strong>block 变量的结构体。</p>\n<p>上面的代码中 ^{++val;} 和 ++val; 都会被转换成 ++(val.__forwarding-&gt;val);，堆上的 val 被加了两次，最后打印堆上的 val 为 2。</p>\n<p><img src=\"http://i4.piimg.com/567571/ae21fcf6a92ab9ee.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。本文将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。<br>","more":"<br>上篇文章举了个例子，在 block 内获取了一个外部的局部变量，可以读取，但无法进行写入的修改操作。在 C 语言中有三种类型的变量，可在 block 内进行读写操作</p>\n<blockquote>\n<ul>\n<li>全局变量</li>\n<li>全局静态变量</li>\n<li>静态变量</li>\n</ul>\n</blockquote>\n<p>全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？</p>\n<p>Apple 早就为我们准备了这么一个东西 —— “__block”</p>\n<h2 id=\"block-说明符\"><a href=\"#block-说明符\" class=\"headerlink\" title=\"__block 说明符\"></a>__block 说明符</h2><p>按照惯例，重写一小段代码看看 __block 的真身<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 __block 的源码 *************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    __block int intValue = 0;</div><div class=\"line\">    void (^blk)(void) = ^&#123;</div><div class=\"line\">        intValue = 1;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************* 使用 clang 翻译后如下 *************/</div><div class=\"line\">struct __block_impl</div><div class=\"line\">&#123;</div><div class=\"line\">    void *isa;</div><div class=\"line\">    int Flags;</div><div class=\"line\">    int Reserved;</div><div class=\"line\">    void *FuncPtr;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __Block_byref_intValue_0</div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_intValue_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    int intValue;</div><div class=\"line\">&#125;;</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0* Desc;</div><div class=\"line\">    __Block_byref_intValue_0 *intValue; // by ref</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue-&gt;__forwarding)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock;</div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</div><div class=\"line\">&#123;</div><div class=\"line\">    __Block_byref_intValue_0 *intValue = __cself-&gt;intValue; // bound by ref</div><div class=\"line\">    (intValue-&gt;__forwarding-&gt;intValue) = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign((void*)&amp;dst-&gt;intValue, (void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose((void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</div><div class=\"line\">&#125;</div><div class=\"line\">static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    size_t reserved;</div><div class=\"line\">    size_t Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123;  0, </div><div class=\"line\">                                sizeof(struct __main_block_impl_0), </div><div class=\"line\">                                __main_block_copy_0, </div><div class=\"line\">                                __main_block_dispose_0</div><div class=\"line\">                             &#125;;</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    __attribute__((__blocks__(byref))) __Block_byref_intValue_0 \\</div><div class=\"line\">    intValue = </div><div class=\"line\">    &#123;</div><div class=\"line\">        (void*)0,</div><div class=\"line\">        (__Block_byref_intValue_0 *)&amp;intValue, </div><div class=\"line\">        0, </div><div class=\"line\">        sizeof(__Block_byref_intValue_0), </div><div class=\"line\">        0</div><div class=\"line\">    &#125;;</div><div class=\"line\">    void (*blk)(void) = (void (*)()) &amp;__main_block_impl_0   \\</div><div class=\"line\">                (</div><div class=\"line\">                    (void *)__main_block_func_0,            \\</div><div class=\"line\">                    &amp;__main_block_desc_0_DATA,              \\</div><div class=\"line\">                    (__Block_byref_intValue_0 *)&amp;intValue,  \\</div><div class=\"line\">                    570425344                               \\</div><div class=\"line\">                );</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在加了 __block 之后，代码量增加了不少，仔细查看，其实只是比原来多了</p>\n<blockquote>\n<p>-<strong>Block_byref_intValue_0 结构体：用于封装 </strong>block 修饰的外部变量。</p>\n<ul>\n<li>_Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。</li>\n<li>_Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。</li>\n</ul>\n</blockquote>\n<p>OC源码中的 <strong>block intValue 翻译后变成了 </strong>Block_byref_intValue_0 结构体指针变量 intValue，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。除此之外，整体的执行流程与不加 <strong>block 基本一致，不再赘述。但 </strong>Block_byref_intValue_0 这个结构体需特别注意下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 存储 __block 外部变量的结构体</div><div class=\"line\">struct __Block_byref_intValue_0</div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa; // 对象指针</div><div class=\"line\">    __Block_byref_intValue_0 *__forwarding; // 指向自己的指针</div><div class=\"line\">    int __flags; // 标志位变量</div><div class=\"line\">    int __size; // 结构体大小</div><div class=\"line\">    int intValue; // 外部变量</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><img src=\"http://i4.piimg.com/567571/edba9eda9e760d13.png\" alt=\"\"><br>在已有结构体指针指向 <code>__Block_byref_intValue_0</code> 时，结构体里面还多了个 __forwarding 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。</p>\n<h2 id=\"block-的内存管理\"><a href=\"#block-的内存管理\" class=\"headerlink\" title=\"block 的内存管理\"></a>block 的内存管理</h2><p>在前文中，已经提到了 block 的三种类型 <code>NSConcreteGlobalBlock</code>、<code>_NSConcreteStackBlock</code>、<code>_NSConcreteMallocBlock</code>，见名知意，可以看出三种 block 在内存中的分布<br><img src=\"http://i4.piimg.com/567571/ab4b00f9b39f146a.png\" alt=\"\"></p>\n<h3 id=\"NSConcreteGlobalBlock\"><a href=\"#NSConcreteGlobalBlock\" class=\"headerlink\" title=\"_NSConcreteGlobalBlock\"></a>_NSConcreteGlobalBlock</h3><blockquote>\n<ul>\n<li>1、当 block 字面量写在全局作用域时，即为 global block； </li>\n<li>2、当 block 字面量不获取任何外部变量时，即为 global block；</li>\n</ul>\n</blockquote>\n<p>除了上述描述的两种情况，其他形式创建的 block 均为 stack block。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block</div><div class=\"line\">typedef int (^blk_t)(int);</div><div class=\"line\">for (int rate = 0; rate &lt; 10; ++rate) </div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t blk = ^(int count)&#123;return rate * count;&#125;; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>_NSConcreteGlobalBlock 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。</p>\n<h3 id=\"NSConcreteStackBlock\"><a href=\"#NSConcreteStackBlock\" class=\"headerlink\" title=\"_NSConcreteStackBlock\"></a>_NSConcreteStackBlock</h3><p>_NSConcreteStackBlock 类型的 block 处于内存的栈区。global block 由于处在 data 段，可以通过指针安全访问，但 stack block 处在内存栈区，如果其变量作用域结束，这个 block 就被废弃，block 上的 __block 变量也同样会被废弃。<br><img src=\"http://i4.piimg.com/567571/eb42780701d9dfdd.png\" alt=\"\"></p>\n<p>为了解决这个问题，block 提供了 copy 的功能，将 block 和 __block 变量从栈拷贝到堆，就是下面要说的 _NSConcreteMallocBlock。</p>\n<h3 id=\"NSConcreteMallocBlock\"><a href=\"#NSConcreteMallocBlock\" class=\"headerlink\" title=\"_NSConcreteMallocBlock\"></a>_NSConcreteMallocBlock</h3><p>当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block<br><img src=\"http://i4.piimg.com/567571/a4cf5bfee64c0faf.png\" alt=\"\"><br>此时，堆上的 block 类型为 _NSConcreteMallocBlock，所以会将 _NSConcreteMallocBlock 写入 isa</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">impl.isa = &amp;_NSConcreteMallocBlock;</div></pre></td></tr></table></figure>\n<p>如果你细心的观察上面的转换后的代码，会发现访问结构体 <strong>Block_byref_intValue_0 内部的成员变量都是通过访问 </strong>forwarding 指针完成的。为了保证能正确访问栈上的 <strong>block 变量，进行 copy 操作时，会将栈上的 </strong>forwarding 指针指向了堆上的 block 结构体实例。</p>\n<h2 id=\"block-的自动拷贝和手动拷贝\"><a href=\"#block-的自动拷贝和手动拷贝\" class=\"headerlink\" title=\"block 的自动拷贝和手动拷贝\"></a>block 的自动拷贝和手动拷贝</h2><p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当</p>\n<blockquote>\n<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p>\n</blockquote>\n<p>但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p>\n<blockquote>\n<ul>\n<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;</li>\n</ul>\n</blockquote>\n<p>让我们看个 block 自动拷贝的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************ ARC下编译器自动拷贝block ************/</div><div class=\"line\">typedef int (^blk_t)(int);</div><div class=\"line\">blk_t func(int rate)</div><div class=\"line\">&#123;</div><div class=\"line\">    return ^(int count)&#123;return rate * count;&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">blk_t func(int rate)</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</div><div class=\"line\">    tmp = objc_retainBlock(tmp);</div><div class=\"line\">    return objc_autoreleaseReturnValue(tmp); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>转换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。如果你看过runtime 库（点此下载） ，在 runtime/objc-arr.mm 文件中就有这两个函数的实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*********** objc_retainBlock() 的实现 ***********/</div><div class=\"line\">id objc_retainBlock(id x) </div><div class=\"line\">&#123;</div><div class=\"line\">#if ARR_LOGGING</div><div class=\"line\">    objc_arr_log(&quot;objc_retain_block&quot;, x);</div><div class=\"line\">    ++CompilerGenerated.blockCopies;</div><div class=\"line\">#endif</div><div class=\"line\">    return (id)_Block_copy(x);</div><div class=\"line\">&#125;</div><div class=\"line\">// Create a heap based copy of a Block or simply add a reference to an existing one.</div><div class=\"line\">// This must be paired with Block_release to recover memory, even when running</div><div class=\"line\">// under Objective-C Garbage Collection.</div><div class=\"line\">BLOCK_EXPORT void *_Block_copy(const void *aBlock)</div><div class=\"line\">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</div></pre></td></tr></table></figure>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    /*********** objc_autoreleaseReturnValue() 的实现 ***********/</div><div class=\"line\">id objc_autoreleaseReturnValue(id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">#if SUPPORT_RETURN_AUTORELEASE</div><div class=\"line\">    assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);</div><div class=\"line\">    if (callerAcceptsFastAutorelease(__builtin_return_address(0))) &#123;</div><div class=\"line\">        _pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);</div><div class=\"line\">        return obj;</div><div class=\"line\">    &#125;</div><div class=\"line\">#endif</div><div class=\"line\">    return objc_autorelease(obj);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码和注释，意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。</p>\n<p>看完了 block 的自动拷贝，那么看看在 ARC 下需要手动拷贝 block 的例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">/************ ARC下编译器手动拷贝block ************/</div><div class=\"line\">- (id)getBlockArray</div><div class=\"line\">&#123;</div><div class=\"line\">    int val = 10;</div><div class=\"line\">    return [[NSArray alloc] initWithObjects: </div><div class=\"line\">                            ^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125;, </div><div class=\"line\">                            ^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125;, nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。</p>\n<p>关于 block 的拷贝操作可以用一张表总结下</p>\n<p><img src=\"http://i4.piimg.com/567571/82a9a9d7492f431e.png\" alt=\"\"></p>\n<p>block 拷贝的讲解就到此为止，有兴趣可以了解下 block 的多次拷贝。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">block的多次拷贝：下面的例子在 ARC 下并不会产生内存泄露哦</div><div class=\"line\"></div><div class=\"line\">// block 多次拷贝源码</div><div class=\"line\">blk = [[[[blk copy] copy] copy] copy]; </div><div class=\"line\">// 翻译后的代码</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp; </div><div class=\"line\">&#125;</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t tmp = [blk copy];</div><div class=\"line\">    blk = tmp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"block-变量的内存管理\"><a href=\"#block-变量的内存管理\" class=\"headerlink\" title=\"__block 变量的内存管理\"></a>__block 变量的内存管理</h2><p>上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。</p>\n<ul>\n<li>当 block 从栈内存被拷贝到堆内存时，<strong>block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 </strong>block 变量已经没有影响了。</li>\n</ul>\n<p><img src=\"http://i4.piimg.com/567571/c6c5e220ca09511e.png\" alt=\"\"></p>\n<ul>\n<li><p>当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时<br><img src=\"http://i4.piimg.com/567571/5e7b1f767a1526f8.png\" alt=\"\"></p>\n</li>\n<li><p>当 block 被废弃时，__block 变量被释放<br><img src=\"http://i4.piimg.com/567571/f6c64412dfaed0f4.png\" alt=\"\"></p>\n</li>\n<li><p>__forwarding </p>\n</li>\n</ul>\n<p>前文已经说过，当 block 从栈被拷贝到堆时，<strong>forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 </strong>forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 <strong>forwarding 指针指向堆上结构体。后面如果要想使用 </strong>block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*************** __forwarding 的作用 ***************/</div><div class=\"line\">//猜猜下面代码的打印结果？</div><div class=\"line\">&#123;</div><div class=\"line\">    __block int val = 0;</div><div class=\"line\">    void (^blk)(void) = [^&#123;++val;&#125; copy];</div><div class=\"line\">    ++val;</div><div class=\"line\">    blk();</div><div class=\"line\">    NSLog(@&quot;%d&quot;, val);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>一定有很多人会猜 1，其实打印 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 <strong>forwarding 也会指向堆上的 </strong>block 变量的结构体。</p>\n<p>上面的代码中 ^{++val;} 和 ++val; 都会被转换成 ++(val.__forwarding-&gt;val);，堆上的 val 被加了两次，最后打印堆上的 val 为 2。</p>\n<p><img src=\"http://i4.piimg.com/567571/ae21fcf6a92ab9ee.png\" alt=\"\"></p>"},{"title":"(转)block进阶3--block和对象的内存管理","date":"2016-06-25T06:16:13.000Z","_content":"原文链接<https://www.zybuluo.com/MicroCai/note/51116>\n在上一篇文章中，我们讲了很多关于 block 和基础变量的内存管理，接着我们聊聊 block 和对象的内存管理，如 block 经常会碰到的循环引用问题等等。\n\n获取对象\n<!--more-->\n照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的\n```\n/********************** capturing objects **********************/\ntypedef void (^blk_t)(id obj);\nblk_t blk;\n- (void)viewDidLoad\n{\n    [self captureObject];\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n}\n- (void)captureObject\n{\n    id array = [[NSMutableArray alloc] init];\n    blk = [^(id obj) {\n             [array addObject:obj];\n             NSLog(@\"array count = %ld\", [array count]);\n          } copy];\n}\n```\n翻译后的关键代码摘录如下\n\n```\n/* a struct for the Block and some functions */\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0 *Desc;\n    id __strong array;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array)\n    {\n        impl.isa = &_NSConcreteStackBlock; \n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)\n{\n    id __strong array = __cself->array;\n    [array addObject:obj];\n    NSLog(@\"array count = %ld\", [array count]);\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)\n{\n    _Block_object_assign(&dst->array, src->array, BLOCK_FIELD_IS_OBJECT);\n}\nstatic void __main_block_dispose_0(struct __main_block_impl_0 *src)\n{\n    _Block_object_dispose(src->array, BLOCK_FIELD_IS_OBJECT);\n}\nstruct static struct __main_block_desc_0\n{\n    unsigned long reserved;\n    unsigned long Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = {  0,\n                                sizeof(struct __main_block_impl_0),\n                                __main_block_copy_0,\n                                __main_block_dispose_0\n                             };\n/* Block literal and executing the Block */\nblk_t blk;\n{\n    id __strong array = [[NSMutableArray alloc] init];\n    blk = &__main_block_impl_0(__main_block_func_0, \n                               &__main_block_desc_0_DATA, \n                               array, \n                               0x22000000);\n    blk = [blk copy];\n}\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]);\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]);\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]); \n```\n\n在本例中，当变量变量作用域结束时，array 被废弃，强引用失效，NSMutableArray 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了 copy 方法，在 _Block_object_assign 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。\n\n总结代码可正常运行的原因关键就在于 block 通过调用 copy 方法，持有了 __strong 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。\n\n在以下情形中， block 会从栈拷贝到堆：\n\n- 当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；\n- 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;\n其实后三种情况在上篇文章block的自动拷贝已经做过说明\n除此之外，都需要手动调用。\n\n>延伸阅读：Objective-C 结构体中的 __strong 成员变量\n\n>注意到 __main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 __strong 关键字修饰的变量。\n\n>通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 __strong、__weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。\n\n## __block 变量和对象\n\n__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。\n\n```\n/******* block 修饰对象 *******/\n__block id obj = [[NSObject alloc] init];\n```\n\nARC 下，对象所有权修饰符默认为 __strong，即\n\n```\n__block id __strong obj = [[NSObject alloc] init];\n/******* block 修饰对象转换后的代码 *******/\n/* struct for __block variable */\nstruct __Block_byref_obj_0 \n{\n    void *__isa;\n    __Block_byref_obj_0 *__forwarding;\n    int __flags;\n    int __size;\n    void (*__Block_byref_id_object_copy)(void*, void*);\n    void (*__Block_byref_id_object_dispose)(void*); \n    __strong id obj;\n};\nstatic void __Block_byref_id_object_copy_131(void *dst, void *src) \n{\n    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);\n}\nstatic void __Block_byref_id_object_dispose_131(void *src) \n{\n    _Block_object_dispose(*(void * *) ((char*)src + 40), 131);\n}\n/* __block variable declaration */\n__Block_byref_obj_0 obj = { 0,\n                            &obj,\n                            0x2000000, \n                            sizeof(__Block_byref_obj_0), \n                            __Block_byref_id_object_copy_131, \n                            __Block_byref_id_object_dispose_131,\n                            [[NSObject alloc] init]\n                           };\n```\n\n__block id __strong obj 的作用和 id __strong obj 的作用十分类似。当 __block id __strong obj 从栈上拷贝到堆上时，_Block_object_assign 被调用，block 持有 obj；当 __block id __strong obj 从堆上被废弃时，_Block_object_dispose 被调用用以释放此对象，block 引用消失。\n\n所以，只要是堆上的 __strong 修饰符修饰的 __block 对象类型的变量，和 block 内获取到的 __strong 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。\n\n如果上面的 __strong 换成 __weak，结果会怎样呢？\n\n```\n/********************** capturing __weak objects **********************/\ntypedef void (^blk_t)(id obj);\nblk_t blk;\n- (void)viewDidLoad\n{\n    [self captureObject];\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n}\n- (void)captureObject\n{\n    id array = [[NSMutableArray alloc] init]; \n    id __weak array2 = array;\n    blk = [^(id obj) {\n             [array2 addObject:obj];\n             NSLog(@\"array2 count = %ld\", [array2 count]);\n          } copy];\n}\n结果是：\n\narray2 count = 0\narray2 count = 0\narray2 count = 0\n```\n原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。\n\n如果 __weak 再改成 __unsafe_unretained 呢？__unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。\n\n如果 __unsafe_unretained 再改成 __autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写\n\n`__block id __autoreleasing obj = [[NSObject alloc] init];`\n编译器就会报下面的错误，意思就是 __block 和 __autoreleasing 不能同时使用。\n\n```\nerror: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init];\n```\n## 循环引用\n\n千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！\n\n愉快的代码时间到\n\n```\n// ARC enabled\n/************** MyObject Class **************/\ntypedef void (^blk_t)(void);\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n} \n@end\n@implementation MyObject\n- (id)init\n{\n    self = [super init];\n    blk_ = ^{NSLog(@\"self = %@\", self);}; \n    return self;\n}\n- (void)dealloc\n{\n    NSLog(@\"dealloc\");\n} \n@end\n/************** main function **************/\nint main()\n{\n    id myObject = [[MyObject alloc] init]; \n    NSLog(@\"%@\", myObject);\n    return 0;\n}\n```\n\n由于 self 是 __strong 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 block，就造成了传说中的循环引用。\n\n![](http://i1.piimg.com/567571/e54d448697dabc19.png)\n\n \n由于循环引用的存在，造成在 main() 函数结束时，内存仍然无法释放，即内存泄露。编译器也会给出警告信息\n```\nwarning: capturing 'self' strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles] \nblk_ = ^{NSLog(@\"self = %@\", self);};\n\nnote: Block will be retained by an object strongly retained by the captured object \nblk_ = ^{NSLog(@\"self = %@\", self);};\n```\n为了避免这种情况发生，可以在变量声明时用 __weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 __unsafe_unretained 代替。\nƒ\n```\n- (id)init\n{\n    self = [super init];\n    id __weak tmp = self;\n    blk_ = ^{NSLog(@\"self = %@\", tmp);}; \n    return self;\n}\n\n``` \n\n![](http://i1.piimg.com/567571/b1057b9ff703d7cd.png)\n\n再看一个例子\n\n```\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n    id obj_; \n}\n@end\n@implementation MyObject \n- (id)init\n{\n    self = [super init];\n    blk_ = ^{ NSLog(@\"obj_ = %@\", obj_); }; \n    return self;\n}\n...\n...\n@end\n```\n上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self->obj_，所以上面的代码就会变成\n\n`blk_ = ^{ NSLog(@\"obj_ = %@\", self->obj_); };`\n所以这个例子只要用 __weak，在 init 方法里面加一行即可\n\n`id __weak obj = obj_;`\n破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下\n\n```\ntypedef void (^blk_t)(void);\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n} \n@end\n@implementation MyObject \n- (id)init\n{\n    self = [super init]; \n    __block id tmp = self;\n    blk_ = ^{ \n                NSLog(@\"self = %@\", tmp);\n                tmp = nil; \n            };\n    return self;\n}\n- (void)execBlock\n{\n    blk_();\n}\n- (void)dealloc\n{\n    NSLog(@\"dealloc\");\n} \n@end\nint main()\n{\n    id object = [[MyObject alloc] init]; \n    [object execBlock];\n    return 0;\n}\n```\n\n这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。\n\n还有个值得一提的时，在 MRC 下，使用 __block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。\n\n>尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。\n循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。\n\n## Copy 和 Release\n\n在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放\n\n```\nvoid (^blk_on_heap)(void) = [blk_on_stack copy]; \n[blk_on_heap release];\n```\n\n拷贝到堆后，就可以 用 retain 持有 block\n\n```\n[blk_on_heap retain];\n```\n然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。\n\nblock 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法\n\n```\nvoid (^blk_on_heap)(void) = Block_copy(blk_on_stack);\nBlock_release(blk_on_heap);\n```\nBlock_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。\n\n最后这里有一篇总结 block 的文章的很不错，推荐大家看看：<http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/>\n","source":"_posts/2016/转-block进阶3-block和对象的内存管理.md","raw":"---\ntitle: (转)block进阶3--block和对象的内存管理\ndate: 2016-06-25 14:16:13\ntags:\n- iOS进阶\ncategories: iOS\n---\n原文链接<https://www.zybuluo.com/MicroCai/note/51116>\n在上一篇文章中，我们讲了很多关于 block 和基础变量的内存管理，接着我们聊聊 block 和对象的内存管理，如 block 经常会碰到的循环引用问题等等。\n\n获取对象\n<!--more-->\n照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的\n```\n/********************** capturing objects **********************/\ntypedef void (^blk_t)(id obj);\nblk_t blk;\n- (void)viewDidLoad\n{\n    [self captureObject];\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n}\n- (void)captureObject\n{\n    id array = [[NSMutableArray alloc] init];\n    blk = [^(id obj) {\n             [array addObject:obj];\n             NSLog(@\"array count = %ld\", [array count]);\n          } copy];\n}\n```\n翻译后的关键代码摘录如下\n\n```\n/* a struct for the Block and some functions */\nstruct __main_block_impl_0\n{\n    struct __block_impl impl;\n    struct __main_block_desc_0 *Desc;\n    id __strong array;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array)\n    {\n        impl.isa = &_NSConcreteStackBlock; \n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)\n{\n    id __strong array = __cself->array;\n    [array addObject:obj];\n    NSLog(@\"array count = %ld\", [array count]);\n}\nstatic void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)\n{\n    _Block_object_assign(&dst->array, src->array, BLOCK_FIELD_IS_OBJECT);\n}\nstatic void __main_block_dispose_0(struct __main_block_impl_0 *src)\n{\n    _Block_object_dispose(src->array, BLOCK_FIELD_IS_OBJECT);\n}\nstruct static struct __main_block_desc_0\n{\n    unsigned long reserved;\n    unsigned long Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = {  0,\n                                sizeof(struct __main_block_impl_0),\n                                __main_block_copy_0,\n                                __main_block_dispose_0\n                             };\n/* Block literal and executing the Block */\nblk_t blk;\n{\n    id __strong array = [[NSMutableArray alloc] init];\n    blk = &__main_block_impl_0(__main_block_func_0, \n                               &__main_block_desc_0_DATA, \n                               array, \n                               0x22000000);\n    blk = [blk copy];\n}\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]);\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]);\n(*blk->impl.FuncPtr)(blk, [[NSObject alloc] init]); \n```\n\n在本例中，当变量变量作用域结束时，array 被废弃，强引用失效，NSMutableArray 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了 copy 方法，在 _Block_object_assign 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。\n\n总结代码可正常运行的原因关键就在于 block 通过调用 copy 方法，持有了 __strong 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。\n\n在以下情形中， block 会从栈拷贝到堆：\n\n- 当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；\n- 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；\n- 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;\n其实后三种情况在上篇文章block的自动拷贝已经做过说明\n除此之外，都需要手动调用。\n\n>延伸阅读：Objective-C 结构体中的 __strong 成员变量\n\n>注意到 __main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 __strong 关键字修饰的变量。\n\n>通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 __strong、__weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。\n\n## __block 变量和对象\n\n__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。\n\n```\n/******* block 修饰对象 *******/\n__block id obj = [[NSObject alloc] init];\n```\n\nARC 下，对象所有权修饰符默认为 __strong，即\n\n```\n__block id __strong obj = [[NSObject alloc] init];\n/******* block 修饰对象转换后的代码 *******/\n/* struct for __block variable */\nstruct __Block_byref_obj_0 \n{\n    void *__isa;\n    __Block_byref_obj_0 *__forwarding;\n    int __flags;\n    int __size;\n    void (*__Block_byref_id_object_copy)(void*, void*);\n    void (*__Block_byref_id_object_dispose)(void*); \n    __strong id obj;\n};\nstatic void __Block_byref_id_object_copy_131(void *dst, void *src) \n{\n    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);\n}\nstatic void __Block_byref_id_object_dispose_131(void *src) \n{\n    _Block_object_dispose(*(void * *) ((char*)src + 40), 131);\n}\n/* __block variable declaration */\n__Block_byref_obj_0 obj = { 0,\n                            &obj,\n                            0x2000000, \n                            sizeof(__Block_byref_obj_0), \n                            __Block_byref_id_object_copy_131, \n                            __Block_byref_id_object_dispose_131,\n                            [[NSObject alloc] init]\n                           };\n```\n\n__block id __strong obj 的作用和 id __strong obj 的作用十分类似。当 __block id __strong obj 从栈上拷贝到堆上时，_Block_object_assign 被调用，block 持有 obj；当 __block id __strong obj 从堆上被废弃时，_Block_object_dispose 被调用用以释放此对象，block 引用消失。\n\n所以，只要是堆上的 __strong 修饰符修饰的 __block 对象类型的变量，和 block 内获取到的 __strong 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。\n\n如果上面的 __strong 换成 __weak，结果会怎样呢？\n\n```\n/********************** capturing __weak objects **********************/\ntypedef void (^blk_t)(id obj);\nblk_t blk;\n- (void)viewDidLoad\n{\n    [self captureObject];\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n    blk([[NSObject alloc] init]);\n}\n- (void)captureObject\n{\n    id array = [[NSMutableArray alloc] init]; \n    id __weak array2 = array;\n    blk = [^(id obj) {\n             [array2 addObject:obj];\n             NSLog(@\"array2 count = %ld\", [array2 count]);\n          } copy];\n}\n结果是：\n\narray2 count = 0\narray2 count = 0\narray2 count = 0\n```\n原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。\n\n如果 __weak 再改成 __unsafe_unretained 呢？__unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。\n\n如果 __unsafe_unretained 再改成 __autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写\n\n`__block id __autoreleasing obj = [[NSObject alloc] init];`\n编译器就会报下面的错误，意思就是 __block 和 __autoreleasing 不能同时使用。\n\n```\nerror: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init];\n```\n## 循环引用\n\n千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！\n\n愉快的代码时间到\n\n```\n// ARC enabled\n/************** MyObject Class **************/\ntypedef void (^blk_t)(void);\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n} \n@end\n@implementation MyObject\n- (id)init\n{\n    self = [super init];\n    blk_ = ^{NSLog(@\"self = %@\", self);}; \n    return self;\n}\n- (void)dealloc\n{\n    NSLog(@\"dealloc\");\n} \n@end\n/************** main function **************/\nint main()\n{\n    id myObject = [[MyObject alloc] init]; \n    NSLog(@\"%@\", myObject);\n    return 0;\n}\n```\n\n由于 self 是 __strong 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 block，就造成了传说中的循环引用。\n\n![](http://i1.piimg.com/567571/e54d448697dabc19.png)\n\n \n由于循环引用的存在，造成在 main() 函数结束时，内存仍然无法释放，即内存泄露。编译器也会给出警告信息\n```\nwarning: capturing 'self' strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles] \nblk_ = ^{NSLog(@\"self = %@\", self);};\n\nnote: Block will be retained by an object strongly retained by the captured object \nblk_ = ^{NSLog(@\"self = %@\", self);};\n```\n为了避免这种情况发生，可以在变量声明时用 __weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 __unsafe_unretained 代替。\nƒ\n```\n- (id)init\n{\n    self = [super init];\n    id __weak tmp = self;\n    blk_ = ^{NSLog(@\"self = %@\", tmp);}; \n    return self;\n}\n\n``` \n\n![](http://i1.piimg.com/567571/b1057b9ff703d7cd.png)\n\n再看一个例子\n\n```\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n    id obj_; \n}\n@end\n@implementation MyObject \n- (id)init\n{\n    self = [super init];\n    blk_ = ^{ NSLog(@\"obj_ = %@\", obj_); }; \n    return self;\n}\n...\n...\n@end\n```\n上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self->obj_，所以上面的代码就会变成\n\n`blk_ = ^{ NSLog(@\"obj_ = %@\", self->obj_); };`\n所以这个例子只要用 __weak，在 init 方法里面加一行即可\n\n`id __weak obj = obj_;`\n破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下\n\n```\ntypedef void (^blk_t)(void);\n@interface MyObject : NSObject\n{\n    blk_t blk_;\n} \n@end\n@implementation MyObject \n- (id)init\n{\n    self = [super init]; \n    __block id tmp = self;\n    blk_ = ^{ \n                NSLog(@\"self = %@\", tmp);\n                tmp = nil; \n            };\n    return self;\n}\n- (void)execBlock\n{\n    blk_();\n}\n- (void)dealloc\n{\n    NSLog(@\"dealloc\");\n} \n@end\nint main()\n{\n    id object = [[MyObject alloc] init]; \n    [object execBlock];\n    return 0;\n}\n```\n\n这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。\n\n还有个值得一提的时，在 MRC 下，使用 __block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。\n\n>尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。\n循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。\n\n## Copy 和 Release\n\n在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放\n\n```\nvoid (^blk_on_heap)(void) = [blk_on_stack copy]; \n[blk_on_heap release];\n```\n\n拷贝到堆后，就可以 用 retain 持有 block\n\n```\n[blk_on_heap retain];\n```\n然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。\n\nblock 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法\n\n```\nvoid (^blk_on_heap)(void) = Block_copy(blk_on_stack);\nBlock_release(blk_on_heap);\n```\nBlock_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。\n\n最后这里有一篇总结 block 的文章的很不错，推荐大家看看：<http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/>\n","slug":"2016/转-block进阶3-block和对象的内存管理","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4po1005csauao4g9tzxt","content":"<p>原文链接<a href=\"https://www.zybuluo.com/MicroCai/note/51116\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/MicroCai/note/51116</a><br>在上一篇文章中，我们讲了很多关于 block 和基础变量的内存管理，接着我们聊聊 block 和对象的内存管理，如 block 经常会碰到的循环引用问题等等。</p>\n<p>获取对象<br><a id=\"more\"></a><br>照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************** capturing objects **********************/</div><div class=\"line\">typedef void (^blk_t)(id obj);</div><div class=\"line\">blk_t blk;</div><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [self captureObject];</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)captureObject</div><div class=\"line\">&#123;</div><div class=\"line\">    id array = [[NSMutableArray alloc] init];</div><div class=\"line\">    blk = [^(id obj) &#123;</div><div class=\"line\">             [array addObject:obj];</div><div class=\"line\">             NSLog(@&quot;array count = %ld&quot;, [array count]);</div><div class=\"line\">          &#125; copy];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>翻译后的关键代码摘录如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* a struct for the Block and some functions */</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0 *Desc;</div><div class=\"line\">    id __strong array;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock; </div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">    id __strong array = __cself-&gt;array;</div><div class=\"line\">    [array addObject:obj];</div><div class=\"line\">    NSLog(@&quot;array count = %ld&quot;, [array count]);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);</div><div class=\"line\">&#125;</div><div class=\"line\">struct static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned long reserved;</div><div class=\"line\">    unsigned long Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123;  0,</div><div class=\"line\">                                sizeof(struct __main_block_impl_0),</div><div class=\"line\">                                __main_block_copy_0,</div><div class=\"line\">                                __main_block_dispose_0</div><div class=\"line\">                             &#125;;</div><div class=\"line\">/* Block literal and executing the Block */</div><div class=\"line\">blk_t blk;</div><div class=\"line\">&#123;</div><div class=\"line\">    id __strong array = [[NSMutableArray alloc] init];</div><div class=\"line\">    blk = &amp;__main_block_impl_0(__main_block_func_0, </div><div class=\"line\">                               &amp;__main_block_desc_0_DATA, </div><div class=\"line\">                               array, </div><div class=\"line\">                               0x22000000);</div><div class=\"line\">    blk = [blk copy];</div><div class=\"line\">&#125;</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div></pre></td></tr></table></figure>\n<p>在本例中，当变量变量作用域结束时，array 被废弃，强引用失效，NSMutableArray 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了 copy 方法，在 _Block_object_assign 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。</p>\n<p>总结代码可正常运行的原因关键就在于 block 通过调用 copy 方法，持有了 __strong 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。</p>\n<p>在以下情形中， block 会从栈拷贝到堆：</p>\n<ul>\n<li>当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；</li>\n<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;<br>其实后三种情况在上篇文章block的自动拷贝已经做过说明<br>除此之外，都需要手动调用。</li>\n</ul>\n<blockquote>\n<p>延伸阅读：Objective-C 结构体中的 __strong 成员变量</p>\n<p>注意到 <strong>main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 </strong>strong 关键字修饰的变量。</p>\n<p>通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 <strong>strong、</strong>weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。</p>\n</blockquote>\n<h2 id=\"block-变量和对象\"><a href=\"#block-变量和对象\" class=\"headerlink\" title=\"__block 变量和对象\"></a>__block 变量和对象</h2><p>__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/******* block 修饰对象 *******/</div><div class=\"line\">__block id obj = [[NSObject alloc] init];</div></pre></td></tr></table></figure>\n<p>ARC 下，对象所有权修饰符默认为 __strong，即</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block id __strong obj = [[NSObject alloc] init];</div><div class=\"line\">/******* block 修饰对象转换后的代码 *******/</div><div class=\"line\">/* struct for __block variable */</div><div class=\"line\">struct __Block_byref_obj_0 </div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_obj_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    void (*__Block_byref_id_object_copy)(void*, void*);</div><div class=\"line\">    void (*__Block_byref_id_object_dispose)(void*); </div><div class=\"line\">    __strong id obj;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __Block_byref_id_object_copy_131(void *dst, void *src) </div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __Block_byref_id_object_dispose_131(void *src) </div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</div><div class=\"line\">&#125;</div><div class=\"line\">/* __block variable declaration */</div><div class=\"line\">__Block_byref_obj_0 obj = &#123; 0,</div><div class=\"line\">                            &amp;obj,</div><div class=\"line\">                            0x2000000, </div><div class=\"line\">                            sizeof(__Block_byref_obj_0), </div><div class=\"line\">                            __Block_byref_id_object_copy_131, </div><div class=\"line\">                            __Block_byref_id_object_dispose_131,</div><div class=\"line\">                            [[NSObject alloc] init]</div><div class=\"line\">                           &#125;;</div></pre></td></tr></table></figure>\n<p><strong>block id </strong>strong obj 的作用和 id <strong>strong obj 的作用十分类似。当 </strong>block id <strong>strong obj 从栈上拷贝到堆上时，_Block_object_assign 被调用，block 持有 obj；当 </strong>block id __strong obj 从堆上被废弃时，_Block_object_dispose 被调用用以释放此对象，block 引用消失。</p>\n<p>所以，只要是堆上的 <strong>strong 修饰符修饰的 </strong>block 对象类型的变量，和 block 内获取到的 __strong 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。</p>\n<p>如果上面的 <strong>strong 换成 </strong>weak，结果会怎样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************** capturing __weak objects **********************/</div><div class=\"line\">typedef void (^blk_t)(id obj);</div><div class=\"line\">blk_t blk;</div><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [self captureObject];</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)captureObject</div><div class=\"line\">&#123;</div><div class=\"line\">    id array = [[NSMutableArray alloc] init]; </div><div class=\"line\">    id __weak array2 = array;</div><div class=\"line\">    blk = [^(id obj) &#123;</div><div class=\"line\">             [array2 addObject:obj];</div><div class=\"line\">             NSLog(@&quot;array2 count = %ld&quot;, [array2 count]);</div><div class=\"line\">          &#125; copy];</div><div class=\"line\">&#125;</div><div class=\"line\">结果是：</div><div class=\"line\"></div><div class=\"line\">array2 count = 0</div><div class=\"line\">array2 count = 0</div><div class=\"line\">array2 count = 0</div></pre></td></tr></table></figure>\n<p>原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。</p>\n<p>如果 <strong>weak 再改成 </strong>unsafe_unretained 呢？__unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。</p>\n<p>如果 <strong>unsafe_unretained 再改成 </strong>autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写</p>\n<p><code>__block id __autoreleasing obj = [[NSObject alloc] init];</code><br>编译器就会报下面的错误，意思就是 <strong>block 和 </strong>autoreleasing 不能同时使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init];</div></pre></td></tr></table></figure>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><p>千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！</p>\n<p>愉快的代码时间到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ARC enabled</div><div class=\"line\">/************** MyObject Class **************/</div><div class=\"line\">typedef void (^blk_t)(void);</div><div class=\"line\">@interface MyObject : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t blk_;</div><div class=\"line\">&#125; </div><div class=\"line\">@end</div><div class=\"line\">@implementation MyObject</div><div class=\"line\">- (id)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;dealloc&quot;);</div><div class=\"line\">&#125; </div><div class=\"line\">@end</div><div class=\"line\">/************** main function **************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    id myObject = [[MyObject alloc] init]; </div><div class=\"line\">    NSLog(@&quot;%@&quot;, myObject);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于 self 是 __strong 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 block，就造成了传说中的循环引用。</p>\n<p><img src=\"http://i1.piimg.com/567571/e54d448697dabc19.png\" alt=\"\"></p>\n<p>由于循环引用的存在，造成在 main() 函数结束时，内存仍然无法释放，即内存泄露。编译器也会给出警告信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">warning: capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles] </div><div class=\"line\">blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;;</div><div class=\"line\"></div><div class=\"line\">note: Block will be retained by an object strongly retained by the captured object </div><div class=\"line\">blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;;</div></pre></td></tr></table></figure></p>\n<p>为了避免这种情况发生，可以在变量声明时用 <strong>weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 </strong>unsafe_unretained 代替。<br>ƒ<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    id __weak tmp = self;</div><div class=\"line\">    blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, tmp);&#125;; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">![](http://i1.piimg.com/567571/b1057b9ff703d7cd.png)</div><div class=\"line\"></div><div class=\"line\">再看一个例子</div></pre></td></tr></table></figure></p>\n<p>@interface MyObject : NSObject<br>{<br>    blk<em>t blk</em>;<br>    id obj_;<br>}<br>@end<br>@implementation MyObject </p>\n<ul>\n<li>(id)init<br>{<br>  self = [super init];<br>  blk<em> = ^{ NSLog(@”obj</em> = %@”, obj_); };<br>  return self;<br>}<br>…<br>…<br>@end<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self-&gt;obj_，所以上面的代码就会变成</div><div class=\"line\"></div><div class=\"line\">`blk_ = ^&#123; NSLog(@&quot;obj_ = %@&quot;, self-&gt;obj_); &#125;;`</div><div class=\"line\">所以这个例子只要用 __weak，在 init 方法里面加一行即可</div><div class=\"line\"></div><div class=\"line\">`id __weak obj = obj_;`</div><div class=\"line\">破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>typedef void (^blk_t)(void);<br>@interface MyObject : NSObject<br>{<br>    blk<em>t blk</em>;<br>}<br>@end<br>@implementation MyObject </p>\n<ul>\n<li>(id)init<br>{<br>  self = [super init];<br>  _<em>block id tmp = self;<br>  blk</em> = ^{ <pre><code>    NSLog(@&quot;self = %@&quot;, tmp);\n    tmp = nil; \n};\n</code></pre>  return self;<br>}</li>\n<li>(void)execBlock<br>{<br>  blk_();<br>}</li>\n<li>(void)dealloc<br>{<br>  NSLog(@”dealloc”);<br>}<br>@end<br>int main()<br>{<br>  id object = [[MyObject alloc] init];<br>  [object execBlock];<br>  return 0;<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。</div><div class=\"line\"></div><div class=\"line\">还有个值得一提的时，在 MRC 下，使用 __block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。</div><div class=\"line\"></div><div class=\"line\">&gt;尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。</div><div class=\"line\">循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。</div><div class=\"line\"></div><div class=\"line\">## Copy 和 Release</div><div class=\"line\"></div><div class=\"line\">在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>void (^blk_on_heap)(void) = [blk_on_stack copy];<br>[blk_on_heap release];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">拷贝到堆后，就可以 用 retain 持有 block</div></pre></td></tr></table></figure></p>\n<p>[blk_on_heap retain];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。</div><div class=\"line\"></div><div class=\"line\">block 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法</div></pre></td></tr></table></figure></p>\n<p>void (^blk_on_heap)(void) = Block_copy(blk_on_stack);<br>Block_release(blk_on_heap);<br>```<br>Block_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。</p>\n<p>最后这里有一篇总结 block 的文章的很不错，推荐大家看看：<a href=\"http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/\" target=\"_blank\" rel=\"external\">http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/</a></p>\n","site":{"data":{}},"excerpt":"<p>原文链接<a href=\"https://www.zybuluo.com/MicroCai/note/51116\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/MicroCai/note/51116</a><br>在上一篇文章中，我们讲了很多关于 block 和基础变量的内存管理，接着我们聊聊 block 和对象的内存管理，如 block 经常会碰到的循环引用问题等等。</p>\n<p>获取对象<br>","more":"<br>照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************** capturing objects **********************/</div><div class=\"line\">typedef void (^blk_t)(id obj);</div><div class=\"line\">blk_t blk;</div><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [self captureObject];</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)captureObject</div><div class=\"line\">&#123;</div><div class=\"line\">    id array = [[NSMutableArray alloc] init];</div><div class=\"line\">    blk = [^(id obj) &#123;</div><div class=\"line\">             [array addObject:obj];</div><div class=\"line\">             NSLog(@&quot;array count = %ld&quot;, [array count]);</div><div class=\"line\">          &#125; copy];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>翻译后的关键代码摘录如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* a struct for the Block and some functions */</div><div class=\"line\">struct __main_block_impl_0</div><div class=\"line\">&#123;</div><div class=\"line\">    struct __block_impl impl;</div><div class=\"line\">    struct __main_block_desc_0 *Desc;</div><div class=\"line\">    id __strong array;</div><div class=\"line\">    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array)</div><div class=\"line\">    &#123;</div><div class=\"line\">        impl.isa = &amp;_NSConcreteStackBlock; </div><div class=\"line\">        impl.Flags = flags;</div><div class=\"line\">        impl.FuncPtr = fp;</div><div class=\"line\">        Desc = desc;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)</div><div class=\"line\">&#123;</div><div class=\"line\">    id __strong array = __cself-&gt;array;</div><div class=\"line\">    [array addObject:obj];</div><div class=\"line\">    NSLog(@&quot;array count = %ld&quot;, [array count]);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);</div><div class=\"line\">&#125;</div><div class=\"line\">struct static struct __main_block_desc_0</div><div class=\"line\">&#123;</div><div class=\"line\">    unsigned long reserved;</div><div class=\"line\">    unsigned long Block_size;</div><div class=\"line\">    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class=\"line\">    void (*dispose)(struct __main_block_impl_0*);</div><div class=\"line\">&#125; __main_block_desc_0_DATA = &#123;  0,</div><div class=\"line\">                                sizeof(struct __main_block_impl_0),</div><div class=\"line\">                                __main_block_copy_0,</div><div class=\"line\">                                __main_block_dispose_0</div><div class=\"line\">                             &#125;;</div><div class=\"line\">/* Block literal and executing the Block */</div><div class=\"line\">blk_t blk;</div><div class=\"line\">&#123;</div><div class=\"line\">    id __strong array = [[NSMutableArray alloc] init];</div><div class=\"line\">    blk = &amp;__main_block_impl_0(__main_block_func_0, </div><div class=\"line\">                               &amp;__main_block_desc_0_DATA, </div><div class=\"line\">                               array, </div><div class=\"line\">                               0x22000000);</div><div class=\"line\">    blk = [blk copy];</div><div class=\"line\">&#125;</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div><div class=\"line\">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</div></pre></td></tr></table></figure>\n<p>在本例中，当变量变量作用域结束时，array 被废弃，强引用失效，NSMutableArray 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了 copy 方法，在 _Block_object_assign 中，将 array 赋值给 block 成员变量并持有。所以上面代码可以正常运行，打印出来的 array count 依次递增。</p>\n<p>总结代码可正常运行的原因关键就在于 block 通过调用 copy 方法，持有了 __strong 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。</p>\n<p>在以下情形中， block 会从栈拷贝到堆：</p>\n<ul>\n<li>当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；</li>\n<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>\n<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;<br>其实后三种情况在上篇文章block的自动拷贝已经做过说明<br>除此之外，都需要手动调用。</li>\n</ul>\n<blockquote>\n<p>延伸阅读：Objective-C 结构体中的 __strong 成员变量</p>\n<p>注意到 <strong>main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 </strong>strong 关键字修饰的变量。</p>\n<p>通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 <strong>strong、</strong>weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。</p>\n</blockquote>\n<h2 id=\"block-变量和对象\"><a href=\"#block-变量和对象\" class=\"headerlink\" title=\"__block 变量和对象\"></a>__block 变量和对象</h2><p>__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">/******* block 修饰对象 *******/</div><div class=\"line\">__block id obj = [[NSObject alloc] init];</div></pre></td></tr></table></figure>\n<p>ARC 下，对象所有权修饰符默认为 __strong，即</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">__block id __strong obj = [[NSObject alloc] init];</div><div class=\"line\">/******* block 修饰对象转换后的代码 *******/</div><div class=\"line\">/* struct for __block variable */</div><div class=\"line\">struct __Block_byref_obj_0 </div><div class=\"line\">&#123;</div><div class=\"line\">    void *__isa;</div><div class=\"line\">    __Block_byref_obj_0 *__forwarding;</div><div class=\"line\">    int __flags;</div><div class=\"line\">    int __size;</div><div class=\"line\">    void (*__Block_byref_id_object_copy)(void*, void*);</div><div class=\"line\">    void (*__Block_byref_id_object_dispose)(void*); </div><div class=\"line\">    __strong id obj;</div><div class=\"line\">&#125;;</div><div class=\"line\">static void __Block_byref_id_object_copy_131(void *dst, void *src) </div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</div><div class=\"line\">&#125;</div><div class=\"line\">static void __Block_byref_id_object_dispose_131(void *src) </div><div class=\"line\">&#123;</div><div class=\"line\">    _Block_object_dispose(*(void * *) ((char*)src + 40), 131);</div><div class=\"line\">&#125;</div><div class=\"line\">/* __block variable declaration */</div><div class=\"line\">__Block_byref_obj_0 obj = &#123; 0,</div><div class=\"line\">                            &amp;obj,</div><div class=\"line\">                            0x2000000, </div><div class=\"line\">                            sizeof(__Block_byref_obj_0), </div><div class=\"line\">                            __Block_byref_id_object_copy_131, </div><div class=\"line\">                            __Block_byref_id_object_dispose_131,</div><div class=\"line\">                            [[NSObject alloc] init]</div><div class=\"line\">                           &#125;;</div></pre></td></tr></table></figure>\n<p><strong>block id </strong>strong obj 的作用和 id <strong>strong obj 的作用十分类似。当 </strong>block id <strong>strong obj 从栈上拷贝到堆上时，_Block_object_assign 被调用，block 持有 obj；当 </strong>block id __strong obj 从堆上被废弃时，_Block_object_dispose 被调用用以释放此对象，block 引用消失。</p>\n<p>所以，只要是堆上的 <strong>strong 修饰符修饰的 </strong>block 对象类型的变量，和 block 内获取到的 __strong 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。</p>\n<p>如果上面的 <strong>strong 换成 </strong>weak，结果会怎样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********************** capturing __weak objects **********************/</div><div class=\"line\">typedef void (^blk_t)(id obj);</div><div class=\"line\">blk_t blk;</div><div class=\"line\">- (void)viewDidLoad</div><div class=\"line\">&#123;</div><div class=\"line\">    [self captureObject];</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">    blk([[NSObject alloc] init]);</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)captureObject</div><div class=\"line\">&#123;</div><div class=\"line\">    id array = [[NSMutableArray alloc] init]; </div><div class=\"line\">    id __weak array2 = array;</div><div class=\"line\">    blk = [^(id obj) &#123;</div><div class=\"line\">             [array2 addObject:obj];</div><div class=\"line\">             NSLog(@&quot;array2 count = %ld&quot;, [array2 count]);</div><div class=\"line\">          &#125; copy];</div><div class=\"line\">&#125;</div><div class=\"line\">结果是：</div><div class=\"line\"></div><div class=\"line\">array2 count = 0</div><div class=\"line\">array2 count = 0</div><div class=\"line\">array2 count = 0</div></pre></td></tr></table></figure>\n<p>原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。</p>\n<p>如果 <strong>weak 再改成 </strong>unsafe_unretained 呢？__unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。</p>\n<p>如果 <strong>unsafe_unretained 再改成 </strong>autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写</p>\n<p><code>__block id __autoreleasing obj = [[NSObject alloc] init];</code><br>编译器就会报下面的错误，意思就是 <strong>block 和 </strong>autoreleasing 不能同时使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init];</div></pre></td></tr></table></figure>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><p>千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！</p>\n<p>愉快的代码时间到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ARC enabled</div><div class=\"line\">/************** MyObject Class **************/</div><div class=\"line\">typedef void (^blk_t)(void);</div><div class=\"line\">@interface MyObject : NSObject</div><div class=\"line\">&#123;</div><div class=\"line\">    blk_t blk_;</div><div class=\"line\">&#125; </div><div class=\"line\">@end</div><div class=\"line\">@implementation MyObject</div><div class=\"line\">- (id)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)dealloc</div><div class=\"line\">&#123;</div><div class=\"line\">    NSLog(@&quot;dealloc&quot;);</div><div class=\"line\">&#125; </div><div class=\"line\">@end</div><div class=\"line\">/************** main function **************/</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">    id myObject = [[MyObject alloc] init]; </div><div class=\"line\">    NSLog(@&quot;%@&quot;, myObject);</div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于 self 是 __strong 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 block，就造成了传说中的循环引用。</p>\n<p><img src=\"http://i1.piimg.com/567571/e54d448697dabc19.png\" alt=\"\"></p>\n<p>由于循环引用的存在，造成在 main() 函数结束时，内存仍然无法释放，即内存泄露。编译器也会给出警告信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">warning: capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle [-Warc-retain-cycles] </div><div class=\"line\">blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;;</div><div class=\"line\"></div><div class=\"line\">note: Block will be retained by an object strongly retained by the captured object </div><div class=\"line\">blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;;</div></pre></td></tr></table></figure></p>\n<p>为了避免这种情况发生，可以在变量声明时用 <strong>weak 修饰符修饰变量 self，让 block 不强引用 self，从而破除循环。iOS4 和 Snow Leopard 由于对 weak 的支持不够完全，可以用 </strong>unsafe_unretained 代替。<br>ƒ<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (id)init</div><div class=\"line\">&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    id __weak tmp = self;</div><div class=\"line\">    blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, tmp);&#125;; </div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\">![](http://i1.piimg.com/567571/b1057b9ff703d7cd.png)</div><div class=\"line\"></div><div class=\"line\">再看一个例子</div></pre></td></tr></table></figure></p>\n<p>@interface MyObject : NSObject<br>{<br>    blk<em>t blk</em>;<br>    id obj_;<br>}<br>@end<br>@implementation MyObject </p>\n<ul>\n<li>(id)init<br>{<br>  self = [super init];<br>  blk<em> = ^{ NSLog(@”obj</em> = %@”, obj_); };<br>  return self;<br>}<br>…<br>…<br>@end<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self-&gt;obj_，所以上面的代码就会变成</div><div class=\"line\"></div><div class=\"line\">`blk_ = ^&#123; NSLog(@&quot;obj_ = %@&quot;, self-&gt;obj_); &#125;;`</div><div class=\"line\">所以这个例子只要用 __weak，在 init 方法里面加一行即可</div><div class=\"line\"></div><div class=\"line\">`id __weak obj = obj_;`</div><div class=\"line\">破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>typedef void (^blk_t)(void);<br>@interface MyObject : NSObject<br>{<br>    blk<em>t blk</em>;<br>}<br>@end<br>@implementation MyObject </p>\n<ul>\n<li>(id)init<br>{<br>  self = [super init];<br>  _<em>block id tmp = self;<br>  blk</em> = ^{ <pre><code>    NSLog(@&quot;self = %@&quot;, tmp);\n    tmp = nil; \n};\n</code></pre>  return self;<br>}</li>\n<li>(void)execBlock<br>{<br>  blk_();<br>}</li>\n<li>(void)dealloc<br>{<br>  NSLog(@”dealloc”);<br>}<br>@end<br>int main()<br>{<br>  id object = [[MyObject alloc] init];<br>  [object execBlock];<br>  return 0;<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。</div><div class=\"line\"></div><div class=\"line\">还有个值得一提的时，在 MRC 下，使用 __block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。</div><div class=\"line\"></div><div class=\"line\">&gt;尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。</div><div class=\"line\">循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。</div><div class=\"line\"></div><div class=\"line\">## Copy 和 Release</div><div class=\"line\"></div><div class=\"line\">在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>void (^blk_on_heap)(void) = [blk_on_stack copy];<br>[blk_on_heap release];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">拷贝到堆后，就可以 用 retain 持有 block</div></pre></td></tr></table></figure></p>\n<p>[blk_on_heap retain];<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。</div><div class=\"line\"></div><div class=\"line\">block 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法</div></pre></td></tr></table></figure></p>\n<p>void (^blk_on_heap)(void) = Block_copy(blk_on_stack);<br>Block_release(blk_on_heap);<br>```<br>Block_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。</p>\n<p>最后这里有一篇总结 block 的文章的很不错，推荐大家看看：<a href=\"http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/\" target=\"_blank\" rel=\"external\">http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/</a></p>"},{"title":"block进阶4--block的逻辑理解","date":"2016-06-29T03:26:39.000Z","_content":"对为什么要像前边三篇文章分析的那样去实现block？\nblock是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题\n<!--more-->\n- 我怎么保证当我需要执行这段block代码的时候，block本身是存在的\n- 因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的\n\n我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数\n`block结构体--->方法----->从block结构体获取参数`\n\n## 保证block本身存在\n首先如果\n- block字面量写在全局区为global block\n- block字面量没有获取任何外部变量，为global block\n其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时__block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。\n为了解决这个问题，block提供了copy功能，将block和__block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。\n至于这个copy的功能应该说比较隐晦\n### copy的调用时机\n因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳：\n- 作为变量\n- 作为方法参数\n\n第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block\n```\nNSLog(@\"%@\", ^{NSLog(@\"%d\", c);});//结果是这是给stackblock\n```\n所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作\n```\nvoid(^myBlock)() = ^{NSLog(@\"%d\", c);};\n    \nNSLog(@\"%@\", myBlock);\n```\n这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字`__strong`，这个时候编译器会默认对block做copy操作的\n\n第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的\n```\n- (MyBlcok)getaBlock{\n    int a = 0;\n    return ^(){NSLog(@\"%d\", a);};\n}\n```\n打印该block发现是mallocblock\n\n\n## 保证参数可用\n\n### 全局变量\n我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。\n\n### 局部变量\n当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作\n\n### __block\n当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题\n\n","source":"_posts/2016/转-block进阶4-block的逻辑理解.md","raw":"---\ntitle: block进阶4--block的逻辑理解\ndate: 2016-06-29 11:26:39\ntags:\n- iOS进阶\ncategories: iOS\n---\n对为什么要像前边三篇文章分析的那样去实现block？\nblock是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题\n<!--more-->\n- 我怎么保证当我需要执行这段block代码的时候，block本身是存在的\n- 因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的\n\n我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数\n`block结构体--->方法----->从block结构体获取参数`\n\n## 保证block本身存在\n首先如果\n- block字面量写在全局区为global block\n- block字面量没有获取任何外部变量，为global block\n其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时__block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。\n为了解决这个问题，block提供了copy功能，将block和__block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。\n至于这个copy的功能应该说比较隐晦\n### copy的调用时机\n因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳：\n- 作为变量\n- 作为方法参数\n\n第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block\n```\nNSLog(@\"%@\", ^{NSLog(@\"%d\", c);});//结果是这是给stackblock\n```\n所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作\n```\nvoid(^myBlock)() = ^{NSLog(@\"%d\", c);};\n    \nNSLog(@\"%@\", myBlock);\n```\n这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字`__strong`，这个时候编译器会默认对block做copy操作的\n\n第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的\n```\n- (MyBlcok)getaBlock{\n    int a = 0;\n    return ^(){NSLog(@\"%d\", a);};\n}\n```\n打印该block发现是mallocblock\n\n\n## 保证参数可用\n\n### 全局变量\n我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。\n\n### 局部变量\n当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作\n\n### __block\n当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题\n\n","slug":"2016/转-block进阶4-block的逻辑理解","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4po3005fsaua2sx2a211","content":"<p>对为什么要像前边三篇文章分析的那样去实现block？<br>block是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题<br><a id=\"more\"></a></p>\n<ul>\n<li>我怎么保证当我需要执行这段block代码的时候，block本身是存在的</li>\n<li>因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的</li>\n</ul>\n<p>我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数<br><code>block结构体---&gt;方法-----&gt;从block结构体获取参数</code></p>\n<h2 id=\"保证block本身存在\"><a href=\"#保证block本身存在\" class=\"headerlink\" title=\"保证block本身存在\"></a>保证block本身存在</h2><p>首先如果</p>\n<ul>\n<li>block字面量写在全局区为global block</li>\n<li>block字面量没有获取任何外部变量，为global block<br>其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时<strong>block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。<br>为了解决这个问题，block提供了copy功能，将block和</strong>block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。<br>至于这个copy的功能应该说比较隐晦<h3 id=\"copy的调用时机\"><a href=\"#copy的调用时机\" class=\"headerlink\" title=\"copy的调用时机\"></a>copy的调用时机</h3>因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳：</li>\n<li>作为变量</li>\n<li>作为方法参数</li>\n</ul>\n<p>第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%d&quot;, c);&#125;);//结果是这是给stackblock</div></pre></td></tr></table></figure></p>\n<p>所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(^myBlock)() = ^&#123;NSLog(@&quot;%d&quot;, c);&#125;;</div><div class=\"line\">    </div><div class=\"line\">NSLog(@&quot;%@&quot;, myBlock);</div></pre></td></tr></table></figure></p>\n<p>这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字<code>__strong</code>，这个时候编译器会默认对block做copy操作的</p>\n<p>第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (MyBlcok)getaBlock&#123;</div><div class=\"line\">    int a = 0;</div><div class=\"line\">    return ^()&#123;NSLog(@&quot;%d&quot;, a);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印该block发现是mallocblock</p>\n<h2 id=\"保证参数可用\"><a href=\"#保证参数可用\" class=\"headerlink\" title=\"保证参数可用\"></a>保证参数可用</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作</p>\n<h3 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h3><p>当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题</p>\n","site":{"data":{}},"excerpt":"<p>对为什么要像前边三篇文章分析的那样去实现block？<br>block是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题<br>","more":"</p>\n<ul>\n<li>我怎么保证当我需要执行这段block代码的时候，block本身是存在的</li>\n<li>因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的</li>\n</ul>\n<p>我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数<br><code>block结构体---&gt;方法-----&gt;从block结构体获取参数</code></p>\n<h2 id=\"保证block本身存在\"><a href=\"#保证block本身存在\" class=\"headerlink\" title=\"保证block本身存在\"></a>保证block本身存在</h2><p>首先如果</p>\n<ul>\n<li>block字面量写在全局区为global block</li>\n<li>block字面量没有获取任何外部变量，为global block<br>其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时<strong>block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。<br>为了解决这个问题，block提供了copy功能，将block和</strong>block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。<br>至于这个copy的功能应该说比较隐晦<h3 id=\"copy的调用时机\"><a href=\"#copy的调用时机\" class=\"headerlink\" title=\"copy的调用时机\"></a>copy的调用时机</h3>因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳：</li>\n<li>作为变量</li>\n<li>作为方法参数</li>\n</ul>\n<p>第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSLog(@&quot;%@&quot;, ^&#123;NSLog(@&quot;%d&quot;, c);&#125;);//结果是这是给stackblock</div></pre></td></tr></table></figure></p>\n<p>所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">void(^myBlock)() = ^&#123;NSLog(@&quot;%d&quot;, c);&#125;;</div><div class=\"line\">    </div><div class=\"line\">NSLog(@&quot;%@&quot;, myBlock);</div></pre></td></tr></table></figure></p>\n<p>这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字<code>__strong</code>，这个时候编译器会默认对block做copy操作的</p>\n<p>第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (MyBlcok)getaBlock&#123;</div><div class=\"line\">    int a = 0;</div><div class=\"line\">    return ^()&#123;NSLog(@&quot;%d&quot;, a);&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>打印该block发现是mallocblock</p>\n<h2 id=\"保证参数可用\"><a href=\"#保证参数可用\" class=\"headerlink\" title=\"保证参数可用\"></a>保证参数可用</h2><h3 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h3><p>我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作</p>\n<h3 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h3><p>当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题</p>"},{"title":"(转)delegate/KVO/Notification选择","date":"2016-03-18T08:03:41.000Z","_content":"前面分别讲了delegate、notification和KVO的实现原理，以及实际使用步骤，我们心中不禁有个疑问，他们的功能比较类似，那么在实际的编程中，如何选择这些方式呢？\n<!--more-->\n在网上看到一个博客上详细的分析了三者之间的区别以及各自的优势，博文地址为<http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/>，因为博文是用英文写的，下面将其翻译成中文。\n\n在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信：\n\n1.委托delegation；\n\n2.通知中心Notification Center；\n\n3.键值观察key value observing，KVO\n\n因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。\n\n下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。\n\n>上面的三种模式是什么？\n\n三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。我们希望controllers以自己的方式存在，在controllers层面上不能与其他的controllers进行耦合。Controllers能够穿件其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。\n\n这三种模式给controllers(也可以是其他的对象）提供通信的方法。下面将描述如何在ios应用中使用这些模式，同样需要注意的他们在其他的地方也会用到，并且确实是存在。\n\n##  delegation\n\n当我们第一次编写ios应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。\n\ndelegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。\n\n### delegate的优势：\n\n>1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。\n\n2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误\n\n3.协议必须在controller的作用域范围内定义\n\n4.在一个应用中的控制流程是可跟踪的并且是可识别的；\n\n5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates\n\n6.没有第三方对象要求保持/监视通信过程。\n\n7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller\n\n缺点：\n\n1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义\n\n2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash\n\n3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。\n\n## notification\n\n在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。\n\n优势：\n\n>1.不需要编写多少代码，实现比较简单；\n\n2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\n3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\n缺点：\n\n1.在编译期不会检查通知是否能够被观察者正确的处理；\n\n2.在释放注册的对象时，需要在通知中心取消注册；\n\n3.在调试的时候应用的工作以及控制过程难跟踪；\n\n4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；\n\n5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\n6.通知发出后，controller不能从观察者获得任何的反馈信息。\n\n## KVO\n\nKVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。\n\n优点：\n\n>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；\n\n2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；\n\n3.能够提供观察的属性的最新值以及先前值；\n\n4.用key paths来观察属性，因此也可以观察嵌套对象；\n\n5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察\n\n缺点：\n\n1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；\n\n2.对属性重构将导致我们的观察代码不再可用；\n\n3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；\n\n4.当释放观察者时不需要移除观察者。\n\n## 总结：\n\n从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？\n\n根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。UserInfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。\n\n我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。\n\n当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。\n\n根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。\n","source":"_posts/2016/转-delegate-KVO-Notification选择.md","raw":"---\ntitle: (转)delegate/KVO/Notification选择\ndate: 2016-03-18 16:03:41\ntags:\n- iOS基础知识\ncategories: iOS\n---\n前面分别讲了delegate、notification和KVO的实现原理，以及实际使用步骤，我们心中不禁有个疑问，他们的功能比较类似，那么在实际的编程中，如何选择这些方式呢？\n<!--more-->\n在网上看到一个博客上详细的分析了三者之间的区别以及各自的优势，博文地址为<http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/>，因为博文是用英文写的，下面将其翻译成中文。\n\n在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信：\n\n1.委托delegation；\n\n2.通知中心Notification Center；\n\n3.键值观察key value observing，KVO\n\n因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。\n\n下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。\n\n>上面的三种模式是什么？\n\n三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。我们希望controllers以自己的方式存在，在controllers层面上不能与其他的controllers进行耦合。Controllers能够穿件其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。\n\n这三种模式给controllers(也可以是其他的对象）提供通信的方法。下面将描述如何在ios应用中使用这些模式，同样需要注意的他们在其他的地方也会用到，并且确实是存在。\n\n##  delegation\n\n当我们第一次编写ios应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。\n\ndelegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。\n\n### delegate的优势：\n\n>1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。\n\n2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误\n\n3.协议必须在controller的作用域范围内定义\n\n4.在一个应用中的控制流程是可跟踪的并且是可识别的；\n\n5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates\n\n6.没有第三方对象要求保持/监视通信过程。\n\n7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller\n\n缺点：\n\n1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义\n\n2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash\n\n3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。\n\n## notification\n\n在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。\n\n优势：\n\n>1.不需要编写多少代码，实现比较简单；\n\n2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\n3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\n缺点：\n\n1.在编译期不会检查通知是否能够被观察者正确的处理；\n\n2.在释放注册的对象时，需要在通知中心取消注册；\n\n3.在调试的时候应用的工作以及控制过程难跟踪；\n\n4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；\n\n5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\n6.通知发出后，controller不能从观察者获得任何的反馈信息。\n\n## KVO\n\nKVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。\n\n优点：\n\n>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；\n\n2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；\n\n3.能够提供观察的属性的最新值以及先前值；\n\n4.用key paths来观察属性，因此也可以观察嵌套对象；\n\n5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察\n\n缺点：\n\n1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；\n\n2.对属性重构将导致我们的观察代码不再可用；\n\n3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；\n\n4.当释放观察者时不需要移除观察者。\n\n## 总结：\n\n从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？\n\n根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。UserInfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。\n\n我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。\n\n当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。\n\n根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。\n","slug":"2016/转-delegate-KVO-Notification选择","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4po5005hsauahnsbu7za","content":"<p>前面分别讲了delegate、notification和KVO的实现原理，以及实际使用步骤，我们心中不禁有个疑问，他们的功能比较类似，那么在实际的编程中，如何选择这些方式呢？<br><a id=\"more\"></a><br>在网上看到一个博客上详细的分析了三者之间的区别以及各自的优势，博文地址为<a href=\"http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/\" target=\"_blank\" rel=\"external\">http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/</a>，因为博文是用英文写的，下面将其翻译成中文。</p>\n<p>在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信：</p>\n<p>1.委托delegation；</p>\n<p>2.通知中心Notification Center；</p>\n<p>3.键值观察key value observing，KVO</p>\n<p>因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。</p>\n<p>下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。</p>\n<blockquote>\n<p>上面的三种模式是什么？</p>\n</blockquote>\n<p>三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。我们希望controllers以自己的方式存在，在controllers层面上不能与其他的controllers进行耦合。Controllers能够穿件其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。</p>\n<p>这三种模式给controllers(也可以是其他的对象）提供通信的方法。下面将描述如何在ios应用中使用这些模式，同样需要注意的他们在其他的地方也会用到，并且确实是存在。</p>\n<h2 id=\"delegation\"><a href=\"#delegation\" class=\"headerlink\" title=\"delegation\"></a>delegation</h2><p>当我们第一次编写ios应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。</p>\n<p>delegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。</p>\n<h3 id=\"delegate的优势：\"><a href=\"#delegate的优势：\" class=\"headerlink\" title=\"delegate的优势：\"></a>delegate的优势：</h3><blockquote>\n<p>1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。</p>\n</blockquote>\n<p>2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误</p>\n<p>3.协议必须在controller的作用域范围内定义</p>\n<p>4.在一个应用中的控制流程是可跟踪的并且是可识别的；</p>\n<p>5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates</p>\n<p>6.没有第三方对象要求保持/监视通信过程。</p>\n<p>7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller</p>\n<p>缺点：</p>\n<p>1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义</p>\n<p>2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash</p>\n<p>3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。</p>\n<h2 id=\"notification\"><a href=\"#notification\" class=\"headerlink\" title=\"notification\"></a>notification</h2><p>在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。</p>\n<p>优势：</p>\n<blockquote>\n<p>1.不需要编写多少代码，实现比较简单；</p>\n</blockquote>\n<p>2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</p>\n<p>3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</p>\n<p>缺点：</p>\n<p>1.在编译期不会检查通知是否能够被观察者正确的处理；</p>\n<p>2.在释放注册的对象时，需要在通知中心取消注册；</p>\n<p>3.在调试的时候应用的工作以及控制过程难跟踪；</p>\n<p>4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；</p>\n<p>5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</p>\n<p>6.通知发出后，controller不能从观察者获得任何的反馈信息。</p>\n<h2 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h2><p>KVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。</p>\n<p>优点：</p>\n<blockquote>\n<p>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；</p>\n</blockquote>\n<p>2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；</p>\n<p>3.能够提供观察的属性的最新值以及先前值；</p>\n<p>4.用key paths来观察属性，因此也可以观察嵌套对象；</p>\n<p>5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察</p>\n<p>缺点：</p>\n<p>1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；</p>\n<p>2.对属性重构将导致我们的观察代码不再可用；</p>\n<p>3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；</p>\n<p>4.当释放观察者时不需要移除观察者。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？</p>\n<p>根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。UserInfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。</p>\n<p>我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。</p>\n<p>当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。</p>\n<p>根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。</p>\n","site":{"data":{}},"excerpt":"<p>前面分别讲了delegate、notification和KVO的实现原理，以及实际使用步骤，我们心中不禁有个疑问，他们的功能比较类似，那么在实际的编程中，如何选择这些方式呢？<br>","more":"<br>在网上看到一个博客上详细的分析了三者之间的区别以及各自的优势，博文地址为<a href=\"http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/\" target=\"_blank\" rel=\"external\">http://blog.shinetech.com/2011/06/14/delegation-notification-and-observation/</a>，因为博文是用英文写的，下面将其翻译成中文。</p>\n<p>在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。在IOS应用不断的出现三种模式来实现这种通信：</p>\n<p>1.委托delegation；</p>\n<p>2.通知中心Notification Center；</p>\n<p>3.键值观察key value observing，KVO</p>\n<p>因此，那为什么我们需要这些模式以及什么时候用它以及什么时候不用它。</p>\n<p>下面完全根据我的开发经验来讨论这三中模式。我将讨论为什么我觉得某种模式要好于另外一种模式以及为什么我觉得在一定的环境下某中模式比较好。我给出的这些原因并不是圣经，而仅仅是个人观点。如果你有什么不同的观点或者还可以进行补充的地方，可以联系我，一起讨论。</p>\n<blockquote>\n<p>上面的三种模式是什么？</p>\n</blockquote>\n<p>三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。三种模式都是对象来通知某个事件发生了的方法，或者更准确的说，是允许其他的对象收到这种事件的方法。这对于一个对象来说，是非常普通而且必须做的任务，因为没有通信，controllers将不能整合到整个应用中。controller的另外一个目的是尽可能的自包含。我们希望controllers以自己的方式存在，在controllers层面上不能与其他的controllers进行耦合。Controllers能够穿件其他的controllers而且他们之间可以自由通信，但是我们不希望controller又回接到创建自己的controller。如果我们耦合了他们，那么我们将不能复用他们，以及完全失去对应用中一个独立的组件的控制。</p>\n<p>这三种模式给controllers(也可以是其他的对象）提供通信的方法。下面将描述如何在ios应用中使用这些模式，同样需要注意的他们在其他的地方也会用到，并且确实是存在。</p>\n<h2 id=\"delegation\"><a href=\"#delegation\" class=\"headerlink\" title=\"delegation\"></a>delegation</h2><p>当我们第一次编写ios应用时，我们注意到不断的在使用“delegate”，并且贯穿于整个SDK。delegation模式不是IOS特有的模式，而是依赖与你过去拥有的编程背景。针对它的优势以及为什么经常使用到，这种模式可能不是很明显的。</p>\n<p>delegation的基本特征是，一个controller定义了一个协议（即一系列的方法定义）。该协议描述了一个delegate对象为了能够响应一个controller的事件而必须做的事情。协议就是delegator说，“如果你想作为我的delegate，那么你就必须实现这些方法”。实现这些方法就是允许controller在它的delegate能够调用这些方法，而它的delegate知道什么时候调用哪种方法。delegate可以是任何一种对象类型，因此controller不会与某种对象进行耦合，但是当该对象尝试告诉委托事情时，该对象能确定delegate将响应。</p>\n<h3 id=\"delegate的优势：\"><a href=\"#delegate的优势：\" class=\"headerlink\" title=\"delegate的优势：\"></a>delegate的优势：</h3><blockquote>\n<p>1.非常严格的语法。所有将听到的事件必须是在delegate协议中有清晰的定义。</p>\n</blockquote>\n<p>2.如果delegate中的一个方法没有实现那么就会出现编译警告/错误</p>\n<p>3.协议必须在controller的作用域范围内定义</p>\n<p>4.在一个应用中的控制流程是可跟踪的并且是可识别的；</p>\n<p>5.在一个控制器中可以定义定义多个不同的协议，每个协议有不同的delegates</p>\n<p>6.没有第三方对象要求保持/监视通信过程。</p>\n<p>7.能够接收调用的协议方法的返回值。这意味着delegate能够提供反馈信息给controller</p>\n<p>缺点：</p>\n<p>1.需要定义很多代码：1.协议定义；2.controller的delegate属性；3.在delegate本身中实现delegate方法定义</p>\n<p>2.在释放代理对象时，需要小心的将delegate改为nil。一旦设定失败，那么调用释放对象的方法将会出现内存crash</p>\n<p>3.在一个controller中有多个delegate对象，并且delegate是遵守同一个协议，但还是很难告诉多个对象同一个事件，不过有可能。</p>\n<h2 id=\"notification\"><a href=\"#notification\" class=\"headerlink\" title=\"notification\"></a>notification</h2><p>在IOS应用开发中有一个”Notification Center“的概念。它是一个单例对象，允许当事件发生时通知一些对象。它允许我们在低程度耦合的情况下，满足控制器与一个任意的对象进行通信的目的。这种模式的基本特征是为了让其他的对象能够接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称）。这样对于controller来说是匿名的，其他的使用同样的key来注册了该通知的对象（即观察者）能够对通知的事件作出反应。</p>\n<p>优势：</p>\n<blockquote>\n<p>1.不需要编写多少代码，实现比较简单；</p>\n</blockquote>\n<p>2.对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</p>\n<p>3.controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</p>\n<p>缺点：</p>\n<p>1.在编译期不会检查通知是否能够被观察者正确的处理；</p>\n<p>2.在释放注册的对象时，需要在通知中心取消注册；</p>\n<p>3.在调试的时候应用的工作以及控制过程难跟踪；</p>\n<p>4.需要第三方对喜爱那个来管理controller与观察者对象之间的联系；</p>\n<p>5.controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</p>\n<p>6.通知发出后，controller不能从观察者获得任何的反馈信息。</p>\n<h2 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h2><p>KVO是一个对象能够观察另外一个对象的属性的值，并且能够发现值的变化。前面两种模式更加适合一个controller与任何其他的对象进行通信，而KVO更加适合任何类型的对象侦听另外一个任意对象的改变（这里也可以是controller，但一般不是controller）。这是一个对象与另外一个对象保持同步的一种方法，即当另外一种对象的状态发生改变时，观察对象马上作出反应。它只能用来对属性作出反应，而不会用来对方法或者动作作出反应。</p>\n<p>优点：</p>\n<blockquote>\n<p>1.能够提供一种简单的方法实现两个对象间的同步。例如：model和view之间同步；</p>\n</blockquote>\n<p>2.能够对非我们创建的对象，即内部对象的状态改变作出响应，而且不需要改变内部对象（SKD对象）的实现；</p>\n<p>3.能够提供观察的属性的最新值以及先前值；</p>\n<p>4.用key paths来观察属性，因此也可以观察嵌套对象；</p>\n<p>5.完成了对观察对象的抽象，因为不需要额外的代码来允许观察值能够被观察</p>\n<p>缺点：</p>\n<p>1.我们观察的属性必须使用strings来定义。因此在编译器不会出现警告以及检查；</p>\n<p>2.对属性重构将导致我们的观察代码不再可用；</p>\n<p>3.复杂的“IF”语句要求对象正在观察多个值。这是因为所有的观察代码通过一个方法来指向；</p>\n<p>4.当释放观察者时不需要移除观察者。</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p>从上面的分析中可以看出3中设计模式都有各自的优点和缺点。其实任何一种事物都是这样，问题是如何在正确的时间正确的环境下选择正确的事物。下面就讲讲如何发挥他们各自的优势，在哪种情况下使用哪种模式。注意使用任何一种模式都没有对和错，只有更适合或者不适合。每一种模式都给对象提供一种方法来通知一个事件给其他对象，而且前者不需要知道侦听者。在这三种模式中，我认为KVO有最清晰的使用案例，而且针对某个需求有清晰的实用性。而另外两种模式有比较相似的用处，并且经常用来给controller间进行通信。那么我们在什么情况使用其中之一呢？</p>\n<p>根据我开发iOS应用的经历，我发现有些过分的使用通知模式。我个人不是很喜欢使用通知中心。我发现用通知中心很难把握应用的执行流程。UserInfo dictionaries的keys到处传递导致失去了同步，而且在公共空间需要定义太多的常量。对于一个工作于现有的项目的开发者来说，如果过分的使用通知中心，那么很难理解应用的流程。</p>\n<p>我觉得使用命名规则好的协议和协议方法定义对于清晰的理解controllers间的通信是很容易的。努力的定义这些协议方法将增强代码的可读性，以及更好的跟踪你的app。代理协议发生改变以及实现都可通过编译器检查出来，如果没有将会在开发的过程中至少会出现crash，而不仅仅是让一些事情异常工作。甚至在同一事件通知多控制器的场景中，只要你的应用在controller层次有着良好的结构，消息将在该层次上传递。该层次能够向后传递直至让所有需要知道事件的controllers都知道。</p>\n<p>当然会有delegation模式不适合的例外情况出现，而且notification可能更加有效。例如：应用中所有的controller需要知道一个事件。然而这些类型的场景很少出现。另外一个例子是当你建立了一个架构而且需要通知该事件给正在运行中应用。</p>\n<p>根据经验，如果是属性层的事件，不管是在不需要编程的对象还是在紧紧绑定一个view对象的model对象，我只使用观察。对于其他的事件，我都会使用delegate模式。如果因为某种原因我不能使用delegate，首先我将估计我的app架构是否出现了严重的错误。如果没有错误，然后才使用notification。</p>"},{"title":"(转)项目优化--安装包体积控制","date":"2016-01-18T09:20:43.000Z","_content":">iOS微信安装包瘦身\n<!--more-->\n## 前提\n\n微信经过多次版本迭代，产生不少冗余代码和无用资源。之前微信也没有很好的手段知道哪个模块增量多少。另外去年10月微信开始做ARC支持，目的是为了减少野指针带来的Crash，但代价是可执行文件增大20%左右。而苹果规定今年6月提交给Appstore的应用必须支持64位，32位和64位两个架构的存在使得可执行文件增加了一倍多。安装包大小优化迫在眉睫。\n\nAppstore安装包是由资源和可执行文件两部分组成，安装包瘦身也是从这两部分进行。\n\n## 资源瘦身\n\n资源瘦身主要是去掉无用资源和压缩资源，资源包括图片、音视频文件、配置文件以及多语言wording。无用资源是指资源在工程文件里，但没有被代码引用。检查方法是，用资源关键字（通常是文件名，图片资源需要去掉@2x @3x），搜索代码，搜不到就是没有被引用。当然，有些资源在使用过程中是拼接而成的（如loading_xxx.png），需要手工过滤。\n\n资源压缩主要对png进行无损压缩，用的是ImageOptim工具和compress命令（需要安装XQuartz-2.7.5.dm插件）。不建议对资源做有损压缩，有损压缩需要设计一个个检查，通常压缩后效果不尽人意。\n\n## Xcode's Link Map File\n\n在讲可执行文件瘦身之前先介绍Xcode的LinkMap文件。LinkMap文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（__TEXT）和数据段（__DATA）的分布情况。只要设置Project->Build Settings->Write Link Map File为YES，并设置Path to Link Map File，build完后就可以在设置的路径看到LinkMap文件了：\n\n每个LinkMap由3个部分组成，以微信为例：\n\n1. Object files:\n\n[ 0] linker synthesized\n\n[ 1] /xxxx/WCPayInfoItem.o\n\n[ 2] /xxxx/GameCenterFriendRankCell.o\n\n[ 3] /xxxx/WloginTlv_0x168.o\n\n...\n\n第一部分列举可执行文件里所有.obj文件，以及每个文件的编号。\n\n2. Sections:\n\n第二部分是可执行文件的段表，描述各个段在可执行文件中的偏移位置和大小。第一列是段的偏移量，第二列是段占用大小，Address(n)=Address(n-1)+Size(n-1)；第三列是段类型，代码段和数据段；第四列是段名字，如__text是可执行机器码，__cstring是字符串常量。有关段的概念可参考苹果官方文档《OS X ABI Mach-O File Format Reference》\n\n3. Symbols:\n\n# Address Size File Name\n\n0x100005A50 0x00000074 [ 1] +[WCPayInfoItem initialize]\n\n...\n\n0x10231C120 0x00000018 [ 1] literal string: I16@?0@\"WCPayInfoItem\"8\n\n...\n\n0x10252A41A 0x0000000E [ 1] literal string: WCPayInfoItem\n\n...\n\n第三部分详细描述每个obj文件在每个段的分布情况，按第二部分Sections顺序展示。例如序号1的WCPayInfoItem.o文件，+[WCPayInfoItem initialize]方法在__TEXT.__text地址是0x100005A50，占用大小是116字节。根据序号累加每个obj文件在每个段的占用大小，从而计算出每个obj文件在可执行文件的占用大小，进而算出每个静态库、每个功能模块代码占用大小。这里要注意的地方是，由于__DATA.__bbs是代表未初始化的静态变量，Size表示应用运行时占用的堆大小，并不占用可执行文件，所以计算obj占用大小时，要排除这个段的Size。\n\n## 可执行文件瘦身\n\n回到我们的可执行文件瘦身问题，LinkMap文件可以帮助我们寻找优化点。\n\n### 1. 查找无用selector\n\n以往C++在链接时，没有被用到的类和方法是不会编进可执行文件里。但Objctive-C不同，由于它的动态性，它可以通过类名和方法名获取这个类和方法进行调用，所以编译器会把项目里所有OC源文件编进可执行文件里，哪怕该类和方法没有被使用到。\n\n结合LinkMap文件的__TEXT.__text，通过正则表达式([+|-][.+\\s(.+)])，我们可以提取当前可执行文件里所有objc类方法和实例方法（SelectorsAll）。再使用otool命令otool -v -s __DATA __objc_selrefs逆向__DATA.__objc_selrefs段，提取可执行文件里引用到的方法名（UsedSelectorsAll），我们可以大致分析出SelectorsAll里哪些方法是没有被引用的（SelectorsAll-UsedSelectorsAll）。注意，系统API的Protocol可能被列入无用方法名单里，如UITableViewDelegate的方法，我们只需要对这些Protocol里的方法加入白名单过滤即可。\n\n另外第三方库的无用selector也可以这样扫出来的。\n\n### 2. 查找无用oc类\n\n查找无用oc类有两种方式，一种是类似于查找无用资源，通过搜索\"[ClassName alloc/new\"、\"ClassName *\"、\"[ClassName class]\"等关键字在代码里是否出现。另一种是通过otool命令逆向__DATA.__objc_classlist段和__DATA.__objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类。\n\n### 3. 扫描重复代码\n\n可以利用第三方工具simian扫描。南非支付copy代码就是这样被发现的。但除此成果之外，扫描出来的结果过多，重构起来也不方便，不如砍功能需求效果好。\n\n### 4. protobuf精简改造\n\nprotobuf是Google推出的一种轻量高效的结构化数据存储格式，在微信用于网络协议和本地文件序列化。但google默认工具生成的代码比较冗余，像序列化、反序列化、计算序列化大小等方法都生成在具体的pb类里，每个类的实现大同小异。通过代码分析以及结合protobuf原理，要想把这些方法抽象到基类，派生类提供每个字段相关信息就够了：\n\n- field number\n\n- field label, optional, required or repeated\n\n- wire type, double, float, int, etc\n\n- 是否packed\n\n- repeated的数据类型\n```\ntypedef struct {\n    Byte _fieldNumber;\n    Byte _fieldLabel;\n    Byte _fieldType;\n    BOOL _isPacked;\n    int _enumInitValue;\n    union {\n        __unsafe_unretained NSString* _messageClassName;\n        __unsafe_unretained Class _messageClass; // ClassName对应的Class\n        IsEnumValidFunc _isEnumValidFunc; // 检测枚举值是否合法函数指针\n    };\n} PBFieldInfo;\n```\n另外通过无用selector列表，发现不少pb类属性的getter或setter没有被使用。原先的pb类属性是用@synthesize修饰，编译器会自动生成getter和setter。如果不想编译器生成，则要用@dynamic。甚至我们可以把pb类的成员变量去掉。做法如下：\n\n- 基类增加id类型数组ivarValues（参考了objc_class结构体ivars做法），用于存放对象的属性值。对象属性值统一用oc对象表示，如果类型是基础类型（primitive，如int、float等），则用NSValue存\n\n- 重载methodSignatureForSelector:方法，返回属性getter、setter的方法签名\n\n- 重载forwardInvocation:方法，分析invocation.selector类型。如果是getter，从ivarValues获取属性值并设置为invocation的returnValue；如果是setter，从invocation第二个argument获取属性值，并存放到ivarValues里\n\n- 重载setValue:forUndefinedKey:、valueForUndefinedKey:，防止通过KVO访问属性Crash\n\n- 做下性能优化，如pb类在initialize做一次初始化，缓存属性名的hash值，属性的getter、setter方法的objcType等；属性值不用std::map（属性名->属性值），而是改用数组；MRC代替ARC（有些时候ARC自动添加的retain/release挺影响性能的）；等等\n\n```\nclass PBClassInfo {\npublic:\n    PBClassInfo(Class cls, PBFieldInfo* fieldInfo);\n    ~PBClassInfo();\npublic:\n    unsigned int _numberOfProperty;\n    std::string* _propertyNames;\n    size_t* _propertyNameHashes;\n    std::string* _getterObjCTypes;\n    std::string* _setterObjCTypes;\n    PBFieldInfo* _fieldInfos;\n};\n@interface WXPBGeneratedMessage () {\n    uint32_t _has_bits_[3]; // 最多96个属性，表示属性是否有赋值\n    int32_t _serializedSize;\n    PBClassInfo* _classInfo;\n    id* _ivarValues;\n}\n- (NSMethodSignature*) methodSignatureForSelector:(SEL) aSelector;\n- (void) forwardInvocation:(NSInvocation*) anInvocation;\n- (void) setValue:(id) value forUndefinedKey:(NSString*) key;\n- valueForUndefinedKey:(NSString*) key;\n@end\n```\n把冗余代码去掉后，整个类清爽多了。像GameResourceReq只有3个属性的proto结构体，类方法代码行数由以前的127行变成现在的8行。protobuf精简改造中，精简类方法减少了可执行文件8.8M，去掉类成员变量和类属性改用@dynamic减少了2.5M。\n\n```\nmessage GameResourceReq {\n    required BaseRequest BaseRequest = 1;\n    required int32 PropsCount = 2;\n    repeated uint32 PropsIdList = 3[packed=true];\n}\n// 老实现\n@implementation GameResourceReq\n@synthesize hasBaseRequest;\n@synthesize baseRequest;\n@synthesize hasPropsCount;\n@synthesize propsCount;\n@synthesize mutablePropsIdListList;\n@dynamic propsIdList;\n- (id) init {...}\n- (void) SetBaseRequest:(BaseRequest*) value {...}\n- (void) SetPropsCount:(int32_t) value {...}\n- (NSArray*) propsIdListList {...}\n- (NSMutableArray*)propsIdList {...}\n- (void)setPropsIdList:(NSMutableArray*) values {...}\n- (BOOL) isInitialized {...}\n- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {...}\n- (int32_t) serializedSize {...}\n+ (GameResourceReq*) parseFromData:(NSData*) data {...}\n- (GameResourceReq*) mergeFromCodedInputStream:(PBCodedInputStream*) input {...}\n- (void) addPropsIdList:(uint32_t) value {...}\n- (void) addPropsIdListFromArray:(NSArray*) values {...}\n@end\n// 新实现\n@implementation GameResourceReq\nPB_PROPERTY_TYPE baseRequest;\nPB_PROPERTY_TYPE opType;\nPB_PROPERTY_TYPE brandUserName;\n+ (void) initialize {\n  static PBFieldInfo _fieldInfoArray[] = {\n    {1, FieldLabelRequired, FieldTypeMessage, NO, 0, ._messageClassName = STRING_FROM(BaseRequest)},\n    {2, FieldLabelRequired, FieldTypeInt32, NO, 0, 0},\n    {3, FieldLabelRepeated, FieldTypeUint32, NO, 0, 0},\n  };\n  initializePBClassInfo(self, _fieldInfoArray);\n}\n@end\n```\n\n5. 编译选项优化\n\n- Strip Link Product设成YES，WeChatWatch可执行文件减少0.3M\n\n- Make Strings Read-Only设为YES，也许是因为微信工程从低版本Xcode升级过来，这个编译选项之前一直为NO，设为YES后可执行文件减少了3M\n\n- 去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中__gcc_except_tab段减少了17.3M，__text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等\n\n6. 其他可探索途径\n\n- iOS8 Embed-Framework：提取WeChatWatch、ShareExtention和微信主工程的公共代码，可执行文件可以减少5M+，不过这特性需要最低版本iOS8才能用，iOS7设备启动会crash\n\n- iOS9 App Thinning：严格来说App Thinning不会让安装包变小，但用户安装应用时，苹果会根据用户的机型自动选择合适的资源和对应CPU架构的二进制执行文件（也就是说用户本地可执行文件不会同时存在armv7和arm64），安装后空间占用更小\n\n7. 建立监控\n\n通过对LinkMap文件的分析，可以得知每个模块可执行文件占用大小。再对比两个版本，就知道业务模块的增量大小。参考如下：\n","source":"_posts/2016/转-项目优化-安装包体积控制.md","raw":"---\ntitle: (转)项目优化--安装包体积控制\ndate: 2016-01-18 17:20:43\ntags:\n- iOS进阶\ncategories: iOS\n---\n>iOS微信安装包瘦身\n<!--more-->\n## 前提\n\n微信经过多次版本迭代，产生不少冗余代码和无用资源。之前微信也没有很好的手段知道哪个模块增量多少。另外去年10月微信开始做ARC支持，目的是为了减少野指针带来的Crash，但代价是可执行文件增大20%左右。而苹果规定今年6月提交给Appstore的应用必须支持64位，32位和64位两个架构的存在使得可执行文件增加了一倍多。安装包大小优化迫在眉睫。\n\nAppstore安装包是由资源和可执行文件两部分组成，安装包瘦身也是从这两部分进行。\n\n## 资源瘦身\n\n资源瘦身主要是去掉无用资源和压缩资源，资源包括图片、音视频文件、配置文件以及多语言wording。无用资源是指资源在工程文件里，但没有被代码引用。检查方法是，用资源关键字（通常是文件名，图片资源需要去掉@2x @3x），搜索代码，搜不到就是没有被引用。当然，有些资源在使用过程中是拼接而成的（如loading_xxx.png），需要手工过滤。\n\n资源压缩主要对png进行无损压缩，用的是ImageOptim工具和compress命令（需要安装XQuartz-2.7.5.dm插件）。不建议对资源做有损压缩，有损压缩需要设计一个个检查，通常压缩后效果不尽人意。\n\n## Xcode's Link Map File\n\n在讲可执行文件瘦身之前先介绍Xcode的LinkMap文件。LinkMap文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（__TEXT）和数据段（__DATA）的分布情况。只要设置Project->Build Settings->Write Link Map File为YES，并设置Path to Link Map File，build完后就可以在设置的路径看到LinkMap文件了：\n\n每个LinkMap由3个部分组成，以微信为例：\n\n1. Object files:\n\n[ 0] linker synthesized\n\n[ 1] /xxxx/WCPayInfoItem.o\n\n[ 2] /xxxx/GameCenterFriendRankCell.o\n\n[ 3] /xxxx/WloginTlv_0x168.o\n\n...\n\n第一部分列举可执行文件里所有.obj文件，以及每个文件的编号。\n\n2. Sections:\n\n第二部分是可执行文件的段表，描述各个段在可执行文件中的偏移位置和大小。第一列是段的偏移量，第二列是段占用大小，Address(n)=Address(n-1)+Size(n-1)；第三列是段类型，代码段和数据段；第四列是段名字，如__text是可执行机器码，__cstring是字符串常量。有关段的概念可参考苹果官方文档《OS X ABI Mach-O File Format Reference》\n\n3. Symbols:\n\n# Address Size File Name\n\n0x100005A50 0x00000074 [ 1] +[WCPayInfoItem initialize]\n\n...\n\n0x10231C120 0x00000018 [ 1] literal string: I16@?0@\"WCPayInfoItem\"8\n\n...\n\n0x10252A41A 0x0000000E [ 1] literal string: WCPayInfoItem\n\n...\n\n第三部分详细描述每个obj文件在每个段的分布情况，按第二部分Sections顺序展示。例如序号1的WCPayInfoItem.o文件，+[WCPayInfoItem initialize]方法在__TEXT.__text地址是0x100005A50，占用大小是116字节。根据序号累加每个obj文件在每个段的占用大小，从而计算出每个obj文件在可执行文件的占用大小，进而算出每个静态库、每个功能模块代码占用大小。这里要注意的地方是，由于__DATA.__bbs是代表未初始化的静态变量，Size表示应用运行时占用的堆大小，并不占用可执行文件，所以计算obj占用大小时，要排除这个段的Size。\n\n## 可执行文件瘦身\n\n回到我们的可执行文件瘦身问题，LinkMap文件可以帮助我们寻找优化点。\n\n### 1. 查找无用selector\n\n以往C++在链接时，没有被用到的类和方法是不会编进可执行文件里。但Objctive-C不同，由于它的动态性，它可以通过类名和方法名获取这个类和方法进行调用，所以编译器会把项目里所有OC源文件编进可执行文件里，哪怕该类和方法没有被使用到。\n\n结合LinkMap文件的__TEXT.__text，通过正则表达式([+|-][.+\\s(.+)])，我们可以提取当前可执行文件里所有objc类方法和实例方法（SelectorsAll）。再使用otool命令otool -v -s __DATA __objc_selrefs逆向__DATA.__objc_selrefs段，提取可执行文件里引用到的方法名（UsedSelectorsAll），我们可以大致分析出SelectorsAll里哪些方法是没有被引用的（SelectorsAll-UsedSelectorsAll）。注意，系统API的Protocol可能被列入无用方法名单里，如UITableViewDelegate的方法，我们只需要对这些Protocol里的方法加入白名单过滤即可。\n\n另外第三方库的无用selector也可以这样扫出来的。\n\n### 2. 查找无用oc类\n\n查找无用oc类有两种方式，一种是类似于查找无用资源，通过搜索\"[ClassName alloc/new\"、\"ClassName *\"、\"[ClassName class]\"等关键字在代码里是否出现。另一种是通过otool命令逆向__DATA.__objc_classlist段和__DATA.__objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类。\n\n### 3. 扫描重复代码\n\n可以利用第三方工具simian扫描。南非支付copy代码就是这样被发现的。但除此成果之外，扫描出来的结果过多，重构起来也不方便，不如砍功能需求效果好。\n\n### 4. protobuf精简改造\n\nprotobuf是Google推出的一种轻量高效的结构化数据存储格式，在微信用于网络协议和本地文件序列化。但google默认工具生成的代码比较冗余，像序列化、反序列化、计算序列化大小等方法都生成在具体的pb类里，每个类的实现大同小异。通过代码分析以及结合protobuf原理，要想把这些方法抽象到基类，派生类提供每个字段相关信息就够了：\n\n- field number\n\n- field label, optional, required or repeated\n\n- wire type, double, float, int, etc\n\n- 是否packed\n\n- repeated的数据类型\n```\ntypedef struct {\n    Byte _fieldNumber;\n    Byte _fieldLabel;\n    Byte _fieldType;\n    BOOL _isPacked;\n    int _enumInitValue;\n    union {\n        __unsafe_unretained NSString* _messageClassName;\n        __unsafe_unretained Class _messageClass; // ClassName对应的Class\n        IsEnumValidFunc _isEnumValidFunc; // 检测枚举值是否合法函数指针\n    };\n} PBFieldInfo;\n```\n另外通过无用selector列表，发现不少pb类属性的getter或setter没有被使用。原先的pb类属性是用@synthesize修饰，编译器会自动生成getter和setter。如果不想编译器生成，则要用@dynamic。甚至我们可以把pb类的成员变量去掉。做法如下：\n\n- 基类增加id类型数组ivarValues（参考了objc_class结构体ivars做法），用于存放对象的属性值。对象属性值统一用oc对象表示，如果类型是基础类型（primitive，如int、float等），则用NSValue存\n\n- 重载methodSignatureForSelector:方法，返回属性getter、setter的方法签名\n\n- 重载forwardInvocation:方法，分析invocation.selector类型。如果是getter，从ivarValues获取属性值并设置为invocation的returnValue；如果是setter，从invocation第二个argument获取属性值，并存放到ivarValues里\n\n- 重载setValue:forUndefinedKey:、valueForUndefinedKey:，防止通过KVO访问属性Crash\n\n- 做下性能优化，如pb类在initialize做一次初始化，缓存属性名的hash值，属性的getter、setter方法的objcType等；属性值不用std::map（属性名->属性值），而是改用数组；MRC代替ARC（有些时候ARC自动添加的retain/release挺影响性能的）；等等\n\n```\nclass PBClassInfo {\npublic:\n    PBClassInfo(Class cls, PBFieldInfo* fieldInfo);\n    ~PBClassInfo();\npublic:\n    unsigned int _numberOfProperty;\n    std::string* _propertyNames;\n    size_t* _propertyNameHashes;\n    std::string* _getterObjCTypes;\n    std::string* _setterObjCTypes;\n    PBFieldInfo* _fieldInfos;\n};\n@interface WXPBGeneratedMessage () {\n    uint32_t _has_bits_[3]; // 最多96个属性，表示属性是否有赋值\n    int32_t _serializedSize;\n    PBClassInfo* _classInfo;\n    id* _ivarValues;\n}\n- (NSMethodSignature*) methodSignatureForSelector:(SEL) aSelector;\n- (void) forwardInvocation:(NSInvocation*) anInvocation;\n- (void) setValue:(id) value forUndefinedKey:(NSString*) key;\n- valueForUndefinedKey:(NSString*) key;\n@end\n```\n把冗余代码去掉后，整个类清爽多了。像GameResourceReq只有3个属性的proto结构体，类方法代码行数由以前的127行变成现在的8行。protobuf精简改造中，精简类方法减少了可执行文件8.8M，去掉类成员变量和类属性改用@dynamic减少了2.5M。\n\n```\nmessage GameResourceReq {\n    required BaseRequest BaseRequest = 1;\n    required int32 PropsCount = 2;\n    repeated uint32 PropsIdList = 3[packed=true];\n}\n// 老实现\n@implementation GameResourceReq\n@synthesize hasBaseRequest;\n@synthesize baseRequest;\n@synthesize hasPropsCount;\n@synthesize propsCount;\n@synthesize mutablePropsIdListList;\n@dynamic propsIdList;\n- (id) init {...}\n- (void) SetBaseRequest:(BaseRequest*) value {...}\n- (void) SetPropsCount:(int32_t) value {...}\n- (NSArray*) propsIdListList {...}\n- (NSMutableArray*)propsIdList {...}\n- (void)setPropsIdList:(NSMutableArray*) values {...}\n- (BOOL) isInitialized {...}\n- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {...}\n- (int32_t) serializedSize {...}\n+ (GameResourceReq*) parseFromData:(NSData*) data {...}\n- (GameResourceReq*) mergeFromCodedInputStream:(PBCodedInputStream*) input {...}\n- (void) addPropsIdList:(uint32_t) value {...}\n- (void) addPropsIdListFromArray:(NSArray*) values {...}\n@end\n// 新实现\n@implementation GameResourceReq\nPB_PROPERTY_TYPE baseRequest;\nPB_PROPERTY_TYPE opType;\nPB_PROPERTY_TYPE brandUserName;\n+ (void) initialize {\n  static PBFieldInfo _fieldInfoArray[] = {\n    {1, FieldLabelRequired, FieldTypeMessage, NO, 0, ._messageClassName = STRING_FROM(BaseRequest)},\n    {2, FieldLabelRequired, FieldTypeInt32, NO, 0, 0},\n    {3, FieldLabelRepeated, FieldTypeUint32, NO, 0, 0},\n  };\n  initializePBClassInfo(self, _fieldInfoArray);\n}\n@end\n```\n\n5. 编译选项优化\n\n- Strip Link Product设成YES，WeChatWatch可执行文件减少0.3M\n\n- Make Strings Read-Only设为YES，也许是因为微信工程从低版本Xcode升级过来，这个编译选项之前一直为NO，设为YES后可执行文件减少了3M\n\n- 去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中__gcc_except_tab段减少了17.3M，__text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等\n\n6. 其他可探索途径\n\n- iOS8 Embed-Framework：提取WeChatWatch、ShareExtention和微信主工程的公共代码，可执行文件可以减少5M+，不过这特性需要最低版本iOS8才能用，iOS7设备启动会crash\n\n- iOS9 App Thinning：严格来说App Thinning不会让安装包变小，但用户安装应用时，苹果会根据用户的机型自动选择合适的资源和对应CPU架构的二进制执行文件（也就是说用户本地可执行文件不会同时存在armv7和arm64），安装后空间占用更小\n\n7. 建立监控\n\n通过对LinkMap文件的分析，可以得知每个模块可执行文件占用大小。再对比两个版本，就知道业务模块的增量大小。参考如下：\n","slug":"2016/转-项目优化-安装包体积控制","published":1,"updated":"2017-10-11T10:13:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8ns4po6005jsaua8h7ca8si","content":"<blockquote>\n<p>iOS微信安装包瘦身<br><a id=\"more\"></a></p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2></blockquote>\n<p>微信经过多次版本迭代，产生不少冗余代码和无用资源。之前微信也没有很好的手段知道哪个模块增量多少。另外去年10月微信开始做ARC支持，目的是为了减少野指针带来的Crash，但代价是可执行文件增大20%左右。而苹果规定今年6月提交给Appstore的应用必须支持64位，32位和64位两个架构的存在使得可执行文件增加了一倍多。安装包大小优化迫在眉睫。</p>\n<p>Appstore安装包是由资源和可执行文件两部分组成，安装包瘦身也是从这两部分进行。</p>\n<h2 id=\"资源瘦身\"><a href=\"#资源瘦身\" class=\"headerlink\" title=\"资源瘦身\"></a>资源瘦身</h2><p>资源瘦身主要是去掉无用资源和压缩资源，资源包括图片、音视频文件、配置文件以及多语言wording。无用资源是指资源在工程文件里，但没有被代码引用。检查方法是，用资源关键字（通常是文件名，图片资源需要去掉@2x @3x），搜索代码，搜不到就是没有被引用。当然，有些资源在使用过程中是拼接而成的（如loading_xxx.png），需要手工过滤。</p>\n<p>资源压缩主要对png进行无损压缩，用的是ImageOptim工具和compress命令（需要安装XQuartz-2.7.5.dm插件）。不建议对资源做有损压缩，有损压缩需要设计一个个检查，通常压缩后效果不尽人意。</p>\n<h2 id=\"Xcode’s-Link-Map-File\"><a href=\"#Xcode’s-Link-Map-File\" class=\"headerlink\" title=\"Xcode’s Link Map File\"></a>Xcode’s Link Map File</h2><p>在讲可执行文件瘦身之前先介绍Xcode的LinkMap文件。LinkMap文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（<strong>TEXT）和数据段（</strong>DATA）的分布情况。只要设置Project-&gt;Build Settings-&gt;Write Link Map File为YES，并设置Path to Link Map File，build完后就可以在设置的路径看到LinkMap文件了：</p>\n<p>每个LinkMap由3个部分组成，以微信为例：</p>\n<ol>\n<li>Object files:</li>\n</ol>\n<p>[ 0] linker synthesized</p>\n<p>[ 1] /xxxx/WCPayInfoItem.o</p>\n<p>[ 2] /xxxx/GameCenterFriendRankCell.o</p>\n<p>[ 3] /xxxx/WloginTlv_0x168.o</p>\n<p>…</p>\n<p>第一部分列举可执行文件里所有.obj文件，以及每个文件的编号。</p>\n<ol>\n<li>Sections:</li>\n</ol>\n<p>第二部分是可执行文件的段表，描述各个段在可执行文件中的偏移位置和大小。第一列是段的偏移量，第二列是段占用大小，Address(n)=Address(n-1)+Size(n-1)；第三列是段类型，代码段和数据段；第四列是段名字，如<strong>text是可执行机器码，</strong>cstring是字符串常量。有关段的概念可参考苹果官方文档《OS X ABI Mach-O File Format Reference》</p>\n<ol>\n<li>Symbols:</li>\n</ol>\n<h1 id=\"Address-Size-File-Name\"><a href=\"#Address-Size-File-Name\" class=\"headerlink\" title=\"Address Size File Name\"></a>Address Size File Name</h1><p>0x100005A50 0x00000074 [ 1] +[WCPayInfoItem initialize]</p>\n<p>…</p>\n<p>0x10231C120 0x00000018 [ 1] literal string: I16@?0@”WCPayInfoItem”8</p>\n<p>…</p>\n<p>0x10252A41A 0x0000000E [ 1] literal string: WCPayInfoItem</p>\n<p>…</p>\n<p>第三部分详细描述每个obj文件在每个段的分布情况，按第二部分Sections顺序展示。例如序号1的WCPayInfoItem.o文件，+[WCPayInfoItem initialize]方法在<strong>TEXT.</strong>text地址是0x100005A50，占用大小是116字节。根据序号累加每个obj文件在每个段的占用大小，从而计算出每个obj文件在可执行文件的占用大小，进而算出每个静态库、每个功能模块代码占用大小。这里要注意的地方是，由于<strong>DATA.</strong>bbs是代表未初始化的静态变量，Size表示应用运行时占用的堆大小，并不占用可执行文件，所以计算obj占用大小时，要排除这个段的Size。</p>\n<h2 id=\"可执行文件瘦身\"><a href=\"#可执行文件瘦身\" class=\"headerlink\" title=\"可执行文件瘦身\"></a>可执行文件瘦身</h2><p>回到我们的可执行文件瘦身问题，LinkMap文件可以帮助我们寻找优化点。</p>\n<h3 id=\"1-查找无用selector\"><a href=\"#1-查找无用selector\" class=\"headerlink\" title=\"1. 查找无用selector\"></a>1. 查找无用selector</h3><p>以往C++在链接时，没有被用到的类和方法是不会编进可执行文件里。但Objctive-C不同，由于它的动态性，它可以通过类名和方法名获取这个类和方法进行调用，所以编译器会把项目里所有OC源文件编进可执行文件里，哪怕该类和方法没有被使用到。</p>\n<p>结合LinkMap文件的<strong>TEXT.</strong>text，通过正则表达式([+|-][.+\\s(.+)])，我们可以提取当前可执行文件里所有objc类方法和实例方法（SelectorsAll）。再使用otool命令otool -v -s <strong>DATA </strong>objc_selrefs逆向<strong>DATA.</strong>objc_selrefs段，提取可执行文件里引用到的方法名（UsedSelectorsAll），我们可以大致分析出SelectorsAll里哪些方法是没有被引用的（SelectorsAll-UsedSelectorsAll）。注意，系统API的Protocol可能被列入无用方法名单里，如UITableViewDelegate的方法，我们只需要对这些Protocol里的方法加入白名单过滤即可。</p>\n<p>另外第三方库的无用selector也可以这样扫出来的。</p>\n<h3 id=\"2-查找无用oc类\"><a href=\"#2-查找无用oc类\" class=\"headerlink\" title=\"2. 查找无用oc类\"></a>2. 查找无用oc类</h3><p>查找无用oc类有两种方式，一种是类似于查找无用资源，通过搜索”[ClassName alloc/new”、”ClassName *”、”[ClassName class]”等关键字在代码里是否出现。另一种是通过otool命令逆向<strong>DATA.</strong>objc_classlist段和<strong>DATA.</strong>objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类。</p>\n<h3 id=\"3-扫描重复代码\"><a href=\"#3-扫描重复代码\" class=\"headerlink\" title=\"3. 扫描重复代码\"></a>3. 扫描重复代码</h3><p>可以利用第三方工具simian扫描。南非支付copy代码就是这样被发现的。但除此成果之外，扫描出来的结果过多，重构起来也不方便，不如砍功能需求效果好。</p>\n<h3 id=\"4-protobuf精简改造\"><a href=\"#4-protobuf精简改造\" class=\"headerlink\" title=\"4. protobuf精简改造\"></a>4. protobuf精简改造</h3><p>protobuf是Google推出的一种轻量高效的结构化数据存储格式，在微信用于网络协议和本地文件序列化。但google默认工具生成的代码比较冗余，像序列化、反序列化、计算序列化大小等方法都生成在具体的pb类里，每个类的实现大同小异。通过代码分析以及结合protobuf原理，要想把这些方法抽象到基类，派生类提供每个字段相关信息就够了：</p>\n<ul>\n<li><p>field number</p>\n</li>\n<li><p>field label, optional, required or repeated</p>\n</li>\n<li><p>wire type, double, float, int, etc</p>\n</li>\n<li><p>是否packed</p>\n</li>\n<li><p>repeated的数据类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct &#123;</div><div class=\"line\">    Byte _fieldNumber;</div><div class=\"line\">    Byte _fieldLabel;</div><div class=\"line\">    Byte _fieldType;</div><div class=\"line\">    BOOL _isPacked;</div><div class=\"line\">    int _enumInitValue;</div><div class=\"line\">    union &#123;</div><div class=\"line\">        __unsafe_unretained NSString* _messageClassName;</div><div class=\"line\">        __unsafe_unretained Class _messageClass; // ClassName对应的Class</div><div class=\"line\">        IsEnumValidFunc _isEnumValidFunc; // 检测枚举值是否合法函数指针</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125; PBFieldInfo;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>另外通过无用selector列表，发现不少pb类属性的getter或setter没有被使用。原先的pb类属性是用@synthesize修饰，编译器会自动生成getter和setter。如果不想编译器生成，则要用@dynamic。甚至我们可以把pb类的成员变量去掉。做法如下：</p>\n<ul>\n<li><p>基类增加id类型数组ivarValues（参考了objc_class结构体ivars做法），用于存放对象的属性值。对象属性值统一用oc对象表示，如果类型是基础类型（primitive，如int、float等），则用NSValue存</p>\n</li>\n<li><p>重载methodSignatureForSelector:方法，返回属性getter、setter的方法签名</p>\n</li>\n<li><p>重载forwardInvocation:方法，分析invocation.selector类型。如果是getter，从ivarValues获取属性值并设置为invocation的returnValue；如果是setter，从invocation第二个argument获取属性值，并存放到ivarValues里</p>\n</li>\n<li><p>重载setValue:forUndefinedKey:、valueForUndefinedKey:，防止通过KVO访问属性Crash</p>\n</li>\n<li><p>做下性能优化，如pb类在initialize做一次初始化，缓存属性名的hash值，属性的getter、setter方法的objcType等；属性值不用std::map（属性名-&gt;属性值），而是改用数组；MRC代替ARC（有些时候ARC自动添加的retain/release挺影响性能的）；等等</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PBClassInfo &#123;</div><div class=\"line\">public:</div><div class=\"line\">    PBClassInfo(Class cls, PBFieldInfo* fieldInfo);</div><div class=\"line\">    ~PBClassInfo();</div><div class=\"line\">public:</div><div class=\"line\">    unsigned int _numberOfProperty;</div><div class=\"line\">    std::string* _propertyNames;</div><div class=\"line\">    size_t* _propertyNameHashes;</div><div class=\"line\">    std::string* _getterObjCTypes;</div><div class=\"line\">    std::string* _setterObjCTypes;</div><div class=\"line\">    PBFieldInfo* _fieldInfos;</div><div class=\"line\">&#125;;</div><div class=\"line\">@interface WXPBGeneratedMessage () &#123;</div><div class=\"line\">    uint32_t _has_bits_[3]; // 最多96个属性，表示属性是否有赋值</div><div class=\"line\">    int32_t _serializedSize;</div><div class=\"line\">    PBClassInfo* _classInfo;</div><div class=\"line\">    id* _ivarValues;</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSMethodSignature*) methodSignatureForSelector:(SEL) aSelector;</div><div class=\"line\">- (void) forwardInvocation:(NSInvocation*) anInvocation;</div><div class=\"line\">- (void) setValue:(id) value forUndefinedKey:(NSString*) key;</div><div class=\"line\">- valueForUndefinedKey:(NSString*) key;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>把冗余代码去掉后，整个类清爽多了。像GameResourceReq只有3个属性的proto结构体，类方法代码行数由以前的127行变成现在的8行。protobuf精简改造中，精简类方法减少了可执行文件8.8M，去掉类成员变量和类属性改用@dynamic减少了2.5M。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">message GameResourceReq &#123;</div><div class=\"line\">    required BaseRequest BaseRequest = 1;</div><div class=\"line\">    required int32 PropsCount = 2;</div><div class=\"line\">    repeated uint32 PropsIdList = 3[packed=true];</div><div class=\"line\">&#125;</div><div class=\"line\">// 老实现</div><div class=\"line\">@implementation GameResourceReq</div><div class=\"line\">@synthesize hasBaseRequest;</div><div class=\"line\">@synthesize baseRequest;</div><div class=\"line\">@synthesize hasPropsCount;</div><div class=\"line\">@synthesize propsCount;</div><div class=\"line\">@synthesize mutablePropsIdListList;</div><div class=\"line\">@dynamic propsIdList;</div><div class=\"line\">- (id) init &#123;...&#125;</div><div class=\"line\">- (void) SetBaseRequest:(BaseRequest*) value &#123;...&#125;</div><div class=\"line\">- (void) SetPropsCount:(int32_t) value &#123;...&#125;</div><div class=\"line\">- (NSArray*) propsIdListList &#123;...&#125;</div><div class=\"line\">- (NSMutableArray*)propsIdList &#123;...&#125;</div><div class=\"line\">- (void)setPropsIdList:(NSMutableArray*) values &#123;...&#125;</div><div class=\"line\">- (BOOL) isInitialized &#123;...&#125;</div><div class=\"line\">- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output &#123;...&#125;</div><div class=\"line\">- (int32_t) serializedSize &#123;...&#125;</div><div class=\"line\">+ (GameResourceReq*) parseFromData:(NSData*) data &#123;...&#125;</div><div class=\"line\">- (GameResourceReq*) mergeFromCodedInputStream:(PBCodedInputStream*) input &#123;...&#125;</div><div class=\"line\">- (void) addPropsIdList:(uint32_t) value &#123;...&#125;</div><div class=\"line\">- (void) addPropsIdListFromArray:(NSArray*) values &#123;...&#125;</div><div class=\"line\">@end</div><div class=\"line\">// 新实现</div><div class=\"line\">@implementation GameResourceReq</div><div class=\"line\">PB_PROPERTY_TYPE baseRequest;</div><div class=\"line\">PB_PROPERTY_TYPE opType;</div><div class=\"line\">PB_PROPERTY_TYPE brandUserName;</div><div class=\"line\">+ (void) initialize &#123;</div><div class=\"line\">  static PBFieldInfo _fieldInfoArray[] = &#123;</div><div class=\"line\">    &#123;1, FieldLabelRequired, FieldTypeMessage, NO, 0, ._messageClassName = STRING_FROM(BaseRequest)&#125;,</div><div class=\"line\">    &#123;2, FieldLabelRequired, FieldTypeInt32, NO, 0, 0&#125;,</div><div class=\"line\">    &#123;3, FieldLabelRepeated, FieldTypeUint32, NO, 0, 0&#125;,</div><div class=\"line\">  &#125;;</div><div class=\"line\">  initializePBClassInfo(self, _fieldInfoArray);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ol>\n<li>编译选项优化</li>\n</ol>\n<ul>\n<li><p>Strip Link Product设成YES，WeChatWatch可执行文件减少0.3M</p>\n</li>\n<li><p>Make Strings Read-Only设为YES，也许是因为微信工程从低版本Xcode升级过来，这个编译选项之前一直为NO，设为YES后可执行文件减少了3M</p>\n</li>\n<li><p>去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中<strong>gcc_except_tab段减少了17.3M，</strong>text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等</p>\n</li>\n</ul>\n<ol>\n<li>其他可探索途径</li>\n</ol>\n<ul>\n<li><p>iOS8 Embed-Framework：提取WeChatWatch、ShareExtention和微信主工程的公共代码，可执行文件可以减少5M+，不过这特性需要最低版本iOS8才能用，iOS7设备启动会crash</p>\n</li>\n<li><p>iOS9 App Thinning：严格来说App Thinning不会让安装包变小，但用户安装应用时，苹果会根据用户的机型自动选择合适的资源和对应CPU架构的二进制执行文件（也就是说用户本地可执行文件不会同时存在armv7和arm64），安装后空间占用更小</p>\n</li>\n</ul>\n<ol>\n<li>建立监控</li>\n</ol>\n<p>通过对LinkMap文件的分析，可以得知每个模块可执行文件占用大小。再对比两个版本，就知道业务模块的增量大小。参考如下：</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>iOS微信安装包瘦身<br>","more":"</p>\n<h2 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h2></blockquote>\n<p>微信经过多次版本迭代，产生不少冗余代码和无用资源。之前微信也没有很好的手段知道哪个模块增量多少。另外去年10月微信开始做ARC支持，目的是为了减少野指针带来的Crash，但代价是可执行文件增大20%左右。而苹果规定今年6月提交给Appstore的应用必须支持64位，32位和64位两个架构的存在使得可执行文件增加了一倍多。安装包大小优化迫在眉睫。</p>\n<p>Appstore安装包是由资源和可执行文件两部分组成，安装包瘦身也是从这两部分进行。</p>\n<h2 id=\"资源瘦身\"><a href=\"#资源瘦身\" class=\"headerlink\" title=\"资源瘦身\"></a>资源瘦身</h2><p>资源瘦身主要是去掉无用资源和压缩资源，资源包括图片、音视频文件、配置文件以及多语言wording。无用资源是指资源在工程文件里，但没有被代码引用。检查方法是，用资源关键字（通常是文件名，图片资源需要去掉@2x @3x），搜索代码，搜不到就是没有被引用。当然，有些资源在使用过程中是拼接而成的（如loading_xxx.png），需要手工过滤。</p>\n<p>资源压缩主要对png进行无损压缩，用的是ImageOptim工具和compress命令（需要安装XQuartz-2.7.5.dm插件）。不建议对资源做有损压缩，有损压缩需要设计一个个检查，通常压缩后效果不尽人意。</p>\n<h2 id=\"Xcode’s-Link-Map-File\"><a href=\"#Xcode’s-Link-Map-File\" class=\"headerlink\" title=\"Xcode’s Link Map File\"></a>Xcode’s Link Map File</h2><p>在讲可执行文件瘦身之前先介绍Xcode的LinkMap文件。LinkMap文件是Xcode产生可执行文件的同时生成的链接信息，用来描述可执行文件的构造成分，包括代码段（<strong>TEXT）和数据段（</strong>DATA）的分布情况。只要设置Project-&gt;Build Settings-&gt;Write Link Map File为YES，并设置Path to Link Map File，build完后就可以在设置的路径看到LinkMap文件了：</p>\n<p>每个LinkMap由3个部分组成，以微信为例：</p>\n<ol>\n<li>Object files:</li>\n</ol>\n<p>[ 0] linker synthesized</p>\n<p>[ 1] /xxxx/WCPayInfoItem.o</p>\n<p>[ 2] /xxxx/GameCenterFriendRankCell.o</p>\n<p>[ 3] /xxxx/WloginTlv_0x168.o</p>\n<p>…</p>\n<p>第一部分列举可执行文件里所有.obj文件，以及每个文件的编号。</p>\n<ol>\n<li>Sections:</li>\n</ol>\n<p>第二部分是可执行文件的段表，描述各个段在可执行文件中的偏移位置和大小。第一列是段的偏移量，第二列是段占用大小，Address(n)=Address(n-1)+Size(n-1)；第三列是段类型，代码段和数据段；第四列是段名字，如<strong>text是可执行机器码，</strong>cstring是字符串常量。有关段的概念可参考苹果官方文档《OS X ABI Mach-O File Format Reference》</p>\n<ol>\n<li>Symbols:</li>\n</ol>\n<h1 id=\"Address-Size-File-Name\"><a href=\"#Address-Size-File-Name\" class=\"headerlink\" title=\"Address Size File Name\"></a>Address Size File Name</h1><p>0x100005A50 0x00000074 [ 1] +[WCPayInfoItem initialize]</p>\n<p>…</p>\n<p>0x10231C120 0x00000018 [ 1] literal string: I16@?0@”WCPayInfoItem”8</p>\n<p>…</p>\n<p>0x10252A41A 0x0000000E [ 1] literal string: WCPayInfoItem</p>\n<p>…</p>\n<p>第三部分详细描述每个obj文件在每个段的分布情况，按第二部分Sections顺序展示。例如序号1的WCPayInfoItem.o文件，+[WCPayInfoItem initialize]方法在<strong>TEXT.</strong>text地址是0x100005A50，占用大小是116字节。根据序号累加每个obj文件在每个段的占用大小，从而计算出每个obj文件在可执行文件的占用大小，进而算出每个静态库、每个功能模块代码占用大小。这里要注意的地方是，由于<strong>DATA.</strong>bbs是代表未初始化的静态变量，Size表示应用运行时占用的堆大小，并不占用可执行文件，所以计算obj占用大小时，要排除这个段的Size。</p>\n<h2 id=\"可执行文件瘦身\"><a href=\"#可执行文件瘦身\" class=\"headerlink\" title=\"可执行文件瘦身\"></a>可执行文件瘦身</h2><p>回到我们的可执行文件瘦身问题，LinkMap文件可以帮助我们寻找优化点。</p>\n<h3 id=\"1-查找无用selector\"><a href=\"#1-查找无用selector\" class=\"headerlink\" title=\"1. 查找无用selector\"></a>1. 查找无用selector</h3><p>以往C++在链接时，没有被用到的类和方法是不会编进可执行文件里。但Objctive-C不同，由于它的动态性，它可以通过类名和方法名获取这个类和方法进行调用，所以编译器会把项目里所有OC源文件编进可执行文件里，哪怕该类和方法没有被使用到。</p>\n<p>结合LinkMap文件的<strong>TEXT.</strong>text，通过正则表达式([+|-][.+\\s(.+)])，我们可以提取当前可执行文件里所有objc类方法和实例方法（SelectorsAll）。再使用otool命令otool -v -s <strong>DATA </strong>objc_selrefs逆向<strong>DATA.</strong>objc_selrefs段，提取可执行文件里引用到的方法名（UsedSelectorsAll），我们可以大致分析出SelectorsAll里哪些方法是没有被引用的（SelectorsAll-UsedSelectorsAll）。注意，系统API的Protocol可能被列入无用方法名单里，如UITableViewDelegate的方法，我们只需要对这些Protocol里的方法加入白名单过滤即可。</p>\n<p>另外第三方库的无用selector也可以这样扫出来的。</p>\n<h3 id=\"2-查找无用oc类\"><a href=\"#2-查找无用oc类\" class=\"headerlink\" title=\"2. 查找无用oc类\"></a>2. 查找无用oc类</h3><p>查找无用oc类有两种方式，一种是类似于查找无用资源，通过搜索”[ClassName alloc/new”、”ClassName *”、”[ClassName class]”等关键字在代码里是否出现。另一种是通过otool命令逆向<strong>DATA.</strong>objc_classlist段和<strong>DATA.</strong>objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类。</p>\n<h3 id=\"3-扫描重复代码\"><a href=\"#3-扫描重复代码\" class=\"headerlink\" title=\"3. 扫描重复代码\"></a>3. 扫描重复代码</h3><p>可以利用第三方工具simian扫描。南非支付copy代码就是这样被发现的。但除此成果之外，扫描出来的结果过多，重构起来也不方便，不如砍功能需求效果好。</p>\n<h3 id=\"4-protobuf精简改造\"><a href=\"#4-protobuf精简改造\" class=\"headerlink\" title=\"4. protobuf精简改造\"></a>4. protobuf精简改造</h3><p>protobuf是Google推出的一种轻量高效的结构化数据存储格式，在微信用于网络协议和本地文件序列化。但google默认工具生成的代码比较冗余，像序列化、反序列化、计算序列化大小等方法都生成在具体的pb类里，每个类的实现大同小异。通过代码分析以及结合protobuf原理，要想把这些方法抽象到基类，派生类提供每个字段相关信息就够了：</p>\n<ul>\n<li><p>field number</p>\n</li>\n<li><p>field label, optional, required or repeated</p>\n</li>\n<li><p>wire type, double, float, int, etc</p>\n</li>\n<li><p>是否packed</p>\n</li>\n<li><p>repeated的数据类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef struct &#123;</div><div class=\"line\">    Byte _fieldNumber;</div><div class=\"line\">    Byte _fieldLabel;</div><div class=\"line\">    Byte _fieldType;</div><div class=\"line\">    BOOL _isPacked;</div><div class=\"line\">    int _enumInitValue;</div><div class=\"line\">    union &#123;</div><div class=\"line\">        __unsafe_unretained NSString* _messageClassName;</div><div class=\"line\">        __unsafe_unretained Class _messageClass; // ClassName对应的Class</div><div class=\"line\">        IsEnumValidFunc _isEnumValidFunc; // 检测枚举值是否合法函数指针</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125; PBFieldInfo;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>另外通过无用selector列表，发现不少pb类属性的getter或setter没有被使用。原先的pb类属性是用@synthesize修饰，编译器会自动生成getter和setter。如果不想编译器生成，则要用@dynamic。甚至我们可以把pb类的成员变量去掉。做法如下：</p>\n<ul>\n<li><p>基类增加id类型数组ivarValues（参考了objc_class结构体ivars做法），用于存放对象的属性值。对象属性值统一用oc对象表示，如果类型是基础类型（primitive，如int、float等），则用NSValue存</p>\n</li>\n<li><p>重载methodSignatureForSelector:方法，返回属性getter、setter的方法签名</p>\n</li>\n<li><p>重载forwardInvocation:方法，分析invocation.selector类型。如果是getter，从ivarValues获取属性值并设置为invocation的returnValue；如果是setter，从invocation第二个argument获取属性值，并存放到ivarValues里</p>\n</li>\n<li><p>重载setValue:forUndefinedKey:、valueForUndefinedKey:，防止通过KVO访问属性Crash</p>\n</li>\n<li><p>做下性能优化，如pb类在initialize做一次初始化，缓存属性名的hash值，属性的getter、setter方法的objcType等；属性值不用std::map（属性名-&gt;属性值），而是改用数组；MRC代替ARC（有些时候ARC自动添加的retain/release挺影响性能的）；等等</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PBClassInfo &#123;</div><div class=\"line\">public:</div><div class=\"line\">    PBClassInfo(Class cls, PBFieldInfo* fieldInfo);</div><div class=\"line\">    ~PBClassInfo();</div><div class=\"line\">public:</div><div class=\"line\">    unsigned int _numberOfProperty;</div><div class=\"line\">    std::string* _propertyNames;</div><div class=\"line\">    size_t* _propertyNameHashes;</div><div class=\"line\">    std::string* _getterObjCTypes;</div><div class=\"line\">    std::string* _setterObjCTypes;</div><div class=\"line\">    PBFieldInfo* _fieldInfos;</div><div class=\"line\">&#125;;</div><div class=\"line\">@interface WXPBGeneratedMessage () &#123;</div><div class=\"line\">    uint32_t _has_bits_[3]; // 最多96个属性，表示属性是否有赋值</div><div class=\"line\">    int32_t _serializedSize;</div><div class=\"line\">    PBClassInfo* _classInfo;</div><div class=\"line\">    id* _ivarValues;</div><div class=\"line\">&#125;</div><div class=\"line\">- (NSMethodSignature*) methodSignatureForSelector:(SEL) aSelector;</div><div class=\"line\">- (void) forwardInvocation:(NSInvocation*) anInvocation;</div><div class=\"line\">- (void) setValue:(id) value forUndefinedKey:(NSString*) key;</div><div class=\"line\">- valueForUndefinedKey:(NSString*) key;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>把冗余代码去掉后，整个类清爽多了。像GameResourceReq只有3个属性的proto结构体，类方法代码行数由以前的127行变成现在的8行。protobuf精简改造中，精简类方法减少了可执行文件8.8M，去掉类成员变量和类属性改用@dynamic减少了2.5M。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">message GameResourceReq &#123;</div><div class=\"line\">    required BaseRequest BaseRequest = 1;</div><div class=\"line\">    required int32 PropsCount = 2;</div><div class=\"line\">    repeated uint32 PropsIdList = 3[packed=true];</div><div class=\"line\">&#125;</div><div class=\"line\">// 老实现</div><div class=\"line\">@implementation GameResourceReq</div><div class=\"line\">@synthesize hasBaseRequest;</div><div class=\"line\">@synthesize baseRequest;</div><div class=\"line\">@synthesize hasPropsCount;</div><div class=\"line\">@synthesize propsCount;</div><div class=\"line\">@synthesize mutablePropsIdListList;</div><div class=\"line\">@dynamic propsIdList;</div><div class=\"line\">- (id) init &#123;...&#125;</div><div class=\"line\">- (void) SetBaseRequest:(BaseRequest*) value &#123;...&#125;</div><div class=\"line\">- (void) SetPropsCount:(int32_t) value &#123;...&#125;</div><div class=\"line\">- (NSArray*) propsIdListList &#123;...&#125;</div><div class=\"line\">- (NSMutableArray*)propsIdList &#123;...&#125;</div><div class=\"line\">- (void)setPropsIdList:(NSMutableArray*) values &#123;...&#125;</div><div class=\"line\">- (BOOL) isInitialized &#123;...&#125;</div><div class=\"line\">- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output &#123;...&#125;</div><div class=\"line\">- (int32_t) serializedSize &#123;...&#125;</div><div class=\"line\">+ (GameResourceReq*) parseFromData:(NSData*) data &#123;...&#125;</div><div class=\"line\">- (GameResourceReq*) mergeFromCodedInputStream:(PBCodedInputStream*) input &#123;...&#125;</div><div class=\"line\">- (void) addPropsIdList:(uint32_t) value &#123;...&#125;</div><div class=\"line\">- (void) addPropsIdListFromArray:(NSArray*) values &#123;...&#125;</div><div class=\"line\">@end</div><div class=\"line\">// 新实现</div><div class=\"line\">@implementation GameResourceReq</div><div class=\"line\">PB_PROPERTY_TYPE baseRequest;</div><div class=\"line\">PB_PROPERTY_TYPE opType;</div><div class=\"line\">PB_PROPERTY_TYPE brandUserName;</div><div class=\"line\">+ (void) initialize &#123;</div><div class=\"line\">  static PBFieldInfo _fieldInfoArray[] = &#123;</div><div class=\"line\">    &#123;1, FieldLabelRequired, FieldTypeMessage, NO, 0, ._messageClassName = STRING_FROM(BaseRequest)&#125;,</div><div class=\"line\">    &#123;2, FieldLabelRequired, FieldTypeInt32, NO, 0, 0&#125;,</div><div class=\"line\">    &#123;3, FieldLabelRepeated, FieldTypeUint32, NO, 0, 0&#125;,</div><div class=\"line\">  &#125;;</div><div class=\"line\">  initializePBClassInfo(self, _fieldInfoArray);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<ol>\n<li>编译选项优化</li>\n</ol>\n<ul>\n<li><p>Strip Link Product设成YES，WeChatWatch可执行文件减少0.3M</p>\n</li>\n<li><p>Make Strings Read-Only设为YES，也许是因为微信工程从低版本Xcode升级过来，这个编译选项之前一直为NO，设为YES后可执行文件减少了3M</p>\n</li>\n<li><p>去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中<strong>gcc_except_tab段减少了17.3M，</strong>text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等</p>\n</li>\n</ul>\n<ol>\n<li>其他可探索途径</li>\n</ol>\n<ul>\n<li><p>iOS8 Embed-Framework：提取WeChatWatch、ShareExtention和微信主工程的公共代码，可执行文件可以减少5M+，不过这特性需要最低版本iOS8才能用，iOS7设备启动会crash</p>\n</li>\n<li><p>iOS9 App Thinning：严格来说App Thinning不会让安装包变小，但用户安装应用时，苹果会根据用户的机型自动选择合适的资源和对应CPU架构的二进制执行文件（也就是说用户本地可执行文件不会同时存在armv7和arm64），安装后空间占用更小</p>\n</li>\n</ul>\n<ol>\n<li>建立监控</li>\n</ol>\n<p>通过对LinkMap文件的分析，可以得知每个模块可执行文件占用大小。再对比两个版本，就知道业务模块的增量大小。参考如下：</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj8ns4plz001nsauag3d4qph3","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmc0021saua2cgzp6id"},{"post_id":"cj8ns4pm7001vsauamebp7zhb","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmd0024sauaqzcy5llj"},{"post_id":"cj8ns4pmb0020saua9ui4jufx","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmi002bsauacckfoehg"},{"post_id":"cj8ns4pme0027sauarqlwgubi","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmk002hsauapox6lt5c"},{"post_id":"cj8ns4pmi002esaua54x38q7m","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pmn002nsaua3agz3ldc"},{"post_id":"cj8ns4pmc0023sauaqwebjkf5","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pmp002qsauat4vk4ch2"},{"post_id":"cj8ns4pmj002gsaua4skkkxt4","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmq002tsaua16nmfjrg"},{"post_id":"cj8ns4pml002ksaua6kmwxih8","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmr002wsauau3lhl8ws"},{"post_id":"cj8ns4pmh002asaua7bh3myow","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pmt002zsaua9y0txc95"},{"post_id":"cj8ns4pmm002msaualra0a8td","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmv0032saua4491typx"},{"post_id":"cj8ns4pmo002psauasxmqd984","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmw0035sauaj5upxfs0"},{"post_id":"cj8ns4pmp002ssauaagyz40x9","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmy0039saua36p00nzb"},{"post_id":"cj8ns4pmq002vsauaxjvk1iw9","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pmz003csauafzey597k"},{"post_id":"cj8ns4pmr002ysauaf43p1cgu","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pn0003fsaua69d8a9cu"},{"post_id":"cj8ns4pmu0031saua4g0tngud","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pn2003isauaqyl0q61s"},{"post_id":"cj8ns4pmv0034sauavd8c9uic","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pn4003lsauadddcmrgj"},{"post_id":"cj8ns4pn2003jsaua7cq0ds0z","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pnb003usauaaqfre0ce"},{"post_id":"cj8ns4pn9003qsaua9ieteu3r","category_id":"cj8ns4pn5003msaua1099k26v","_id":"cj8ns4pne0040sauat9psj2qy"},{"post_id":"cj8ns4pn1003hsauaha6qh1ga","category_id":"cj8ns4pn5003msaua1099k26v","_id":"cj8ns4pnf0043sauaebhp5lia"},{"post_id":"cj8ns4pn6003osauapnwj2mh3","category_id":"cj8ns4pn5003msaua1099k26v","_id":"cj8ns4png0046sauaffeyr90l"},{"post_id":"cj8ns4pnn004lsauanyq3sh9f","category_id":"cj8ns4pn5003msaua1099k26v","_id":"cj8ns4pnt004tsauaygxq0hte"},{"post_id":"cj8ns4pno004nsauaozlkrvbt","category_id":"cj8ns4pmh0028sauamq5c9ub2","_id":"cj8ns4pnv004wsaua47c0cox4"},{"post_id":"cj8ns4pnr004psaua78hrjqmy","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pnw004zsaua9op1muv7"},{"post_id":"cj8ns4pns004ssauasoq1khwz","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pnx0052sauays4n5itk"},{"post_id":"cj8ns4pnu004vsaua94az9zzn","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4pny0055sauaysa7f3wb"},{"post_id":"cj8ns4pnx0051saua7klf3s3q","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po1005asauam40s0k7z"},{"post_id":"cj8ns4pny0054sauaesbvozi8","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po3005dsauazid64h8r"},{"post_id":"cj8ns4po1005csauao4g9tzxt","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po7005ksaua10gen0x5"},{"post_id":"cj8ns4po3005fsaua2sx2a211","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po7005msauaur9noxtr"},{"post_id":"cj8ns4po5005hsauahnsbu7za","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po8005osaua4rtojzok"},{"post_id":"cj8ns4po6005jsaua8h7ca8si","category_id":"cj8ns4pm2001qsauairvnfmah","_id":"cj8ns4po8005qsauag3mwh0on"}],"PostTag":[{"post_id":"cj8ns4pjx0000sauatp2x9hvc","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4pkh000asauank8cr5zj"},{"post_id":"cj8ns4pk30002saua2mkih4o0","tag_id":"cj8ns4pkg0009sauatucq1ln0","_id":"cj8ns4pkk000fsauajx1mtyes"},{"post_id":"cj8ns4pk90005sauaeunr6ivd","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pko000jsaua0o7pysv8"},{"post_id":"cj8ns4pkb0007sauaomac232t","tag_id":"cj8ns4pkl000hsaual2aurxv2","_id":"cj8ns4pkq000nsauachkquw9y"},{"post_id":"cj8ns4pkf0008sauafar54q20","tag_id":"cj8ns4pkp000lsaua4mlklh4n","_id":"cj8ns4pku000rsaua9lkkkh4z"},{"post_id":"cj8ns4pkh000bsauaj6m3lu51","tag_id":"cj8ns4pku000qsauaa1aam9wv","_id":"cj8ns4pkz000wsauaqebrrcnh"},{"post_id":"cj8ns4pki000csauaclaqumha","tag_id":"cj8ns4pkx000usauawr2illm1","_id":"cj8ns4pkz000ysaua3ixexica"},{"post_id":"cj8ns4pkj000esaua416ru8cq","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pl10010saua318h5mwj"},{"post_id":"cj8ns4pkk000gsauak16iins1","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pl20012sauaseh7lv4c"},{"post_id":"cj8ns4pkm000isauax6xcepcl","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pl20014saua8nh2ft31"},{"post_id":"cj8ns4pko000ksauarmslobst","tag_id":"cj8ns4pkx000usauawr2illm1","_id":"cj8ns4pl30017sauasheimrxg"},{"post_id":"cj8ns4pko000ksauarmslobst","tag_id":"cj8ns4pl20015sauayi4ocyi8","_id":"cj8ns4pl30018sauao9kmwfqp"},{"post_id":"cj8ns4pkp000msaua2t3a1hx4","tag_id":"cj8ns4pl20015sauayi4ocyi8","_id":"cj8ns4pl3001bsauakc4f3b11"},{"post_id":"cj8ns4pkp000msaua2t3a1hx4","tag_id":"cj8ns4pl30019sauabgadcnvi","_id":"cj8ns4pl3001csauak4mxkqbt"},{"post_id":"cj8ns4pkr000osauadx5ku899","tag_id":"cj8ns4pl3001asaua6de093y0","_id":"cj8ns4pl4001esaua1ma2s1xy"},{"post_id":"cj8ns4pks000psaua9cnonjub","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pl7001hsaua3a27jhq8"},{"post_id":"cj8ns4pks000psaua9cnonjub","tag_id":"cj8ns4pku000qsauaa1aam9wv","_id":"cj8ns4pl8001isauaauj8veos"},{"post_id":"cj8ns4pkv000ssauaw82fwtyw","tag_id":"cj8ns4pl6001gsaua8pfpyufz","_id":"cj8ns4pl8001jsauaw2aditmp"},{"post_id":"cj8ns4pm2001rsauazwyi7dn7","tag_id":"cj8ns4pm0001osaua1kzrfh05","_id":"cj8ns4pm7001usauakywmf3dj"},{"post_id":"cj8ns4plx001msauacz7v1aur","tag_id":"cj8ns4pm0001osaua1kzrfh05","_id":"cj8ns4pm8001wsauan8o2zy7u"},{"post_id":"cj8ns4pm7001vsauamebp7zhb","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmb001zsauajzrq0dbh"},{"post_id":"cj8ns4plz001nsauag3d4qph3","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmc0022sauavookvq2s"},{"post_id":"cj8ns4pmb0020saua9ui4jufx","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmd0026sauau3xlog71"},{"post_id":"cj8ns4pm0001psauaxr8fnzks","tag_id":"cj8ns4pm0001osaua1kzrfh05","_id":"cj8ns4pmh0029sauag3x1cw7j"},{"post_id":"cj8ns4pme0027sauarqlwgubi","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmi002dsaua9jctg39z"},{"post_id":"cj8ns4pm5001ssauapuqz7vx1","tag_id":"cj8ns4pmd0025sauay9vgawf9","_id":"cj8ns4pmj002fsauafljui5dt"},{"post_id":"cj8ns4pmh002asaua7bh3myow","tag_id":"cj8ns4pkx000usauawr2illm1","_id":"cj8ns4pml002jsauafmdy4pcc"},{"post_id":"cj8ns4pmi002esaua54x38q7m","tag_id":"cj8ns4pkx000usauawr2illm1","_id":"cj8ns4pmm002lsauai8u8d3d4"},{"post_id":"cj8ns4pmc0023sauaqwebjkf5","tag_id":"cj8ns4pmi002csaua5v2bdyav","_id":"cj8ns4pmo002osauazlwniw3p"},{"post_id":"cj8ns4pmj002gsaua4skkkxt4","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmp002rsaualodrszrk"},{"post_id":"cj8ns4pml002ksaua6kmwxih8","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4pmq002usaua9g3npjbk"},{"post_id":"cj8ns4pmm002msaualra0a8td","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4pmr002xsauampjh73z7"},{"post_id":"cj8ns4pmo002psauasxmqd984","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmu0030saua336oxyyg"},{"post_id":"cj8ns4pmp002ssauaagyz40x9","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmv0033saua3y12082c"},{"post_id":"cj8ns4pmq002vsauaxjvk1iw9","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pmx0037sauax4n6jvso"},{"post_id":"cj8ns4pmr002ysauaf43p1cgu","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4pmy003asauak7uc6sgp"},{"post_id":"cj8ns4pmu0031saua4g0tngud","tag_id":"cj8ns4pmw0036saua39veao5l","_id":"cj8ns4pn1003gsauasxnbmu8a"},{"post_id":"cj8ns4pn1003hsauaha6qh1ga","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pn6003nsauapx852pte"},{"post_id":"cj8ns4pmv0034sauavd8c9uic","tag_id":"cj8ns4pmw0036saua39veao5l","_id":"cj8ns4pn8003psauaqjfj0ifn"},{"post_id":"cj8ns4pn2003jsaua7cq0ds0z","tag_id":"cj8ns4pmw0036saua39veao5l","_id":"cj8ns4pna003ssauakym0eryy"},{"post_id":"cj8ns4pn6003osauapnwj2mh3","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pnc003wsauanzqho6fp"},{"post_id":"cj8ns4pmz003bsaua2afv7qli","tag_id":"cj8ns4pn4003ksauadce3nlp4","_id":"cj8ns4pnd003ysaua4lmd3azk"},{"post_id":"cj8ns4pn9003qsaua9ieteu3r","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pne0041saua3mjocifu"},{"post_id":"cj8ns4pnb003tsaua6nrhpr7u","tag_id":"cj8ns4pm0001osaua1kzrfh05","_id":"cj8ns4pnf0044sauawjm3p3so"},{"post_id":"cj8ns4pn0003dsaua3uvnbqcx","tag_id":"cj8ns4pna003rsauamubkdmcu","_id":"cj8ns4pnh0048sauabsfnlmfd"},{"post_id":"cj8ns4pnc003xsauazqkbv806","tag_id":"cj8ns4pm0001osaua1kzrfh05","_id":"cj8ns4pni004asauaroffp2ps"},{"post_id":"cj8ns4pni004bsauawx939p87","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pnk004esauaiqmkjuuu"},{"post_id":"cj8ns4pne0042saua8u1icurf","tag_id":"cj8ns4png0047sauagjrzoaqu","_id":"cj8ns4pnl004gsauaf4hzvhbv"},{"post_id":"cj8ns4pnl004hsauabkm9qrlm","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4pnn004ksauauq0qwgc5"},{"post_id":"cj8ns4pnf0045sauau6zj0vr8","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pnq004osauaq79vjy2r"},{"post_id":"cj8ns4pnf0045sauau6zj0vr8","tag_id":"cj8ns4pnj004dsauasc4bpz3i","_id":"cj8ns4pns004qsauauetpqqrq"},{"post_id":"cj8ns4pnf0045sauau6zj0vr8","tag_id":"cj8ns4pnm004isauacrv1wrwu","_id":"cj8ns4pnt004usaua9utz88q1"},{"post_id":"cj8ns4pnn004lsauanyq3sh9f","tag_id":"cj8ns4pkj000dsaua1g28nt8h","_id":"cj8ns4pnv004xsauahr64yjpf"},{"post_id":"cj8ns4pno004nsauaozlkrvbt","tag_id":"cj8ns4pmw0036saua39veao5l","_id":"cj8ns4pnw0050sauaid7y9so3"},{"post_id":"cj8ns4pnh0049saua97v5d5mj","tag_id":"cj8ns4pno004msauaokq9r0sz","_id":"cj8ns4pnx0053sauaw71ofp7h"},{"post_id":"cj8ns4pnr004psaua78hrjqmy","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4pnz0056sauaajvjuvxt"},{"post_id":"cj8ns4pns004ssauasoq1khwz","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po00058sauahk9physu"},{"post_id":"cj8ns4pnu004vsaua94az9zzn","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po1005bsaualw28ybkl"},{"post_id":"cj8ns4pnm004jsauabm4insud","tag_id":"cj8ns4pns004rsauabcfzxgsa","_id":"cj8ns4po3005esauaylzc6ist"},{"post_id":"cj8ns4pnm004jsauabm4insud","tag_id":"cj8ns4pkz000xsauacwqed4sm","_id":"cj8ns4po5005gsaua46reat1z"},{"post_id":"cj8ns4pnv004ysauam5jn0qay","tag_id":"cj8ns4pmd0025sauay9vgawf9","_id":"cj8ns4po6005isauake1jeugf"},{"post_id":"cj8ns4pnx0051saua7klf3s3q","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po7005lsauave8kyw8i"},{"post_id":"cj8ns4po00059saua00ez5awk","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po7005nsaua68klj7ta"},{"post_id":"cj8ns4po1005csauao4g9tzxt","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po8005psaua6qhtecac"},{"post_id":"cj8ns4po3005fsaua2sx2a211","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po8005rsauavz9htocs"},{"post_id":"cj8ns4po5005hsauahnsbu7za","tag_id":"cj8ns4pm6001tsauatkfr8909","_id":"cj8ns4po8005ssauadpqlxcbk"},{"post_id":"cj8ns4po6005jsaua8h7ca8si","tag_id":"cj8ns4pk60004saua9xkiis2c","_id":"cj8ns4po8005tsauaeszhjnau"}],"Tag":[{"name":"iOS进阶","_id":"cj8ns4pk60004saua9xkiis2c"},{"name":"c++","_id":"cj8ns4pkg0009sauatucq1ln0"},{"name":"Python","_id":"cj8ns4pkj000dsaua1g28nt8h"},{"name":"clang插件","_id":"cj8ns4pkl000hsaual2aurxv2"},{"name":"命令行","_id":"cj8ns4pkp000lsaua4mlklh4n"},{"name":"hexo","_id":"cj8ns4pku000qsauaa1aam9wv"},{"name":"工具","_id":"cj8ns4pkx000usauawr2illm1"},{"name":"python","_id":"cj8ns4pkz000xsauacwqed4sm"},{"name":"xcode","_id":"cj8ns4pl20015sauayi4ocyi8"},{"name":"git","_id":"cj8ns4pl30019sauabgadcnvi"},{"name":"数据结构算法","_id":"cj8ns4pl3001asaua6de093y0"},{"name":"深度学习","_id":"cj8ns4pl6001gsaua8pfpyufz"},{"name":"iOS","_id":"cj8ns4pm0001osaua1kzrfh05"},{"name":"iOS基础知识","_id":"cj8ns4pm6001tsauatkfr8909"},{"name":"IOS","_id":"cj8ns4pmd0025sauay9vgawf9"},{"name":"计算机基础","_id":"cj8ns4pmi002csaua5v2bdyav"},{"name":"流媒体","_id":"cj8ns4pmw0036saua39veao5l"},{"name":"自动化","_id":"cj8ns4pn4003ksauadce3nlp4"},{"name":"Lunix","_id":"cj8ns4pna003rsauamubkdmcu"},{"name":"mac","_id":"cj8ns4png0047sauagjrzoaqu"},{"name":"Django","_id":"cj8ns4pnj004dsauasc4bpz3i"},{"name":"JS","_id":"cj8ns4pnm004isauacrv1wrwu"},{"name":"mongo","_id":"cj8ns4pno004msauaokq9r0sz"},{"name":"爬虫","_id":"cj8ns4pns004rsauabcfzxgsa"}]}}
---
title: block进阶4--block的逻辑理解
date: 2016-06-29 11:26:39
tags:
- iOS进阶
categories: iOS
---
对为什么要像前边三篇文章分析的那样去实现block？
block是一种类似于闭包的技术，也就是将一段代码保存，然后在需要的时候再执行，这样就带来了两个问题
<!--more-->
- 我怎么保证当我需要执行这段block代码的时候，block本身是存在的
- 因为代码执行的参数需要，我如何保证当我执行的时候参数是可用的

我们通过前边的学习知道，block是一个结构体，要执行的代码会被封装为一段函数，然后这个函数的指针被结构体引用，而这个函数的一个参数就是block结构体，因为我们需要从结构体中获取需要的参数
`block结构体--->方法----->从block结构体获取参数`

## 保证block本身存在
首先如果
- block字面量写在全局区为global block
- block字面量没有获取任何外部变量，为global block
其他情况全部为statck block，global block存在于全局区，不依赖上下文，内存管理没有啥大的困扰，栈block在内存中的栈区，变量的作用域结束后，block会被废弃，同时__block也会被废弃，我们需要为栈block找到一个提升生命周期的方法。
为了解决这个问题，block提供了copy功能，将block和__block变量从栈拷贝到堆，此时这个block也就变成了堆block，这样只要引用的指针存在，block的生存就不成问题。
至于这个copy的功能应该说比较隐晦
### copy的调用时机
因为block是匿名的，所以当我们不创建一个block声明的话，我们不能够调用和使用这个block，所以所以我们可以对block的使用情况做如下的归纳：
- 作为变量
- 作为方法参数

第一种情况下，我们总需要做一个赋值的操作，否则无法使用block，我们可以像下边这样打印一个捕获局部变量的block
```
NSLog(@"%@", ^{NSLog(@"%d", c);});//结果是这是给stackblock
```
所以并不是捕获了局部变量就是堆block的，需要做一个赋值操作
```
void(^myBlock)() = ^{NSLog(@"%d", c);};
    
NSLog(@"%@", myBlock);
```
这个时候我们得到的就是一个mallocblock了，这是因为这个变量前边有个默认的关键字`__strong`，这个时候编译器会默认对block做copy操作的

第二种情况，作为一个参数被传递的时候，如果是栈block，那么默认也是做copy操作的
```
- (MyBlcok)getaBlock{
    int a = 0;
    return ^(){NSLog(@"%d", a);};
}
```
打印该block发现是mallocblock


## 保证参数可用

### 全局变量
我们使用一个参数无非做取值和赋值两种操作，而我们能否拿到这个变量一个关键点在于这个变量的作用域，本质来讲block是一个单独的作用域，全局变量穿透没有问题，但是局部变量就无法被直接使用，所以局部变量在使用的时候，是在block结构体内部又重新定义了另外一个变量，然后将值赋给这个变量，这样的结果就是，该变量首先可以被block使用了，其次生命周期与block一致了，不会存在被访问的时候释放这样的问题了，这个block内部的同名变量与局部变量其实没有任何的关系。修改该变量的值并不会改变局部变量的值。

### 局部变量
当我们在局部变量的外边加上一个const的时候，这个变量的生命周期发生了改变，并且内存上移动到了静态变量区，但是作用域并没有变化，所以还是不能穿透block像全局变量一样被赋值，当然我们发现，这个时候我们是可以改变局部变量的值得，其实这个时候系统的做法是，将该局部变量的指针传入进去，因为加上了const首先起码生命周期一致了，能够保证不会被释放了，将指针传入进去，这个时候我们可以通过指针来访问该静态变量的内存地址进行一些修改的操作

### __block
当然对于修改局部变量除了提升其生命周期还有一种办法就是加上__block关键字，该关键字的作用是生成了另外一个结构体，然后赋值给block，这样一方面保证了生命周期一致，又因为最后的执行函数以block为参数，所以访问该变量问题不大，也解决了作用域的问题

